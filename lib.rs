# ! [ feature ( abi_msp430_interrupt ) ]
# ! [ doc = "Peripheral access API for MSP430FR2355 microcontrollers (generated using svd2rust v0.17.0)\n\nYou can find an overview of the API [here].\n\n[here]: https://docs.rs/svd2rust/0.17.0/svd2rust/#peripheral-api" ] # ! [ deny ( const_err ) ] # ! [ deny ( dead_code ) ] # ! [ deny ( improper_ctypes ) ] # ! [ deny ( legacy_directory_ownership ) ] # ! [ deny ( missing_docs ) ] # ! [ deny ( no_mangle_generic_items ) ] # ! [ deny ( non_shorthand_field_patterns ) ] # ! [ deny ( overflowing_literals ) ] # ! [ deny ( path_statements ) ] # ! [ deny ( patterns_in_fns_without_body ) ] # ! [ deny ( plugin_as_library ) ] # ! [ deny ( private_in_public ) ] # ! [ deny ( safe_extern_statics ) ] # ! [ deny ( unconditional_recursion ) ] # ! [ deny ( unions_with_drop_fields ) ] # ! [ deny ( unused_allocation ) ] # ! [ deny ( unused_comparisons ) ] # ! [ deny ( unused_parens ) ] # ! [ deny ( while_true ) ] # ! [ allow ( non_camel_case_types ) ] # ! [ allow ( non_snake_case ) ] # ! [ no_std ]
extern crate msp430 ; # [ cfg ( feature = "rt" ) ] extern crate msp430_rt ;
extern crate bare_metal ; extern crate vcell ; use core :: ops :: Deref ; use core :: marker :: PhantomData ;
# [ cfg ( feature = "rt" ) ] extern "msp430-interrupt" { fn PORT4 ( ) ; fn PORT3 ( ) ; fn PORT2 ( ) ; fn PORT1 ( ) ; fn SAC1_SAC3 ( ) ; fn SAC0_SAC2 ( ) ; fn ECOMP0_ECOMP1 ( ) ; fn ADC ( ) ; fn EUSCI_B1 ( ) ; fn EUSCI_B0 ( ) ; fn EUSCI_A1 ( ) ; fn EUSCI_A0 ( ) ; fn WDT ( ) ; fn RTC ( ) ; fn TIMER3_B1 ( ) ; fn TIMER3_B0 ( ) ; fn TIMER2_B1 ( ) ; fn TIMER2_B0 ( ) ; fn TIMER1_B1 ( ) ; fn TIMER1_B0 ( ) ; fn TIMER0_B1 ( ) ; fn TIMER0_B0 ( ) ; fn UNMI ( ) ; fn SYSNMI ( ) ; } # [ doc ( hidden ) ] pub union Vector { _handler : unsafe extern "msp430-interrupt" fn ( ) , _reserved : u16 , } # [ cfg ( feature = "rt" ) ] # [ doc ( hidden ) ] # [ link_section = ".vector_table.interrupts" ] # [ no_mangle ] # [ used ] pub static __INTERRUPTS : [ Vector ; 45 ] = [ Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _handler : PORT4 } , Vector { _handler : PORT3 } , Vector { _handler : PORT2 } , Vector { _handler : PORT1 } , Vector { _handler : SAC1_SAC3 } , Vector { _handler : SAC0_SAC2 } , Vector { _handler : ECOMP0_ECOMP1 } , Vector { _handler : ADC } , Vector { _handler : EUSCI_B1 } , Vector { _handler : EUSCI_B0 } , Vector { _handler : EUSCI_A1 } , Vector { _handler : EUSCI_A0 } , Vector { _handler : WDT } , Vector { _handler : RTC } , Vector { _handler : TIMER3_B1 } , Vector { _handler : TIMER3_B0 } , Vector { _handler : TIMER2_B1 } , Vector { _handler : TIMER2_B0 } , Vector { _handler : TIMER1_B1 } , Vector { _handler : TIMER1_B0 } , Vector { _handler : TIMER0_B1 } , Vector { _handler : TIMER0_B0 } , Vector { _handler : UNMI } , Vector { _handler : SYSNMI } , ] ;
# [ doc = r"Enumeration of all the interrupts" ] # [ derive ( Copy , Clone , Debug ) ] pub enum Interrupt { # [ doc = "21 - 0xFFCE" ] PORT4 , # [ doc = "22 - 0xFFD0" ] PORT3 , # [ doc = "23 - 0xFFD2" ] PORT2 , # [ doc = "24 - 0xFFD4" ] PORT1 , # [ doc = "25 - 0xFFD6" ] SAC1_SAC3 , # [ doc = "26 - 0xFFD8" ] SAC0_SAC2 , # [ doc = "27 - 0xFFDA" ] ECOMP0_ECOMP1 , # [ doc = "28 - 0xFFDC" ] ADC , # [ doc = "29 - 0xFFDE" ] EUSCI_B1 , # [ doc = "30 - 0xFFE0" ] EUSCI_B0 , # [ doc = "31 - 0xFFE2" ] EUSCI_A1 , # [ doc = "32 - 0xFFE4" ] EUSCI_A0 , # [ doc = "33 - 0xFFE6" ] WDT , # [ doc = "34 - 0xFFE8" ] RTC , # [ doc = "35 - 0xFFEA" ] TIMER3_B1 , # [ doc = "36 - 0xFFEC" ] TIMER3_B0 , # [ doc = "37 - 0xFFEE" ] TIMER2_B1 , # [ doc = "38 - 0xFFF0" ] TIMER2_B0 , # [ doc = "39 - 0xFFF2" ] TIMER1_B1 , # [ doc = "40 - 0xFFF4" ] TIMER1_B0 , # [ doc = "41 - 0xFFF6" ] TIMER0_B1 , # [ doc = "42 - 0xFFF8" ] TIMER0_B0 , # [ doc = "43 - 0xFFFA" ] UNMI , # [ doc = "44 - 0xFFFC" ] SYSNMI , } unsafe impl bare_metal :: Nr for Interrupt { # [ inline ] fn nr ( & self ) -> u8 { match * self { Interrupt :: PORT4 => 21 , Interrupt :: PORT3 => 22 , Interrupt :: PORT2 => 23 , Interrupt :: PORT1 => 24 , Interrupt :: SAC1_SAC3 => 25 , Interrupt :: SAC0_SAC2 => 26 , Interrupt :: ECOMP0_ECOMP1 => 27 , Interrupt :: ADC => 28 , Interrupt :: EUSCI_B1 => 29 , Interrupt :: EUSCI_B0 => 30 , Interrupt :: EUSCI_A1 => 31 , Interrupt :: EUSCI_A0 => 32 , Interrupt :: WDT => 33 , Interrupt :: RTC => 34 , Interrupt :: TIMER3_B1 => 35 , Interrupt :: TIMER3_B0 => 36 , Interrupt :: TIMER2_B1 => 37 , Interrupt :: TIMER2_B0 => 38 , Interrupt :: TIMER1_B1 => 39 , Interrupt :: TIMER1_B0 => 40 , Interrupt :: TIMER0_B1 => 41 , Interrupt :: TIMER0_B0 => 42 , Interrupt :: UNMI => 43 , Interrupt :: SYSNMI => 44 , } } }
# [ cfg ( feature = "rt" ) ] pub use msp430_rt :: interrupt ; # [ cfg ( feature = "rt" ) ] pub use self :: Interrupt as interrupt ;
# [ allow ( unused_imports ) ] use generic :: * ; # [ doc = r"Common register and bit access and modify traits" ] pub mod generic { use core :: marker ; # [ doc = "This trait shows that register has `read` method" ] # [ doc = "" ] # [ doc = "Registers marked with `Writable` can be also `modify`'ed" ] pub trait Readable { } # [ doc = "This trait shows that register has `write`, `write_with_zero` and `reset` method" ] # [ doc = "" ] # [ doc = "Registers marked with `Readable` can be also `modify`'ed" ] pub trait Writable { } # [ doc = "Reset value of the register" ] # [ doc = "" ] # [ doc = "This value is initial value for `write` method." ] # [ doc = "It can be also directly writed to register by `reset` method." ] pub trait ResetValue { # [ doc = "Register size" ] type Type ; # [ doc = "Reset value of the register" ] fn reset_value ( ) -> Self :: Type ; } # [ doc = "This structure provides volatile access to register" ] pub struct Reg < U , REG > { register : vcell :: VolatileCell < U > , _marker : marker :: PhantomData < REG > , } unsafe impl < U : Send , REG > Send for Reg < U , REG > { } impl < U , REG > Reg < U , REG > where Self : Readable , U : Copy { # [ doc = "Reads the contents of `Readable` register" ] # [ doc = "" ] # [ doc = "You can read the contents of a register in such way:" ] # [ doc = "```ignore" ] # [ doc = "let bits = periph.reg.read().bits();" ] # [ doc = "```" ] # [ doc = "or get the content of a particular field of a register." ] # [ doc = "```ignore" ] # [ doc = "let reader = periph.reg.read();" ] # [ doc = "let bits = reader.field1().bits();" ] # [ doc = "let flag = reader.field2().bit_is_set();" ] # [ doc = "```" ] # [ inline ( always ) ] pub fn read ( & self ) -> R < U , Self > { R { bits : self . register . get ( ) , _reg : marker :: PhantomData } } } impl < U , REG > Reg < U , REG > where Self : ResetValue < Type = U > + Writable , U : Copy , { # [ doc = "Writes the reset value to `Writable` register" ] # [ doc = "" ] # [ doc = "Resets the register to its initial state" ] # [ inline ( always ) ] pub fn reset ( & self ) { self . register . set ( Self :: reset_value ( ) ) } } impl < U , REG > Reg < U , REG > where Self : ResetValue < Type = U > + Writable , U : Copy { # [ doc = "Writes bits to `Writable` register" ] # [ doc = "" ] # [ doc = "You can write raw bits into a register:" ] # [ doc = "```ignore" ] # [ doc = "periph.reg.write(|w| unsafe { w.bits(rawbits) });" ] # [ doc = "```" ] # [ doc = "or write only the fields you need:" ] # [ doc = "```ignore" ] # [ doc = "periph.reg.write(|w| w" ] # [ doc = "    .field1().bits(newfield1bits)" ] # [ doc = "    .field2().set_bit()" ] # [ doc = "    .field3().variant(VARIANT)" ] # [ doc = ");" ] # [ doc = "```" ] # [ doc = "Other fields will have reset value." ] # [ inline ( always ) ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W < U , Self > ) -> & mut W < U , Self > { self . register . set ( f ( & mut W { bits : Self :: reset_value ( ) , _reg : marker :: PhantomData } ) . bits ) ; } } impl < U , REG > Reg < U , REG > where Self : Writable , U : Copy + Default { # [ doc = "Writes Zero to `Writable` register" ] # [ doc = "" ] # [ doc = "Similar to `write`, but unused bits will contain 0." ] # [ inline ( always ) ] pub fn write_with_zero < F > ( & self , f : F ) where F : FnOnce ( & mut W < U , Self > ) -> & mut W < U , Self > { self . register . set ( f ( & mut W { bits : U :: default ( ) , _reg : marker :: PhantomData } ) . bits ) ; } } impl < U , REG > Reg < U , REG > where Self : Readable + Writable , U : Copy , { # [ doc = "Modifies the contents of the register" ] # [ doc = "" ] # [ doc = "E.g. to do a read-modify-write sequence to change parts of a register:" ] # [ doc = "```ignore" ] # [ doc = "periph.reg.modify(|r, w| unsafe { w.bits(" ] # [ doc = "   r.bits() | 3" ] # [ doc = ") });" ] # [ doc = "```" ] # [ doc = "or" ] # [ doc = "```ignore" ] # [ doc = "periph.reg.modify(|_, w| w" ] # [ doc = "    .field1().bits(newfield1bits)" ] # [ doc = "    .field2().set_bit()" ] # [ doc = "    .field3().variant(VARIANT)" ] # [ doc = ");" ] # [ doc = "```" ] # [ doc = "Other fields will have value they had before call `modify`." ] # [ inline ( always ) ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R < U , Self > , & 'w mut W < U , Self > ) -> & 'w mut W < U , Self > { let bits = self . register . get ( ) ; self . register . set ( f ( & R { bits , _reg : marker :: PhantomData } , & mut W { bits , _reg : marker :: PhantomData } ) . bits ) ; } } # [ doc = "Register/field reader" ] # [ doc = "" ] # [ doc = "Result of the [`read`](Reg::read) method of a register." ] # [ doc = "Also it can be used in the [`modify`](Reg::read) method" ] pub struct R < U , T > { pub ( crate ) bits : U , _reg : marker :: PhantomData < T > , } impl < U , T > R < U , T > where U : Copy { # [ doc = "Create new instance of reader" ] # [ inline ( always ) ] pub ( crate ) fn new ( bits : U ) -> Self { Self { bits , _reg : marker :: PhantomData , } } # [ doc = "Read raw bits from register/field" ] # [ inline ( always ) ] pub fn bits ( & self ) -> U { self . bits } } impl < U , T , FI > PartialEq < FI > for R < U , T > where U : PartialEq , FI : Copy + Into < U > { # [ inline ( always ) ] fn eq ( & self , other : & FI ) -> bool { self . bits . eq ( & ( * other ) . into ( ) ) } } impl < FI > R < bool , FI > { # [ doc = "Value of the field as raw bits" ] # [ inline ( always ) ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = "Returns `true` if the bit is clear (0)" ] # [ inline ( always ) ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = "Returns `true` if the bit is set (1)" ] # [ inline ( always ) ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = "Register writer" ] # [ doc = "" ] # [ doc = "Used as an argument to the closures in the [`write`](Reg::write) and [`modify`](Reg::modify) methods of the register" ] pub struct W < U , REG > { # [ doc = "Writable bits" ] pub ( crate ) bits : U , _reg : marker :: PhantomData < REG > , } impl < U , REG > W < U , REG > { # [ doc = "Writes raw bits to the register" ] # [ inline ( always ) ] pub unsafe fn bits ( & mut self , bits : U ) -> & mut Self { self . bits = bits ; self } } # [ doc = "Used if enumerated values cover not the whole range" ] # [ derive ( Clone , Copy , PartialEq ) ] pub enum Variant < U , T > { # [ doc = "Expected variant" ] Val ( T ) , # [ doc = "Raw bits" ] Res ( U ) , } }
# [ doc = "P1" ] pub struct P1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for P1 { } impl P1 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const p1 :: RegisterBlock { 0x0200 as * const _ } } impl Deref for P1 { type Target = p1 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * P1 :: ptr ( ) } } }
# [ doc = "P1" ] pub mod p1 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Port 1 Input" ] pub p1in : P1IN , _reserved1 : [ u8 ; 1usize ] , # [ doc = "0x02 - Port 1 Output" ] pub p1out : P1OUT , _reserved2 : [ u8 ; 1usize ] , # [ doc = "0x04 - Port 1 Direction" ] pub p1dir : P1DIR , _reserved3 : [ u8 ; 1usize ] , # [ doc = "0x06 - Port 1 Resistor Enable" ] pub p1ren : P1REN , _reserved4 : [ u8 ; 3usize ] , # [ doc = "0x0a - Port 1 Select 0" ] pub p1sel0 : P1SEL0 , _reserved5 : [ u8 ; 1usize ] , # [ doc = "0x0c - Port 1 Select 1" ] pub p1sel1 : P1SEL1 , _reserved6 : [ u8 ; 1usize ] , # [ doc = "0x0e - Port 1 Interrupt Vector Register" ] pub p1iv : P1IV , _reserved7 : [ u8 ; 6usize ] , # [ doc = "0x16 - Port 1 Complement Select" ] pub p1selc : P1SELC , _reserved8 : [ u8 ; 1usize ] , # [ doc = "0x18 - Port 1 Interrupt Edge Select" ] pub p1ies : P1IES , _reserved9 : [ u8 ; 1usize ] , # [ doc = "0x1a - Port 1 Interrupt Enable" ] pub p1ie : P1IE , _reserved10 : [ u8 ; 1usize ] , # [ doc = "0x1c - Port 1 Interrupt Flag" ] pub p1ifg : P1IFG , }
# [ doc = "Port 1 Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1in](p1in) module" ] pub type P1IN = crate :: Reg < u8 , _P1IN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1IN ;
# [ doc = "`read()` method returns [p1in::R](p1in::R) reader structure" ] impl crate :: Readable for P1IN { }
# [ doc = "`write(|w| ..)` method takes [p1in::W](p1in::W) writer structure" ] impl crate :: Writable for P1IN { }
# [ doc = "Port 1 Input" ] pub mod p1in {
# [ doc = "Reader of register P1IN" ] pub type R = crate :: R < u8 , super :: P1IN > ;
# [ doc = "Writer for register P1IN" ] pub type W = crate :: W < u8 , super :: P1IN > ;
# [ doc = "Register P1IN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P1IN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 1 Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1out](p1out) module" ] pub type P1OUT = crate :: Reg < u8 , _P1OUT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1OUT ;
# [ doc = "`read()` method returns [p1out::R](p1out::R) reader structure" ] impl crate :: Readable for P1OUT { }
# [ doc = "`write(|w| ..)` method takes [p1out::W](p1out::W) writer structure" ] impl crate :: Writable for P1OUT { }
# [ doc = "Port 1 Output" ] pub mod p1out {
# [ doc = "Reader of register P1OUT" ] pub type R = crate :: R < u8 , super :: P1OUT > ;
# [ doc = "Writer for register P1OUT" ] pub type W = crate :: W < u8 , super :: P1OUT > ;
# [ doc = "Register P1OUT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P1OUT { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 1 Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1dir](p1dir) module" ] pub type P1DIR = crate :: Reg < u8 , _P1DIR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1DIR ;
# [ doc = "`read()` method returns [p1dir::R](p1dir::R) reader structure" ] impl crate :: Readable for P1DIR { }
# [ doc = "`write(|w| ..)` method takes [p1dir::W](p1dir::W) writer structure" ] impl crate :: Writable for P1DIR { }
# [ doc = "Port 1 Direction" ] pub mod p1dir {
# [ doc = "Reader of register P1DIR" ] pub type R = crate :: R < u8 , super :: P1DIR > ;
# [ doc = "Writer for register P1DIR" ] pub type W = crate :: W < u8 , super :: P1DIR > ;
# [ doc = "Register P1DIR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P1DIR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 1 Resistor Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1ren](p1ren) module" ] pub type P1REN = crate :: Reg < u8 , _P1REN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1REN ;
# [ doc = "`read()` method returns [p1ren::R](p1ren::R) reader structure" ] impl crate :: Readable for P1REN { }
# [ doc = "`write(|w| ..)` method takes [p1ren::W](p1ren::W) writer structure" ] impl crate :: Writable for P1REN { }
# [ doc = "Port 1 Resistor Enable" ] pub mod p1ren {
# [ doc = "Reader of register P1REN" ] pub type R = crate :: R < u8 , super :: P1REN > ;
# [ doc = "Writer for register P1REN" ] pub type W = crate :: W < u8 , super :: P1REN > ;
# [ doc = "Register P1REN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P1REN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 1 Select 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1sel0](p1sel0) module" ] pub type P1SEL0 = crate :: Reg < u8 , _P1SEL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1SEL0 ;
# [ doc = "`read()` method returns [p1sel0::R](p1sel0::R) reader structure" ] impl crate :: Readable for P1SEL0 { }
# [ doc = "`write(|w| ..)` method takes [p1sel0::W](p1sel0::W) writer structure" ] impl crate :: Writable for P1SEL0 { }
# [ doc = "Port 1 Select 0" ] pub mod p1sel0 {
# [ doc = "Reader of register P1SEL0" ] pub type R = crate :: R < u8 , super :: P1SEL0 > ;
# [ doc = "Writer for register P1SEL0" ] pub type W = crate :: W < u8 , super :: P1SEL0 > ;
# [ doc = "Register P1SEL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P1SEL0 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 1 Select 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1sel1](p1sel1) module" ] pub type P1SEL1 = crate :: Reg < u8 , _P1SEL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1SEL1 ;
# [ doc = "`read()` method returns [p1sel1::R](p1sel1::R) reader structure" ] impl crate :: Readable for P1SEL1 { }
# [ doc = "`write(|w| ..)` method takes [p1sel1::W](p1sel1::W) writer structure" ] impl crate :: Writable for P1SEL1 { }
# [ doc = "Port 1 Select 1" ] pub mod p1sel1 {
# [ doc = "Reader of register P1SEL1" ] pub type R = crate :: R < u8 , super :: P1SEL1 > ;
# [ doc = "Writer for register P1SEL1" ] pub type W = crate :: W < u8 , super :: P1SEL1 > ;
# [ doc = "Register P1SEL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P1SEL1 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 1 Complement Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1selc](p1selc) module" ] pub type P1SELC = crate :: Reg < u8 , _P1SELC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1SELC ;
# [ doc = "`read()` method returns [p1selc::R](p1selc::R) reader structure" ] impl crate :: Readable for P1SELC { }
# [ doc = "`write(|w| ..)` method takes [p1selc::W](p1selc::W) writer structure" ] impl crate :: Writable for P1SELC { }
# [ doc = "Port 1 Complement Select" ] pub mod p1selc {
# [ doc = "Reader of register P1SELC" ] pub type R = crate :: R < u8 , super :: P1SELC > ;
# [ doc = "Writer for register P1SELC" ] pub type W = crate :: W < u8 , super :: P1SELC > ;
# [ doc = "Register P1SELC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P1SELC { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 1 Interrupt Edge Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1ies](p1ies) module" ] pub type P1IES = crate :: Reg < u8 , _P1IES > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1IES ;
# [ doc = "`read()` method returns [p1ies::R](p1ies::R) reader structure" ] impl crate :: Readable for P1IES { }
# [ doc = "`write(|w| ..)` method takes [p1ies::W](p1ies::W) writer structure" ] impl crate :: Writable for P1IES { }
# [ doc = "Port 1 Interrupt Edge Select" ] pub mod p1ies {
# [ doc = "Reader of register P1IES" ] pub type R = crate :: R < u8 , super :: P1IES > ;
# [ doc = "Writer for register P1IES" ] pub type W = crate :: W < u8 , super :: P1IES > ;
# [ doc = "Register P1IES `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P1IES { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 1 Interrupt Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1ie](p1ie) module" ] pub type P1IE = crate :: Reg < u8 , _P1IE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1IE ;
# [ doc = "`read()` method returns [p1ie::R](p1ie::R) reader structure" ] impl crate :: Readable for P1IE { }
# [ doc = "`write(|w| ..)` method takes [p1ie::W](p1ie::W) writer structure" ] impl crate :: Writable for P1IE { }
# [ doc = "Port 1 Interrupt Enable" ] pub mod p1ie {
# [ doc = "Reader of register P1IE" ] pub type R = crate :: R < u8 , super :: P1IE > ;
# [ doc = "Writer for register P1IE" ] pub type W = crate :: W < u8 , super :: P1IE > ;
# [ doc = "Register P1IE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P1IE { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 1 Interrupt Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1ifg](p1ifg) module" ] pub type P1IFG = crate :: Reg < u8 , _P1IFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1IFG ;
# [ doc = "`read()` method returns [p1ifg::R](p1ifg::R) reader structure" ] impl crate :: Readable for P1IFG { }
# [ doc = "`write(|w| ..)` method takes [p1ifg::W](p1ifg::W) writer structure" ] impl crate :: Writable for P1IFG { }
# [ doc = "Port 1 Interrupt Flag" ] pub mod p1ifg {
# [ doc = "Reader of register P1IFG" ] pub type R = crate :: R < u8 , super :: P1IFG > ;
# [ doc = "Writer for register P1IFG" ] pub type W = crate :: W < u8 , super :: P1IFG > ;
# [ doc = "Register P1IFG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P1IFG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 1 Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1iv](p1iv) module" ] pub type P1IV = crate :: Reg < u16 , _P1IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1IV ;
# [ doc = "`read()` method returns [p1iv::R](p1iv::R) reader structure" ] impl crate :: Readable for P1IV { }
# [ doc = "Port 1 Interrupt Vector Register" ] pub mod p1iv {
# [ doc = "Reader of register P1IV" ] pub type R = crate :: R < u16 , super :: P1IV > ;
# [ doc = "Port 1 interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum P1IV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Port 1.0 interrupt; Interrupt Flag: P1IFG0; Interrupt Priority: Highest" ] P1IFG0 = 2 , # [ doc = "4: Interrupt Source: Port 1.1 interrupt; Interrupt Flag: P1IFG1" ] P1IFG1 = 4 , # [ doc = "6: Interrupt Source: Port 1.2 interrupt; Interrupt Flag: P1IFG2" ] P1IFG2 = 6 , # [ doc = "8: Interrupt Source: Port 1.3 interrupt; Interrupt Flag: P1IFG3" ] P1IFG3 = 8 , # [ doc = "10: Interrupt Source: Port 1.4 interrupt; Interrupt Flag: P1IFG4" ] P1IFG4 = 10 , # [ doc = "12: Interrupt Source: Port 1.5 interrupt; Interrupt Flag: P1IFG5" ] P1IFG5 = 12 , # [ doc = "14: Interrupt Source: Port 1.6 interrupt; Interrupt Flag: P1IFG6" ] P1IFG6 = 14 , # [ doc = "16: Interrupt Source: Port 1.7 interrupt; Interrupt Flag: P1IFG7; Interrupt Priority: Lowest" ] P1IFG7 = 16 } impl From < P1IV_A > for u8 { # [ inline ( always ) ] fn from ( variant : P1IV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `P1IV`" ] pub type P1IV_R = crate :: R < u8 , P1IV_A > ; impl P1IV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , P1IV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( P1IV_A :: NONE ) , 2 => Val ( P1IV_A :: P1IFG0 ) , 4 => Val ( P1IV_A :: P1IFG1 ) , 6 => Val ( P1IV_A :: P1IFG2 ) , 8 => Val ( P1IV_A :: P1IFG3 ) , 10 => Val ( P1IV_A :: P1IFG4 ) , 12 => Val ( P1IV_A :: P1IFG5 ) , 14 => Val ( P1IV_A :: P1IFG6 ) , 16 => Val ( P1IV_A :: P1IFG7 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == P1IV_A :: NONE } # [ doc = "Checks if the value of the field is `P1IFG0`" ] # [ inline ( always ) ] pub fn is_p1ifg0 ( & self ) -> bool { * self == P1IV_A :: P1IFG0 } # [ doc = "Checks if the value of the field is `P1IFG1`" ] # [ inline ( always ) ] pub fn is_p1ifg1 ( & self ) -> bool { * self == P1IV_A :: P1IFG1 } # [ doc = "Checks if the value of the field is `P1IFG2`" ] # [ inline ( always ) ] pub fn is_p1ifg2 ( & self ) -> bool { * self == P1IV_A :: P1IFG2 } # [ doc = "Checks if the value of the field is `P1IFG3`" ] # [ inline ( always ) ] pub fn is_p1ifg3 ( & self ) -> bool { * self == P1IV_A :: P1IFG3 } # [ doc = "Checks if the value of the field is `P1IFG4`" ] # [ inline ( always ) ] pub fn is_p1ifg4 ( & self ) -> bool { * self == P1IV_A :: P1IFG4 } # [ doc = "Checks if the value of the field is `P1IFG5`" ] # [ inline ( always ) ] pub fn is_p1ifg5 ( & self ) -> bool { * self == P1IV_A :: P1IFG5 } # [ doc = "Checks if the value of the field is `P1IFG6`" ] # [ inline ( always ) ] pub fn is_p1ifg6 ( & self ) -> bool { * self == P1IV_A :: P1IFG6 } # [ doc = "Checks if the value of the field is `P1IFG7`" ] # [ inline ( always ) ] pub fn is_p1ifg7 ( & self ) -> bool { * self == P1IV_A :: P1IFG7 } }
impl R {
# [ doc = "Bits 0:4 - Port 1 interrupt vector value" ] # [ inline ( always ) ] pub fn p1iv ( & self ) -> P1IV_R { P1IV_R :: new ( ( self . bits & 0x1f ) as u8 ) }
}
}
}
# [ doc = "P2" ] pub struct P2 { _marker : PhantomData < * const ( ) > } unsafe impl Send for P2 { } impl P2 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const p2 :: RegisterBlock { 0x0200 as * const _ } } impl Deref for P2 { type Target = p2 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * P2 :: ptr ( ) } } }
# [ doc = "P2" ] pub mod p2 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved0 : [ u8 ; 1usize ] , # [ doc = "0x01 - Port 2 Input" ] pub p2in : P2IN , _reserved1 : [ u8 ; 1usize ] , # [ doc = "0x03 - Port 2 Output" ] pub p2out : P2OUT , _reserved2 : [ u8 ; 1usize ] , # [ doc = "0x05 - Port 2 Direction" ] pub p2dir : P2DIR , _reserved3 : [ u8 ; 1usize ] , # [ doc = "0x07 - Port 2 Resistor Enable" ] pub p2ren : P2REN , _reserved4 : [ u8 ; 3usize ] , # [ doc = "0x0b - Port 2 Select 0" ] pub p2sel0 : P2SEL0 , _reserved5 : [ u8 ; 1usize ] , # [ doc = "0x0d - Port 2 Select 1" ] pub p2sel1 : P2SEL1 , _reserved6 : [ u8 ; 9usize ] , # [ doc = "0x17 - Port 2 Complement Select" ] pub p2selc : P2SELC , _reserved7 : [ u8 ; 1usize ] , # [ doc = "0x19 - Port 2 Interrupt Edge Select" ] pub p2ies : P2IES , _reserved8 : [ u8 ; 1usize ] , # [ doc = "0x1b - Port 2 Interrupt Enable" ] pub p2ie : P2IE , _reserved9 : [ u8 ; 1usize ] , # [ doc = "0x1d - Port 2 Interrupt Flag" ] pub p2ifg : P2IFG , # [ doc = "0x1e - Port 2 Interrupt Vector Register" ] pub p2iv : P2IV , }
# [ doc = "Port 2 Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2in](p2in) module" ] pub type P2IN = crate :: Reg < u8 , _P2IN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2IN ;
# [ doc = "`read()` method returns [p2in::R](p2in::R) reader structure" ] impl crate :: Readable for P2IN { }
# [ doc = "`write(|w| ..)` method takes [p2in::W](p2in::W) writer structure" ] impl crate :: Writable for P2IN { }
# [ doc = "Port 2 Input" ] pub mod p2in {
# [ doc = "Reader of register P2IN" ] pub type R = crate :: R < u8 , super :: P2IN > ;
# [ doc = "Writer for register P2IN" ] pub type W = crate :: W < u8 , super :: P2IN > ;
# [ doc = "Register P2IN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P2IN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 2 Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2out](p2out) module" ] pub type P2OUT = crate :: Reg < u8 , _P2OUT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2OUT ;
# [ doc = "`read()` method returns [p2out::R](p2out::R) reader structure" ] impl crate :: Readable for P2OUT { }
# [ doc = "`write(|w| ..)` method takes [p2out::W](p2out::W) writer structure" ] impl crate :: Writable for P2OUT { }
# [ doc = "Port 2 Output" ] pub mod p2out {
# [ doc = "Reader of register P2OUT" ] pub type R = crate :: R < u8 , super :: P2OUT > ;
# [ doc = "Writer for register P2OUT" ] pub type W = crate :: W < u8 , super :: P2OUT > ;
# [ doc = "Register P2OUT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P2OUT { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 2 Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2dir](p2dir) module" ] pub type P2DIR = crate :: Reg < u8 , _P2DIR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2DIR ;
# [ doc = "`read()` method returns [p2dir::R](p2dir::R) reader structure" ] impl crate :: Readable for P2DIR { }
# [ doc = "`write(|w| ..)` method takes [p2dir::W](p2dir::W) writer structure" ] impl crate :: Writable for P2DIR { }
# [ doc = "Port 2 Direction" ] pub mod p2dir {
# [ doc = "Reader of register P2DIR" ] pub type R = crate :: R < u8 , super :: P2DIR > ;
# [ doc = "Writer for register P2DIR" ] pub type W = crate :: W < u8 , super :: P2DIR > ;
# [ doc = "Register P2DIR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P2DIR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 2 Resistor Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2ren](p2ren) module" ] pub type P2REN = crate :: Reg < u8 , _P2REN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2REN ;
# [ doc = "`read()` method returns [p2ren::R](p2ren::R) reader structure" ] impl crate :: Readable for P2REN { }
# [ doc = "`write(|w| ..)` method takes [p2ren::W](p2ren::W) writer structure" ] impl crate :: Writable for P2REN { }
# [ doc = "Port 2 Resistor Enable" ] pub mod p2ren {
# [ doc = "Reader of register P2REN" ] pub type R = crate :: R < u8 , super :: P2REN > ;
# [ doc = "Writer for register P2REN" ] pub type W = crate :: W < u8 , super :: P2REN > ;
# [ doc = "Register P2REN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P2REN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 2 Select 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2sel0](p2sel0) module" ] pub type P2SEL0 = crate :: Reg < u8 , _P2SEL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2SEL0 ;
# [ doc = "`read()` method returns [p2sel0::R](p2sel0::R) reader structure" ] impl crate :: Readable for P2SEL0 { }
# [ doc = "`write(|w| ..)` method takes [p2sel0::W](p2sel0::W) writer structure" ] impl crate :: Writable for P2SEL0 { }
# [ doc = "Port 2 Select 0" ] pub mod p2sel0 {
# [ doc = "Reader of register P2SEL0" ] pub type R = crate :: R < u8 , super :: P2SEL0 > ;
# [ doc = "Writer for register P2SEL0" ] pub type W = crate :: W < u8 , super :: P2SEL0 > ;
# [ doc = "Register P2SEL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P2SEL0 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 2 Select 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2sel1](p2sel1) module" ] pub type P2SEL1 = crate :: Reg < u8 , _P2SEL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2SEL1 ;
# [ doc = "`read()` method returns [p2sel1::R](p2sel1::R) reader structure" ] impl crate :: Readable for P2SEL1 { }
# [ doc = "`write(|w| ..)` method takes [p2sel1::W](p2sel1::W) writer structure" ] impl crate :: Writable for P2SEL1 { }
# [ doc = "Port 2 Select 1" ] pub mod p2sel1 {
# [ doc = "Reader of register P2SEL1" ] pub type R = crate :: R < u8 , super :: P2SEL1 > ;
# [ doc = "Writer for register P2SEL1" ] pub type W = crate :: W < u8 , super :: P2SEL1 > ;
# [ doc = "Register P2SEL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P2SEL1 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 2 Complement Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2selc](p2selc) module" ] pub type P2SELC = crate :: Reg < u8 , _P2SELC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2SELC ;
# [ doc = "`read()` method returns [p2selc::R](p2selc::R) reader structure" ] impl crate :: Readable for P2SELC { }
# [ doc = "`write(|w| ..)` method takes [p2selc::W](p2selc::W) writer structure" ] impl crate :: Writable for P2SELC { }
# [ doc = "Port 2 Complement Select" ] pub mod p2selc {
# [ doc = "Reader of register P2SELC" ] pub type R = crate :: R < u8 , super :: P2SELC > ;
# [ doc = "Writer for register P2SELC" ] pub type W = crate :: W < u8 , super :: P2SELC > ;
# [ doc = "Register P2SELC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P2SELC { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 2 Interrupt Edge Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2ies](p2ies) module" ] pub type P2IES = crate :: Reg < u8 , _P2IES > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2IES ;
# [ doc = "`read()` method returns [p2ies::R](p2ies::R) reader structure" ] impl crate :: Readable for P2IES { }
# [ doc = "`write(|w| ..)` method takes [p2ies::W](p2ies::W) writer structure" ] impl crate :: Writable for P2IES { }
# [ doc = "Port 2 Interrupt Edge Select" ] pub mod p2ies {
# [ doc = "Reader of register P2IES" ] pub type R = crate :: R < u8 , super :: P2IES > ;
# [ doc = "Writer for register P2IES" ] pub type W = crate :: W < u8 , super :: P2IES > ;
# [ doc = "Register P2IES `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P2IES { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 2 Interrupt Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2ie](p2ie) module" ] pub type P2IE = crate :: Reg < u8 , _P2IE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2IE ;
# [ doc = "`read()` method returns [p2ie::R](p2ie::R) reader structure" ] impl crate :: Readable for P2IE { }
# [ doc = "`write(|w| ..)` method takes [p2ie::W](p2ie::W) writer structure" ] impl crate :: Writable for P2IE { }
# [ doc = "Port 2 Interrupt Enable" ] pub mod p2ie {
# [ doc = "Reader of register P2IE" ] pub type R = crate :: R < u8 , super :: P2IE > ;
# [ doc = "Writer for register P2IE" ] pub type W = crate :: W < u8 , super :: P2IE > ;
# [ doc = "Register P2IE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P2IE { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 2 Interrupt Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2ifg](p2ifg) module" ] pub type P2IFG = crate :: Reg < u8 , _P2IFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2IFG ;
# [ doc = "`read()` method returns [p2ifg::R](p2ifg::R) reader structure" ] impl crate :: Readable for P2IFG { }
# [ doc = "`write(|w| ..)` method takes [p2ifg::W](p2ifg::W) writer structure" ] impl crate :: Writable for P2IFG { }
# [ doc = "Port 2 Interrupt Flag" ] pub mod p2ifg {
# [ doc = "Reader of register P2IFG" ] pub type R = crate :: R < u8 , super :: P2IFG > ;
# [ doc = "Writer for register P2IFG" ] pub type W = crate :: W < u8 , super :: P2IFG > ;
# [ doc = "Register P2IFG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P2IFG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 2 Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2iv](p2iv) module" ] pub type P2IV = crate :: Reg < u16 , _P2IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2IV ;
# [ doc = "`read()` method returns [p2iv::R](p2iv::R) reader structure" ] impl crate :: Readable for P2IV { }
# [ doc = "Port 2 Interrupt Vector Register" ] pub mod p2iv {
# [ doc = "Reader of register P2IV" ] pub type R = crate :: R < u16 , super :: P2IV > ;
# [ doc = "Port 2 interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum P2IV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Port 2.0 interrupt; Interrupt Flag: P2IFG0; Interrupt Priority: Highest" ] P2IFG0 = 2 , # [ doc = "4: Interrupt Source: Port 2.1 interrupt; Interrupt Flag: P2IFG1" ] P2IFG1 = 4 , # [ doc = "6: Interrupt Source: Port 2.2 interrupt; Interrupt Flag: P2IFG2" ] P2IFG2 = 6 , # [ doc = "8: Interrupt Source: Port 2.3 interrupt; Interrupt Flag: P2IFG3" ] P2IFG3 = 8 , # [ doc = "10: Interrupt Source: Port 2.4 interrupt; Interrupt Flag: P2IFG4" ] P2IFG4 = 10 , # [ doc = "12: Interrupt Source: Port 2.5 interrupt; Interrupt Flag: P2IFG5" ] P2IFG5 = 12 , # [ doc = "14: Interrupt Source: Port 2.6 interrupt; Interrupt Flag: P2IFG6" ] P2IFG6 = 14 , # [ doc = "16: Interrupt Source: Port 2.7 interrupt; Interrupt Flag: P2IFG7; Interrupt Priority: Lowest" ] P2IFG7 = 16 } impl From < P2IV_A > for u8 { # [ inline ( always ) ] fn from ( variant : P2IV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `P2IV`" ] pub type P2IV_R = crate :: R < u8 , P2IV_A > ; impl P2IV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , P2IV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( P2IV_A :: NONE ) , 2 => Val ( P2IV_A :: P2IFG0 ) , 4 => Val ( P2IV_A :: P2IFG1 ) , 6 => Val ( P2IV_A :: P2IFG2 ) , 8 => Val ( P2IV_A :: P2IFG3 ) , 10 => Val ( P2IV_A :: P2IFG4 ) , 12 => Val ( P2IV_A :: P2IFG5 ) , 14 => Val ( P2IV_A :: P2IFG6 ) , 16 => Val ( P2IV_A :: P2IFG7 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == P2IV_A :: NONE } # [ doc = "Checks if the value of the field is `P2IFG0`" ] # [ inline ( always ) ] pub fn is_p2ifg0 ( & self ) -> bool { * self == P2IV_A :: P2IFG0 } # [ doc = "Checks if the value of the field is `P2IFG1`" ] # [ inline ( always ) ] pub fn is_p2ifg1 ( & self ) -> bool { * self == P2IV_A :: P2IFG1 } # [ doc = "Checks if the value of the field is `P2IFG2`" ] # [ inline ( always ) ] pub fn is_p2ifg2 ( & self ) -> bool { * self == P2IV_A :: P2IFG2 } # [ doc = "Checks if the value of the field is `P2IFG3`" ] # [ inline ( always ) ] pub fn is_p2ifg3 ( & self ) -> bool { * self == P2IV_A :: P2IFG3 } # [ doc = "Checks if the value of the field is `P2IFG4`" ] # [ inline ( always ) ] pub fn is_p2ifg4 ( & self ) -> bool { * self == P2IV_A :: P2IFG4 } # [ doc = "Checks if the value of the field is `P2IFG5`" ] # [ inline ( always ) ] pub fn is_p2ifg5 ( & self ) -> bool { * self == P2IV_A :: P2IFG5 } # [ doc = "Checks if the value of the field is `P2IFG6`" ] # [ inline ( always ) ] pub fn is_p2ifg6 ( & self ) -> bool { * self == P2IV_A :: P2IFG6 } # [ doc = "Checks if the value of the field is `P2IFG7`" ] # [ inline ( always ) ] pub fn is_p2ifg7 ( & self ) -> bool { * self == P2IV_A :: P2IFG7 } }
impl R {
# [ doc = "Bits 0:4 - Port 2 interrupt vector value" ] # [ inline ( always ) ] pub fn p2iv ( & self ) -> P2IV_R { P2IV_R :: new ( ( self . bits & 0x1f ) as u8 ) }
}
}
}
# [ doc = "P3" ] pub struct P3 { _marker : PhantomData < * const ( ) > } unsafe impl Send for P3 { } impl P3 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const p3 :: RegisterBlock { 0x0220 as * const _ } } impl Deref for P3 { type Target = p3 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * P3 :: ptr ( ) } } }
# [ doc = "P3" ] pub mod p3 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Port 3 Input" ] pub p3in : P3IN , _reserved1 : [ u8 ; 1usize ] , # [ doc = "0x02 - Port 3 Output" ] pub p3out : P3OUT , _reserved2 : [ u8 ; 1usize ] , # [ doc = "0x04 - Port 3 Direction" ] pub p3dir : P3DIR , _reserved3 : [ u8 ; 1usize ] , # [ doc = "0x06 - Port 3 Resistor Enable" ] pub p3ren : P3REN , _reserved4 : [ u8 ; 3usize ] , # [ doc = "0x0a - Port 3 Select 0" ] pub p3sel0 : P3SEL0 , _reserved5 : [ u8 ; 1usize ] , # [ doc = "0x0c - Port 3 Select 1" ] pub p3sel1 : P3SEL1 , _reserved6 : [ u8 ; 1usize ] , # [ doc = "0x0e - Port 3 Interrupt Vector Register" ] pub p3iv : P3IV , _reserved7 : [ u8 ; 6usize ] , # [ doc = "0x16 - Port 3 Complement Select" ] pub p3selc : P3SELC , _reserved8 : [ u8 ; 1usize ] , # [ doc = "0x18 - Port 3 Interrupt Edge Select" ] pub p3ies : P3IES , _reserved9 : [ u8 ; 1usize ] , # [ doc = "0x1a - Port 3 Interrupt Enable" ] pub p3ie : P3IE , _reserved10 : [ u8 ; 1usize ] , # [ doc = "0x1c - Port 3 Interrupt Flag" ] pub p3ifg : P3IFG , }
# [ doc = "Port 3 Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3in](p3in) module" ] pub type P3IN = crate :: Reg < u8 , _P3IN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3IN ;
# [ doc = "`read()` method returns [p3in::R](p3in::R) reader structure" ] impl crate :: Readable for P3IN { }
# [ doc = "`write(|w| ..)` method takes [p3in::W](p3in::W) writer structure" ] impl crate :: Writable for P3IN { }
# [ doc = "Port 3 Input" ] pub mod p3in {
# [ doc = "Reader of register P3IN" ] pub type R = crate :: R < u8 , super :: P3IN > ;
# [ doc = "Writer for register P3IN" ] pub type W = crate :: W < u8 , super :: P3IN > ;
# [ doc = "Register P3IN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P3IN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 3 Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3out](p3out) module" ] pub type P3OUT = crate :: Reg < u8 , _P3OUT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3OUT ;
# [ doc = "`read()` method returns [p3out::R](p3out::R) reader structure" ] impl crate :: Readable for P3OUT { }
# [ doc = "`write(|w| ..)` method takes [p3out::W](p3out::W) writer structure" ] impl crate :: Writable for P3OUT { }
# [ doc = "Port 3 Output" ] pub mod p3out {
# [ doc = "Reader of register P3OUT" ] pub type R = crate :: R < u8 , super :: P3OUT > ;
# [ doc = "Writer for register P3OUT" ] pub type W = crate :: W < u8 , super :: P3OUT > ;
# [ doc = "Register P3OUT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P3OUT { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 3 Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3dir](p3dir) module" ] pub type P3DIR = crate :: Reg < u8 , _P3DIR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3DIR ;
# [ doc = "`read()` method returns [p3dir::R](p3dir::R) reader structure" ] impl crate :: Readable for P3DIR { }
# [ doc = "`write(|w| ..)` method takes [p3dir::W](p3dir::W) writer structure" ] impl crate :: Writable for P3DIR { }
# [ doc = "Port 3 Direction" ] pub mod p3dir {
# [ doc = "Reader of register P3DIR" ] pub type R = crate :: R < u8 , super :: P3DIR > ;
# [ doc = "Writer for register P3DIR" ] pub type W = crate :: W < u8 , super :: P3DIR > ;
# [ doc = "Register P3DIR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P3DIR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 3 Resistor Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3ren](p3ren) module" ] pub type P3REN = crate :: Reg < u8 , _P3REN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3REN ;
# [ doc = "`read()` method returns [p3ren::R](p3ren::R) reader structure" ] impl crate :: Readable for P3REN { }
# [ doc = "`write(|w| ..)` method takes [p3ren::W](p3ren::W) writer structure" ] impl crate :: Writable for P3REN { }
# [ doc = "Port 3 Resistor Enable" ] pub mod p3ren {
# [ doc = "Reader of register P3REN" ] pub type R = crate :: R < u8 , super :: P3REN > ;
# [ doc = "Writer for register P3REN" ] pub type W = crate :: W < u8 , super :: P3REN > ;
# [ doc = "Register P3REN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P3REN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 3 Select 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3sel0](p3sel0) module" ] pub type P3SEL0 = crate :: Reg < u8 , _P3SEL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3SEL0 ;
# [ doc = "`read()` method returns [p3sel0::R](p3sel0::R) reader structure" ] impl crate :: Readable for P3SEL0 { }
# [ doc = "`write(|w| ..)` method takes [p3sel0::W](p3sel0::W) writer structure" ] impl crate :: Writable for P3SEL0 { }
# [ doc = "Port 3 Select 0" ] pub mod p3sel0 {
# [ doc = "Reader of register P3SEL0" ] pub type R = crate :: R < u8 , super :: P3SEL0 > ;
# [ doc = "Writer for register P3SEL0" ] pub type W = crate :: W < u8 , super :: P3SEL0 > ;
# [ doc = "Register P3SEL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P3SEL0 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 3 Select 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3sel1](p3sel1) module" ] pub type P3SEL1 = crate :: Reg < u8 , _P3SEL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3SEL1 ;
# [ doc = "`read()` method returns [p3sel1::R](p3sel1::R) reader structure" ] impl crate :: Readable for P3SEL1 { }
# [ doc = "`write(|w| ..)` method takes [p3sel1::W](p3sel1::W) writer structure" ] impl crate :: Writable for P3SEL1 { }
# [ doc = "Port 3 Select 1" ] pub mod p3sel1 {
# [ doc = "Reader of register P3SEL1" ] pub type R = crate :: R < u8 , super :: P3SEL1 > ;
# [ doc = "Writer for register P3SEL1" ] pub type W = crate :: W < u8 , super :: P3SEL1 > ;
# [ doc = "Register P3SEL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P3SEL1 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 3 Complement Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3selc](p3selc) module" ] pub type P3SELC = crate :: Reg < u8 , _P3SELC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3SELC ;
# [ doc = "`read()` method returns [p3selc::R](p3selc::R) reader structure" ] impl crate :: Readable for P3SELC { }
# [ doc = "`write(|w| ..)` method takes [p3selc::W](p3selc::W) writer structure" ] impl crate :: Writable for P3SELC { }
# [ doc = "Port 3 Complement Select" ] pub mod p3selc {
# [ doc = "Reader of register P3SELC" ] pub type R = crate :: R < u8 , super :: P3SELC > ;
# [ doc = "Writer for register P3SELC" ] pub type W = crate :: W < u8 , super :: P3SELC > ;
# [ doc = "Register P3SELC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P3SELC { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 3 Interrupt Edge Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3ies](p3ies) module" ] pub type P3IES = crate :: Reg < u8 , _P3IES > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3IES ;
# [ doc = "`read()` method returns [p3ies::R](p3ies::R) reader structure" ] impl crate :: Readable for P3IES { }
# [ doc = "`write(|w| ..)` method takes [p3ies::W](p3ies::W) writer structure" ] impl crate :: Writable for P3IES { }
# [ doc = "Port 3 Interrupt Edge Select" ] pub mod p3ies {
# [ doc = "Reader of register P3IES" ] pub type R = crate :: R < u8 , super :: P3IES > ;
# [ doc = "Writer for register P3IES" ] pub type W = crate :: W < u8 , super :: P3IES > ;
# [ doc = "Register P3IES `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P3IES { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 3 Interrupt Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3ie](p3ie) module" ] pub type P3IE = crate :: Reg < u8 , _P3IE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3IE ;
# [ doc = "`read()` method returns [p3ie::R](p3ie::R) reader structure" ] impl crate :: Readable for P3IE { }
# [ doc = "`write(|w| ..)` method takes [p3ie::W](p3ie::W) writer structure" ] impl crate :: Writable for P3IE { }
# [ doc = "Port 3 Interrupt Enable" ] pub mod p3ie {
# [ doc = "Reader of register P3IE" ] pub type R = crate :: R < u8 , super :: P3IE > ;
# [ doc = "Writer for register P3IE" ] pub type W = crate :: W < u8 , super :: P3IE > ;
# [ doc = "Register P3IE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P3IE { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 3 Interrupt Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3ifg](p3ifg) module" ] pub type P3IFG = crate :: Reg < u8 , _P3IFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3IFG ;
# [ doc = "`read()` method returns [p3ifg::R](p3ifg::R) reader structure" ] impl crate :: Readable for P3IFG { }
# [ doc = "`write(|w| ..)` method takes [p3ifg::W](p3ifg::W) writer structure" ] impl crate :: Writable for P3IFG { }
# [ doc = "Port 3 Interrupt Flag" ] pub mod p3ifg {
# [ doc = "Reader of register P3IFG" ] pub type R = crate :: R < u8 , super :: P3IFG > ;
# [ doc = "Writer for register P3IFG" ] pub type W = crate :: W < u8 , super :: P3IFG > ;
# [ doc = "Register P3IFG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P3IFG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 3 Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3iv](p3iv) module" ] pub type P3IV = crate :: Reg < u16 , _P3IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3IV ;
# [ doc = "`read()` method returns [p3iv::R](p3iv::R) reader structure" ] impl crate :: Readable for P3IV { }
# [ doc = "Port 3 Interrupt Vector Register" ] pub mod p3iv {
# [ doc = "Reader of register P3IV" ] pub type R = crate :: R < u16 , super :: P3IV > ;
# [ doc = "Port 3 interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum P3IV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Port 3.0 interrupt; Interrupt Flag: P3IFG0; Interrupt Priority: Highest" ] P3IFG0 = 2 , # [ doc = "4: Interrupt Source: Port 3.1 interrupt; Interrupt Flag: P3IFG1" ] P3IFG1 = 4 , # [ doc = "6: Interrupt Source: Port 3.2 interrupt; Interrupt Flag: P3IFG2" ] P3IFG2 = 6 , # [ doc = "8: Interrupt Source: Port 3.3 interrupt; Interrupt Flag: P3IFG3" ] P3IFG3 = 8 , # [ doc = "10: Interrupt Source: Port 3.4 interrupt; Interrupt Flag: P3IFG4" ] P3IFG4 = 10 , # [ doc = "12: Interrupt Source: Port 3.5 interrupt; Interrupt Flag: P3IFG5" ] P3IFG5 = 12 , # [ doc = "14: Interrupt Source: Port 3.6 interrupt; Interrupt Flag: P3IFG6" ] P3IFG6 = 14 , # [ doc = "16: Interrupt Source: Port 3.7 interrupt; Interrupt Flag: P3IFG7; Interrupt Priority: Lowest" ] P3IFG7 = 16 } impl From < P3IV_A > for u8 { # [ inline ( always ) ] fn from ( variant : P3IV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `P3IV`" ] pub type P3IV_R = crate :: R < u8 , P3IV_A > ; impl P3IV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , P3IV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( P3IV_A :: NONE ) , 2 => Val ( P3IV_A :: P3IFG0 ) , 4 => Val ( P3IV_A :: P3IFG1 ) , 6 => Val ( P3IV_A :: P3IFG2 ) , 8 => Val ( P3IV_A :: P3IFG3 ) , 10 => Val ( P3IV_A :: P3IFG4 ) , 12 => Val ( P3IV_A :: P3IFG5 ) , 14 => Val ( P3IV_A :: P3IFG6 ) , 16 => Val ( P3IV_A :: P3IFG7 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == P3IV_A :: NONE } # [ doc = "Checks if the value of the field is `P3IFG0`" ] # [ inline ( always ) ] pub fn is_p3ifg0 ( & self ) -> bool { * self == P3IV_A :: P3IFG0 } # [ doc = "Checks if the value of the field is `P3IFG1`" ] # [ inline ( always ) ] pub fn is_p3ifg1 ( & self ) -> bool { * self == P3IV_A :: P3IFG1 } # [ doc = "Checks if the value of the field is `P3IFG2`" ] # [ inline ( always ) ] pub fn is_p3ifg2 ( & self ) -> bool { * self == P3IV_A :: P3IFG2 } # [ doc = "Checks if the value of the field is `P3IFG3`" ] # [ inline ( always ) ] pub fn is_p3ifg3 ( & self ) -> bool { * self == P3IV_A :: P3IFG3 } # [ doc = "Checks if the value of the field is `P3IFG4`" ] # [ inline ( always ) ] pub fn is_p3ifg4 ( & self ) -> bool { * self == P3IV_A :: P3IFG4 } # [ doc = "Checks if the value of the field is `P3IFG5`" ] # [ inline ( always ) ] pub fn is_p3ifg5 ( & self ) -> bool { * self == P3IV_A :: P3IFG5 } # [ doc = "Checks if the value of the field is `P3IFG6`" ] # [ inline ( always ) ] pub fn is_p3ifg6 ( & self ) -> bool { * self == P3IV_A :: P3IFG6 } # [ doc = "Checks if the value of the field is `P3IFG7`" ] # [ inline ( always ) ] pub fn is_p3ifg7 ( & self ) -> bool { * self == P3IV_A :: P3IFG7 } }
impl R {
# [ doc = "Bits 0:4 - Port 3 interrupt vector value" ] # [ inline ( always ) ] pub fn p3iv ( & self ) -> P3IV_R { P3IV_R :: new ( ( self . bits & 0x1f ) as u8 ) }
}
}
}
# [ doc = "P4" ] pub struct P4 { _marker : PhantomData < * const ( ) > } unsafe impl Send for P4 { } impl P4 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const p4 :: RegisterBlock { 0x0220 as * const _ } } impl Deref for P4 { type Target = p4 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * P4 :: ptr ( ) } } }
# [ doc = "P4" ] pub mod p4 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved0 : [ u8 ; 1usize ] , # [ doc = "0x01 - Port 4 Input" ] pub p4in : P4IN , _reserved1 : [ u8 ; 1usize ] , # [ doc = "0x03 - Port 4 Output" ] pub p4out : P4OUT , _reserved2 : [ u8 ; 1usize ] , # [ doc = "0x05 - Port 4 Direction" ] pub p4dir : P4DIR , _reserved3 : [ u8 ; 1usize ] , # [ doc = "0x07 - Port 4 Resistor Enable" ] pub p4ren : P4REN , _reserved4 : [ u8 ; 3usize ] , # [ doc = "0x0b - Port 4 Select 0" ] pub p4sel0 : P4SEL0 , _reserved5 : [ u8 ; 1usize ] , # [ doc = "0x0d - Port 4 Select 1" ] pub p4sel1 : P4SEL1 , _reserved6 : [ u8 ; 9usize ] , # [ doc = "0x17 - Port 4 Complement Select" ] pub p4selc : P4SELC , _reserved7 : [ u8 ; 1usize ] , # [ doc = "0x19 - Port 4 Interrupt Edge Select" ] pub p4ies : P4IES , _reserved8 : [ u8 ; 1usize ] , # [ doc = "0x1b - Port 4 Interrupt Enable" ] pub p4ie : P4IE , _reserved9 : [ u8 ; 1usize ] , # [ doc = "0x1d - Port 4 Interrupt Flag" ] pub p4ifg : P4IFG , # [ doc = "0x1e - Port 4 Interrupt Vector Register" ] pub p4iv : P4IV , }
# [ doc = "Port 4 Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4in](p4in) module" ] pub type P4IN = crate :: Reg < u8 , _P4IN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4IN ;
# [ doc = "`read()` method returns [p4in::R](p4in::R) reader structure" ] impl crate :: Readable for P4IN { }
# [ doc = "`write(|w| ..)` method takes [p4in::W](p4in::W) writer structure" ] impl crate :: Writable for P4IN { }
# [ doc = "Port 4 Input" ] pub mod p4in {
# [ doc = "Reader of register P4IN" ] pub type R = crate :: R < u8 , super :: P4IN > ;
# [ doc = "Writer for register P4IN" ] pub type W = crate :: W < u8 , super :: P4IN > ;
# [ doc = "Register P4IN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P4IN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 4 Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4out](p4out) module" ] pub type P4OUT = crate :: Reg < u8 , _P4OUT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4OUT ;
# [ doc = "`read()` method returns [p4out::R](p4out::R) reader structure" ] impl crate :: Readable for P4OUT { }
# [ doc = "`write(|w| ..)` method takes [p4out::W](p4out::W) writer structure" ] impl crate :: Writable for P4OUT { }
# [ doc = "Port 4 Output" ] pub mod p4out {
# [ doc = "Reader of register P4OUT" ] pub type R = crate :: R < u8 , super :: P4OUT > ;
# [ doc = "Writer for register P4OUT" ] pub type W = crate :: W < u8 , super :: P4OUT > ;
# [ doc = "Register P4OUT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P4OUT { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 4 Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4dir](p4dir) module" ] pub type P4DIR = crate :: Reg < u8 , _P4DIR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4DIR ;
# [ doc = "`read()` method returns [p4dir::R](p4dir::R) reader structure" ] impl crate :: Readable for P4DIR { }
# [ doc = "`write(|w| ..)` method takes [p4dir::W](p4dir::W) writer structure" ] impl crate :: Writable for P4DIR { }
# [ doc = "Port 4 Direction" ] pub mod p4dir {
# [ doc = "Reader of register P4DIR" ] pub type R = crate :: R < u8 , super :: P4DIR > ;
# [ doc = "Writer for register P4DIR" ] pub type W = crate :: W < u8 , super :: P4DIR > ;
# [ doc = "Register P4DIR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P4DIR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 4 Resistor Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4ren](p4ren) module" ] pub type P4REN = crate :: Reg < u8 , _P4REN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4REN ;
# [ doc = "`read()` method returns [p4ren::R](p4ren::R) reader structure" ] impl crate :: Readable for P4REN { }
# [ doc = "`write(|w| ..)` method takes [p4ren::W](p4ren::W) writer structure" ] impl crate :: Writable for P4REN { }
# [ doc = "Port 4 Resistor Enable" ] pub mod p4ren {
# [ doc = "Reader of register P4REN" ] pub type R = crate :: R < u8 , super :: P4REN > ;
# [ doc = "Writer for register P4REN" ] pub type W = crate :: W < u8 , super :: P4REN > ;
# [ doc = "Register P4REN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P4REN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 4 Select 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4sel0](p4sel0) module" ] pub type P4SEL0 = crate :: Reg < u8 , _P4SEL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4SEL0 ;
# [ doc = "`read()` method returns [p4sel0::R](p4sel0::R) reader structure" ] impl crate :: Readable for P4SEL0 { }
# [ doc = "`write(|w| ..)` method takes [p4sel0::W](p4sel0::W) writer structure" ] impl crate :: Writable for P4SEL0 { }
# [ doc = "Port 4 Select 0" ] pub mod p4sel0 {
# [ doc = "Reader of register P4SEL0" ] pub type R = crate :: R < u8 , super :: P4SEL0 > ;
# [ doc = "Writer for register P4SEL0" ] pub type W = crate :: W < u8 , super :: P4SEL0 > ;
# [ doc = "Register P4SEL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P4SEL0 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 4 Select 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4sel1](p4sel1) module" ] pub type P4SEL1 = crate :: Reg < u8 , _P4SEL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4SEL1 ;
# [ doc = "`read()` method returns [p4sel1::R](p4sel1::R) reader structure" ] impl crate :: Readable for P4SEL1 { }
# [ doc = "`write(|w| ..)` method takes [p4sel1::W](p4sel1::W) writer structure" ] impl crate :: Writable for P4SEL1 { }
# [ doc = "Port 4 Select 1" ] pub mod p4sel1 {
# [ doc = "Reader of register P4SEL1" ] pub type R = crate :: R < u8 , super :: P4SEL1 > ;
# [ doc = "Writer for register P4SEL1" ] pub type W = crate :: W < u8 , super :: P4SEL1 > ;
# [ doc = "Register P4SEL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P4SEL1 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 4 Complement Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4selc](p4selc) module" ] pub type P4SELC = crate :: Reg < u8 , _P4SELC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4SELC ;
# [ doc = "`read()` method returns [p4selc::R](p4selc::R) reader structure" ] impl crate :: Readable for P4SELC { }
# [ doc = "`write(|w| ..)` method takes [p4selc::W](p4selc::W) writer structure" ] impl crate :: Writable for P4SELC { }
# [ doc = "Port 4 Complement Select" ] pub mod p4selc {
# [ doc = "Reader of register P4SELC" ] pub type R = crate :: R < u8 , super :: P4SELC > ;
# [ doc = "Writer for register P4SELC" ] pub type W = crate :: W < u8 , super :: P4SELC > ;
# [ doc = "Register P4SELC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P4SELC { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 4 Interrupt Edge Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4ies](p4ies) module" ] pub type P4IES = crate :: Reg < u8 , _P4IES > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4IES ;
# [ doc = "`read()` method returns [p4ies::R](p4ies::R) reader structure" ] impl crate :: Readable for P4IES { }
# [ doc = "`write(|w| ..)` method takes [p4ies::W](p4ies::W) writer structure" ] impl crate :: Writable for P4IES { }
# [ doc = "Port 4 Interrupt Edge Select" ] pub mod p4ies {
# [ doc = "Reader of register P4IES" ] pub type R = crate :: R < u8 , super :: P4IES > ;
# [ doc = "Writer for register P4IES" ] pub type W = crate :: W < u8 , super :: P4IES > ;
# [ doc = "Register P4IES `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P4IES { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 4 Interrupt Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4ie](p4ie) module" ] pub type P4IE = crate :: Reg < u8 , _P4IE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4IE ;
# [ doc = "`read()` method returns [p4ie::R](p4ie::R) reader structure" ] impl crate :: Readable for P4IE { }
# [ doc = "`write(|w| ..)` method takes [p4ie::W](p4ie::W) writer structure" ] impl crate :: Writable for P4IE { }
# [ doc = "Port 4 Interrupt Enable" ] pub mod p4ie {
# [ doc = "Reader of register P4IE" ] pub type R = crate :: R < u8 , super :: P4IE > ;
# [ doc = "Writer for register P4IE" ] pub type W = crate :: W < u8 , super :: P4IE > ;
# [ doc = "Register P4IE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P4IE { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 4 Interrupt Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4ifg](p4ifg) module" ] pub type P4IFG = crate :: Reg < u8 , _P4IFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4IFG ;
# [ doc = "`read()` method returns [p4ifg::R](p4ifg::R) reader structure" ] impl crate :: Readable for P4IFG { }
# [ doc = "`write(|w| ..)` method takes [p4ifg::W](p4ifg::W) writer structure" ] impl crate :: Writable for P4IFG { }
# [ doc = "Port 4 Interrupt Flag" ] pub mod p4ifg {
# [ doc = "Reader of register P4IFG" ] pub type R = crate :: R < u8 , super :: P4IFG > ;
# [ doc = "Writer for register P4IFG" ] pub type W = crate :: W < u8 , super :: P4IFG > ;
# [ doc = "Register P4IFG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P4IFG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 4 Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4iv](p4iv) module" ] pub type P4IV = crate :: Reg < u16 , _P4IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4IV ;
# [ doc = "`read()` method returns [p4iv::R](p4iv::R) reader structure" ] impl crate :: Readable for P4IV { }
# [ doc = "Port 4 Interrupt Vector Register" ] pub mod p4iv {
# [ doc = "Reader of register P4IV" ] pub type R = crate :: R < u16 , super :: P4IV > ;
# [ doc = "Port 4 interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum P4IV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Port 4.0 interrupt; Interrupt Flag: P4IFG0; Interrupt Priority: Highest" ] P4IFG0 = 2 , # [ doc = "4: Interrupt Source: Port 4.1 interrupt; Interrupt Flag: P4IFG1" ] P4IFG1 = 4 , # [ doc = "6: Interrupt Source: Port 4.2 interrupt; Interrupt Flag: P4IFG2" ] P4IFG2 = 6 , # [ doc = "8: Interrupt Source: Port 4.3 interrupt; Interrupt Flag: P4IFG3" ] P4IFG3 = 8 , # [ doc = "10: Interrupt Source: Port 4.4 interrupt; Interrupt Flag: P4IFG4" ] P4IFG4 = 10 , # [ doc = "12: Interrupt Source: Port 4.5 interrupt; Interrupt Flag: P4IFG5" ] P4IFG5 = 12 , # [ doc = "14: Interrupt Source: Port 4.6 interrupt; Interrupt Flag: P4IFG6" ] P4IFG6 = 14 , # [ doc = "16: Interrupt Source: Port 4.7 interrupt; Interrupt Flag: P4IFG7; Interrupt Priority: Lowest" ] P4IFG7 = 16 } impl From < P4IV_A > for u8 { # [ inline ( always ) ] fn from ( variant : P4IV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `P4IV`" ] pub type P4IV_R = crate :: R < u8 , P4IV_A > ; impl P4IV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , P4IV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( P4IV_A :: NONE ) , 2 => Val ( P4IV_A :: P4IFG0 ) , 4 => Val ( P4IV_A :: P4IFG1 ) , 6 => Val ( P4IV_A :: P4IFG2 ) , 8 => Val ( P4IV_A :: P4IFG3 ) , 10 => Val ( P4IV_A :: P4IFG4 ) , 12 => Val ( P4IV_A :: P4IFG5 ) , 14 => Val ( P4IV_A :: P4IFG6 ) , 16 => Val ( P4IV_A :: P4IFG7 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == P4IV_A :: NONE } # [ doc = "Checks if the value of the field is `P4IFG0`" ] # [ inline ( always ) ] pub fn is_p4ifg0 ( & self ) -> bool { * self == P4IV_A :: P4IFG0 } # [ doc = "Checks if the value of the field is `P4IFG1`" ] # [ inline ( always ) ] pub fn is_p4ifg1 ( & self ) -> bool { * self == P4IV_A :: P4IFG1 } # [ doc = "Checks if the value of the field is `P4IFG2`" ] # [ inline ( always ) ] pub fn is_p4ifg2 ( & self ) -> bool { * self == P4IV_A :: P4IFG2 } # [ doc = "Checks if the value of the field is `P4IFG3`" ] # [ inline ( always ) ] pub fn is_p4ifg3 ( & self ) -> bool { * self == P4IV_A :: P4IFG3 } # [ doc = "Checks if the value of the field is `P4IFG4`" ] # [ inline ( always ) ] pub fn is_p4ifg4 ( & self ) -> bool { * self == P4IV_A :: P4IFG4 } # [ doc = "Checks if the value of the field is `P4IFG5`" ] # [ inline ( always ) ] pub fn is_p4ifg5 ( & self ) -> bool { * self == P4IV_A :: P4IFG5 } # [ doc = "Checks if the value of the field is `P4IFG6`" ] # [ inline ( always ) ] pub fn is_p4ifg6 ( & self ) -> bool { * self == P4IV_A :: P4IFG6 } # [ doc = "Checks if the value of the field is `P4IFG7`" ] # [ inline ( always ) ] pub fn is_p4ifg7 ( & self ) -> bool { * self == P4IV_A :: P4IFG7 } }
impl R {
# [ doc = "Bits 0:4 - Port 4 interrupt vector value" ] # [ inline ( always ) ] pub fn p4iv ( & self ) -> P4IV_R { P4IV_R :: new ( ( self . bits & 0x1f ) as u8 ) }
}
}
}
# [ doc = "P5" ] pub struct P5 { _marker : PhantomData < * const ( ) > } unsafe impl Send for P5 { } impl P5 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const p5 :: RegisterBlock { 0x0240 as * const _ } } impl Deref for P5 { type Target = p5 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * P5 :: ptr ( ) } } }
# [ doc = "P5" ] pub mod p5 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Port 5 Input" ] pub p5in : P5IN , _reserved1 : [ u8 ; 1usize ] , # [ doc = "0x02 - Port 5 Output" ] pub p5out : P5OUT , _reserved2 : [ u8 ; 1usize ] , # [ doc = "0x04 - Port 5 Direction" ] pub p5dir : P5DIR , _reserved3 : [ u8 ; 1usize ] , # [ doc = "0x06 - Port 5 Resistor Enable" ] pub p5ren : P5REN , _reserved4 : [ u8 ; 3usize ] , # [ doc = "0x0a - Port 5 Select 0" ] pub p5sel0 : P5SEL0 , _reserved5 : [ u8 ; 1usize ] , # [ doc = "0x0c - Port 5 Select 1" ] pub p5sel1 : P5SEL1 , _reserved6 : [ u8 ; 9usize ] , # [ doc = "0x16 - Port 5 Complement Select" ] pub p5selc : P5SELC , }
# [ doc = "Port 5 Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p5in](p5in) module" ] pub type P5IN = crate :: Reg < u8 , _P5IN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P5IN ;
# [ doc = "`read()` method returns [p5in::R](p5in::R) reader structure" ] impl crate :: Readable for P5IN { }
# [ doc = "`write(|w| ..)` method takes [p5in::W](p5in::W) writer structure" ] impl crate :: Writable for P5IN { }
# [ doc = "Port 5 Input" ] pub mod p5in {
# [ doc = "Reader of register P5IN" ] pub type R = crate :: R < u8 , super :: P5IN > ;
# [ doc = "Writer for register P5IN" ] pub type W = crate :: W < u8 , super :: P5IN > ;
# [ doc = "Register P5IN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P5IN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 5 Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p5out](p5out) module" ] pub type P5OUT = crate :: Reg < u8 , _P5OUT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P5OUT ;
# [ doc = "`read()` method returns [p5out::R](p5out::R) reader structure" ] impl crate :: Readable for P5OUT { }
# [ doc = "`write(|w| ..)` method takes [p5out::W](p5out::W) writer structure" ] impl crate :: Writable for P5OUT { }
# [ doc = "Port 5 Output" ] pub mod p5out {
# [ doc = "Reader of register P5OUT" ] pub type R = crate :: R < u8 , super :: P5OUT > ;
# [ doc = "Writer for register P5OUT" ] pub type W = crate :: W < u8 , super :: P5OUT > ;
# [ doc = "Register P5OUT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P5OUT { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 5 Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p5dir](p5dir) module" ] pub type P5DIR = crate :: Reg < u8 , _P5DIR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P5DIR ;
# [ doc = "`read()` method returns [p5dir::R](p5dir::R) reader structure" ] impl crate :: Readable for P5DIR { }
# [ doc = "`write(|w| ..)` method takes [p5dir::W](p5dir::W) writer structure" ] impl crate :: Writable for P5DIR { }
# [ doc = "Port 5 Direction" ] pub mod p5dir {
# [ doc = "Reader of register P5DIR" ] pub type R = crate :: R < u8 , super :: P5DIR > ;
# [ doc = "Writer for register P5DIR" ] pub type W = crate :: W < u8 , super :: P5DIR > ;
# [ doc = "Register P5DIR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P5DIR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 5 Resistor Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p5ren](p5ren) module" ] pub type P5REN = crate :: Reg < u8 , _P5REN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P5REN ;
# [ doc = "`read()` method returns [p5ren::R](p5ren::R) reader structure" ] impl crate :: Readable for P5REN { }
# [ doc = "`write(|w| ..)` method takes [p5ren::W](p5ren::W) writer structure" ] impl crate :: Writable for P5REN { }
# [ doc = "Port 5 Resistor Enable" ] pub mod p5ren {
# [ doc = "Reader of register P5REN" ] pub type R = crate :: R < u8 , super :: P5REN > ;
# [ doc = "Writer for register P5REN" ] pub type W = crate :: W < u8 , super :: P5REN > ;
# [ doc = "Register P5REN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P5REN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 5 Select 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p5sel0](p5sel0) module" ] pub type P5SEL0 = crate :: Reg < u8 , _P5SEL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P5SEL0 ;
# [ doc = "`read()` method returns [p5sel0::R](p5sel0::R) reader structure" ] impl crate :: Readable for P5SEL0 { }
# [ doc = "`write(|w| ..)` method takes [p5sel0::W](p5sel0::W) writer structure" ] impl crate :: Writable for P5SEL0 { }
# [ doc = "Port 5 Select 0" ] pub mod p5sel0 {
# [ doc = "Reader of register P5SEL0" ] pub type R = crate :: R < u8 , super :: P5SEL0 > ;
# [ doc = "Writer for register P5SEL0" ] pub type W = crate :: W < u8 , super :: P5SEL0 > ;
# [ doc = "Register P5SEL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P5SEL0 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 5 Select 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p5sel1](p5sel1) module" ] pub type P5SEL1 = crate :: Reg < u8 , _P5SEL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P5SEL1 ;
# [ doc = "`read()` method returns [p5sel1::R](p5sel1::R) reader structure" ] impl crate :: Readable for P5SEL1 { }
# [ doc = "`write(|w| ..)` method takes [p5sel1::W](p5sel1::W) writer structure" ] impl crate :: Writable for P5SEL1 { }
# [ doc = "Port 5 Select 1" ] pub mod p5sel1 {
# [ doc = "Reader of register P5SEL1" ] pub type R = crate :: R < u8 , super :: P5SEL1 > ;
# [ doc = "Writer for register P5SEL1" ] pub type W = crate :: W < u8 , super :: P5SEL1 > ;
# [ doc = "Register P5SEL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P5SEL1 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 5 Complement Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p5selc](p5selc) module" ] pub type P5SELC = crate :: Reg < u8 , _P5SELC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P5SELC ;
# [ doc = "`read()` method returns [p5selc::R](p5selc::R) reader structure" ] impl crate :: Readable for P5SELC { }
# [ doc = "`write(|w| ..)` method takes [p5selc::W](p5selc::W) writer structure" ] impl crate :: Writable for P5SELC { }
# [ doc = "Port 5 Complement Select" ] pub mod p5selc {
# [ doc = "Reader of register P5SELC" ] pub type R = crate :: R < u8 , super :: P5SELC > ;
# [ doc = "Writer for register P5SELC" ] pub type W = crate :: W < u8 , super :: P5SELC > ;
# [ doc = "Register P5SELC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P5SELC { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
}
# [ doc = "P6" ] pub struct P6 { _marker : PhantomData < * const ( ) > } unsafe impl Send for P6 { } impl P6 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const p6 :: RegisterBlock { 0x0240 as * const _ } } impl Deref for P6 { type Target = p6 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * P6 :: ptr ( ) } } }
# [ doc = "P6" ] pub mod p6 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved0 : [ u8 ; 1usize ] , # [ doc = "0x01 - Port 6 Input" ] pub p6in : P6IN , _reserved1 : [ u8 ; 1usize ] , # [ doc = "0x03 - Port 6 Output" ] pub p6out : P6OUT , _reserved2 : [ u8 ; 1usize ] , # [ doc = "0x05 - Port 6 Direction" ] pub p6dir : P6DIR , _reserved3 : [ u8 ; 1usize ] , # [ doc = "0x07 - Port 6 Resistor Enable" ] pub p6ren : P6REN , _reserved4 : [ u8 ; 3usize ] , # [ doc = "0x0b - Port 6 Select 0" ] pub p6sel0 : P6SEL0 , _reserved5 : [ u8 ; 1usize ] , # [ doc = "0x0d - Port 6 Select 1" ] pub p6sel1 : P6SEL1 , _reserved6 : [ u8 ; 9usize ] , # [ doc = "0x17 - Port 6 Complement Select" ] pub p6selc : P6SELC , }
# [ doc = "Port 6 Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p6in](p6in) module" ] pub type P6IN = crate :: Reg < u8 , _P6IN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P6IN ;
# [ doc = "`read()` method returns [p6in::R](p6in::R) reader structure" ] impl crate :: Readable for P6IN { }
# [ doc = "`write(|w| ..)` method takes [p6in::W](p6in::W) writer structure" ] impl crate :: Writable for P6IN { }
# [ doc = "Port 6 Input" ] pub mod p6in {
# [ doc = "Reader of register P6IN" ] pub type R = crate :: R < u8 , super :: P6IN > ;
# [ doc = "Writer for register P6IN" ] pub type W = crate :: W < u8 , super :: P6IN > ;
# [ doc = "Register P6IN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P6IN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 6 Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p6out](p6out) module" ] pub type P6OUT = crate :: Reg < u8 , _P6OUT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P6OUT ;
# [ doc = "`read()` method returns [p6out::R](p6out::R) reader structure" ] impl crate :: Readable for P6OUT { }
# [ doc = "`write(|w| ..)` method takes [p6out::W](p6out::W) writer structure" ] impl crate :: Writable for P6OUT { }
# [ doc = "Port 6 Output" ] pub mod p6out {
# [ doc = "Reader of register P6OUT" ] pub type R = crate :: R < u8 , super :: P6OUT > ;
# [ doc = "Writer for register P6OUT" ] pub type W = crate :: W < u8 , super :: P6OUT > ;
# [ doc = "Register P6OUT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P6OUT { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 6 Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p6dir](p6dir) module" ] pub type P6DIR = crate :: Reg < u8 , _P6DIR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P6DIR ;
# [ doc = "`read()` method returns [p6dir::R](p6dir::R) reader structure" ] impl crate :: Readable for P6DIR { }
# [ doc = "`write(|w| ..)` method takes [p6dir::W](p6dir::W) writer structure" ] impl crate :: Writable for P6DIR { }
# [ doc = "Port 6 Direction" ] pub mod p6dir {
# [ doc = "Reader of register P6DIR" ] pub type R = crate :: R < u8 , super :: P6DIR > ;
# [ doc = "Writer for register P6DIR" ] pub type W = crate :: W < u8 , super :: P6DIR > ;
# [ doc = "Register P6DIR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P6DIR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 6 Resistor Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p6ren](p6ren) module" ] pub type P6REN = crate :: Reg < u8 , _P6REN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P6REN ;
# [ doc = "`read()` method returns [p6ren::R](p6ren::R) reader structure" ] impl crate :: Readable for P6REN { }
# [ doc = "`write(|w| ..)` method takes [p6ren::W](p6ren::W) writer structure" ] impl crate :: Writable for P6REN { }
# [ doc = "Port 6 Resistor Enable" ] pub mod p6ren {
# [ doc = "Reader of register P6REN" ] pub type R = crate :: R < u8 , super :: P6REN > ;
# [ doc = "Writer for register P6REN" ] pub type W = crate :: W < u8 , super :: P6REN > ;
# [ doc = "Register P6REN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P6REN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 6 Select 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p6sel0](p6sel0) module" ] pub type P6SEL0 = crate :: Reg < u8 , _P6SEL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P6SEL0 ;
# [ doc = "`read()` method returns [p6sel0::R](p6sel0::R) reader structure" ] impl crate :: Readable for P6SEL0 { }
# [ doc = "`write(|w| ..)` method takes [p6sel0::W](p6sel0::W) writer structure" ] impl crate :: Writable for P6SEL0 { }
# [ doc = "Port 6 Select 0" ] pub mod p6sel0 {
# [ doc = "Reader of register P6SEL0" ] pub type R = crate :: R < u8 , super :: P6SEL0 > ;
# [ doc = "Writer for register P6SEL0" ] pub type W = crate :: W < u8 , super :: P6SEL0 > ;
# [ doc = "Register P6SEL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P6SEL0 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 6 Select 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p6sel1](p6sel1) module" ] pub type P6SEL1 = crate :: Reg < u8 , _P6SEL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P6SEL1 ;
# [ doc = "`read()` method returns [p6sel1::R](p6sel1::R) reader structure" ] impl crate :: Readable for P6SEL1 { }
# [ doc = "`write(|w| ..)` method takes [p6sel1::W](p6sel1::W) writer structure" ] impl crate :: Writable for P6SEL1 { }
# [ doc = "Port 6 Select 1" ] pub mod p6sel1 {
# [ doc = "Reader of register P6SEL1" ] pub type R = crate :: R < u8 , super :: P6SEL1 > ;
# [ doc = "Writer for register P6SEL1" ] pub type W = crate :: W < u8 , super :: P6SEL1 > ;
# [ doc = "Register P6SEL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P6SEL1 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 6 Complement Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p6selc](p6selc) module" ] pub type P6SELC = crate :: Reg < u8 , _P6SELC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P6SELC ;
# [ doc = "`read()` method returns [p6selc::R](p6selc::R) reader structure" ] impl crate :: Readable for P6SELC { }
# [ doc = "`write(|w| ..)` method takes [p6selc::W](p6selc::W) writer structure" ] impl crate :: Writable for P6SELC { }
# [ doc = "Port 6 Complement Select" ] pub mod p6selc {
# [ doc = "Reader of register P6SELC" ] pub type R = crate :: R < u8 , super :: P6SELC > ;
# [ doc = "Writer for register P6SELC" ] pub type W = crate :: W < u8 , super :: P6SELC > ;
# [ doc = "Register P6SELC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P6SELC { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
}
# [ doc = "TB0" ] pub struct TB0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TB0 { } impl TB0 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const tb0 :: RegisterBlock { 0x0380 as * const _ } } impl Deref for TB0 { type Target = tb0 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * TB0 :: ptr ( ) } } }
# [ doc = "TB0" ] pub mod tb0 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Timer_B Control Register" ] pub tb0ctl : TB0CTL , # [ doc = "0x02 - Timer_B Capture/Compare Control Register" ] pub tb0cctl0 : TB0CCTL0 , # [ doc = "0x04 - Timer_B Capture/Compare Control Register" ] pub tb0cctl1 : TB0CCTL1 , # [ doc = "0x06 - Timer_B Capture/Compare Control Register" ] pub tb0cctl2 : TB0CCTL2 , _reserved4 : [ u8 ; 8usize ] , # [ doc = "0x10 - Timer_B count register" ] pub tb0r : TB0R , # [ doc = "0x12 - Timer_B Capture/Compare Register" ] pub tb0ccr0 : TB0CCR0 , # [ doc = "0x14 - Timer_B Capture/Compare Register" ] pub tb0ccr1 : TB0CCR1 , # [ doc = "0x16 - Timer_B Capture/Compare Register" ] pub tb0ccr2 : TB0CCR2 , _reserved8 : [ u8 ; 8usize ] , # [ doc = "0x20 - Timer_Bx Expansion Register 0" ] pub tb0ex0 : TB0EX0 , _reserved9 : [ u8 ; 12usize ] , # [ doc = "0x2e - Timer_Bx Interrupt Vector Register" ] pub tb0iv : TB0IV , }
# [ doc = "Timer_B Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb0ctl](tb0ctl) module" ] pub type TB0CTL = crate :: Reg < u16 , _TB0CTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB0CTL ;
# [ doc = "`read()` method returns [tb0ctl::R](tb0ctl::R) reader structure" ] impl crate :: Readable for TB0CTL { }
# [ doc = "`write(|w| ..)` method takes [tb0ctl::W](tb0ctl::W) writer structure" ] impl crate :: Writable for TB0CTL { }
# [ doc = "Timer_B Control Register" ] pub mod tb0ctl {
# [ doc = "Reader of register TB0CTL" ] pub type R = crate :: R < u16 , super :: TB0CTL > ;
# [ doc = "Writer for register TB0CTL" ] pub type W = crate :: W < u16 , super :: TB0CTL > ;
# [ doc = "Register TB0CTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB0CTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "TimerB interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TBIFG_A { # [ doc = "0: No interrupt pending" ] TBIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] TBIFG_1 = 1 } impl From < TBIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : TBIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `TBIFG`" ] pub type TBIFG_R = crate :: R < bool , TBIFG_A > ; impl TBIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIFG_A { match self . bits { false => TBIFG_A :: TBIFG_0 , true => TBIFG_A :: TBIFG_1 } } # [ doc = "Checks if the value of the field is `TBIFG_0`" ] # [ inline ( always ) ] pub fn is_tbifg_0 ( & self ) -> bool { * self == TBIFG_A :: TBIFG_0 } # [ doc = "Checks if the value of the field is `TBIFG_1`" ] # [ inline ( always ) ] pub fn is_tbifg_1 ( & self ) -> bool { * self == TBIFG_A :: TBIFG_1 } }
# [ doc = "Write proxy for field `TBIFG`" ] pub struct TBIFG_W < 'a > { w : & 'a mut W , } impl < 'a > TBIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn tbifg_0 ( self ) -> & 'a mut W { self . variant ( TBIFG_A :: TBIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn tbifg_1 ( self ) -> & 'a mut W { self . variant ( TBIFG_A :: TBIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "TimerB interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TBIE_A { # [ doc = "0: Interrupt disabled" ] TBIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] TBIE_1 = 1 } impl From < TBIE_A > for bool { # [ inline ( always ) ] fn from ( variant : TBIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `TBIE`" ] pub type TBIE_R = crate :: R < bool , TBIE_A > ; impl TBIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIE_A { match self . bits { false => TBIE_A :: TBIE_0 , true => TBIE_A :: TBIE_1 } } # [ doc = "Checks if the value of the field is `TBIE_0`" ] # [ inline ( always ) ] pub fn is_tbie_0 ( & self ) -> bool { * self == TBIE_A :: TBIE_0 } # [ doc = "Checks if the value of the field is `TBIE_1`" ] # [ inline ( always ) ] pub fn is_tbie_1 ( & self ) -> bool { * self == TBIE_A :: TBIE_1 } }
# [ doc = "Write proxy for field `TBIE`" ] pub struct TBIE_W < 'a > { w : & 'a mut W , } impl < 'a > TBIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn tbie_0 ( self ) -> & 'a mut W { self . variant ( TBIE_A :: TBIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn tbie_1 ( self ) -> & 'a mut W { self . variant ( TBIE_A :: TBIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `TBCLR`" ] pub type TBCLR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TBCLR`" ] pub struct TBCLR_W < 'a > { w : & 'a mut W , } impl < 'a > TBCLR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Mode control\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum MC_A { # [ doc = "0: Stop mode: Timer is halted" ] STOP = 0 , # [ doc = "1: Up mode: Timer counts up to TBxCL0" ] UP = 1 , # [ doc = "2: Continuous mode: Timer counts up to the value set by CNTL" ] CONTINUOUS = 2 , # [ doc = "3: Up/down mode: Timer counts up to TBxCL0 then down to 0000h" ] UPDOWN = 3 } impl From < MC_A > for u8 { # [ inline ( always ) ] fn from ( variant : MC_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `MC`" ] pub type MC_R = crate :: R < u8 , MC_A > ; impl MC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MC_A { match self . bits { 0 => MC_A :: STOP , 1 => MC_A :: UP , 2 => MC_A :: CONTINUOUS , 3 => MC_A :: UPDOWN , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `STOP`" ] # [ inline ( always ) ] pub fn is_stop ( & self ) -> bool { * self == MC_A :: STOP } # [ doc = "Checks if the value of the field is `UP`" ] # [ inline ( always ) ] pub fn is_up ( & self ) -> bool { * self == MC_A :: UP } # [ doc = "Checks if the value of the field is `CONTINUOUS`" ] # [ inline ( always ) ] pub fn is_continuous ( & self ) -> bool { * self == MC_A :: CONTINUOUS } # [ doc = "Checks if the value of the field is `UPDOWN`" ] # [ inline ( always ) ] pub fn is_updown ( & self ) -> bool { * self == MC_A :: UPDOWN } }
# [ doc = "Write proxy for field `MC`" ] pub struct MC_W < 'a > { w : & 'a mut W , } impl < 'a > MC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MC_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Stop mode: Timer is halted" ] # [ inline ( always ) ] pub fn stop ( self ) -> & 'a mut W { self . variant ( MC_A :: STOP ) } # [ doc = "Up mode: Timer counts up to TBxCL0" ] # [ inline ( always ) ] pub fn up ( self ) -> & 'a mut W { self . variant ( MC_A :: UP ) } # [ doc = "Continuous mode: Timer counts up to the value set by CNTL" ] # [ inline ( always ) ] pub fn continuous ( self ) -> & 'a mut W { self . variant ( MC_A :: CONTINUOUS ) } # [ doc = "Up/down mode: Timer counts up to TBxCL0 then down to 0000h" ] # [ inline ( always ) ] pub fn updown ( self ) -> & 'a mut W { self . variant ( MC_A :: UPDOWN ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Input divider\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ID_A { # [ doc = "0: /1" ] _1 = 0 , # [ doc = "1: /2" ] _2 = 1 , # [ doc = "2: /4" ] _4 = 2 , # [ doc = "3: /8" ] _8 = 3 } impl From < ID_A > for u8 { # [ inline ( always ) ] fn from ( variant : ID_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ID`" ] pub type ID_R = crate :: R < u8 , ID_A > ; impl ID_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ID_A { match self . bits { 0 => ID_A :: _1 , 1 => ID_A :: _2 , 2 => ID_A :: _4 , 3 => ID_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == ID_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == ID_A :: _2 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == ID_A :: _4 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == ID_A :: _8 } }
# [ doc = "Write proxy for field `ID`" ] pub struct ID_W < 'a > { w : & 'a mut W , } impl < 'a > ID_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ID_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "/1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( ID_A :: _1 ) } # [ doc = "/2" ] # [ inline ( always ) ] pub fn _2 ( self ) -> & 'a mut W { self . variant ( ID_A :: _2 ) } # [ doc = "/4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( ID_A :: _4 ) } # [ doc = "/8" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( ID_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "TimerB clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBSSEL_A { # [ doc = "0: TBxCLK" ] TBCLK = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: INCLK" ] INCLK = 3 } impl From < TBSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBSSEL`" ] pub type TBSSEL_R = crate :: R < u8 , TBSSEL_A > ; impl TBSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBSSEL_A { match self . bits { 0 => TBSSEL_A :: TBCLK , 1 => TBSSEL_A :: ACLK , 2 => TBSSEL_A :: SMCLK , 3 => TBSSEL_A :: INCLK , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `TBCLK`" ] # [ inline ( always ) ] pub fn is_tbclk ( & self ) -> bool { * self == TBSSEL_A :: TBCLK } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == TBSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == TBSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `INCLK`" ] # [ inline ( always ) ] pub fn is_inclk ( & self ) -> bool { * self == TBSSEL_A :: INCLK } }
# [ doc = "Write proxy for field `TBSSEL`" ] pub struct TBSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > TBSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLK" ] # [ inline ( always ) ] pub fn tbclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: TBCLK ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: SMCLK ) } # [ doc = "INCLK" ] # [ inline ( always ) ] pub fn inclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: INCLK ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Counter length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CNTL_A { # [ doc = "0: 16-bit, TBxR(max) = 0FFFFh" ] _16 = 0 , # [ doc = "1: 12-bit, TBxR(max) = 0FFFh" ] _12 = 1 , # [ doc = "2: 10-bit, TBxR(max) = 03FFh" ] _10 = 2 , # [ doc = "3: 8-bit, TBxR(max) = 0FFh" ] _8 = 3 } impl From < CNTL_A > for u8 { # [ inline ( always ) ] fn from ( variant : CNTL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CNTL`" ] pub type CNTL_R = crate :: R < u8 , CNTL_A > ; impl CNTL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CNTL_A { match self . bits { 0 => CNTL_A :: _16 , 1 => CNTL_A :: _12 , 2 => CNTL_A :: _10 , 3 => CNTL_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_16`" ] # [ inline ( always ) ] pub fn is_16 ( & self ) -> bool { * self == CNTL_A :: _16 } # [ doc = "Checks if the value of the field is `_12`" ] # [ inline ( always ) ] pub fn is_12 ( & self ) -> bool { * self == CNTL_A :: _12 } # [ doc = "Checks if the value of the field is `_10`" ] # [ inline ( always ) ] pub fn is_10 ( & self ) -> bool { * self == CNTL_A :: _10 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == CNTL_A :: _8 } }
# [ doc = "Write proxy for field `CNTL`" ] pub struct CNTL_W < 'a > { w : & 'a mut W , } impl < 'a > CNTL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CNTL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "16-bit, TBxR(max) = 0FFFFh" ] # [ inline ( always ) ] pub fn _16 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _16 ) } # [ doc = "12-bit, TBxR(max) = 0FFFh" ] # [ inline ( always ) ] pub fn _12 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _12 ) } # [ doc = "10-bit, TBxR(max) = 03FFh" ] # [ inline ( always ) ] pub fn _10 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _10 ) } # [ doc = "8-bit, TBxR(max) = 0FFh" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 11 ) ) | ( ( ( value as u16 ) & 0x03 ) << 11 ) ; self . w } }
# [ doc = "TBxCLn group\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBCLGRP_A { # [ doc = "0: Each TBxCLn latch loads independently" ] TBCLGRP_0 = 0 , # [ doc = "1: TBxCL1+TBxCL2 (TBxCCR1 CLLD bits control the update); TBxCL3+TBxCL4 (TBxCCR3 CLLD bits control the update); TBxCL5+TBxCL6 (TBxCCR5 CLLD bits control the update); TBxCL0 independent" ] TBCLGRP_1 = 1 , # [ doc = "2: TBxCL1+TBxCL2+TBxCL3 (TBxCCR1 CLLD bits control the update); TBxCL4+TBxCL5+TBxCL6 (TBxCCR4 CLLD bits control the update); TBxCL0 independent" ] TBCLGRP_2 = 2 , # [ doc = "3: TBxCL0+TBxCL1+TBxCL2+TBxCL3+TBxCL4+TBxCL5+TBxCL6 (TBxCCR1 CLLD bits control the update)" ] TBCLGRP_3 = 3 } impl From < TBCLGRP_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBCLGRP_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBCLGRP`" ] pub type TBCLGRP_R = crate :: R < u8 , TBCLGRP_A > ; impl TBCLGRP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBCLGRP_A { match self . bits { 0 => TBCLGRP_A :: TBCLGRP_0 , 1 => TBCLGRP_A :: TBCLGRP_1 , 2 => TBCLGRP_A :: TBCLGRP_2 , 3 => TBCLGRP_A :: TBCLGRP_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `TBCLGRP_0`" ] # [ inline ( always ) ] pub fn is_tbclgrp_0 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_0 } # [ doc = "Checks if the value of the field is `TBCLGRP_1`" ] # [ inline ( always ) ] pub fn is_tbclgrp_1 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_1 } # [ doc = "Checks if the value of the field is `TBCLGRP_2`" ] # [ inline ( always ) ] pub fn is_tbclgrp_2 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_2 } # [ doc = "Checks if the value of the field is `TBCLGRP_3`" ] # [ inline ( always ) ] pub fn is_tbclgrp_3 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_3 } }
# [ doc = "Write proxy for field `TBCLGRP`" ] pub struct TBCLGRP_W < 'a > { w : & 'a mut W , } impl < 'a > TBCLGRP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBCLGRP_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Each TBxCLn latch loads independently" ] # [ inline ( always ) ] pub fn tbclgrp_0 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_0 ) } # [ doc = "TBxCL1+TBxCL2 (TBxCCR1 CLLD bits control the update); TBxCL3+TBxCL4 (TBxCCR3 CLLD bits control the update); TBxCL5+TBxCL6 (TBxCCR5 CLLD bits control the update); TBxCL0 independent" ] # [ inline ( always ) ] pub fn tbclgrp_1 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_1 ) } # [ doc = "TBxCL1+TBxCL2+TBxCL3 (TBxCCR1 CLLD bits control the update); TBxCL4+TBxCL5+TBxCL6 (TBxCCR4 CLLD bits control the update); TBxCL0 independent" ] # [ inline ( always ) ] pub fn tbclgrp_2 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_2 ) } # [ doc = "TBxCL0+TBxCL1+TBxCL2+TBxCL3+TBxCL4+TBxCL5+TBxCL6 (TBxCCR1 CLLD bits control the update)" ] # [ inline ( always ) ] pub fn tbclgrp_3 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 13 ) ) | ( ( ( value as u16 ) & 0x03 ) << 13 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - TimerB interrupt flag" ] # [ inline ( always ) ] pub fn tbifg ( & self ) -> TBIFG_R { TBIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - TimerB interrupt enable" ] # [ inline ( always ) ] pub fn tbie ( & self ) -> TBIE_R { TBIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - TimerB clear" ] # [ inline ( always ) ] pub fn tbclr ( & self ) -> TBCLR_R { TBCLR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - Mode control" ] # [ inline ( always ) ] pub fn mc ( & self ) -> MC_R { MC_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 6:7 - Input divider" ] # [ inline ( always ) ] pub fn id ( & self ) -> ID_R { ID_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:9 - TimerB clock source select" ] # [ inline ( always ) ] pub fn tbssel ( & self ) -> TBSSEL_R { TBSSEL_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 11:12 - Counter length" ] # [ inline ( always ) ] pub fn cntl ( & self ) -> CNTL_R { CNTL_R :: new ( ( ( self . bits >> 11 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 13:14 - TBxCLn group" ] # [ inline ( always ) ] pub fn tbclgrp ( & self ) -> TBCLGRP_R { TBCLGRP_R :: new ( ( ( self . bits >> 13 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - TimerB interrupt flag" ] # [ inline ( always ) ] pub fn tbifg ( & mut self ) -> TBIFG_W { TBIFG_W { w : self } }
# [ doc = "Bit 1 - TimerB interrupt enable" ] # [ inline ( always ) ] pub fn tbie ( & mut self ) -> TBIE_W { TBIE_W { w : self } }
# [ doc = "Bit 2 - TimerB clear" ] # [ inline ( always ) ] pub fn tbclr ( & mut self ) -> TBCLR_W { TBCLR_W { w : self } }
# [ doc = "Bits 4:5 - Mode control" ] # [ inline ( always ) ] pub fn mc ( & mut self ) -> MC_W { MC_W { w : self } }
# [ doc = "Bits 6:7 - Input divider" ] # [ inline ( always ) ] pub fn id ( & mut self ) -> ID_W { ID_W { w : self } }
# [ doc = "Bits 8:9 - TimerB clock source select" ] # [ inline ( always ) ] pub fn tbssel ( & mut self ) -> TBSSEL_W { TBSSEL_W { w : self } }
# [ doc = "Bits 11:12 - Counter length" ] # [ inline ( always ) ] pub fn cntl ( & mut self ) -> CNTL_W { CNTL_W { w : self } }
# [ doc = "Bits 13:14 - TBxCLn group" ] # [ inline ( always ) ] pub fn tbclgrp ( & mut self ) -> TBCLGRP_W { TBCLGRP_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb0cctl0](tb0cctl0) module" ] pub type TB0CCTL0 = crate :: Reg < u16 , _TB0CCTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB0CCTL0 ;
# [ doc = "`read()` method returns [tb0cctl0::R](tb0cctl0::R) reader structure" ] impl crate :: Readable for TB0CCTL0 { }
# [ doc = "`write(|w| ..)` method takes [tb0cctl0::W](tb0cctl0::W) writer structure" ] impl crate :: Writable for TB0CCTL0 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb0cctl0 {
# [ doc = "Reader of register TB0CCTL0" ] pub type R = crate :: R < u16 , super :: TB0CCTL0 > ;
# [ doc = "Writer for register TB0CCTL0" ] pub type W = crate :: W < u16 , super :: TB0CCTL0 > ;
# [ doc = "Register TB0CCTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB0CCTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb0cctl1](tb0cctl1) module" ] pub type TB0CCTL1 = crate :: Reg < u16 , _TB0CCTL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB0CCTL1 ;
# [ doc = "`read()` method returns [tb0cctl1::R](tb0cctl1::R) reader structure" ] impl crate :: Readable for TB0CCTL1 { }
# [ doc = "`write(|w| ..)` method takes [tb0cctl1::W](tb0cctl1::W) writer structure" ] impl crate :: Writable for TB0CCTL1 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb0cctl1 {
# [ doc = "Reader of register TB0CCTL1" ] pub type R = crate :: R < u16 , super :: TB0CCTL1 > ;
# [ doc = "Writer for register TB0CCTL1" ] pub type W = crate :: W < u16 , super :: TB0CCTL1 > ;
# [ doc = "Register TB0CCTL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB0CCTL1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb0cctl2](tb0cctl2) module" ] pub type TB0CCTL2 = crate :: Reg < u16 , _TB0CCTL2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB0CCTL2 ;
# [ doc = "`read()` method returns [tb0cctl2::R](tb0cctl2::R) reader structure" ] impl crate :: Readable for TB0CCTL2 { }
# [ doc = "`write(|w| ..)` method takes [tb0cctl2::W](tb0cctl2::W) writer structure" ] impl crate :: Writable for TB0CCTL2 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb0cctl2 {
# [ doc = "Reader of register TB0CCTL2" ] pub type R = crate :: R < u16 , super :: TB0CCTL2 > ;
# [ doc = "Writer for register TB0CCTL2" ] pub type W = crate :: W < u16 , super :: TB0CCTL2 > ;
# [ doc = "Register TB0CCTL2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB0CCTL2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B count register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb0r](tb0r) module" ] pub type TB0R = crate :: Reg < u16 , _TB0R > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB0R ;
# [ doc = "`read()` method returns [tb0r::R](tb0r::R) reader structure" ] impl crate :: Readable for TB0R { }
# [ doc = "`write(|w| ..)` method takes [tb0r::W](tb0r::W) writer structure" ] impl crate :: Writable for TB0R { }
# [ doc = "Timer_B count register" ] pub mod tb0r {
# [ doc = "Reader of register TB0R" ] pub type R = crate :: R < u16 , super :: TB0R > ;
# [ doc = "Writer for register TB0R" ] pub type W = crate :: W < u16 , super :: TB0R > ;
# [ doc = "Register TB0R `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB0R { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb0ccr0](tb0ccr0) module" ] pub type TB0CCR0 = crate :: Reg < u16 , _TB0CCR0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB0CCR0 ;
# [ doc = "`read()` method returns [tb0ccr0::R](tb0ccr0::R) reader structure" ] impl crate :: Readable for TB0CCR0 { }
# [ doc = "`write(|w| ..)` method takes [tb0ccr0::W](tb0ccr0::W) writer structure" ] impl crate :: Writable for TB0CCR0 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb0ccr0 {
# [ doc = "Reader of register TB0CCR0" ] pub type R = crate :: R < u16 , super :: TB0CCR0 > ;
# [ doc = "Writer for register TB0CCR0" ] pub type W = crate :: W < u16 , super :: TB0CCR0 > ;
# [ doc = "Register TB0CCR0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB0CCR0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb0ccr1](tb0ccr1) module" ] pub type TB0CCR1 = crate :: Reg < u16 , _TB0CCR1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB0CCR1 ;
# [ doc = "`read()` method returns [tb0ccr1::R](tb0ccr1::R) reader structure" ] impl crate :: Readable for TB0CCR1 { }
# [ doc = "`write(|w| ..)` method takes [tb0ccr1::W](tb0ccr1::W) writer structure" ] impl crate :: Writable for TB0CCR1 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb0ccr1 {
# [ doc = "Reader of register TB0CCR1" ] pub type R = crate :: R < u16 , super :: TB0CCR1 > ;
# [ doc = "Writer for register TB0CCR1" ] pub type W = crate :: W < u16 , super :: TB0CCR1 > ;
# [ doc = "Register TB0CCR1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB0CCR1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb0ccr2](tb0ccr2) module" ] pub type TB0CCR2 = crate :: Reg < u16 , _TB0CCR2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB0CCR2 ;
# [ doc = "`read()` method returns [tb0ccr2::R](tb0ccr2::R) reader structure" ] impl crate :: Readable for TB0CCR2 { }
# [ doc = "`write(|w| ..)` method takes [tb0ccr2::W](tb0ccr2::W) writer structure" ] impl crate :: Writable for TB0CCR2 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb0ccr2 {
# [ doc = "Reader of register TB0CCR2" ] pub type R = crate :: R < u16 , super :: TB0CCR2 > ;
# [ doc = "Writer for register TB0CCR2" ] pub type W = crate :: W < u16 , super :: TB0CCR2 > ;
# [ doc = "Register TB0CCR2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB0CCR2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_Bx Expansion Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb0ex0](tb0ex0) module" ] pub type TB0EX0 = crate :: Reg < u16 , _TB0EX0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB0EX0 ;
# [ doc = "`read()` method returns [tb0ex0::R](tb0ex0::R) reader structure" ] impl crate :: Readable for TB0EX0 { }
# [ doc = "`write(|w| ..)` method takes [tb0ex0::W](tb0ex0::W) writer structure" ] impl crate :: Writable for TB0EX0 { }
# [ doc = "Timer_Bx Expansion Register 0" ] pub mod tb0ex0 {
# [ doc = "Reader of register TB0EX0" ] pub type R = crate :: R < u16 , super :: TB0EX0 > ;
# [ doc = "Writer for register TB0EX0" ] pub type W = crate :: W < u16 , super :: TB0EX0 > ;
# [ doc = "Register TB0EX0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB0EX0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Input divider expansion\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBIDEX_A { # [ doc = "0: Divide by 1" ] _1 = 0 , # [ doc = "1: Divide by 2" ] _2 = 1 , # [ doc = "2: Divide by 3" ] _3 = 2 , # [ doc = "3: Divide by 4" ] _4 = 3 , # [ doc = "4: Divide by 5" ] _5 = 4 , # [ doc = "5: Divide by 6" ] _6 = 5 , # [ doc = "6: Divide by 7" ] _7 = 6 , # [ doc = "7: Divide by 8" ] _8 = 7 } impl From < TBIDEX_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBIDEX_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBIDEX`" ] pub type TBIDEX_R = crate :: R < u8 , TBIDEX_A > ; impl TBIDEX_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIDEX_A { match self . bits { 0 => TBIDEX_A :: _1 , 1 => TBIDEX_A :: _2 , 2 => TBIDEX_A :: _3 , 3 => TBIDEX_A :: _4 , 4 => TBIDEX_A :: _5 , 5 => TBIDEX_A :: _6 , 6 => TBIDEX_A :: _7 , 7 => TBIDEX_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == TBIDEX_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == TBIDEX_A :: _2 } # [ doc = "Checks if the value of the field is `_3`" ] # [ inline ( always ) ] pub fn is_3 ( & self ) -> bool { * self == TBIDEX_A :: _3 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == TBIDEX_A :: _4 } # [ doc = "Checks if the value of the field is `_5`" ] # [ inline ( always ) ] pub fn is_5 ( & self ) -> bool { * self == TBIDEX_A :: _5 } # [ doc = "Checks if the value of the field is `_6`" ] # [ inline ( always ) ] pub fn is_6 ( & self ) -> bool { * self == TBIDEX_A :: _6 } # [ doc = "Checks if the value of the field is `_7`" ] # [ inline ( always ) ] pub fn is_7 ( & self ) -> bool { * self == TBIDEX_A :: _7 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == TBIDEX_A :: _8 } }
# [ doc = "Write proxy for field `TBIDEX`" ] pub struct TBIDEX_W < 'a > { w : & 'a mut W , } impl < 'a > TBIDEX_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIDEX_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Divide by 1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _1 ) } # [ doc = "Divide by 2" ] # [ inline ( always ) ] pub fn _2 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _2 ) } # [ doc = "Divide by 3" ] # [ inline ( always ) ] pub fn _3 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _3 ) } # [ doc = "Divide by 4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _4 ) } # [ doc = "Divide by 5" ] # [ inline ( always ) ] pub fn _5 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _5 ) } # [ doc = "Divide by 6" ] # [ inline ( always ) ] pub fn _6 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _6 ) } # [ doc = "Divide by 7" ] # [ inline ( always ) ] pub fn _7 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _7 ) } # [ doc = "Divide by 8" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u16 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Input divider expansion" ] # [ inline ( always ) ] pub fn tbidex ( & self ) -> TBIDEX_R { TBIDEX_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Input divider expansion" ] # [ inline ( always ) ] pub fn tbidex ( & mut self ) -> TBIDEX_W { TBIDEX_W { w : self } }
}
}
# [ doc = "Timer_Bx Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb0iv](tb0iv) module" ] pub type TB0IV = crate :: Reg < u16 , _TB0IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB0IV ;
# [ doc = "`read()` method returns [tb0iv::R](tb0iv::R) reader structure" ] impl crate :: Readable for TB0IV { }
# [ doc = "Timer_Bx Interrupt Vector Register" ] pub mod tb0iv {
# [ doc = "Reader of register TB0IV" ] pub type R = crate :: R < u16 , super :: TB0IV > ;
# [ doc = "Timer_B interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum TBIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Capture/compare 1; Interrupt Flag: TBxCCR1 CCIFG; Interrupt Priority: Highest" ] TBCCR1 = 2 , # [ doc = "4: Interrupt Source: Capture/compare 2; Interrupt Flag: TBxCCR2 CCIFG" ] TBCCR2 = 4 , # [ doc = "6: Interrupt Source: Capture/compare 3; Interrupt Flag: TBxCCR3 CCIFG" ] TBCCR3 = 6 , # [ doc = "8: Interrupt Source: Capture/compare 4; Interrupt Flag: TBxCCR4 CCIFG" ] TBCCR4 = 8 , # [ doc = "10: Interrupt Source: Capture/compare 5; Interrupt Flag: TBxCCR5 CCIFG" ] TBCCR5 = 10 , # [ doc = "12: Interrupt Source: Capture/compare 6; Interrupt Flag: TBxCCR6 CCIFG" ] TBCCR6 = 12 , # [ doc = "14: Interrupt Source: Timer overflow; Interrupt Flag: TBxCTL TBIFG; Interrupt Priority: Lowest" ] TBIFG = 14 } impl From < TBIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : TBIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBIV`" ] pub type TBIV_R = crate :: R < u16 , TBIV_A > ; impl TBIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , TBIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( TBIV_A :: NONE ) , 2 => Val ( TBIV_A :: TBCCR1 ) , 4 => Val ( TBIV_A :: TBCCR2 ) , 6 => Val ( TBIV_A :: TBCCR3 ) , 8 => Val ( TBIV_A :: TBCCR4 ) , 10 => Val ( TBIV_A :: TBCCR5 ) , 12 => Val ( TBIV_A :: TBCCR6 ) , 14 => Val ( TBIV_A :: TBIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == TBIV_A :: NONE } # [ doc = "Checks if the value of the field is `TBCCR1`" ] # [ inline ( always ) ] pub fn is_tbccr1 ( & self ) -> bool { * self == TBIV_A :: TBCCR1 } # [ doc = "Checks if the value of the field is `TBCCR2`" ] # [ inline ( always ) ] pub fn is_tbccr2 ( & self ) -> bool { * self == TBIV_A :: TBCCR2 } # [ doc = "Checks if the value of the field is `TBCCR3`" ] # [ inline ( always ) ] pub fn is_tbccr3 ( & self ) -> bool { * self == TBIV_A :: TBCCR3 } # [ doc = "Checks if the value of the field is `TBCCR4`" ] # [ inline ( always ) ] pub fn is_tbccr4 ( & self ) -> bool { * self == TBIV_A :: TBCCR4 } # [ doc = "Checks if the value of the field is `TBCCR5`" ] # [ inline ( always ) ] pub fn is_tbccr5 ( & self ) -> bool { * self == TBIV_A :: TBCCR5 } # [ doc = "Checks if the value of the field is `TBCCR6`" ] # [ inline ( always ) ] pub fn is_tbccr6 ( & self ) -> bool { * self == TBIV_A :: TBCCR6 } # [ doc = "Checks if the value of the field is `TBIFG`" ] # [ inline ( always ) ] pub fn is_tbifg ( & self ) -> bool { * self == TBIV_A :: TBIFG } }
impl R {
# [ doc = "Bits 0:15 - Timer_B interrupt vector value" ] # [ inline ( always ) ] pub fn tbiv ( & self ) -> TBIV_R { TBIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "TB1" ] pub struct TB1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TB1 { } impl TB1 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const tb1 :: RegisterBlock { 0x03c0 as * const _ } } impl Deref for TB1 { type Target = tb1 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * TB1 :: ptr ( ) } } }
# [ doc = "TB1" ] pub mod tb1 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Timer_B Control Register" ] pub tb1ctl : TB1CTL , # [ doc = "0x02 - Timer_B Capture/Compare Control Register" ] pub tb1cctl0 : TB1CCTL0 , # [ doc = "0x04 - Timer_B Capture/Compare Control Register" ] pub tb1cctl1 : TB1CCTL1 , # [ doc = "0x06 - Timer_B Capture/Compare Control Register" ] pub tb1cctl2 : TB1CCTL2 , _reserved4 : [ u8 ; 8usize ] , # [ doc = "0x10 - Timer_B count register" ] pub tb1r : TB1R , # [ doc = "0x12 - Timer_B Capture/Compare Register" ] pub tb1ccr0 : TB1CCR0 , # [ doc = "0x14 - Timer_B Capture/Compare Register" ] pub tb1ccr1 : TB1CCR1 , # [ doc = "0x16 - Timer_B Capture/Compare Register" ] pub tb1ccr2 : TB1CCR2 , _reserved8 : [ u8 ; 8usize ] , # [ doc = "0x20 - Timer_Bx Expansion Register 0" ] pub tb1ex0 : TB1EX0 , _reserved9 : [ u8 ; 12usize ] , # [ doc = "0x2e - Timer_Bx Interrupt Vector Register" ] pub tb1iv : TB1IV , }
# [ doc = "Timer_B Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb1ctl](tb1ctl) module" ] pub type TB1CTL = crate :: Reg < u16 , _TB1CTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB1CTL ;
# [ doc = "`read()` method returns [tb1ctl::R](tb1ctl::R) reader structure" ] impl crate :: Readable for TB1CTL { }
# [ doc = "`write(|w| ..)` method takes [tb1ctl::W](tb1ctl::W) writer structure" ] impl crate :: Writable for TB1CTL { }
# [ doc = "Timer_B Control Register" ] pub mod tb1ctl {
# [ doc = "Reader of register TB1CTL" ] pub type R = crate :: R < u16 , super :: TB1CTL > ;
# [ doc = "Writer for register TB1CTL" ] pub type W = crate :: W < u16 , super :: TB1CTL > ;
# [ doc = "Register TB1CTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB1CTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "TimerB interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TBIFG_A { # [ doc = "0: No interrupt pending" ] TBIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] TBIFG_1 = 1 } impl From < TBIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : TBIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `TBIFG`" ] pub type TBIFG_R = crate :: R < bool , TBIFG_A > ; impl TBIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIFG_A { match self . bits { false => TBIFG_A :: TBIFG_0 , true => TBIFG_A :: TBIFG_1 } } # [ doc = "Checks if the value of the field is `TBIFG_0`" ] # [ inline ( always ) ] pub fn is_tbifg_0 ( & self ) -> bool { * self == TBIFG_A :: TBIFG_0 } # [ doc = "Checks if the value of the field is `TBIFG_1`" ] # [ inline ( always ) ] pub fn is_tbifg_1 ( & self ) -> bool { * self == TBIFG_A :: TBIFG_1 } }
# [ doc = "Write proxy for field `TBIFG`" ] pub struct TBIFG_W < 'a > { w : & 'a mut W , } impl < 'a > TBIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn tbifg_0 ( self ) -> & 'a mut W { self . variant ( TBIFG_A :: TBIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn tbifg_1 ( self ) -> & 'a mut W { self . variant ( TBIFG_A :: TBIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "TimerB interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TBIE_A { # [ doc = "0: Interrupt disabled" ] TBIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] TBIE_1 = 1 } impl From < TBIE_A > for bool { # [ inline ( always ) ] fn from ( variant : TBIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `TBIE`" ] pub type TBIE_R = crate :: R < bool , TBIE_A > ; impl TBIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIE_A { match self . bits { false => TBIE_A :: TBIE_0 , true => TBIE_A :: TBIE_1 } } # [ doc = "Checks if the value of the field is `TBIE_0`" ] # [ inline ( always ) ] pub fn is_tbie_0 ( & self ) -> bool { * self == TBIE_A :: TBIE_0 } # [ doc = "Checks if the value of the field is `TBIE_1`" ] # [ inline ( always ) ] pub fn is_tbie_1 ( & self ) -> bool { * self == TBIE_A :: TBIE_1 } }
# [ doc = "Write proxy for field `TBIE`" ] pub struct TBIE_W < 'a > { w : & 'a mut W , } impl < 'a > TBIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn tbie_0 ( self ) -> & 'a mut W { self . variant ( TBIE_A :: TBIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn tbie_1 ( self ) -> & 'a mut W { self . variant ( TBIE_A :: TBIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `TBCLR`" ] pub type TBCLR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TBCLR`" ] pub struct TBCLR_W < 'a > { w : & 'a mut W , } impl < 'a > TBCLR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Mode control\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum MC_A { # [ doc = "0: Stop mode: Timer is halted" ] STOP = 0 , # [ doc = "1: Up mode: Timer counts up to TBxCL0" ] UP = 1 , # [ doc = "2: Continuous mode: Timer counts up to the value set by CNTL" ] CONTINUOUS = 2 , # [ doc = "3: Up/down mode: Timer counts up to TBxCL0 then down to 0000h" ] UPDOWN = 3 } impl From < MC_A > for u8 { # [ inline ( always ) ] fn from ( variant : MC_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `MC`" ] pub type MC_R = crate :: R < u8 , MC_A > ; impl MC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MC_A { match self . bits { 0 => MC_A :: STOP , 1 => MC_A :: UP , 2 => MC_A :: CONTINUOUS , 3 => MC_A :: UPDOWN , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `STOP`" ] # [ inline ( always ) ] pub fn is_stop ( & self ) -> bool { * self == MC_A :: STOP } # [ doc = "Checks if the value of the field is `UP`" ] # [ inline ( always ) ] pub fn is_up ( & self ) -> bool { * self == MC_A :: UP } # [ doc = "Checks if the value of the field is `CONTINUOUS`" ] # [ inline ( always ) ] pub fn is_continuous ( & self ) -> bool { * self == MC_A :: CONTINUOUS } # [ doc = "Checks if the value of the field is `UPDOWN`" ] # [ inline ( always ) ] pub fn is_updown ( & self ) -> bool { * self == MC_A :: UPDOWN } }
# [ doc = "Write proxy for field `MC`" ] pub struct MC_W < 'a > { w : & 'a mut W , } impl < 'a > MC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MC_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Stop mode: Timer is halted" ] # [ inline ( always ) ] pub fn stop ( self ) -> & 'a mut W { self . variant ( MC_A :: STOP ) } # [ doc = "Up mode: Timer counts up to TBxCL0" ] # [ inline ( always ) ] pub fn up ( self ) -> & 'a mut W { self . variant ( MC_A :: UP ) } # [ doc = "Continuous mode: Timer counts up to the value set by CNTL" ] # [ inline ( always ) ] pub fn continuous ( self ) -> & 'a mut W { self . variant ( MC_A :: CONTINUOUS ) } # [ doc = "Up/down mode: Timer counts up to TBxCL0 then down to 0000h" ] # [ inline ( always ) ] pub fn updown ( self ) -> & 'a mut W { self . variant ( MC_A :: UPDOWN ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Input divider\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ID_A { # [ doc = "0: /1" ] _1 = 0 , # [ doc = "1: /2" ] _2 = 1 , # [ doc = "2: /4" ] _4 = 2 , # [ doc = "3: /8" ] _8 = 3 } impl From < ID_A > for u8 { # [ inline ( always ) ] fn from ( variant : ID_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ID`" ] pub type ID_R = crate :: R < u8 , ID_A > ; impl ID_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ID_A { match self . bits { 0 => ID_A :: _1 , 1 => ID_A :: _2 , 2 => ID_A :: _4 , 3 => ID_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == ID_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == ID_A :: _2 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == ID_A :: _4 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == ID_A :: _8 } }
# [ doc = "Write proxy for field `ID`" ] pub struct ID_W < 'a > { w : & 'a mut W , } impl < 'a > ID_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ID_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "/1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( ID_A :: _1 ) } # [ doc = "/2" ] # [ inline ( always ) ] pub fn _2 ( self ) -> & 'a mut W { self . variant ( ID_A :: _2 ) } # [ doc = "/4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( ID_A :: _4 ) } # [ doc = "/8" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( ID_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "TimerB clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBSSEL_A { # [ doc = "0: TBxCLK" ] TBCLK = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: INCLK" ] INCLK = 3 } impl From < TBSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBSSEL`" ] pub type TBSSEL_R = crate :: R < u8 , TBSSEL_A > ; impl TBSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBSSEL_A { match self . bits { 0 => TBSSEL_A :: TBCLK , 1 => TBSSEL_A :: ACLK , 2 => TBSSEL_A :: SMCLK , 3 => TBSSEL_A :: INCLK , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `TBCLK`" ] # [ inline ( always ) ] pub fn is_tbclk ( & self ) -> bool { * self == TBSSEL_A :: TBCLK } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == TBSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == TBSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `INCLK`" ] # [ inline ( always ) ] pub fn is_inclk ( & self ) -> bool { * self == TBSSEL_A :: INCLK } }
# [ doc = "Write proxy for field `TBSSEL`" ] pub struct TBSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > TBSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLK" ] # [ inline ( always ) ] pub fn tbclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: TBCLK ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: SMCLK ) } # [ doc = "INCLK" ] # [ inline ( always ) ] pub fn inclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: INCLK ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Counter length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CNTL_A { # [ doc = "0: 16-bit, TBxR(max) = 0FFFFh" ] _16 = 0 , # [ doc = "1: 12-bit, TBxR(max) = 0FFFh" ] _12 = 1 , # [ doc = "2: 10-bit, TBxR(max) = 03FFh" ] _10 = 2 , # [ doc = "3: 8-bit, TBxR(max) = 0FFh" ] _8 = 3 } impl From < CNTL_A > for u8 { # [ inline ( always ) ] fn from ( variant : CNTL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CNTL`" ] pub type CNTL_R = crate :: R < u8 , CNTL_A > ; impl CNTL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CNTL_A { match self . bits { 0 => CNTL_A :: _16 , 1 => CNTL_A :: _12 , 2 => CNTL_A :: _10 , 3 => CNTL_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_16`" ] # [ inline ( always ) ] pub fn is_16 ( & self ) -> bool { * self == CNTL_A :: _16 } # [ doc = "Checks if the value of the field is `_12`" ] # [ inline ( always ) ] pub fn is_12 ( & self ) -> bool { * self == CNTL_A :: _12 } # [ doc = "Checks if the value of the field is `_10`" ] # [ inline ( always ) ] pub fn is_10 ( & self ) -> bool { * self == CNTL_A :: _10 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == CNTL_A :: _8 } }
# [ doc = "Write proxy for field `CNTL`" ] pub struct CNTL_W < 'a > { w : & 'a mut W , } impl < 'a > CNTL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CNTL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "16-bit, TBxR(max) = 0FFFFh" ] # [ inline ( always ) ] pub fn _16 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _16 ) } # [ doc = "12-bit, TBxR(max) = 0FFFh" ] # [ inline ( always ) ] pub fn _12 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _12 ) } # [ doc = "10-bit, TBxR(max) = 03FFh" ] # [ inline ( always ) ] pub fn _10 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _10 ) } # [ doc = "8-bit, TBxR(max) = 0FFh" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 11 ) ) | ( ( ( value as u16 ) & 0x03 ) << 11 ) ; self . w } }
# [ doc = "TBxCLn group\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBCLGRP_A { # [ doc = "0: Each TBxCLn latch loads independently" ] TBCLGRP_0 = 0 , # [ doc = "1: TBxCL1+TBxCL2 (TBxCCR1 CLLD bits control the update); TBxCL3+TBxCL4 (TBxCCR3 CLLD bits control the update); TBxCL5+TBxCL6 (TBxCCR5 CLLD bits control the update); TBxCL0 independent" ] TBCLGRP_1 = 1 , # [ doc = "2: TBxCL1+TBxCL2+TBxCL3 (TBxCCR1 CLLD bits control the update); TBxCL4+TBxCL5+TBxCL6 (TBxCCR4 CLLD bits control the update); TBxCL0 independent" ] TBCLGRP_2 = 2 , # [ doc = "3: TBxCL0+TBxCL1+TBxCL2+TBxCL3+TBxCL4+TBxCL5+TBxCL6 (TBxCCR1 CLLD bits control the update)" ] TBCLGRP_3 = 3 } impl From < TBCLGRP_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBCLGRP_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBCLGRP`" ] pub type TBCLGRP_R = crate :: R < u8 , TBCLGRP_A > ; impl TBCLGRP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBCLGRP_A { match self . bits { 0 => TBCLGRP_A :: TBCLGRP_0 , 1 => TBCLGRP_A :: TBCLGRP_1 , 2 => TBCLGRP_A :: TBCLGRP_2 , 3 => TBCLGRP_A :: TBCLGRP_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `TBCLGRP_0`" ] # [ inline ( always ) ] pub fn is_tbclgrp_0 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_0 } # [ doc = "Checks if the value of the field is `TBCLGRP_1`" ] # [ inline ( always ) ] pub fn is_tbclgrp_1 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_1 } # [ doc = "Checks if the value of the field is `TBCLGRP_2`" ] # [ inline ( always ) ] pub fn is_tbclgrp_2 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_2 } # [ doc = "Checks if the value of the field is `TBCLGRP_3`" ] # [ inline ( always ) ] pub fn is_tbclgrp_3 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_3 } }
# [ doc = "Write proxy for field `TBCLGRP`" ] pub struct TBCLGRP_W < 'a > { w : & 'a mut W , } impl < 'a > TBCLGRP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBCLGRP_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Each TBxCLn latch loads independently" ] # [ inline ( always ) ] pub fn tbclgrp_0 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_0 ) } # [ doc = "TBxCL1+TBxCL2 (TBxCCR1 CLLD bits control the update); TBxCL3+TBxCL4 (TBxCCR3 CLLD bits control the update); TBxCL5+TBxCL6 (TBxCCR5 CLLD bits control the update); TBxCL0 independent" ] # [ inline ( always ) ] pub fn tbclgrp_1 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_1 ) } # [ doc = "TBxCL1+TBxCL2+TBxCL3 (TBxCCR1 CLLD bits control the update); TBxCL4+TBxCL5+TBxCL6 (TBxCCR4 CLLD bits control the update); TBxCL0 independent" ] # [ inline ( always ) ] pub fn tbclgrp_2 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_2 ) } # [ doc = "TBxCL0+TBxCL1+TBxCL2+TBxCL3+TBxCL4+TBxCL5+TBxCL6 (TBxCCR1 CLLD bits control the update)" ] # [ inline ( always ) ] pub fn tbclgrp_3 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 13 ) ) | ( ( ( value as u16 ) & 0x03 ) << 13 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - TimerB interrupt flag" ] # [ inline ( always ) ] pub fn tbifg ( & self ) -> TBIFG_R { TBIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - TimerB interrupt enable" ] # [ inline ( always ) ] pub fn tbie ( & self ) -> TBIE_R { TBIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - TimerB clear" ] # [ inline ( always ) ] pub fn tbclr ( & self ) -> TBCLR_R { TBCLR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - Mode control" ] # [ inline ( always ) ] pub fn mc ( & self ) -> MC_R { MC_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 6:7 - Input divider" ] # [ inline ( always ) ] pub fn id ( & self ) -> ID_R { ID_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:9 - TimerB clock source select" ] # [ inline ( always ) ] pub fn tbssel ( & self ) -> TBSSEL_R { TBSSEL_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 11:12 - Counter length" ] # [ inline ( always ) ] pub fn cntl ( & self ) -> CNTL_R { CNTL_R :: new ( ( ( self . bits >> 11 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 13:14 - TBxCLn group" ] # [ inline ( always ) ] pub fn tbclgrp ( & self ) -> TBCLGRP_R { TBCLGRP_R :: new ( ( ( self . bits >> 13 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - TimerB interrupt flag" ] # [ inline ( always ) ] pub fn tbifg ( & mut self ) -> TBIFG_W { TBIFG_W { w : self } }
# [ doc = "Bit 1 - TimerB interrupt enable" ] # [ inline ( always ) ] pub fn tbie ( & mut self ) -> TBIE_W { TBIE_W { w : self } }
# [ doc = "Bit 2 - TimerB clear" ] # [ inline ( always ) ] pub fn tbclr ( & mut self ) -> TBCLR_W { TBCLR_W { w : self } }
# [ doc = "Bits 4:5 - Mode control" ] # [ inline ( always ) ] pub fn mc ( & mut self ) -> MC_W { MC_W { w : self } }
# [ doc = "Bits 6:7 - Input divider" ] # [ inline ( always ) ] pub fn id ( & mut self ) -> ID_W { ID_W { w : self } }
# [ doc = "Bits 8:9 - TimerB clock source select" ] # [ inline ( always ) ] pub fn tbssel ( & mut self ) -> TBSSEL_W { TBSSEL_W { w : self } }
# [ doc = "Bits 11:12 - Counter length" ] # [ inline ( always ) ] pub fn cntl ( & mut self ) -> CNTL_W { CNTL_W { w : self } }
# [ doc = "Bits 13:14 - TBxCLn group" ] # [ inline ( always ) ] pub fn tbclgrp ( & mut self ) -> TBCLGRP_W { TBCLGRP_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb1cctl0](tb1cctl0) module" ] pub type TB1CCTL0 = crate :: Reg < u16 , _TB1CCTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB1CCTL0 ;
# [ doc = "`read()` method returns [tb1cctl0::R](tb1cctl0::R) reader structure" ] impl crate :: Readable for TB1CCTL0 { }
# [ doc = "`write(|w| ..)` method takes [tb1cctl0::W](tb1cctl0::W) writer structure" ] impl crate :: Writable for TB1CCTL0 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb1cctl0 {
# [ doc = "Reader of register TB1CCTL0" ] pub type R = crate :: R < u16 , super :: TB1CCTL0 > ;
# [ doc = "Writer for register TB1CCTL0" ] pub type W = crate :: W < u16 , super :: TB1CCTL0 > ;
# [ doc = "Register TB1CCTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB1CCTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb1cctl1](tb1cctl1) module" ] pub type TB1CCTL1 = crate :: Reg < u16 , _TB1CCTL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB1CCTL1 ;
# [ doc = "`read()` method returns [tb1cctl1::R](tb1cctl1::R) reader structure" ] impl crate :: Readable for TB1CCTL1 { }
# [ doc = "`write(|w| ..)` method takes [tb1cctl1::W](tb1cctl1::W) writer structure" ] impl crate :: Writable for TB1CCTL1 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb1cctl1 {
# [ doc = "Reader of register TB1CCTL1" ] pub type R = crate :: R < u16 , super :: TB1CCTL1 > ;
# [ doc = "Writer for register TB1CCTL1" ] pub type W = crate :: W < u16 , super :: TB1CCTL1 > ;
# [ doc = "Register TB1CCTL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB1CCTL1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb1cctl2](tb1cctl2) module" ] pub type TB1CCTL2 = crate :: Reg < u16 , _TB1CCTL2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB1CCTL2 ;
# [ doc = "`read()` method returns [tb1cctl2::R](tb1cctl2::R) reader structure" ] impl crate :: Readable for TB1CCTL2 { }
# [ doc = "`write(|w| ..)` method takes [tb1cctl2::W](tb1cctl2::W) writer structure" ] impl crate :: Writable for TB1CCTL2 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb1cctl2 {
# [ doc = "Reader of register TB1CCTL2" ] pub type R = crate :: R < u16 , super :: TB1CCTL2 > ;
# [ doc = "Writer for register TB1CCTL2" ] pub type W = crate :: W < u16 , super :: TB1CCTL2 > ;
# [ doc = "Register TB1CCTL2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB1CCTL2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B count register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb1r](tb1r) module" ] pub type TB1R = crate :: Reg < u16 , _TB1R > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB1R ;
# [ doc = "`read()` method returns [tb1r::R](tb1r::R) reader structure" ] impl crate :: Readable for TB1R { }
# [ doc = "`write(|w| ..)` method takes [tb1r::W](tb1r::W) writer structure" ] impl crate :: Writable for TB1R { }
# [ doc = "Timer_B count register" ] pub mod tb1r {
# [ doc = "Reader of register TB1R" ] pub type R = crate :: R < u16 , super :: TB1R > ;
# [ doc = "Writer for register TB1R" ] pub type W = crate :: W < u16 , super :: TB1R > ;
# [ doc = "Register TB1R `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB1R { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb1ccr0](tb1ccr0) module" ] pub type TB1CCR0 = crate :: Reg < u16 , _TB1CCR0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB1CCR0 ;
# [ doc = "`read()` method returns [tb1ccr0::R](tb1ccr0::R) reader structure" ] impl crate :: Readable for TB1CCR0 { }
# [ doc = "`write(|w| ..)` method takes [tb1ccr0::W](tb1ccr0::W) writer structure" ] impl crate :: Writable for TB1CCR0 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb1ccr0 {
# [ doc = "Reader of register TB1CCR0" ] pub type R = crate :: R < u16 , super :: TB1CCR0 > ;
# [ doc = "Writer for register TB1CCR0" ] pub type W = crate :: W < u16 , super :: TB1CCR0 > ;
# [ doc = "Register TB1CCR0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB1CCR0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb1ccr1](tb1ccr1) module" ] pub type TB1CCR1 = crate :: Reg < u16 , _TB1CCR1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB1CCR1 ;
# [ doc = "`read()` method returns [tb1ccr1::R](tb1ccr1::R) reader structure" ] impl crate :: Readable for TB1CCR1 { }
# [ doc = "`write(|w| ..)` method takes [tb1ccr1::W](tb1ccr1::W) writer structure" ] impl crate :: Writable for TB1CCR1 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb1ccr1 {
# [ doc = "Reader of register TB1CCR1" ] pub type R = crate :: R < u16 , super :: TB1CCR1 > ;
# [ doc = "Writer for register TB1CCR1" ] pub type W = crate :: W < u16 , super :: TB1CCR1 > ;
# [ doc = "Register TB1CCR1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB1CCR1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb1ccr2](tb1ccr2) module" ] pub type TB1CCR2 = crate :: Reg < u16 , _TB1CCR2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB1CCR2 ;
# [ doc = "`read()` method returns [tb1ccr2::R](tb1ccr2::R) reader structure" ] impl crate :: Readable for TB1CCR2 { }
# [ doc = "`write(|w| ..)` method takes [tb1ccr2::W](tb1ccr2::W) writer structure" ] impl crate :: Writable for TB1CCR2 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb1ccr2 {
# [ doc = "Reader of register TB1CCR2" ] pub type R = crate :: R < u16 , super :: TB1CCR2 > ;
# [ doc = "Writer for register TB1CCR2" ] pub type W = crate :: W < u16 , super :: TB1CCR2 > ;
# [ doc = "Register TB1CCR2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB1CCR2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_Bx Expansion Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb1ex0](tb1ex0) module" ] pub type TB1EX0 = crate :: Reg < u16 , _TB1EX0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB1EX0 ;
# [ doc = "`read()` method returns [tb1ex0::R](tb1ex0::R) reader structure" ] impl crate :: Readable for TB1EX0 { }
# [ doc = "`write(|w| ..)` method takes [tb1ex0::W](tb1ex0::W) writer structure" ] impl crate :: Writable for TB1EX0 { }
# [ doc = "Timer_Bx Expansion Register 0" ] pub mod tb1ex0 {
# [ doc = "Reader of register TB1EX0" ] pub type R = crate :: R < u16 , super :: TB1EX0 > ;
# [ doc = "Writer for register TB1EX0" ] pub type W = crate :: W < u16 , super :: TB1EX0 > ;
# [ doc = "Register TB1EX0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB1EX0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Input divider expansion\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBIDEX_A { # [ doc = "0: Divide by 1" ] _1 = 0 , # [ doc = "1: Divide by 2" ] _2 = 1 , # [ doc = "2: Divide by 3" ] _3 = 2 , # [ doc = "3: Divide by 4" ] _4 = 3 , # [ doc = "4: Divide by 5" ] _5 = 4 , # [ doc = "5: Divide by 6" ] _6 = 5 , # [ doc = "6: Divide by 7" ] _7 = 6 , # [ doc = "7: Divide by 8" ] _8 = 7 } impl From < TBIDEX_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBIDEX_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBIDEX`" ] pub type TBIDEX_R = crate :: R < u8 , TBIDEX_A > ; impl TBIDEX_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIDEX_A { match self . bits { 0 => TBIDEX_A :: _1 , 1 => TBIDEX_A :: _2 , 2 => TBIDEX_A :: _3 , 3 => TBIDEX_A :: _4 , 4 => TBIDEX_A :: _5 , 5 => TBIDEX_A :: _6 , 6 => TBIDEX_A :: _7 , 7 => TBIDEX_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == TBIDEX_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == TBIDEX_A :: _2 } # [ doc = "Checks if the value of the field is `_3`" ] # [ inline ( always ) ] pub fn is_3 ( & self ) -> bool { * self == TBIDEX_A :: _3 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == TBIDEX_A :: _4 } # [ doc = "Checks if the value of the field is `_5`" ] # [ inline ( always ) ] pub fn is_5 ( & self ) -> bool { * self == TBIDEX_A :: _5 } # [ doc = "Checks if the value of the field is `_6`" ] # [ inline ( always ) ] pub fn is_6 ( & self ) -> bool { * self == TBIDEX_A :: _6 } # [ doc = "Checks if the value of the field is `_7`" ] # [ inline ( always ) ] pub fn is_7 ( & self ) -> bool { * self == TBIDEX_A :: _7 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == TBIDEX_A :: _8 } }
# [ doc = "Write proxy for field `TBIDEX`" ] pub struct TBIDEX_W < 'a > { w : & 'a mut W , } impl < 'a > TBIDEX_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIDEX_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Divide by 1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _1 ) } # [ doc = "Divide by 2" ] # [ inline ( always ) ] pub fn _2 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _2 ) } # [ doc = "Divide by 3" ] # [ inline ( always ) ] pub fn _3 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _3 ) } # [ doc = "Divide by 4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _4 ) } # [ doc = "Divide by 5" ] # [ inline ( always ) ] pub fn _5 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _5 ) } # [ doc = "Divide by 6" ] # [ inline ( always ) ] pub fn _6 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _6 ) } # [ doc = "Divide by 7" ] # [ inline ( always ) ] pub fn _7 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _7 ) } # [ doc = "Divide by 8" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u16 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Input divider expansion" ] # [ inline ( always ) ] pub fn tbidex ( & self ) -> TBIDEX_R { TBIDEX_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Input divider expansion" ] # [ inline ( always ) ] pub fn tbidex ( & mut self ) -> TBIDEX_W { TBIDEX_W { w : self } }
}
}
# [ doc = "Timer_Bx Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb1iv](tb1iv) module" ] pub type TB1IV = crate :: Reg < u16 , _TB1IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB1IV ;
# [ doc = "`read()` method returns [tb1iv::R](tb1iv::R) reader structure" ] impl crate :: Readable for TB1IV { }
# [ doc = "Timer_Bx Interrupt Vector Register" ] pub mod tb1iv {
# [ doc = "Reader of register TB1IV" ] pub type R = crate :: R < u16 , super :: TB1IV > ;
# [ doc = "Timer_B interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum TBIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Capture/compare 1; Interrupt Flag: TBxCCR1 CCIFG; Interrupt Priority: Highest" ] TBCCR1 = 2 , # [ doc = "4: Interrupt Source: Capture/compare 2; Interrupt Flag: TBxCCR2 CCIFG" ] TBCCR2 = 4 , # [ doc = "6: Interrupt Source: Capture/compare 3; Interrupt Flag: TBxCCR3 CCIFG" ] TBCCR3 = 6 , # [ doc = "8: Interrupt Source: Capture/compare 4; Interrupt Flag: TBxCCR4 CCIFG" ] TBCCR4 = 8 , # [ doc = "10: Interrupt Source: Capture/compare 5; Interrupt Flag: TBxCCR5 CCIFG" ] TBCCR5 = 10 , # [ doc = "12: Interrupt Source: Capture/compare 6; Interrupt Flag: TBxCCR6 CCIFG" ] TBCCR6 = 12 , # [ doc = "14: Interrupt Source: Timer overflow; Interrupt Flag: TBxCTL TBIFG; Interrupt Priority: Lowest" ] TBIFG = 14 } impl From < TBIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : TBIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBIV`" ] pub type TBIV_R = crate :: R < u16 , TBIV_A > ; impl TBIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , TBIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( TBIV_A :: NONE ) , 2 => Val ( TBIV_A :: TBCCR1 ) , 4 => Val ( TBIV_A :: TBCCR2 ) , 6 => Val ( TBIV_A :: TBCCR3 ) , 8 => Val ( TBIV_A :: TBCCR4 ) , 10 => Val ( TBIV_A :: TBCCR5 ) , 12 => Val ( TBIV_A :: TBCCR6 ) , 14 => Val ( TBIV_A :: TBIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == TBIV_A :: NONE } # [ doc = "Checks if the value of the field is `TBCCR1`" ] # [ inline ( always ) ] pub fn is_tbccr1 ( & self ) -> bool { * self == TBIV_A :: TBCCR1 } # [ doc = "Checks if the value of the field is `TBCCR2`" ] # [ inline ( always ) ] pub fn is_tbccr2 ( & self ) -> bool { * self == TBIV_A :: TBCCR2 } # [ doc = "Checks if the value of the field is `TBCCR3`" ] # [ inline ( always ) ] pub fn is_tbccr3 ( & self ) -> bool { * self == TBIV_A :: TBCCR3 } # [ doc = "Checks if the value of the field is `TBCCR4`" ] # [ inline ( always ) ] pub fn is_tbccr4 ( & self ) -> bool { * self == TBIV_A :: TBCCR4 } # [ doc = "Checks if the value of the field is `TBCCR5`" ] # [ inline ( always ) ] pub fn is_tbccr5 ( & self ) -> bool { * self == TBIV_A :: TBCCR5 } # [ doc = "Checks if the value of the field is `TBCCR6`" ] # [ inline ( always ) ] pub fn is_tbccr6 ( & self ) -> bool { * self == TBIV_A :: TBCCR6 } # [ doc = "Checks if the value of the field is `TBIFG`" ] # [ inline ( always ) ] pub fn is_tbifg ( & self ) -> bool { * self == TBIV_A :: TBIFG } }
impl R {
# [ doc = "Bits 0:15 - Timer_B interrupt vector value" ] # [ inline ( always ) ] pub fn tbiv ( & self ) -> TBIV_R { TBIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "TB2" ] pub struct TB2 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TB2 { } impl TB2 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const tb2 :: RegisterBlock { 0x0400 as * const _ } } impl Deref for TB2 { type Target = tb2 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * TB2 :: ptr ( ) } } }
# [ doc = "TB2" ] pub mod tb2 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Timer_B Control Register" ] pub tb2ctl : TB2CTL , # [ doc = "0x02 - Timer_B Capture/Compare Control Register" ] pub tb2cctl0 : TB2CCTL0 , # [ doc = "0x04 - Timer_B Capture/Compare Control Register" ] pub tb2cctl1 : TB2CCTL1 , # [ doc = "0x06 - Timer_B Capture/Compare Control Register" ] pub tb2cctl2 : TB2CCTL2 , _reserved4 : [ u8 ; 8usize ] , # [ doc = "0x10 - Timer_B count register" ] pub tb2r : TB2R , # [ doc = "0x12 - Timer_B Capture/Compare Register" ] pub tb2ccr0 : TB2CCR0 , # [ doc = "0x14 - Timer_B Capture/Compare Register" ] pub tb2ccr1 : TB2CCR1 , # [ doc = "0x16 - Timer_B Capture/Compare Register" ] pub tb2ccr2 : TB2CCR2 , _reserved8 : [ u8 ; 8usize ] , # [ doc = "0x20 - Timer_Bx Expansion Register 0" ] pub tb2ex0 : TB2EX0 , _reserved9 : [ u8 ; 12usize ] , # [ doc = "0x2e - Timer_Bx Interrupt Vector Register" ] pub tb2iv : TB2IV , }
# [ doc = "Timer_B Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb2ctl](tb2ctl) module" ] pub type TB2CTL = crate :: Reg < u16 , _TB2CTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB2CTL ;
# [ doc = "`read()` method returns [tb2ctl::R](tb2ctl::R) reader structure" ] impl crate :: Readable for TB2CTL { }
# [ doc = "`write(|w| ..)` method takes [tb2ctl::W](tb2ctl::W) writer structure" ] impl crate :: Writable for TB2CTL { }
# [ doc = "Timer_B Control Register" ] pub mod tb2ctl {
# [ doc = "Reader of register TB2CTL" ] pub type R = crate :: R < u16 , super :: TB2CTL > ;
# [ doc = "Writer for register TB2CTL" ] pub type W = crate :: W < u16 , super :: TB2CTL > ;
# [ doc = "Register TB2CTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB2CTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "TimerB interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TBIFG_A { # [ doc = "0: No interrupt pending" ] TBIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] TBIFG_1 = 1 } impl From < TBIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : TBIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `TBIFG`" ] pub type TBIFG_R = crate :: R < bool , TBIFG_A > ; impl TBIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIFG_A { match self . bits { false => TBIFG_A :: TBIFG_0 , true => TBIFG_A :: TBIFG_1 } } # [ doc = "Checks if the value of the field is `TBIFG_0`" ] # [ inline ( always ) ] pub fn is_tbifg_0 ( & self ) -> bool { * self == TBIFG_A :: TBIFG_0 } # [ doc = "Checks if the value of the field is `TBIFG_1`" ] # [ inline ( always ) ] pub fn is_tbifg_1 ( & self ) -> bool { * self == TBIFG_A :: TBIFG_1 } }
# [ doc = "Write proxy for field `TBIFG`" ] pub struct TBIFG_W < 'a > { w : & 'a mut W , } impl < 'a > TBIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn tbifg_0 ( self ) -> & 'a mut W { self . variant ( TBIFG_A :: TBIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn tbifg_1 ( self ) -> & 'a mut W { self . variant ( TBIFG_A :: TBIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "TimerB interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TBIE_A { # [ doc = "0: Interrupt disabled" ] TBIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] TBIE_1 = 1 } impl From < TBIE_A > for bool { # [ inline ( always ) ] fn from ( variant : TBIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `TBIE`" ] pub type TBIE_R = crate :: R < bool , TBIE_A > ; impl TBIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIE_A { match self . bits { false => TBIE_A :: TBIE_0 , true => TBIE_A :: TBIE_1 } } # [ doc = "Checks if the value of the field is `TBIE_0`" ] # [ inline ( always ) ] pub fn is_tbie_0 ( & self ) -> bool { * self == TBIE_A :: TBIE_0 } # [ doc = "Checks if the value of the field is `TBIE_1`" ] # [ inline ( always ) ] pub fn is_tbie_1 ( & self ) -> bool { * self == TBIE_A :: TBIE_1 } }
# [ doc = "Write proxy for field `TBIE`" ] pub struct TBIE_W < 'a > { w : & 'a mut W , } impl < 'a > TBIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn tbie_0 ( self ) -> & 'a mut W { self . variant ( TBIE_A :: TBIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn tbie_1 ( self ) -> & 'a mut W { self . variant ( TBIE_A :: TBIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `TBCLR`" ] pub type TBCLR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TBCLR`" ] pub struct TBCLR_W < 'a > { w : & 'a mut W , } impl < 'a > TBCLR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Mode control\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum MC_A { # [ doc = "0: Stop mode: Timer is halted" ] STOP = 0 , # [ doc = "1: Up mode: Timer counts up to TBxCL0" ] UP = 1 , # [ doc = "2: Continuous mode: Timer counts up to the value set by CNTL" ] CONTINUOUS = 2 , # [ doc = "3: Up/down mode: Timer counts up to TBxCL0 then down to 0000h" ] UPDOWN = 3 } impl From < MC_A > for u8 { # [ inline ( always ) ] fn from ( variant : MC_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `MC`" ] pub type MC_R = crate :: R < u8 , MC_A > ; impl MC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MC_A { match self . bits { 0 => MC_A :: STOP , 1 => MC_A :: UP , 2 => MC_A :: CONTINUOUS , 3 => MC_A :: UPDOWN , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `STOP`" ] # [ inline ( always ) ] pub fn is_stop ( & self ) -> bool { * self == MC_A :: STOP } # [ doc = "Checks if the value of the field is `UP`" ] # [ inline ( always ) ] pub fn is_up ( & self ) -> bool { * self == MC_A :: UP } # [ doc = "Checks if the value of the field is `CONTINUOUS`" ] # [ inline ( always ) ] pub fn is_continuous ( & self ) -> bool { * self == MC_A :: CONTINUOUS } # [ doc = "Checks if the value of the field is `UPDOWN`" ] # [ inline ( always ) ] pub fn is_updown ( & self ) -> bool { * self == MC_A :: UPDOWN } }
# [ doc = "Write proxy for field `MC`" ] pub struct MC_W < 'a > { w : & 'a mut W , } impl < 'a > MC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MC_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Stop mode: Timer is halted" ] # [ inline ( always ) ] pub fn stop ( self ) -> & 'a mut W { self . variant ( MC_A :: STOP ) } # [ doc = "Up mode: Timer counts up to TBxCL0" ] # [ inline ( always ) ] pub fn up ( self ) -> & 'a mut W { self . variant ( MC_A :: UP ) } # [ doc = "Continuous mode: Timer counts up to the value set by CNTL" ] # [ inline ( always ) ] pub fn continuous ( self ) -> & 'a mut W { self . variant ( MC_A :: CONTINUOUS ) } # [ doc = "Up/down mode: Timer counts up to TBxCL0 then down to 0000h" ] # [ inline ( always ) ] pub fn updown ( self ) -> & 'a mut W { self . variant ( MC_A :: UPDOWN ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Input divider\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ID_A { # [ doc = "0: /1" ] _1 = 0 , # [ doc = "1: /2" ] _2 = 1 , # [ doc = "2: /4" ] _4 = 2 , # [ doc = "3: /8" ] _8 = 3 } impl From < ID_A > for u8 { # [ inline ( always ) ] fn from ( variant : ID_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ID`" ] pub type ID_R = crate :: R < u8 , ID_A > ; impl ID_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ID_A { match self . bits { 0 => ID_A :: _1 , 1 => ID_A :: _2 , 2 => ID_A :: _4 , 3 => ID_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == ID_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == ID_A :: _2 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == ID_A :: _4 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == ID_A :: _8 } }
# [ doc = "Write proxy for field `ID`" ] pub struct ID_W < 'a > { w : & 'a mut W , } impl < 'a > ID_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ID_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "/1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( ID_A :: _1 ) } # [ doc = "/2" ] # [ inline ( always ) ] pub fn _2 ( self ) -> & 'a mut W { self . variant ( ID_A :: _2 ) } # [ doc = "/4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( ID_A :: _4 ) } # [ doc = "/8" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( ID_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "TimerB clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBSSEL_A { # [ doc = "0: TBxCLK" ] TBCLK = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: INCLK" ] INCLK = 3 } impl From < TBSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBSSEL`" ] pub type TBSSEL_R = crate :: R < u8 , TBSSEL_A > ; impl TBSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBSSEL_A { match self . bits { 0 => TBSSEL_A :: TBCLK , 1 => TBSSEL_A :: ACLK , 2 => TBSSEL_A :: SMCLK , 3 => TBSSEL_A :: INCLK , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `TBCLK`" ] # [ inline ( always ) ] pub fn is_tbclk ( & self ) -> bool { * self == TBSSEL_A :: TBCLK } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == TBSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == TBSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `INCLK`" ] # [ inline ( always ) ] pub fn is_inclk ( & self ) -> bool { * self == TBSSEL_A :: INCLK } }
# [ doc = "Write proxy for field `TBSSEL`" ] pub struct TBSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > TBSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLK" ] # [ inline ( always ) ] pub fn tbclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: TBCLK ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: SMCLK ) } # [ doc = "INCLK" ] # [ inline ( always ) ] pub fn inclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: INCLK ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Counter length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CNTL_A { # [ doc = "0: 16-bit, TBxR(max) = 0FFFFh" ] _16 = 0 , # [ doc = "1: 12-bit, TBxR(max) = 0FFFh" ] _12 = 1 , # [ doc = "2: 10-bit, TBxR(max) = 03FFh" ] _10 = 2 , # [ doc = "3: 8-bit, TBxR(max) = 0FFh" ] _8 = 3 } impl From < CNTL_A > for u8 { # [ inline ( always ) ] fn from ( variant : CNTL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CNTL`" ] pub type CNTL_R = crate :: R < u8 , CNTL_A > ; impl CNTL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CNTL_A { match self . bits { 0 => CNTL_A :: _16 , 1 => CNTL_A :: _12 , 2 => CNTL_A :: _10 , 3 => CNTL_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_16`" ] # [ inline ( always ) ] pub fn is_16 ( & self ) -> bool { * self == CNTL_A :: _16 } # [ doc = "Checks if the value of the field is `_12`" ] # [ inline ( always ) ] pub fn is_12 ( & self ) -> bool { * self == CNTL_A :: _12 } # [ doc = "Checks if the value of the field is `_10`" ] # [ inline ( always ) ] pub fn is_10 ( & self ) -> bool { * self == CNTL_A :: _10 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == CNTL_A :: _8 } }
# [ doc = "Write proxy for field `CNTL`" ] pub struct CNTL_W < 'a > { w : & 'a mut W , } impl < 'a > CNTL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CNTL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "16-bit, TBxR(max) = 0FFFFh" ] # [ inline ( always ) ] pub fn _16 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _16 ) } # [ doc = "12-bit, TBxR(max) = 0FFFh" ] # [ inline ( always ) ] pub fn _12 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _12 ) } # [ doc = "10-bit, TBxR(max) = 03FFh" ] # [ inline ( always ) ] pub fn _10 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _10 ) } # [ doc = "8-bit, TBxR(max) = 0FFh" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 11 ) ) | ( ( ( value as u16 ) & 0x03 ) << 11 ) ; self . w } }
# [ doc = "TBxCLn group\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBCLGRP_A { # [ doc = "0: Each TBxCLn latch loads independently" ] TBCLGRP_0 = 0 , # [ doc = "1: TBxCL1+TBxCL2 (TBxCCR1 CLLD bits control the update); TBxCL3+TBxCL4 (TBxCCR3 CLLD bits control the update); TBxCL5+TBxCL6 (TBxCCR5 CLLD bits control the update); TBxCL0 independent" ] TBCLGRP_1 = 1 , # [ doc = "2: TBxCL1+TBxCL2+TBxCL3 (TBxCCR1 CLLD bits control the update); TBxCL4+TBxCL5+TBxCL6 (TBxCCR4 CLLD bits control the update); TBxCL0 independent" ] TBCLGRP_2 = 2 , # [ doc = "3: TBxCL0+TBxCL1+TBxCL2+TBxCL3+TBxCL4+TBxCL5+TBxCL6 (TBxCCR1 CLLD bits control the update)" ] TBCLGRP_3 = 3 } impl From < TBCLGRP_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBCLGRP_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBCLGRP`" ] pub type TBCLGRP_R = crate :: R < u8 , TBCLGRP_A > ; impl TBCLGRP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBCLGRP_A { match self . bits { 0 => TBCLGRP_A :: TBCLGRP_0 , 1 => TBCLGRP_A :: TBCLGRP_1 , 2 => TBCLGRP_A :: TBCLGRP_2 , 3 => TBCLGRP_A :: TBCLGRP_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `TBCLGRP_0`" ] # [ inline ( always ) ] pub fn is_tbclgrp_0 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_0 } # [ doc = "Checks if the value of the field is `TBCLGRP_1`" ] # [ inline ( always ) ] pub fn is_tbclgrp_1 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_1 } # [ doc = "Checks if the value of the field is `TBCLGRP_2`" ] # [ inline ( always ) ] pub fn is_tbclgrp_2 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_2 } # [ doc = "Checks if the value of the field is `TBCLGRP_3`" ] # [ inline ( always ) ] pub fn is_tbclgrp_3 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_3 } }
# [ doc = "Write proxy for field `TBCLGRP`" ] pub struct TBCLGRP_W < 'a > { w : & 'a mut W , } impl < 'a > TBCLGRP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBCLGRP_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Each TBxCLn latch loads independently" ] # [ inline ( always ) ] pub fn tbclgrp_0 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_0 ) } # [ doc = "TBxCL1+TBxCL2 (TBxCCR1 CLLD bits control the update); TBxCL3+TBxCL4 (TBxCCR3 CLLD bits control the update); TBxCL5+TBxCL6 (TBxCCR5 CLLD bits control the update); TBxCL0 independent" ] # [ inline ( always ) ] pub fn tbclgrp_1 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_1 ) } # [ doc = "TBxCL1+TBxCL2+TBxCL3 (TBxCCR1 CLLD bits control the update); TBxCL4+TBxCL5+TBxCL6 (TBxCCR4 CLLD bits control the update); TBxCL0 independent" ] # [ inline ( always ) ] pub fn tbclgrp_2 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_2 ) } # [ doc = "TBxCL0+TBxCL1+TBxCL2+TBxCL3+TBxCL4+TBxCL5+TBxCL6 (TBxCCR1 CLLD bits control the update)" ] # [ inline ( always ) ] pub fn tbclgrp_3 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 13 ) ) | ( ( ( value as u16 ) & 0x03 ) << 13 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - TimerB interrupt flag" ] # [ inline ( always ) ] pub fn tbifg ( & self ) -> TBIFG_R { TBIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - TimerB interrupt enable" ] # [ inline ( always ) ] pub fn tbie ( & self ) -> TBIE_R { TBIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - TimerB clear" ] # [ inline ( always ) ] pub fn tbclr ( & self ) -> TBCLR_R { TBCLR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - Mode control" ] # [ inline ( always ) ] pub fn mc ( & self ) -> MC_R { MC_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 6:7 - Input divider" ] # [ inline ( always ) ] pub fn id ( & self ) -> ID_R { ID_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:9 - TimerB clock source select" ] # [ inline ( always ) ] pub fn tbssel ( & self ) -> TBSSEL_R { TBSSEL_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 11:12 - Counter length" ] # [ inline ( always ) ] pub fn cntl ( & self ) -> CNTL_R { CNTL_R :: new ( ( ( self . bits >> 11 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 13:14 - TBxCLn group" ] # [ inline ( always ) ] pub fn tbclgrp ( & self ) -> TBCLGRP_R { TBCLGRP_R :: new ( ( ( self . bits >> 13 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - TimerB interrupt flag" ] # [ inline ( always ) ] pub fn tbifg ( & mut self ) -> TBIFG_W { TBIFG_W { w : self } }
# [ doc = "Bit 1 - TimerB interrupt enable" ] # [ inline ( always ) ] pub fn tbie ( & mut self ) -> TBIE_W { TBIE_W { w : self } }
# [ doc = "Bit 2 - TimerB clear" ] # [ inline ( always ) ] pub fn tbclr ( & mut self ) -> TBCLR_W { TBCLR_W { w : self } }
# [ doc = "Bits 4:5 - Mode control" ] # [ inline ( always ) ] pub fn mc ( & mut self ) -> MC_W { MC_W { w : self } }
# [ doc = "Bits 6:7 - Input divider" ] # [ inline ( always ) ] pub fn id ( & mut self ) -> ID_W { ID_W { w : self } }
# [ doc = "Bits 8:9 - TimerB clock source select" ] # [ inline ( always ) ] pub fn tbssel ( & mut self ) -> TBSSEL_W { TBSSEL_W { w : self } }
# [ doc = "Bits 11:12 - Counter length" ] # [ inline ( always ) ] pub fn cntl ( & mut self ) -> CNTL_W { CNTL_W { w : self } }
# [ doc = "Bits 13:14 - TBxCLn group" ] # [ inline ( always ) ] pub fn tbclgrp ( & mut self ) -> TBCLGRP_W { TBCLGRP_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb2cctl0](tb2cctl0) module" ] pub type TB2CCTL0 = crate :: Reg < u16 , _TB2CCTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB2CCTL0 ;
# [ doc = "`read()` method returns [tb2cctl0::R](tb2cctl0::R) reader structure" ] impl crate :: Readable for TB2CCTL0 { }
# [ doc = "`write(|w| ..)` method takes [tb2cctl0::W](tb2cctl0::W) writer structure" ] impl crate :: Writable for TB2CCTL0 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb2cctl0 {
# [ doc = "Reader of register TB2CCTL0" ] pub type R = crate :: R < u16 , super :: TB2CCTL0 > ;
# [ doc = "Writer for register TB2CCTL0" ] pub type W = crate :: W < u16 , super :: TB2CCTL0 > ;
# [ doc = "Register TB2CCTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB2CCTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb2cctl1](tb2cctl1) module" ] pub type TB2CCTL1 = crate :: Reg < u16 , _TB2CCTL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB2CCTL1 ;
# [ doc = "`read()` method returns [tb2cctl1::R](tb2cctl1::R) reader structure" ] impl crate :: Readable for TB2CCTL1 { }
# [ doc = "`write(|w| ..)` method takes [tb2cctl1::W](tb2cctl1::W) writer structure" ] impl crate :: Writable for TB2CCTL1 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb2cctl1 {
# [ doc = "Reader of register TB2CCTL1" ] pub type R = crate :: R < u16 , super :: TB2CCTL1 > ;
# [ doc = "Writer for register TB2CCTL1" ] pub type W = crate :: W < u16 , super :: TB2CCTL1 > ;
# [ doc = "Register TB2CCTL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB2CCTL1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb2cctl2](tb2cctl2) module" ] pub type TB2CCTL2 = crate :: Reg < u16 , _TB2CCTL2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB2CCTL2 ;
# [ doc = "`read()` method returns [tb2cctl2::R](tb2cctl2::R) reader structure" ] impl crate :: Readable for TB2CCTL2 { }
# [ doc = "`write(|w| ..)` method takes [tb2cctl2::W](tb2cctl2::W) writer structure" ] impl crate :: Writable for TB2CCTL2 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb2cctl2 {
# [ doc = "Reader of register TB2CCTL2" ] pub type R = crate :: R < u16 , super :: TB2CCTL2 > ;
# [ doc = "Writer for register TB2CCTL2" ] pub type W = crate :: W < u16 , super :: TB2CCTL2 > ;
# [ doc = "Register TB2CCTL2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB2CCTL2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B count register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb2r](tb2r) module" ] pub type TB2R = crate :: Reg < u16 , _TB2R > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB2R ;
# [ doc = "`read()` method returns [tb2r::R](tb2r::R) reader structure" ] impl crate :: Readable for TB2R { }
# [ doc = "`write(|w| ..)` method takes [tb2r::W](tb2r::W) writer structure" ] impl crate :: Writable for TB2R { }
# [ doc = "Timer_B count register" ] pub mod tb2r {
# [ doc = "Reader of register TB2R" ] pub type R = crate :: R < u16 , super :: TB2R > ;
# [ doc = "Writer for register TB2R" ] pub type W = crate :: W < u16 , super :: TB2R > ;
# [ doc = "Register TB2R `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB2R { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb2ccr0](tb2ccr0) module" ] pub type TB2CCR0 = crate :: Reg < u16 , _TB2CCR0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB2CCR0 ;
# [ doc = "`read()` method returns [tb2ccr0::R](tb2ccr0::R) reader structure" ] impl crate :: Readable for TB2CCR0 { }
# [ doc = "`write(|w| ..)` method takes [tb2ccr0::W](tb2ccr0::W) writer structure" ] impl crate :: Writable for TB2CCR0 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb2ccr0 {
# [ doc = "Reader of register TB2CCR0" ] pub type R = crate :: R < u16 , super :: TB2CCR0 > ;
# [ doc = "Writer for register TB2CCR0" ] pub type W = crate :: W < u16 , super :: TB2CCR0 > ;
# [ doc = "Register TB2CCR0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB2CCR0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb2ccr1](tb2ccr1) module" ] pub type TB2CCR1 = crate :: Reg < u16 , _TB2CCR1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB2CCR1 ;
# [ doc = "`read()` method returns [tb2ccr1::R](tb2ccr1::R) reader structure" ] impl crate :: Readable for TB2CCR1 { }
# [ doc = "`write(|w| ..)` method takes [tb2ccr1::W](tb2ccr1::W) writer structure" ] impl crate :: Writable for TB2CCR1 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb2ccr1 {
# [ doc = "Reader of register TB2CCR1" ] pub type R = crate :: R < u16 , super :: TB2CCR1 > ;
# [ doc = "Writer for register TB2CCR1" ] pub type W = crate :: W < u16 , super :: TB2CCR1 > ;
# [ doc = "Register TB2CCR1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB2CCR1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb2ccr2](tb2ccr2) module" ] pub type TB2CCR2 = crate :: Reg < u16 , _TB2CCR2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB2CCR2 ;
# [ doc = "`read()` method returns [tb2ccr2::R](tb2ccr2::R) reader structure" ] impl crate :: Readable for TB2CCR2 { }
# [ doc = "`write(|w| ..)` method takes [tb2ccr2::W](tb2ccr2::W) writer structure" ] impl crate :: Writable for TB2CCR2 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb2ccr2 {
# [ doc = "Reader of register TB2CCR2" ] pub type R = crate :: R < u16 , super :: TB2CCR2 > ;
# [ doc = "Writer for register TB2CCR2" ] pub type W = crate :: W < u16 , super :: TB2CCR2 > ;
# [ doc = "Register TB2CCR2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB2CCR2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_Bx Expansion Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb2ex0](tb2ex0) module" ] pub type TB2EX0 = crate :: Reg < u16 , _TB2EX0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB2EX0 ;
# [ doc = "`read()` method returns [tb2ex0::R](tb2ex0::R) reader structure" ] impl crate :: Readable for TB2EX0 { }
# [ doc = "`write(|w| ..)` method takes [tb2ex0::W](tb2ex0::W) writer structure" ] impl crate :: Writable for TB2EX0 { }
# [ doc = "Timer_Bx Expansion Register 0" ] pub mod tb2ex0 {
# [ doc = "Reader of register TB2EX0" ] pub type R = crate :: R < u16 , super :: TB2EX0 > ;
# [ doc = "Writer for register TB2EX0" ] pub type W = crate :: W < u16 , super :: TB2EX0 > ;
# [ doc = "Register TB2EX0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB2EX0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Input divider expansion\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBIDEX_A { # [ doc = "0: Divide by 1" ] _1 = 0 , # [ doc = "1: Divide by 2" ] _2 = 1 , # [ doc = "2: Divide by 3" ] _3 = 2 , # [ doc = "3: Divide by 4" ] _4 = 3 , # [ doc = "4: Divide by 5" ] _5 = 4 , # [ doc = "5: Divide by 6" ] _6 = 5 , # [ doc = "6: Divide by 7" ] _7 = 6 , # [ doc = "7: Divide by 8" ] _8 = 7 } impl From < TBIDEX_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBIDEX_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBIDEX`" ] pub type TBIDEX_R = crate :: R < u8 , TBIDEX_A > ; impl TBIDEX_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIDEX_A { match self . bits { 0 => TBIDEX_A :: _1 , 1 => TBIDEX_A :: _2 , 2 => TBIDEX_A :: _3 , 3 => TBIDEX_A :: _4 , 4 => TBIDEX_A :: _5 , 5 => TBIDEX_A :: _6 , 6 => TBIDEX_A :: _7 , 7 => TBIDEX_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == TBIDEX_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == TBIDEX_A :: _2 } # [ doc = "Checks if the value of the field is `_3`" ] # [ inline ( always ) ] pub fn is_3 ( & self ) -> bool { * self == TBIDEX_A :: _3 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == TBIDEX_A :: _4 } # [ doc = "Checks if the value of the field is `_5`" ] # [ inline ( always ) ] pub fn is_5 ( & self ) -> bool { * self == TBIDEX_A :: _5 } # [ doc = "Checks if the value of the field is `_6`" ] # [ inline ( always ) ] pub fn is_6 ( & self ) -> bool { * self == TBIDEX_A :: _6 } # [ doc = "Checks if the value of the field is `_7`" ] # [ inline ( always ) ] pub fn is_7 ( & self ) -> bool { * self == TBIDEX_A :: _7 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == TBIDEX_A :: _8 } }
# [ doc = "Write proxy for field `TBIDEX`" ] pub struct TBIDEX_W < 'a > { w : & 'a mut W , } impl < 'a > TBIDEX_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIDEX_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Divide by 1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _1 ) } # [ doc = "Divide by 2" ] # [ inline ( always ) ] pub fn _2 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _2 ) } # [ doc = "Divide by 3" ] # [ inline ( always ) ] pub fn _3 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _3 ) } # [ doc = "Divide by 4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _4 ) } # [ doc = "Divide by 5" ] # [ inline ( always ) ] pub fn _5 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _5 ) } # [ doc = "Divide by 6" ] # [ inline ( always ) ] pub fn _6 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _6 ) } # [ doc = "Divide by 7" ] # [ inline ( always ) ] pub fn _7 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _7 ) } # [ doc = "Divide by 8" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u16 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Input divider expansion" ] # [ inline ( always ) ] pub fn tbidex ( & self ) -> TBIDEX_R { TBIDEX_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Input divider expansion" ] # [ inline ( always ) ] pub fn tbidex ( & mut self ) -> TBIDEX_W { TBIDEX_W { w : self } }
}
}
# [ doc = "Timer_Bx Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb2iv](tb2iv) module" ] pub type TB2IV = crate :: Reg < u16 , _TB2IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB2IV ;
# [ doc = "`read()` method returns [tb2iv::R](tb2iv::R) reader structure" ] impl crate :: Readable for TB2IV { }
# [ doc = "Timer_Bx Interrupt Vector Register" ] pub mod tb2iv {
# [ doc = "Reader of register TB2IV" ] pub type R = crate :: R < u16 , super :: TB2IV > ;
# [ doc = "Timer_B interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum TBIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Capture/compare 1; Interrupt Flag: TBxCCR1 CCIFG; Interrupt Priority: Highest" ] TBCCR1 = 2 , # [ doc = "4: Interrupt Source: Capture/compare 2; Interrupt Flag: TBxCCR2 CCIFG" ] TBCCR2 = 4 , # [ doc = "6: Interrupt Source: Capture/compare 3; Interrupt Flag: TBxCCR3 CCIFG" ] TBCCR3 = 6 , # [ doc = "8: Interrupt Source: Capture/compare 4; Interrupt Flag: TBxCCR4 CCIFG" ] TBCCR4 = 8 , # [ doc = "10: Interrupt Source: Capture/compare 5; Interrupt Flag: TBxCCR5 CCIFG" ] TBCCR5 = 10 , # [ doc = "12: Interrupt Source: Capture/compare 6; Interrupt Flag: TBxCCR6 CCIFG" ] TBCCR6 = 12 , # [ doc = "14: Interrupt Source: Timer overflow; Interrupt Flag: TBxCTL TBIFG; Interrupt Priority: Lowest" ] TBIFG = 14 } impl From < TBIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : TBIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBIV`" ] pub type TBIV_R = crate :: R < u16 , TBIV_A > ; impl TBIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , TBIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( TBIV_A :: NONE ) , 2 => Val ( TBIV_A :: TBCCR1 ) , 4 => Val ( TBIV_A :: TBCCR2 ) , 6 => Val ( TBIV_A :: TBCCR3 ) , 8 => Val ( TBIV_A :: TBCCR4 ) , 10 => Val ( TBIV_A :: TBCCR5 ) , 12 => Val ( TBIV_A :: TBCCR6 ) , 14 => Val ( TBIV_A :: TBIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == TBIV_A :: NONE } # [ doc = "Checks if the value of the field is `TBCCR1`" ] # [ inline ( always ) ] pub fn is_tbccr1 ( & self ) -> bool { * self == TBIV_A :: TBCCR1 } # [ doc = "Checks if the value of the field is `TBCCR2`" ] # [ inline ( always ) ] pub fn is_tbccr2 ( & self ) -> bool { * self == TBIV_A :: TBCCR2 } # [ doc = "Checks if the value of the field is `TBCCR3`" ] # [ inline ( always ) ] pub fn is_tbccr3 ( & self ) -> bool { * self == TBIV_A :: TBCCR3 } # [ doc = "Checks if the value of the field is `TBCCR4`" ] # [ inline ( always ) ] pub fn is_tbccr4 ( & self ) -> bool { * self == TBIV_A :: TBCCR4 } # [ doc = "Checks if the value of the field is `TBCCR5`" ] # [ inline ( always ) ] pub fn is_tbccr5 ( & self ) -> bool { * self == TBIV_A :: TBCCR5 } # [ doc = "Checks if the value of the field is `TBCCR6`" ] # [ inline ( always ) ] pub fn is_tbccr6 ( & self ) -> bool { * self == TBIV_A :: TBCCR6 } # [ doc = "Checks if the value of the field is `TBIFG`" ] # [ inline ( always ) ] pub fn is_tbifg ( & self ) -> bool { * self == TBIV_A :: TBIFG } }
impl R {
# [ doc = "Bits 0:15 - Timer_B interrupt vector value" ] # [ inline ( always ) ] pub fn tbiv ( & self ) -> TBIV_R { TBIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "TB3" ] pub struct TB3 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TB3 { } impl TB3 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const tb3 :: RegisterBlock { 0x0440 as * const _ } } impl Deref for TB3 { type Target = tb3 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * TB3 :: ptr ( ) } } }
# [ doc = "TB3" ] pub mod tb3 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Timer_B Control Register" ] pub tb3ctl : TB3CTL , # [ doc = "0x02 - Timer_B Capture/Compare Control Register" ] pub tb3cctl0 : TB3CCTL0 , # [ doc = "0x04 - Timer_B Capture/Compare Control Register" ] pub tb3cctl1 : TB3CCTL1 , # [ doc = "0x06 - Timer_B Capture/Compare Control Register" ] pub tb3cctl2 : TB3CCTL2 , # [ doc = "0x08 - Timer_B Capture/Compare Control Register" ] pub tb3cctl3 : TB3CCTL3 , # [ doc = "0x0a - Timer_B Capture/Compare Control Register" ] pub tb3cctl4 : TB3CCTL4 , # [ doc = "0x0c - Timer_B Capture/Compare Control Register" ] pub tb3cctl5 : TB3CCTL5 , # [ doc = "0x0e - Timer_B Capture/Compare Control Register" ] pub tb3cctl6 : TB3CCTL6 , # [ doc = "0x10 - Timer_B count register" ] pub tb3r : TB3R , # [ doc = "0x12 - Timer_B Capture/Compare Register" ] pub tb3ccr0 : TB3CCR0 , # [ doc = "0x14 - Timer_B Capture/Compare Register" ] pub tb3ccr1 : TB3CCR1 , # [ doc = "0x16 - Timer_B Capture/Compare Register" ] pub tb3ccr2 : TB3CCR2 , # [ doc = "0x18 - Timer_B Capture/Compare Register" ] pub tb3ccr3 : TB3CCR3 , # [ doc = "0x1a - Timer_B Capture/Compare Register" ] pub tb3ccr4 : TB3CCR4 , # [ doc = "0x1c - Timer_B Capture/Compare Register" ] pub tb3ccr5 : TB3CCR5 , # [ doc = "0x1e - Timer_B Capture/Compare Register" ] pub tb3ccr6 : TB3CCR6 , # [ doc = "0x20 - Timer_Bx Expansion Register 0" ] pub tb3ex0 : TB3EX0 , _reserved17 : [ u8 ; 12usize ] , # [ doc = "0x2e - Timer_Bx Interrupt Vector Register" ] pub tb3iv : TB3IV , }
# [ doc = "Timer_B Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3ctl](tb3ctl) module" ] pub type TB3CTL = crate :: Reg < u16 , _TB3CTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CTL ;
# [ doc = "`read()` method returns [tb3ctl::R](tb3ctl::R) reader structure" ] impl crate :: Readable for TB3CTL { }
# [ doc = "`write(|w| ..)` method takes [tb3ctl::W](tb3ctl::W) writer structure" ] impl crate :: Writable for TB3CTL { }
# [ doc = "Timer_B Control Register" ] pub mod tb3ctl {
# [ doc = "Reader of register TB3CTL" ] pub type R = crate :: R < u16 , super :: TB3CTL > ;
# [ doc = "Writer for register TB3CTL" ] pub type W = crate :: W < u16 , super :: TB3CTL > ;
# [ doc = "Register TB3CTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "TimerB interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TBIFG_A { # [ doc = "0: No interrupt pending" ] TBIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] TBIFG_1 = 1 } impl From < TBIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : TBIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `TBIFG`" ] pub type TBIFG_R = crate :: R < bool , TBIFG_A > ; impl TBIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIFG_A { match self . bits { false => TBIFG_A :: TBIFG_0 , true => TBIFG_A :: TBIFG_1 } } # [ doc = "Checks if the value of the field is `TBIFG_0`" ] # [ inline ( always ) ] pub fn is_tbifg_0 ( & self ) -> bool { * self == TBIFG_A :: TBIFG_0 } # [ doc = "Checks if the value of the field is `TBIFG_1`" ] # [ inline ( always ) ] pub fn is_tbifg_1 ( & self ) -> bool { * self == TBIFG_A :: TBIFG_1 } }
# [ doc = "Write proxy for field `TBIFG`" ] pub struct TBIFG_W < 'a > { w : & 'a mut W , } impl < 'a > TBIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn tbifg_0 ( self ) -> & 'a mut W { self . variant ( TBIFG_A :: TBIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn tbifg_1 ( self ) -> & 'a mut W { self . variant ( TBIFG_A :: TBIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "TimerB interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TBIE_A { # [ doc = "0: Interrupt disabled" ] TBIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] TBIE_1 = 1 } impl From < TBIE_A > for bool { # [ inline ( always ) ] fn from ( variant : TBIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `TBIE`" ] pub type TBIE_R = crate :: R < bool , TBIE_A > ; impl TBIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIE_A { match self . bits { false => TBIE_A :: TBIE_0 , true => TBIE_A :: TBIE_1 } } # [ doc = "Checks if the value of the field is `TBIE_0`" ] # [ inline ( always ) ] pub fn is_tbie_0 ( & self ) -> bool { * self == TBIE_A :: TBIE_0 } # [ doc = "Checks if the value of the field is `TBIE_1`" ] # [ inline ( always ) ] pub fn is_tbie_1 ( & self ) -> bool { * self == TBIE_A :: TBIE_1 } }
# [ doc = "Write proxy for field `TBIE`" ] pub struct TBIE_W < 'a > { w : & 'a mut W , } impl < 'a > TBIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn tbie_0 ( self ) -> & 'a mut W { self . variant ( TBIE_A :: TBIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn tbie_1 ( self ) -> & 'a mut W { self . variant ( TBIE_A :: TBIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `TBCLR`" ] pub type TBCLR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TBCLR`" ] pub struct TBCLR_W < 'a > { w : & 'a mut W , } impl < 'a > TBCLR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Mode control\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum MC_A { # [ doc = "0: Stop mode: Timer is halted" ] STOP = 0 , # [ doc = "1: Up mode: Timer counts up to TBxCL0" ] UP = 1 , # [ doc = "2: Continuous mode: Timer counts up to the value set by CNTL" ] CONTINUOUS = 2 , # [ doc = "3: Up/down mode: Timer counts up to TBxCL0 then down to 0000h" ] UPDOWN = 3 } impl From < MC_A > for u8 { # [ inline ( always ) ] fn from ( variant : MC_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `MC`" ] pub type MC_R = crate :: R < u8 , MC_A > ; impl MC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MC_A { match self . bits { 0 => MC_A :: STOP , 1 => MC_A :: UP , 2 => MC_A :: CONTINUOUS , 3 => MC_A :: UPDOWN , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `STOP`" ] # [ inline ( always ) ] pub fn is_stop ( & self ) -> bool { * self == MC_A :: STOP } # [ doc = "Checks if the value of the field is `UP`" ] # [ inline ( always ) ] pub fn is_up ( & self ) -> bool { * self == MC_A :: UP } # [ doc = "Checks if the value of the field is `CONTINUOUS`" ] # [ inline ( always ) ] pub fn is_continuous ( & self ) -> bool { * self == MC_A :: CONTINUOUS } # [ doc = "Checks if the value of the field is `UPDOWN`" ] # [ inline ( always ) ] pub fn is_updown ( & self ) -> bool { * self == MC_A :: UPDOWN } }
# [ doc = "Write proxy for field `MC`" ] pub struct MC_W < 'a > { w : & 'a mut W , } impl < 'a > MC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MC_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Stop mode: Timer is halted" ] # [ inline ( always ) ] pub fn stop ( self ) -> & 'a mut W { self . variant ( MC_A :: STOP ) } # [ doc = "Up mode: Timer counts up to TBxCL0" ] # [ inline ( always ) ] pub fn up ( self ) -> & 'a mut W { self . variant ( MC_A :: UP ) } # [ doc = "Continuous mode: Timer counts up to the value set by CNTL" ] # [ inline ( always ) ] pub fn continuous ( self ) -> & 'a mut W { self . variant ( MC_A :: CONTINUOUS ) } # [ doc = "Up/down mode: Timer counts up to TBxCL0 then down to 0000h" ] # [ inline ( always ) ] pub fn updown ( self ) -> & 'a mut W { self . variant ( MC_A :: UPDOWN ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Input divider\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ID_A { # [ doc = "0: /1" ] _1 = 0 , # [ doc = "1: /2" ] _2 = 1 , # [ doc = "2: /4" ] _4 = 2 , # [ doc = "3: /8" ] _8 = 3 } impl From < ID_A > for u8 { # [ inline ( always ) ] fn from ( variant : ID_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ID`" ] pub type ID_R = crate :: R < u8 , ID_A > ; impl ID_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ID_A { match self . bits { 0 => ID_A :: _1 , 1 => ID_A :: _2 , 2 => ID_A :: _4 , 3 => ID_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == ID_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == ID_A :: _2 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == ID_A :: _4 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == ID_A :: _8 } }
# [ doc = "Write proxy for field `ID`" ] pub struct ID_W < 'a > { w : & 'a mut W , } impl < 'a > ID_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ID_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "/1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( ID_A :: _1 ) } # [ doc = "/2" ] # [ inline ( always ) ] pub fn _2 ( self ) -> & 'a mut W { self . variant ( ID_A :: _2 ) } # [ doc = "/4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( ID_A :: _4 ) } # [ doc = "/8" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( ID_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "TimerB clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBSSEL_A { # [ doc = "0: TBxCLK" ] TBCLK = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: INCLK" ] INCLK = 3 } impl From < TBSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBSSEL`" ] pub type TBSSEL_R = crate :: R < u8 , TBSSEL_A > ; impl TBSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBSSEL_A { match self . bits { 0 => TBSSEL_A :: TBCLK , 1 => TBSSEL_A :: ACLK , 2 => TBSSEL_A :: SMCLK , 3 => TBSSEL_A :: INCLK , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `TBCLK`" ] # [ inline ( always ) ] pub fn is_tbclk ( & self ) -> bool { * self == TBSSEL_A :: TBCLK } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == TBSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == TBSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `INCLK`" ] # [ inline ( always ) ] pub fn is_inclk ( & self ) -> bool { * self == TBSSEL_A :: INCLK } }
# [ doc = "Write proxy for field `TBSSEL`" ] pub struct TBSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > TBSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLK" ] # [ inline ( always ) ] pub fn tbclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: TBCLK ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: SMCLK ) } # [ doc = "INCLK" ] # [ inline ( always ) ] pub fn inclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: INCLK ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Counter length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CNTL_A { # [ doc = "0: 16-bit, TBxR(max) = 0FFFFh" ] _16 = 0 , # [ doc = "1: 12-bit, TBxR(max) = 0FFFh" ] _12 = 1 , # [ doc = "2: 10-bit, TBxR(max) = 03FFh" ] _10 = 2 , # [ doc = "3: 8-bit, TBxR(max) = 0FFh" ] _8 = 3 } impl From < CNTL_A > for u8 { # [ inline ( always ) ] fn from ( variant : CNTL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CNTL`" ] pub type CNTL_R = crate :: R < u8 , CNTL_A > ; impl CNTL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CNTL_A { match self . bits { 0 => CNTL_A :: _16 , 1 => CNTL_A :: _12 , 2 => CNTL_A :: _10 , 3 => CNTL_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_16`" ] # [ inline ( always ) ] pub fn is_16 ( & self ) -> bool { * self == CNTL_A :: _16 } # [ doc = "Checks if the value of the field is `_12`" ] # [ inline ( always ) ] pub fn is_12 ( & self ) -> bool { * self == CNTL_A :: _12 } # [ doc = "Checks if the value of the field is `_10`" ] # [ inline ( always ) ] pub fn is_10 ( & self ) -> bool { * self == CNTL_A :: _10 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == CNTL_A :: _8 } }
# [ doc = "Write proxy for field `CNTL`" ] pub struct CNTL_W < 'a > { w : & 'a mut W , } impl < 'a > CNTL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CNTL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "16-bit, TBxR(max) = 0FFFFh" ] # [ inline ( always ) ] pub fn _16 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _16 ) } # [ doc = "12-bit, TBxR(max) = 0FFFh" ] # [ inline ( always ) ] pub fn _12 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _12 ) } # [ doc = "10-bit, TBxR(max) = 03FFh" ] # [ inline ( always ) ] pub fn _10 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _10 ) } # [ doc = "8-bit, TBxR(max) = 0FFh" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 11 ) ) | ( ( ( value as u16 ) & 0x03 ) << 11 ) ; self . w } }
# [ doc = "TBxCLn group\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBCLGRP_A { # [ doc = "0: Each TBxCLn latch loads independently" ] TBCLGRP_0 = 0 , # [ doc = "1: TBxCL1+TBxCL2 (TBxCCR1 CLLD bits control the update); TBxCL3+TBxCL4 (TBxCCR3 CLLD bits control the update); TBxCL5+TBxCL6 (TBxCCR5 CLLD bits control the update); TBxCL0 independent" ] TBCLGRP_1 = 1 , # [ doc = "2: TBxCL1+TBxCL2+TBxCL3 (TBxCCR1 CLLD bits control the update); TBxCL4+TBxCL5+TBxCL6 (TBxCCR4 CLLD bits control the update); TBxCL0 independent" ] TBCLGRP_2 = 2 , # [ doc = "3: TBxCL0+TBxCL1+TBxCL2+TBxCL3+TBxCL4+TBxCL5+TBxCL6 (TBxCCR1 CLLD bits control the update)" ] TBCLGRP_3 = 3 } impl From < TBCLGRP_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBCLGRP_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBCLGRP`" ] pub type TBCLGRP_R = crate :: R < u8 , TBCLGRP_A > ; impl TBCLGRP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBCLGRP_A { match self . bits { 0 => TBCLGRP_A :: TBCLGRP_0 , 1 => TBCLGRP_A :: TBCLGRP_1 , 2 => TBCLGRP_A :: TBCLGRP_2 , 3 => TBCLGRP_A :: TBCLGRP_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `TBCLGRP_0`" ] # [ inline ( always ) ] pub fn is_tbclgrp_0 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_0 } # [ doc = "Checks if the value of the field is `TBCLGRP_1`" ] # [ inline ( always ) ] pub fn is_tbclgrp_1 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_1 } # [ doc = "Checks if the value of the field is `TBCLGRP_2`" ] # [ inline ( always ) ] pub fn is_tbclgrp_2 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_2 } # [ doc = "Checks if the value of the field is `TBCLGRP_3`" ] # [ inline ( always ) ] pub fn is_tbclgrp_3 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_3 } }
# [ doc = "Write proxy for field `TBCLGRP`" ] pub struct TBCLGRP_W < 'a > { w : & 'a mut W , } impl < 'a > TBCLGRP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBCLGRP_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Each TBxCLn latch loads independently" ] # [ inline ( always ) ] pub fn tbclgrp_0 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_0 ) } # [ doc = "TBxCL1+TBxCL2 (TBxCCR1 CLLD bits control the update); TBxCL3+TBxCL4 (TBxCCR3 CLLD bits control the update); TBxCL5+TBxCL6 (TBxCCR5 CLLD bits control the update); TBxCL0 independent" ] # [ inline ( always ) ] pub fn tbclgrp_1 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_1 ) } # [ doc = "TBxCL1+TBxCL2+TBxCL3 (TBxCCR1 CLLD bits control the update); TBxCL4+TBxCL5+TBxCL6 (TBxCCR4 CLLD bits control the update); TBxCL0 independent" ] # [ inline ( always ) ] pub fn tbclgrp_2 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_2 ) } # [ doc = "TBxCL0+TBxCL1+TBxCL2+TBxCL3+TBxCL4+TBxCL5+TBxCL6 (TBxCCR1 CLLD bits control the update)" ] # [ inline ( always ) ] pub fn tbclgrp_3 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 13 ) ) | ( ( ( value as u16 ) & 0x03 ) << 13 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - TimerB interrupt flag" ] # [ inline ( always ) ] pub fn tbifg ( & self ) -> TBIFG_R { TBIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - TimerB interrupt enable" ] # [ inline ( always ) ] pub fn tbie ( & self ) -> TBIE_R { TBIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - TimerB clear" ] # [ inline ( always ) ] pub fn tbclr ( & self ) -> TBCLR_R { TBCLR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - Mode control" ] # [ inline ( always ) ] pub fn mc ( & self ) -> MC_R { MC_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 6:7 - Input divider" ] # [ inline ( always ) ] pub fn id ( & self ) -> ID_R { ID_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:9 - TimerB clock source select" ] # [ inline ( always ) ] pub fn tbssel ( & self ) -> TBSSEL_R { TBSSEL_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 11:12 - Counter length" ] # [ inline ( always ) ] pub fn cntl ( & self ) -> CNTL_R { CNTL_R :: new ( ( ( self . bits >> 11 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 13:14 - TBxCLn group" ] # [ inline ( always ) ] pub fn tbclgrp ( & self ) -> TBCLGRP_R { TBCLGRP_R :: new ( ( ( self . bits >> 13 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - TimerB interrupt flag" ] # [ inline ( always ) ] pub fn tbifg ( & mut self ) -> TBIFG_W { TBIFG_W { w : self } }
# [ doc = "Bit 1 - TimerB interrupt enable" ] # [ inline ( always ) ] pub fn tbie ( & mut self ) -> TBIE_W { TBIE_W { w : self } }
# [ doc = "Bit 2 - TimerB clear" ] # [ inline ( always ) ] pub fn tbclr ( & mut self ) -> TBCLR_W { TBCLR_W { w : self } }
# [ doc = "Bits 4:5 - Mode control" ] # [ inline ( always ) ] pub fn mc ( & mut self ) -> MC_W { MC_W { w : self } }
# [ doc = "Bits 6:7 - Input divider" ] # [ inline ( always ) ] pub fn id ( & mut self ) -> ID_W { ID_W { w : self } }
# [ doc = "Bits 8:9 - TimerB clock source select" ] # [ inline ( always ) ] pub fn tbssel ( & mut self ) -> TBSSEL_W { TBSSEL_W { w : self } }
# [ doc = "Bits 11:12 - Counter length" ] # [ inline ( always ) ] pub fn cntl ( & mut self ) -> CNTL_W { CNTL_W { w : self } }
# [ doc = "Bits 13:14 - TBxCLn group" ] # [ inline ( always ) ] pub fn tbclgrp ( & mut self ) -> TBCLGRP_W { TBCLGRP_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3cctl0](tb3cctl0) module" ] pub type TB3CCTL0 = crate :: Reg < u16 , _TB3CCTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCTL0 ;
# [ doc = "`read()` method returns [tb3cctl0::R](tb3cctl0::R) reader structure" ] impl crate :: Readable for TB3CCTL0 { }
# [ doc = "`write(|w| ..)` method takes [tb3cctl0::W](tb3cctl0::W) writer structure" ] impl crate :: Writable for TB3CCTL0 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb3cctl0 {
# [ doc = "Reader of register TB3CCTL0" ] pub type R = crate :: R < u16 , super :: TB3CCTL0 > ;
# [ doc = "Writer for register TB3CCTL0" ] pub type W = crate :: W < u16 , super :: TB3CCTL0 > ;
# [ doc = "Register TB3CCTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3cctl1](tb3cctl1) module" ] pub type TB3CCTL1 = crate :: Reg < u16 , _TB3CCTL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCTL1 ;
# [ doc = "`read()` method returns [tb3cctl1::R](tb3cctl1::R) reader structure" ] impl crate :: Readable for TB3CCTL1 { }
# [ doc = "`write(|w| ..)` method takes [tb3cctl1::W](tb3cctl1::W) writer structure" ] impl crate :: Writable for TB3CCTL1 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb3cctl1 {
# [ doc = "Reader of register TB3CCTL1" ] pub type R = crate :: R < u16 , super :: TB3CCTL1 > ;
# [ doc = "Writer for register TB3CCTL1" ] pub type W = crate :: W < u16 , super :: TB3CCTL1 > ;
# [ doc = "Register TB3CCTL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCTL1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3cctl2](tb3cctl2) module" ] pub type TB3CCTL2 = crate :: Reg < u16 , _TB3CCTL2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCTL2 ;
# [ doc = "`read()` method returns [tb3cctl2::R](tb3cctl2::R) reader structure" ] impl crate :: Readable for TB3CCTL2 { }
# [ doc = "`write(|w| ..)` method takes [tb3cctl2::W](tb3cctl2::W) writer structure" ] impl crate :: Writable for TB3CCTL2 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb3cctl2 {
# [ doc = "Reader of register TB3CCTL2" ] pub type R = crate :: R < u16 , super :: TB3CCTL2 > ;
# [ doc = "Writer for register TB3CCTL2" ] pub type W = crate :: W < u16 , super :: TB3CCTL2 > ;
# [ doc = "Register TB3CCTL2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCTL2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3cctl3](tb3cctl3) module" ] pub type TB3CCTL3 = crate :: Reg < u16 , _TB3CCTL3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCTL3 ;
# [ doc = "`read()` method returns [tb3cctl3::R](tb3cctl3::R) reader structure" ] impl crate :: Readable for TB3CCTL3 { }
# [ doc = "`write(|w| ..)` method takes [tb3cctl3::W](tb3cctl3::W) writer structure" ] impl crate :: Writable for TB3CCTL3 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb3cctl3 {
# [ doc = "Reader of register TB3CCTL3" ] pub type R = crate :: R < u16 , super :: TB3CCTL3 > ;
# [ doc = "Writer for register TB3CCTL3" ] pub type W = crate :: W < u16 , super :: TB3CCTL3 > ;
# [ doc = "Register TB3CCTL3 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCTL3 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3cctl4](tb3cctl4) module" ] pub type TB3CCTL4 = crate :: Reg < u16 , _TB3CCTL4 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCTL4 ;
# [ doc = "`read()` method returns [tb3cctl4::R](tb3cctl4::R) reader structure" ] impl crate :: Readable for TB3CCTL4 { }
# [ doc = "`write(|w| ..)` method takes [tb3cctl4::W](tb3cctl4::W) writer structure" ] impl crate :: Writable for TB3CCTL4 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb3cctl4 {
# [ doc = "Reader of register TB3CCTL4" ] pub type R = crate :: R < u16 , super :: TB3CCTL4 > ;
# [ doc = "Writer for register TB3CCTL4" ] pub type W = crate :: W < u16 , super :: TB3CCTL4 > ;
# [ doc = "Register TB3CCTL4 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCTL4 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3cctl5](tb3cctl5) module" ] pub type TB3CCTL5 = crate :: Reg < u16 , _TB3CCTL5 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCTL5 ;
# [ doc = "`read()` method returns [tb3cctl5::R](tb3cctl5::R) reader structure" ] impl crate :: Readable for TB3CCTL5 { }
# [ doc = "`write(|w| ..)` method takes [tb3cctl5::W](tb3cctl5::W) writer structure" ] impl crate :: Writable for TB3CCTL5 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb3cctl5 {
# [ doc = "Reader of register TB3CCTL5" ] pub type R = crate :: R < u16 , super :: TB3CCTL5 > ;
# [ doc = "Writer for register TB3CCTL5" ] pub type W = crate :: W < u16 , super :: TB3CCTL5 > ;
# [ doc = "Register TB3CCTL5 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCTL5 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3cctl6](tb3cctl6) module" ] pub type TB3CCTL6 = crate :: Reg < u16 , _TB3CCTL6 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCTL6 ;
# [ doc = "`read()` method returns [tb3cctl6::R](tb3cctl6::R) reader structure" ] impl crate :: Readable for TB3CCTL6 { }
# [ doc = "`write(|w| ..)` method takes [tb3cctl6::W](tb3cctl6::W) writer structure" ] impl crate :: Writable for TB3CCTL6 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb3cctl6 {
# [ doc = "Reader of register TB3CCTL6" ] pub type R = crate :: R < u16 , super :: TB3CCTL6 > ;
# [ doc = "Writer for register TB3CCTL6" ] pub type W = crate :: W < u16 , super :: TB3CCTL6 > ;
# [ doc = "Register TB3CCTL6 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCTL6 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B count register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3r](tb3r) module" ] pub type TB3R = crate :: Reg < u16 , _TB3R > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3R ;
# [ doc = "`read()` method returns [tb3r::R](tb3r::R) reader structure" ] impl crate :: Readable for TB3R { }
# [ doc = "`write(|w| ..)` method takes [tb3r::W](tb3r::W) writer structure" ] impl crate :: Writable for TB3R { }
# [ doc = "Timer_B count register" ] pub mod tb3r {
# [ doc = "Reader of register TB3R" ] pub type R = crate :: R < u16 , super :: TB3R > ;
# [ doc = "Writer for register TB3R" ] pub type W = crate :: W < u16 , super :: TB3R > ;
# [ doc = "Register TB3R `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3R { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3ccr0](tb3ccr0) module" ] pub type TB3CCR0 = crate :: Reg < u16 , _TB3CCR0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCR0 ;
# [ doc = "`read()` method returns [tb3ccr0::R](tb3ccr0::R) reader structure" ] impl crate :: Readable for TB3CCR0 { }
# [ doc = "`write(|w| ..)` method takes [tb3ccr0::W](tb3ccr0::W) writer structure" ] impl crate :: Writable for TB3CCR0 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb3ccr0 {
# [ doc = "Reader of register TB3CCR0" ] pub type R = crate :: R < u16 , super :: TB3CCR0 > ;
# [ doc = "Writer for register TB3CCR0" ] pub type W = crate :: W < u16 , super :: TB3CCR0 > ;
# [ doc = "Register TB3CCR0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCR0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3ccr1](tb3ccr1) module" ] pub type TB3CCR1 = crate :: Reg < u16 , _TB3CCR1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCR1 ;
# [ doc = "`read()` method returns [tb3ccr1::R](tb3ccr1::R) reader structure" ] impl crate :: Readable for TB3CCR1 { }
# [ doc = "`write(|w| ..)` method takes [tb3ccr1::W](tb3ccr1::W) writer structure" ] impl crate :: Writable for TB3CCR1 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb3ccr1 {
# [ doc = "Reader of register TB3CCR1" ] pub type R = crate :: R < u16 , super :: TB3CCR1 > ;
# [ doc = "Writer for register TB3CCR1" ] pub type W = crate :: W < u16 , super :: TB3CCR1 > ;
# [ doc = "Register TB3CCR1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCR1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3ccr2](tb3ccr2) module" ] pub type TB3CCR2 = crate :: Reg < u16 , _TB3CCR2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCR2 ;
# [ doc = "`read()` method returns [tb3ccr2::R](tb3ccr2::R) reader structure" ] impl crate :: Readable for TB3CCR2 { }
# [ doc = "`write(|w| ..)` method takes [tb3ccr2::W](tb3ccr2::W) writer structure" ] impl crate :: Writable for TB3CCR2 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb3ccr2 {
# [ doc = "Reader of register TB3CCR2" ] pub type R = crate :: R < u16 , super :: TB3CCR2 > ;
# [ doc = "Writer for register TB3CCR2" ] pub type W = crate :: W < u16 , super :: TB3CCR2 > ;
# [ doc = "Register TB3CCR2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCR2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3ccr3](tb3ccr3) module" ] pub type TB3CCR3 = crate :: Reg < u16 , _TB3CCR3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCR3 ;
# [ doc = "`read()` method returns [tb3ccr3::R](tb3ccr3::R) reader structure" ] impl crate :: Readable for TB3CCR3 { }
# [ doc = "`write(|w| ..)` method takes [tb3ccr3::W](tb3ccr3::W) writer structure" ] impl crate :: Writable for TB3CCR3 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb3ccr3 {
# [ doc = "Reader of register TB3CCR3" ] pub type R = crate :: R < u16 , super :: TB3CCR3 > ;
# [ doc = "Writer for register TB3CCR3" ] pub type W = crate :: W < u16 , super :: TB3CCR3 > ;
# [ doc = "Register TB3CCR3 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCR3 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3ccr4](tb3ccr4) module" ] pub type TB3CCR4 = crate :: Reg < u16 , _TB3CCR4 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCR4 ;
# [ doc = "`read()` method returns [tb3ccr4::R](tb3ccr4::R) reader structure" ] impl crate :: Readable for TB3CCR4 { }
# [ doc = "`write(|w| ..)` method takes [tb3ccr4::W](tb3ccr4::W) writer structure" ] impl crate :: Writable for TB3CCR4 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb3ccr4 {
# [ doc = "Reader of register TB3CCR4" ] pub type R = crate :: R < u16 , super :: TB3CCR4 > ;
# [ doc = "Writer for register TB3CCR4" ] pub type W = crate :: W < u16 , super :: TB3CCR4 > ;
# [ doc = "Register TB3CCR4 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCR4 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3ccr5](tb3ccr5) module" ] pub type TB3CCR5 = crate :: Reg < u16 , _TB3CCR5 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCR5 ;
# [ doc = "`read()` method returns [tb3ccr5::R](tb3ccr5::R) reader structure" ] impl crate :: Readable for TB3CCR5 { }
# [ doc = "`write(|w| ..)` method takes [tb3ccr5::W](tb3ccr5::W) writer structure" ] impl crate :: Writable for TB3CCR5 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb3ccr5 {
# [ doc = "Reader of register TB3CCR5" ] pub type R = crate :: R < u16 , super :: TB3CCR5 > ;
# [ doc = "Writer for register TB3CCR5" ] pub type W = crate :: W < u16 , super :: TB3CCR5 > ;
# [ doc = "Register TB3CCR5 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCR5 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3ccr6](tb3ccr6) module" ] pub type TB3CCR6 = crate :: Reg < u16 , _TB3CCR6 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCR6 ;
# [ doc = "`read()` method returns [tb3ccr6::R](tb3ccr6::R) reader structure" ] impl crate :: Readable for TB3CCR6 { }
# [ doc = "`write(|w| ..)` method takes [tb3ccr6::W](tb3ccr6::W) writer structure" ] impl crate :: Writable for TB3CCR6 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb3ccr6 {
# [ doc = "Reader of register TB3CCR6" ] pub type R = crate :: R < u16 , super :: TB3CCR6 > ;
# [ doc = "Writer for register TB3CCR6" ] pub type W = crate :: W < u16 , super :: TB3CCR6 > ;
# [ doc = "Register TB3CCR6 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCR6 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_Bx Expansion Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3ex0](tb3ex0) module" ] pub type TB3EX0 = crate :: Reg < u16 , _TB3EX0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3EX0 ;
# [ doc = "`read()` method returns [tb3ex0::R](tb3ex0::R) reader structure" ] impl crate :: Readable for TB3EX0 { }
# [ doc = "`write(|w| ..)` method takes [tb3ex0::W](tb3ex0::W) writer structure" ] impl crate :: Writable for TB3EX0 { }
# [ doc = "Timer_Bx Expansion Register 0" ] pub mod tb3ex0 {
# [ doc = "Reader of register TB3EX0" ] pub type R = crate :: R < u16 , super :: TB3EX0 > ;
# [ doc = "Writer for register TB3EX0" ] pub type W = crate :: W < u16 , super :: TB3EX0 > ;
# [ doc = "Register TB3EX0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3EX0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Input divider expansion\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBIDEX_A { # [ doc = "0: Divide by 1" ] _1 = 0 , # [ doc = "1: Divide by 2" ] _2 = 1 , # [ doc = "2: Divide by 3" ] _3 = 2 , # [ doc = "3: Divide by 4" ] _4 = 3 , # [ doc = "4: Divide by 5" ] _5 = 4 , # [ doc = "5: Divide by 6" ] _6 = 5 , # [ doc = "6: Divide by 7" ] _7 = 6 , # [ doc = "7: Divide by 8" ] _8 = 7 } impl From < TBIDEX_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBIDEX_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBIDEX`" ] pub type TBIDEX_R = crate :: R < u8 , TBIDEX_A > ; impl TBIDEX_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIDEX_A { match self . bits { 0 => TBIDEX_A :: _1 , 1 => TBIDEX_A :: _2 , 2 => TBIDEX_A :: _3 , 3 => TBIDEX_A :: _4 , 4 => TBIDEX_A :: _5 , 5 => TBIDEX_A :: _6 , 6 => TBIDEX_A :: _7 , 7 => TBIDEX_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == TBIDEX_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == TBIDEX_A :: _2 } # [ doc = "Checks if the value of the field is `_3`" ] # [ inline ( always ) ] pub fn is_3 ( & self ) -> bool { * self == TBIDEX_A :: _3 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == TBIDEX_A :: _4 } # [ doc = "Checks if the value of the field is `_5`" ] # [ inline ( always ) ] pub fn is_5 ( & self ) -> bool { * self == TBIDEX_A :: _5 } # [ doc = "Checks if the value of the field is `_6`" ] # [ inline ( always ) ] pub fn is_6 ( & self ) -> bool { * self == TBIDEX_A :: _6 } # [ doc = "Checks if the value of the field is `_7`" ] # [ inline ( always ) ] pub fn is_7 ( & self ) -> bool { * self == TBIDEX_A :: _7 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == TBIDEX_A :: _8 } }
# [ doc = "Write proxy for field `TBIDEX`" ] pub struct TBIDEX_W < 'a > { w : & 'a mut W , } impl < 'a > TBIDEX_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIDEX_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Divide by 1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _1 ) } # [ doc = "Divide by 2" ] # [ inline ( always ) ] pub fn _2 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _2 ) } # [ doc = "Divide by 3" ] # [ inline ( always ) ] pub fn _3 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _3 ) } # [ doc = "Divide by 4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _4 ) } # [ doc = "Divide by 5" ] # [ inline ( always ) ] pub fn _5 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _5 ) } # [ doc = "Divide by 6" ] # [ inline ( always ) ] pub fn _6 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _6 ) } # [ doc = "Divide by 7" ] # [ inline ( always ) ] pub fn _7 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _7 ) } # [ doc = "Divide by 8" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u16 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Input divider expansion" ] # [ inline ( always ) ] pub fn tbidex ( & self ) -> TBIDEX_R { TBIDEX_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Input divider expansion" ] # [ inline ( always ) ] pub fn tbidex ( & mut self ) -> TBIDEX_W { TBIDEX_W { w : self } }
}
}
# [ doc = "Timer_Bx Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3iv](tb3iv) module" ] pub type TB3IV = crate :: Reg < u16 , _TB3IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3IV ;
# [ doc = "`read()` method returns [tb3iv::R](tb3iv::R) reader structure" ] impl crate :: Readable for TB3IV { }
# [ doc = "Timer_Bx Interrupt Vector Register" ] pub mod tb3iv {
# [ doc = "Reader of register TB3IV" ] pub type R = crate :: R < u16 , super :: TB3IV > ;
# [ doc = "Timer_B interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum TBIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Capture/compare 1; Interrupt Flag: TBxCCR1 CCIFG; Interrupt Priority: Highest" ] TBCCR1 = 2 , # [ doc = "4: Interrupt Source: Capture/compare 2; Interrupt Flag: TBxCCR2 CCIFG" ] TBCCR2 = 4 , # [ doc = "6: Interrupt Source: Capture/compare 3; Interrupt Flag: TBxCCR3 CCIFG" ] TBCCR3 = 6 , # [ doc = "8: Interrupt Source: Capture/compare 4; Interrupt Flag: TBxCCR4 CCIFG" ] TBCCR4 = 8 , # [ doc = "10: Interrupt Source: Capture/compare 5; Interrupt Flag: TBxCCR5 CCIFG" ] TBCCR5 = 10 , # [ doc = "12: Interrupt Source: Capture/compare 6; Interrupt Flag: TBxCCR6 CCIFG" ] TBCCR6 = 12 , # [ doc = "14: Interrupt Source: Timer overflow; Interrupt Flag: TBxCTL TBIFG; Interrupt Priority: Lowest" ] TBIFG = 14 } impl From < TBIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : TBIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBIV`" ] pub type TBIV_R = crate :: R < u16 , TBIV_A > ; impl TBIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , TBIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( TBIV_A :: NONE ) , 2 => Val ( TBIV_A :: TBCCR1 ) , 4 => Val ( TBIV_A :: TBCCR2 ) , 6 => Val ( TBIV_A :: TBCCR3 ) , 8 => Val ( TBIV_A :: TBCCR4 ) , 10 => Val ( TBIV_A :: TBCCR5 ) , 12 => Val ( TBIV_A :: TBCCR6 ) , 14 => Val ( TBIV_A :: TBIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == TBIV_A :: NONE } # [ doc = "Checks if the value of the field is `TBCCR1`" ] # [ inline ( always ) ] pub fn is_tbccr1 ( & self ) -> bool { * self == TBIV_A :: TBCCR1 } # [ doc = "Checks if the value of the field is `TBCCR2`" ] # [ inline ( always ) ] pub fn is_tbccr2 ( & self ) -> bool { * self == TBIV_A :: TBCCR2 } # [ doc = "Checks if the value of the field is `TBCCR3`" ] # [ inline ( always ) ] pub fn is_tbccr3 ( & self ) -> bool { * self == TBIV_A :: TBCCR3 } # [ doc = "Checks if the value of the field is `TBCCR4`" ] # [ inline ( always ) ] pub fn is_tbccr4 ( & self ) -> bool { * self == TBIV_A :: TBCCR4 } # [ doc = "Checks if the value of the field is `TBCCR5`" ] # [ inline ( always ) ] pub fn is_tbccr5 ( & self ) -> bool { * self == TBIV_A :: TBCCR5 } # [ doc = "Checks if the value of the field is `TBCCR6`" ] # [ inline ( always ) ] pub fn is_tbccr6 ( & self ) -> bool { * self == TBIV_A :: TBCCR6 } # [ doc = "Checks if the value of the field is `TBIFG`" ] # [ inline ( always ) ] pub fn is_tbifg ( & self ) -> bool { * self == TBIV_A :: TBIFG } }
impl R {
# [ doc = "Bits 0:15 - Timer_B interrupt vector value" ] # [ inline ( always ) ] pub fn tbiv ( & self ) -> TBIV_R { TBIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "MPY32" ] pub struct MPY32 { _marker : PhantomData < * const ( ) > } unsafe impl Send for MPY32 { } impl MPY32 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const mpy32 :: RegisterBlock { 0x04c0 as * const _ } } impl Deref for MPY32 { type Target = mpy32 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * MPY32 :: ptr ( ) } } }
# [ doc = "MPY32" ] pub mod mpy32 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - 16-bit operand one multiply" ] pub mpy : MPY , # [ doc = "0x02 - 16-bit operand one signed multiply" ] pub mpys : MPYS , # [ doc = "0x04 - 16-bit operand one multiply accumulate" ] pub mac : MAC , # [ doc = "0x06 - 16-bit operand one signed multiply accumulate" ] pub macs : MACS , # [ doc = "0x08 - 16-bit operand two" ] pub op2 : OP2 , # [ doc = "0x0a - 16x16-bit result low word" ] pub reslo : RESLO , # [ doc = "0x0c - 16x16-bit result high word" ] pub reshi : RESHI , # [ doc = "0x0e - 16x16-bit sum extension register" ] pub sumext : SUMEXT , # [ doc = "0x10 - 32-bit operand 1 multiply low word" ] pub mpy32l : MPY32L , # [ doc = "0x12 - 32-bit operand 1 multiply high word" ] pub mpy32h : MPY32H , # [ doc = "0x14 - 32-bit operand 1 signed multiply low word" ] pub mpys32l : MPYS32L , # [ doc = "0x16 - 32-bit operand 1 signed multiply high word" ] pub mpys32h : MPYS32H , # [ doc = "0x18 - 32-bit operand 1 multiply accumulate low word" ] pub mac32l : MAC32L , # [ doc = "0x1a - 32-bit operand 1 multiply accumulate high word" ] pub mac32h : MAC32H , # [ doc = "0x1c - 32-bit operand 1 signed multiply accumulate low word" ] pub macs32l : MACS32L , # [ doc = "0x1e - 32-bit operand 1 signed multiply accumulate high word" ] pub macs32h : MACS32H , # [ doc = "0x20 - 32-bit operand 2 low word" ] pub op2l : OP2L , # [ doc = "0x22 - 32-bit operand 2 high word" ] pub op2h : OP2H , # [ doc = "0x24 - 32x32-bit result 0 least significant word" ] pub res0 : RES0 , # [ doc = "0x26 - 32x32-bit result 1" ] pub res1 : RES1 , # [ doc = "0x28 - 32x32-bit result 2" ] pub res2 : RES2 , # [ doc = "0x2a - 32x32-bit result 3 most significant word" ] pub res3 : RES3 , # [ doc = "0x2c - MPY32 control register 0" ] pub mpy32ctl0 : MPY32CTL0 , }
# [ doc = "16-bit operand one multiply\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpy](mpy) module" ] pub type MPY = crate :: Reg < u16 , _MPY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MPY ;
# [ doc = "`read()` method returns [mpy::R](mpy::R) reader structure" ] impl crate :: Readable for MPY { }
# [ doc = "`write(|w| ..)` method takes [mpy::W](mpy::W) writer structure" ] impl crate :: Writable for MPY { }
# [ doc = "16-bit operand one multiply" ] pub mod mpy {
# [ doc = "Reader of register MPY" ] pub type R = crate :: R < u16 , super :: MPY > ;
# [ doc = "Writer for register MPY" ] pub type W = crate :: W < u16 , super :: MPY > ;
# [ doc = "Register MPY `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MPY { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "16-bit operand one signed multiply\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpys](mpys) module" ] pub type MPYS = crate :: Reg < u16 , _MPYS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MPYS ;
# [ doc = "`read()` method returns [mpys::R](mpys::R) reader structure" ] impl crate :: Readable for MPYS { }
# [ doc = "`write(|w| ..)` method takes [mpys::W](mpys::W) writer structure" ] impl crate :: Writable for MPYS { }
# [ doc = "16-bit operand one signed multiply" ] pub mod mpys {
# [ doc = "Reader of register MPYS" ] pub type R = crate :: R < u16 , super :: MPYS > ;
# [ doc = "Writer for register MPYS" ] pub type W = crate :: W < u16 , super :: MPYS > ;
# [ doc = "Register MPYS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MPYS { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "16-bit operand one multiply accumulate\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mac](mac) module" ] pub type MAC = crate :: Reg < u16 , _MAC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MAC ;
# [ doc = "`read()` method returns [mac::R](mac::R) reader structure" ] impl crate :: Readable for MAC { }
# [ doc = "`write(|w| ..)` method takes [mac::W](mac::W) writer structure" ] impl crate :: Writable for MAC { }
# [ doc = "16-bit operand one multiply accumulate" ] pub mod mac {
# [ doc = "Reader of register MAC" ] pub type R = crate :: R < u16 , super :: MAC > ;
# [ doc = "Writer for register MAC" ] pub type W = crate :: W < u16 , super :: MAC > ;
# [ doc = "Register MAC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MAC { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "16-bit operand one signed multiply accumulate\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [macs](macs) module" ] pub type MACS = crate :: Reg < u16 , _MACS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MACS ;
# [ doc = "`read()` method returns [macs::R](macs::R) reader structure" ] impl crate :: Readable for MACS { }
# [ doc = "`write(|w| ..)` method takes [macs::W](macs::W) writer structure" ] impl crate :: Writable for MACS { }
# [ doc = "16-bit operand one signed multiply accumulate" ] pub mod macs {
# [ doc = "Reader of register MACS" ] pub type R = crate :: R < u16 , super :: MACS > ;
# [ doc = "Writer for register MACS" ] pub type W = crate :: W < u16 , super :: MACS > ;
# [ doc = "Register MACS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MACS { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "16-bit operand two\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [op2](op2) module" ] pub type OP2 = crate :: Reg < u16 , _OP2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _OP2 ;
# [ doc = "`read()` method returns [op2::R](op2::R) reader structure" ] impl crate :: Readable for OP2 { }
# [ doc = "`write(|w| ..)` method takes [op2::W](op2::W) writer structure" ] impl crate :: Writable for OP2 { }
# [ doc = "16-bit operand two" ] pub mod op2 {
# [ doc = "Reader of register OP2" ] pub type R = crate :: R < u16 , super :: OP2 > ;
# [ doc = "Writer for register OP2" ] pub type W = crate :: W < u16 , super :: OP2 > ;
# [ doc = "Register OP2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: OP2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "16x16-bit result low word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [reslo](reslo) module" ] pub type RESLO = crate :: Reg < u16 , _RESLO > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RESLO ;
# [ doc = "`read()` method returns [reslo::R](reslo::R) reader structure" ] impl crate :: Readable for RESLO { }
# [ doc = "`write(|w| ..)` method takes [reslo::W](reslo::W) writer structure" ] impl crate :: Writable for RESLO { }
# [ doc = "16x16-bit result low word" ] pub mod reslo {
# [ doc = "Reader of register RESLO" ] pub type R = crate :: R < u16 , super :: RESLO > ;
# [ doc = "Writer for register RESLO" ] pub type W = crate :: W < u16 , super :: RESLO > ;
# [ doc = "Register RESLO `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RESLO { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "16x16-bit result high word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [reshi](reshi) module" ] pub type RESHI = crate :: Reg < u16 , _RESHI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RESHI ;
# [ doc = "`read()` method returns [reshi::R](reshi::R) reader structure" ] impl crate :: Readable for RESHI { }
# [ doc = "`write(|w| ..)` method takes [reshi::W](reshi::W) writer structure" ] impl crate :: Writable for RESHI { }
# [ doc = "16x16-bit result high word" ] pub mod reshi {
# [ doc = "Reader of register RESHI" ] pub type R = crate :: R < u16 , super :: RESHI > ;
# [ doc = "Writer for register RESHI" ] pub type W = crate :: W < u16 , super :: RESHI > ;
# [ doc = "Register RESHI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RESHI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "16x16-bit sum extension register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sumext](sumext) module" ] pub type SUMEXT = crate :: Reg < u16 , _SUMEXT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SUMEXT ;
# [ doc = "`read()` method returns [sumext::R](sumext::R) reader structure" ] impl crate :: Readable for SUMEXT { }
# [ doc = "`write(|w| ..)` method takes [sumext::W](sumext::W) writer structure" ] impl crate :: Writable for SUMEXT { }
# [ doc = "16x16-bit sum extension register" ] pub mod sumext {
# [ doc = "Reader of register SUMEXT" ] pub type R = crate :: R < u16 , super :: SUMEXT > ;
# [ doc = "Writer for register SUMEXT" ] pub type W = crate :: W < u16 , super :: SUMEXT > ;
# [ doc = "Register SUMEXT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SUMEXT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32-bit operand 1 multiply low word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpy32l](mpy32l) module" ] pub type MPY32L = crate :: Reg < u16 , _MPY32L > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MPY32L ;
# [ doc = "`read()` method returns [mpy32l::R](mpy32l::R) reader structure" ] impl crate :: Readable for MPY32L { }
# [ doc = "`write(|w| ..)` method takes [mpy32l::W](mpy32l::W) writer structure" ] impl crate :: Writable for MPY32L { }
# [ doc = "32-bit operand 1 multiply low word" ] pub mod mpy32l {
# [ doc = "Reader of register MPY32L" ] pub type R = crate :: R < u16 , super :: MPY32L > ;
# [ doc = "Writer for register MPY32L" ] pub type W = crate :: W < u16 , super :: MPY32L > ;
# [ doc = "Register MPY32L `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MPY32L { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32-bit operand 1 multiply high word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpy32h](mpy32h) module" ] pub type MPY32H = crate :: Reg < u16 , _MPY32H > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MPY32H ;
# [ doc = "`read()` method returns [mpy32h::R](mpy32h::R) reader structure" ] impl crate :: Readable for MPY32H { }
# [ doc = "`write(|w| ..)` method takes [mpy32h::W](mpy32h::W) writer structure" ] impl crate :: Writable for MPY32H { }
# [ doc = "32-bit operand 1 multiply high word" ] pub mod mpy32h {
# [ doc = "Reader of register MPY32H" ] pub type R = crate :: R < u16 , super :: MPY32H > ;
# [ doc = "Writer for register MPY32H" ] pub type W = crate :: W < u16 , super :: MPY32H > ;
# [ doc = "Register MPY32H `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MPY32H { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32-bit operand 1 signed multiply low word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpys32l](mpys32l) module" ] pub type MPYS32L = crate :: Reg < u16 , _MPYS32L > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MPYS32L ;
# [ doc = "`read()` method returns [mpys32l::R](mpys32l::R) reader structure" ] impl crate :: Readable for MPYS32L { }
# [ doc = "`write(|w| ..)` method takes [mpys32l::W](mpys32l::W) writer structure" ] impl crate :: Writable for MPYS32L { }
# [ doc = "32-bit operand 1 signed multiply low word" ] pub mod mpys32l {
# [ doc = "Reader of register MPYS32L" ] pub type R = crate :: R < u16 , super :: MPYS32L > ;
# [ doc = "Writer for register MPYS32L" ] pub type W = crate :: W < u16 , super :: MPYS32L > ;
# [ doc = "Register MPYS32L `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MPYS32L { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32-bit operand 1 signed multiply high word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpys32h](mpys32h) module" ] pub type MPYS32H = crate :: Reg < u16 , _MPYS32H > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MPYS32H ;
# [ doc = "`read()` method returns [mpys32h::R](mpys32h::R) reader structure" ] impl crate :: Readable for MPYS32H { }
# [ doc = "`write(|w| ..)` method takes [mpys32h::W](mpys32h::W) writer structure" ] impl crate :: Writable for MPYS32H { }
# [ doc = "32-bit operand 1 signed multiply high word" ] pub mod mpys32h {
# [ doc = "Reader of register MPYS32H" ] pub type R = crate :: R < u16 , super :: MPYS32H > ;
# [ doc = "Writer for register MPYS32H" ] pub type W = crate :: W < u16 , super :: MPYS32H > ;
# [ doc = "Register MPYS32H `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MPYS32H { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32-bit operand 1 multiply accumulate low word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mac32l](mac32l) module" ] pub type MAC32L = crate :: Reg < u16 , _MAC32L > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MAC32L ;
# [ doc = "`read()` method returns [mac32l::R](mac32l::R) reader structure" ] impl crate :: Readable for MAC32L { }
# [ doc = "`write(|w| ..)` method takes [mac32l::W](mac32l::W) writer structure" ] impl crate :: Writable for MAC32L { }
# [ doc = "32-bit operand 1 multiply accumulate low word" ] pub mod mac32l {
# [ doc = "Reader of register MAC32L" ] pub type R = crate :: R < u16 , super :: MAC32L > ;
# [ doc = "Writer for register MAC32L" ] pub type W = crate :: W < u16 , super :: MAC32L > ;
# [ doc = "Register MAC32L `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MAC32L { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32-bit operand 1 multiply accumulate high word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mac32h](mac32h) module" ] pub type MAC32H = crate :: Reg < u16 , _MAC32H > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MAC32H ;
# [ doc = "`read()` method returns [mac32h::R](mac32h::R) reader structure" ] impl crate :: Readable for MAC32H { }
# [ doc = "`write(|w| ..)` method takes [mac32h::W](mac32h::W) writer structure" ] impl crate :: Writable for MAC32H { }
# [ doc = "32-bit operand 1 multiply accumulate high word" ] pub mod mac32h {
# [ doc = "Reader of register MAC32H" ] pub type R = crate :: R < u16 , super :: MAC32H > ;
# [ doc = "Writer for register MAC32H" ] pub type W = crate :: W < u16 , super :: MAC32H > ;
# [ doc = "Register MAC32H `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MAC32H { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32-bit operand 1 signed multiply accumulate low word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [macs32l](macs32l) module" ] pub type MACS32L = crate :: Reg < u16 , _MACS32L > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MACS32L ;
# [ doc = "`read()` method returns [macs32l::R](macs32l::R) reader structure" ] impl crate :: Readable for MACS32L { }
# [ doc = "`write(|w| ..)` method takes [macs32l::W](macs32l::W) writer structure" ] impl crate :: Writable for MACS32L { }
# [ doc = "32-bit operand 1 signed multiply accumulate low word" ] pub mod macs32l {
# [ doc = "Reader of register MACS32L" ] pub type R = crate :: R < u16 , super :: MACS32L > ;
# [ doc = "Writer for register MACS32L" ] pub type W = crate :: W < u16 , super :: MACS32L > ;
# [ doc = "Register MACS32L `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MACS32L { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32-bit operand 1 signed multiply accumulate high word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [macs32h](macs32h) module" ] pub type MACS32H = crate :: Reg < u16 , _MACS32H > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MACS32H ;
# [ doc = "`read()` method returns [macs32h::R](macs32h::R) reader structure" ] impl crate :: Readable for MACS32H { }
# [ doc = "`write(|w| ..)` method takes [macs32h::W](macs32h::W) writer structure" ] impl crate :: Writable for MACS32H { }
# [ doc = "32-bit operand 1 signed multiply accumulate high word" ] pub mod macs32h {
# [ doc = "Reader of register MACS32H" ] pub type R = crate :: R < u16 , super :: MACS32H > ;
# [ doc = "Writer for register MACS32H" ] pub type W = crate :: W < u16 , super :: MACS32H > ;
# [ doc = "Register MACS32H `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MACS32H { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `MACS32H`" ] pub type MACS32H_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `MACS32H`" ] pub struct MACS32H_W < 'a > { w : & 'a mut W , } impl < 'a > MACS32H_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 8 ) ) | ( ( ( value as u16 ) & 0xff ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 8:15 - 32-bit operand 1 signed multiply accumulate high word" ] # [ inline ( always ) ] pub fn macs32h ( & self ) -> MACS32H_R { MACS32H_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 8:15 - 32-bit operand 1 signed multiply accumulate high word" ] # [ inline ( always ) ] pub fn macs32h ( & mut self ) -> MACS32H_W { MACS32H_W { w : self } }
}
}
# [ doc = "32-bit operand 2 low word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [op2l](op2l) module" ] pub type OP2L = crate :: Reg < u16 , _OP2L > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _OP2L ;
# [ doc = "`read()` method returns [op2l::R](op2l::R) reader structure" ] impl crate :: Readable for OP2L { }
# [ doc = "`write(|w| ..)` method takes [op2l::W](op2l::W) writer structure" ] impl crate :: Writable for OP2L { }
# [ doc = "32-bit operand 2 low word" ] pub mod op2l {
# [ doc = "Reader of register OP2L" ] pub type R = crate :: R < u16 , super :: OP2L > ;
# [ doc = "Writer for register OP2L" ] pub type W = crate :: W < u16 , super :: OP2L > ;
# [ doc = "Register OP2L `reset()`'s with value 0" ] impl crate :: ResetValue for super :: OP2L { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32-bit operand 2 high word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [op2h](op2h) module" ] pub type OP2H = crate :: Reg < u16 , _OP2H > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _OP2H ;
# [ doc = "`read()` method returns [op2h::R](op2h::R) reader structure" ] impl crate :: Readable for OP2H { }
# [ doc = "`write(|w| ..)` method takes [op2h::W](op2h::W) writer structure" ] impl crate :: Writable for OP2H { }
# [ doc = "32-bit operand 2 high word" ] pub mod op2h {
# [ doc = "Reader of register OP2H" ] pub type R = crate :: R < u16 , super :: OP2H > ;
# [ doc = "Writer for register OP2H" ] pub type W = crate :: W < u16 , super :: OP2H > ;
# [ doc = "Register OP2H `reset()`'s with value 0" ] impl crate :: ResetValue for super :: OP2H { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32x32-bit result 0 least significant word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [res0](res0) module" ] pub type RES0 = crate :: Reg < u16 , _RES0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RES0 ;
# [ doc = "`read()` method returns [res0::R](res0::R) reader structure" ] impl crate :: Readable for RES0 { }
# [ doc = "`write(|w| ..)` method takes [res0::W](res0::W) writer structure" ] impl crate :: Writable for RES0 { }
# [ doc = "32x32-bit result 0 least significant word" ] pub mod res0 {
# [ doc = "Reader of register RES0" ] pub type R = crate :: R < u16 , super :: RES0 > ;
# [ doc = "Writer for register RES0" ] pub type W = crate :: W < u16 , super :: RES0 > ;
# [ doc = "Register RES0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RES0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32x32-bit result 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [res1](res1) module" ] pub type RES1 = crate :: Reg < u16 , _RES1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RES1 ;
# [ doc = "`read()` method returns [res1::R](res1::R) reader structure" ] impl crate :: Readable for RES1 { }
# [ doc = "`write(|w| ..)` method takes [res1::W](res1::W) writer structure" ] impl crate :: Writable for RES1 { }
# [ doc = "32x32-bit result 1" ] pub mod res1 {
# [ doc = "Reader of register RES1" ] pub type R = crate :: R < u16 , super :: RES1 > ;
# [ doc = "Writer for register RES1" ] pub type W = crate :: W < u16 , super :: RES1 > ;
# [ doc = "Register RES1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RES1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32x32-bit result 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [res2](res2) module" ] pub type RES2 = crate :: Reg < u16 , _RES2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RES2 ;
# [ doc = "`read()` method returns [res2::R](res2::R) reader structure" ] impl crate :: Readable for RES2 { }
# [ doc = "`write(|w| ..)` method takes [res2::W](res2::W) writer structure" ] impl crate :: Writable for RES2 { }
# [ doc = "32x32-bit result 2" ] pub mod res2 {
# [ doc = "Reader of register RES2" ] pub type R = crate :: R < u16 , super :: RES2 > ;
# [ doc = "Writer for register RES2" ] pub type W = crate :: W < u16 , super :: RES2 > ;
# [ doc = "Register RES2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RES2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32x32-bit result 3 most significant word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [res3](res3) module" ] pub type RES3 = crate :: Reg < u16 , _RES3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RES3 ;
# [ doc = "`read()` method returns [res3::R](res3::R) reader structure" ] impl crate :: Readable for RES3 { }
# [ doc = "`write(|w| ..)` method takes [res3::W](res3::W) writer structure" ] impl crate :: Writable for RES3 { }
# [ doc = "32x32-bit result 3 most significant word" ] pub mod res3 {
# [ doc = "Reader of register RES3" ] pub type R = crate :: R < u16 , super :: RES3 > ;
# [ doc = "Writer for register RES3" ] pub type W = crate :: W < u16 , super :: RES3 > ;
# [ doc = "Register RES3 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RES3 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "MPY32 control register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpy32ctl0](mpy32ctl0) module" ] pub type MPY32CTL0 = crate :: Reg < u16 , _MPY32CTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MPY32CTL0 ;
# [ doc = "`read()` method returns [mpy32ctl0::R](mpy32ctl0::R) reader structure" ] impl crate :: Readable for MPY32CTL0 { }
# [ doc = "`write(|w| ..)` method takes [mpy32ctl0::W](mpy32ctl0::W) writer structure" ] impl crate :: Writable for MPY32CTL0 { }
# [ doc = "MPY32 control register 0" ] pub mod mpy32ctl0 {
# [ doc = "Reader of register MPY32CTL0" ] pub type R = crate :: R < u16 , super :: MPY32CTL0 > ;
# [ doc = "Writer for register MPY32CTL0" ] pub type W = crate :: W < u16 , super :: MPY32CTL0 > ;
# [ doc = "Register MPY32CTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MPY32CTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Delayed write mode.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MPYDLY32_A { # [ doc = "0: Writes are delayed until 64-bit result (RES0 to RES3) is available." ] MPYDLY32_0 = 0 , # [ doc = "1: Writes are delayed until 32-bit result (RES0 to RES1) is available. 8 MPYDLYWRTEN" ] MPYDLY32_1 = 1 } impl From < MPYDLY32_A > for bool { # [ inline ( always ) ] fn from ( variant : MPYDLY32_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `MPYDLY32`" ] pub type MPYDLY32_R = crate :: R < bool , MPYDLY32_A > ; impl MPYDLY32_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MPYDLY32_A { match self . bits { false => MPYDLY32_A :: MPYDLY32_0 , true => MPYDLY32_A :: MPYDLY32_1 } } # [ doc = "Checks if the value of the field is `MPYDLY32_0`" ] # [ inline ( always ) ] pub fn is_mpydly32_0 ( & self ) -> bool { * self == MPYDLY32_A :: MPYDLY32_0 } # [ doc = "Checks if the value of the field is `MPYDLY32_1`" ] # [ inline ( always ) ] pub fn is_mpydly32_1 ( & self ) -> bool { * self == MPYDLY32_A :: MPYDLY32_1 } }
# [ doc = "Write proxy for field `MPYDLY32`" ] pub struct MPYDLY32_W < 'a > { w : & 'a mut W , } impl < 'a > MPYDLY32_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MPYDLY32_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Writes are delayed until 64-bit result (RES0 to RES3) is available." ] # [ inline ( always ) ] pub fn mpydly32_0 ( self ) -> & 'a mut W { self . variant ( MPYDLY32_A :: MPYDLY32_0 ) } # [ doc = "Writes are delayed until 32-bit result (RES0 to RES1) is available. 8 MPYDLYWRTEN" ] # [ inline ( always ) ] pub fn mpydly32_1 ( self ) -> & 'a mut W { self . variant ( MPYDLY32_A :: MPYDLY32_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Delayed write enable.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MPYDLYWRTEN_A { # [ doc = "0: Writes are not delayed." ] MPYDLYWRTEN_0 = 0 , # [ doc = "1: Writes are delayed." ] MPYDLYWRTEN_1 = 1 } impl From < MPYDLYWRTEN_A > for bool { # [ inline ( always ) ] fn from ( variant : MPYDLYWRTEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `MPYDLYWRTEN`" ] pub type MPYDLYWRTEN_R = crate :: R < bool , MPYDLYWRTEN_A > ; impl MPYDLYWRTEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MPYDLYWRTEN_A { match self . bits { false => MPYDLYWRTEN_A :: MPYDLYWRTEN_0 , true => MPYDLYWRTEN_A :: MPYDLYWRTEN_1 } } # [ doc = "Checks if the value of the field is `MPYDLYWRTEN_0`" ] # [ inline ( always ) ] pub fn is_mpydlywrten_0 ( & self ) -> bool { * self == MPYDLYWRTEN_A :: MPYDLYWRTEN_0 } # [ doc = "Checks if the value of the field is `MPYDLYWRTEN_1`" ] # [ inline ( always ) ] pub fn is_mpydlywrten_1 ( & self ) -> bool { * self == MPYDLYWRTEN_A :: MPYDLYWRTEN_1 } }
# [ doc = "Write proxy for field `MPYDLYWRTEN`" ] pub struct MPYDLYWRTEN_W < 'a > { w : & 'a mut W , } impl < 'a > MPYDLYWRTEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MPYDLYWRTEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Writes are not delayed." ] # [ inline ( always ) ] pub fn mpydlywrten_0 ( self ) -> & 'a mut W { self . variant ( MPYDLYWRTEN_A :: MPYDLYWRTEN_0 ) } # [ doc = "Writes are delayed." ] # [ inline ( always ) ] pub fn mpydlywrten_1 ( self ) -> & 'a mut W { self . variant ( MPYDLYWRTEN_A :: MPYDLYWRTEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Multiplier bit width of operand 2\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MPYOP2_32_A { # [ doc = "0: 16 bits." ] _16 = 0 , # [ doc = "1: 32 bits." ] _32 = 1 } impl From < MPYOP2_32_A > for bool { # [ inline ( always ) ] fn from ( variant : MPYOP2_32_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `MPYOP2_32`" ] pub type MPYOP2_32_R = crate :: R < bool , MPYOP2_32_A > ; impl MPYOP2_32_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MPYOP2_32_A { match self . bits { false => MPYOP2_32_A :: _16 , true => MPYOP2_32_A :: _32 } } # [ doc = "Checks if the value of the field is `_16`" ] # [ inline ( always ) ] pub fn is_16 ( & self ) -> bool { * self == MPYOP2_32_A :: _16 } # [ doc = "Checks if the value of the field is `_32`" ] # [ inline ( always ) ] pub fn is_32 ( & self ) -> bool { * self == MPYOP2_32_A :: _32 } }
# [ doc = "Write proxy for field `MPYOP2_32`" ] pub struct MPYOP2_32_W < 'a > { w : & 'a mut W , } impl < 'a > MPYOP2_32_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MPYOP2_32_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "16 bits." ] # [ inline ( always ) ] pub fn _16 ( self ) -> & 'a mut W { self . variant ( MPYOP2_32_A :: _16 ) } # [ doc = "32 bits." ] # [ inline ( always ) ] pub fn _32 ( self ) -> & 'a mut W { self . variant ( MPYOP2_32_A :: _32 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Multiplier bit width of operand 1\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MPYOP1_32_A { # [ doc = "0: 16 bits." ] _16 = 0 , # [ doc = "1: 32 bits." ] _32 = 1 } impl From < MPYOP1_32_A > for bool { # [ inline ( always ) ] fn from ( variant : MPYOP1_32_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `MPYOP1_32`" ] pub type MPYOP1_32_R = crate :: R < bool , MPYOP1_32_A > ; impl MPYOP1_32_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MPYOP1_32_A { match self . bits { false => MPYOP1_32_A :: _16 , true => MPYOP1_32_A :: _32 } } # [ doc = "Checks if the value of the field is `_16`" ] # [ inline ( always ) ] pub fn is_16 ( & self ) -> bool { * self == MPYOP1_32_A :: _16 } # [ doc = "Checks if the value of the field is `_32`" ] # [ inline ( always ) ] pub fn is_32 ( & self ) -> bool { * self == MPYOP1_32_A :: _32 } }
# [ doc = "Write proxy for field `MPYOP1_32`" ] pub struct MPYOP1_32_W < 'a > { w : & 'a mut W , } impl < 'a > MPYOP1_32_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MPYOP1_32_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "16 bits." ] # [ inline ( always ) ] pub fn _16 ( self ) -> & 'a mut W { self . variant ( MPYOP1_32_A :: _16 ) } # [ doc = "32 bits." ] # [ inline ( always ) ] pub fn _32 ( self ) -> & 'a mut W { self . variant ( MPYOP1_32_A :: _32 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Multiplier mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum MPYM_A { # [ doc = "0: MPY  Multiply" ] MPY = 0 , # [ doc = "1: MPYS  Signed multiply" ] MPYS = 1 , # [ doc = "2: MAC  Multiply accumulate" ] MAC = 2 , # [ doc = "3: MACS  Signed multiply accumulate" ] MACS = 3 } impl From < MPYM_A > for u8 { # [ inline ( always ) ] fn from ( variant : MPYM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `MPYM`" ] pub type MPYM_R = crate :: R < u8 , MPYM_A > ; impl MPYM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MPYM_A { match self . bits { 0 => MPYM_A :: MPY , 1 => MPYM_A :: MPYS , 2 => MPYM_A :: MAC , 3 => MPYM_A :: MACS , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `MPY`" ] # [ inline ( always ) ] pub fn is_mpy ( & self ) -> bool { * self == MPYM_A :: MPY } # [ doc = "Checks if the value of the field is `MPYS`" ] # [ inline ( always ) ] pub fn is_mpys ( & self ) -> bool { * self == MPYM_A :: MPYS } # [ doc = "Checks if the value of the field is `MAC`" ] # [ inline ( always ) ] pub fn is_mac ( & self ) -> bool { * self == MPYM_A :: MAC } # [ doc = "Checks if the value of the field is `MACS`" ] # [ inline ( always ) ] pub fn is_macs ( & self ) -> bool { * self == MPYM_A :: MACS } }
# [ doc = "Write proxy for field `MPYM`" ] pub struct MPYM_W < 'a > { w : & 'a mut W , } impl < 'a > MPYM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MPYM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "MPY Multiply" ] # [ inline ( always ) ] pub fn mpy ( self ) -> & 'a mut W { self . variant ( MPYM_A :: MPY ) } # [ doc = "MPYS Signed multiply" ] # [ inline ( always ) ] pub fn mpys ( self ) -> & 'a mut W { self . variant ( MPYM_A :: MPYS ) } # [ doc = "MAC Multiply accumulate" ] # [ inline ( always ) ] pub fn mac ( self ) -> & 'a mut W { self . variant ( MPYM_A :: MAC ) } # [ doc = "MACS Signed multiply accumulate" ] # [ inline ( always ) ] pub fn macs ( self ) -> & 'a mut W { self . variant ( MPYM_A :: MACS ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Saturation mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MPYSAT_A { # [ doc = "0: Saturation mode disabled." ] DISABLE = 0 , # [ doc = "1: Saturation mode enabled." ] ENABLE = 1 } impl From < MPYSAT_A > for bool { # [ inline ( always ) ] fn from ( variant : MPYSAT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `MPYSAT`" ] pub type MPYSAT_R = crate :: R < bool , MPYSAT_A > ; impl MPYSAT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MPYSAT_A { match self . bits { false => MPYSAT_A :: DISABLE , true => MPYSAT_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == MPYSAT_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == MPYSAT_A :: ENABLE } }
# [ doc = "Write proxy for field `MPYSAT`" ] pub struct MPYSAT_W < 'a > { w : & 'a mut W , } impl < 'a > MPYSAT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MPYSAT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Saturation mode disabled." ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( MPYSAT_A :: DISABLE ) } # [ doc = "Saturation mode enabled." ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( MPYSAT_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Fractional mode.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MPYFRAC_A { # [ doc = "0: Fractional mode disabled." ] DISABLE = 0 , # [ doc = "1: Fractional mode enabled." ] ENABLE = 1 } impl From < MPYFRAC_A > for bool { # [ inline ( always ) ] fn from ( variant : MPYFRAC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `MPYFRAC`" ] pub type MPYFRAC_R = crate :: R < bool , MPYFRAC_A > ; impl MPYFRAC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MPYFRAC_A { match self . bits { false => MPYFRAC_A :: DISABLE , true => MPYFRAC_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == MPYFRAC_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == MPYFRAC_A :: ENABLE } }
# [ doc = "Write proxy for field `MPYFRAC`" ] pub struct MPYFRAC_W < 'a > { w : & 'a mut W , } impl < 'a > MPYFRAC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MPYFRAC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Fractional mode disabled." ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( MPYFRAC_A :: DISABLE ) } # [ doc = "Fractional mode enabled." ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( MPYFRAC_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Carry of the multiplier\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MPYC_A { # [ doc = "0: No carry for result." ] MPYC_0 = 0 , # [ doc = "1: Result has a carry." ] MPYC_1 = 1 } impl From < MPYC_A > for bool { # [ inline ( always ) ] fn from ( variant : MPYC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `MPYC`" ] pub type MPYC_R = crate :: R < bool , MPYC_A > ; impl MPYC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MPYC_A { match self . bits { false => MPYC_A :: MPYC_0 , true => MPYC_A :: MPYC_1 } } # [ doc = "Checks if the value of the field is `MPYC_0`" ] # [ inline ( always ) ] pub fn is_mpyc_0 ( & self ) -> bool { * self == MPYC_A :: MPYC_0 } # [ doc = "Checks if the value of the field is `MPYC_1`" ] # [ inline ( always ) ] pub fn is_mpyc_1 ( & self ) -> bool { * self == MPYC_A :: MPYC_1 } }
# [ doc = "Write proxy for field `MPYC`" ] pub struct MPYC_W < 'a > { w : & 'a mut W , } impl < 'a > MPYC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MPYC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No carry for result." ] # [ inline ( always ) ] pub fn mpyc_0 ( self ) -> & 'a mut W { self . variant ( MPYC_A :: MPYC_0 ) } # [ doc = "Result has a carry." ] # [ inline ( always ) ] pub fn mpyc_1 ( self ) -> & 'a mut W { self . variant ( MPYC_A :: MPYC_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 9 - Delayed write mode." ] # [ inline ( always ) ] pub fn mpydly32 ( & self ) -> MPYDLY32_R { MPYDLY32_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Delayed write enable." ] # [ inline ( always ) ] pub fn mpydlywrten ( & self ) -> MPYDLYWRTEN_R { MPYDLYWRTEN_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Multiplier bit width of operand 2" ] # [ inline ( always ) ] pub fn mpyop2_32 ( & self ) -> MPYOP2_32_R { MPYOP2_32_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Multiplier bit width of operand 1" ] # [ inline ( always ) ] pub fn mpyop1_32 ( & self ) -> MPYOP1_32_R { MPYOP1_32_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - Multiplier mode" ] # [ inline ( always ) ] pub fn mpym ( & self ) -> MPYM_R { MPYM_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 3 - Saturation mode" ] # [ inline ( always ) ] pub fn mpysat ( & self ) -> MPYSAT_R { MPYSAT_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Fractional mode." ] # [ inline ( always ) ] pub fn mpyfrac ( & self ) -> MPYFRAC_R { MPYFRAC_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 0 - Carry of the multiplier" ] # [ inline ( always ) ] pub fn mpyc ( & self ) -> MPYC_R { MPYC_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 9 - Delayed write mode." ] # [ inline ( always ) ] pub fn mpydly32 ( & mut self ) -> MPYDLY32_W { MPYDLY32_W { w : self } }
# [ doc = "Bit 8 - Delayed write enable." ] # [ inline ( always ) ] pub fn mpydlywrten ( & mut self ) -> MPYDLYWRTEN_W { MPYDLYWRTEN_W { w : self } }
# [ doc = "Bit 7 - Multiplier bit width of operand 2" ] # [ inline ( always ) ] pub fn mpyop2_32 ( & mut self ) -> MPYOP2_32_W { MPYOP2_32_W { w : self } }
# [ doc = "Bit 6 - Multiplier bit width of operand 1" ] # [ inline ( always ) ] pub fn mpyop1_32 ( & mut self ) -> MPYOP1_32_W { MPYOP1_32_W { w : self } }
# [ doc = "Bits 4:5 - Multiplier mode" ] # [ inline ( always ) ] pub fn mpym ( & mut self ) -> MPYM_W { MPYM_W { w : self } }
# [ doc = "Bit 3 - Saturation mode" ] # [ inline ( always ) ] pub fn mpysat ( & mut self ) -> MPYSAT_W { MPYSAT_W { w : self } }
# [ doc = "Bit 2 - Fractional mode." ] # [ inline ( always ) ] pub fn mpyfrac ( & mut self ) -> MPYFRAC_W { MPYFRAC_W { w : self } }
# [ doc = "Bit 0 - Carry of the multiplier" ] # [ inline ( always ) ] pub fn mpyc ( & mut self ) -> MPYC_W { MPYC_W { w : self } }
}
}
}
# [ doc = "eUSCI_A0" ] pub struct E_USCI_A0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for E_USCI_A0 { } impl E_USCI_A0 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const e_usci_a0 :: RegisterBlock { 0x0500 as * const _ } } impl Deref for E_USCI_A0 { type Target = e_usci_a0 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * E_USCI_A0 :: ptr ( ) } } }
# [ doc = "eUSCI_A0" ] pub mod e_usci_a0 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved_0_uca0ctlw : [ u8 ; 2usize ] , # [ doc = "0x02 - eUSCI_Ax Control Word Register 1" ] pub uca0ctlw1 : UCA0CTLW1 , _reserved2 : [ u8 ; 2usize ] , _reserved_2_uca0 : [ u8 ; 2usize ] , # [ doc = "0x08 - eUSCI_Ax Modulation Control Word Register" ] pub uca0mctlw : UCA0MCTLW , _reserved_4_uca0 : [ u8 ; 2usize ] , _reserved_5_uca0 : [ u8 ; 2usize ] , _reserved_6_uca0 : [ u8 ; 2usize ] , # [ doc = "0x10 - eUSCI_Ax Auto Baud Rate Control Register" ] pub uca0abctl : UCA0ABCTL , # [ doc = "0x12 - eUSCI_Ax IrDA Control Word Register" ] pub uca0irctl : UCA0IRCTL , _reserved9 : [ u8 ; 6usize ] , _reserved_9_uca0 : [ u8 ; 2usize ] , _reserved_10_uca0 : [ u8 ; 2usize ] , _reserved_11_uca0 : [ u8 ; 2usize ] , } impl RegisterBlock { # [ doc = "0x00 - eUSCI_Ax Control Word Register 0" ] # [ inline ( always ) ] pub fn uca0ctlw0_spi ( & self ) -> & UCA0CTLW0_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const UCA0CTLW0_SPI ) } } # [ doc = "0x00 - eUSCI_Ax Control Word Register 0" ] # [ inline ( always ) ] pub fn uca0ctlw0_spi_mut ( & self ) -> & mut UCA0CTLW0_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut UCA0CTLW0_SPI ) } } # [ doc = "0x00 - eUSCI_Ax Control Word Register 0" ] # [ inline ( always ) ] pub fn uca0ctlw0 ( & self ) -> & UCA0CTLW0 { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const UCA0CTLW0 ) } } # [ doc = "0x00 - eUSCI_Ax Control Word Register 0" ] # [ inline ( always ) ] pub fn uca0ctlw0_mut ( & self ) -> & mut UCA0CTLW0 { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut UCA0CTLW0 ) } } # [ doc = "0x06 - eUSCI_Ax Bit Rate Control Register 1" ] # [ inline ( always ) ] pub fn uca0brw_spi ( & self ) -> & UCA0BRW_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 6usize ) as * const UCA0BRW_SPI ) } } # [ doc = "0x06 - eUSCI_Ax Bit Rate Control Register 1" ] # [ inline ( always ) ] pub fn uca0brw_spi_mut ( & self ) -> & mut UCA0BRW_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 6usize ) as * mut UCA0BRW_SPI ) } } # [ doc = "0x06 - eUSCI_Ax Baud Rate Control Word Register" ] # [ inline ( always ) ] pub fn uca0brw ( & self ) -> & UCA0BRW { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 6usize ) as * const UCA0BRW ) } } # [ doc = "0x06 - eUSCI_Ax Baud Rate Control Word Register" ] # [ inline ( always ) ] pub fn uca0brw_mut ( & self ) -> & mut UCA0BRW { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 6usize ) as * mut UCA0BRW ) } } # [ doc = "0x0a - UCA0STATW_SPI" ] # [ inline ( always ) ] pub fn uca0statw_spi ( & self ) -> & UCA0STATW_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 10usize ) as * const UCA0STATW_SPI ) } } # [ doc = "0x0a - UCA0STATW_SPI" ] # [ inline ( always ) ] pub fn uca0statw_spi_mut ( & self ) -> & mut UCA0STATW_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 10usize ) as * mut UCA0STATW_SPI ) } } # [ doc = "0x0a - eUSCI_Ax Status Register" ] # [ inline ( always ) ] pub fn uca0statw ( & self ) -> & UCA0STATW { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 10usize ) as * const UCA0STATW ) } } # [ doc = "0x0a - eUSCI_Ax Status Register" ] # [ inline ( always ) ] pub fn uca0statw_mut ( & self ) -> & mut UCA0STATW { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 10usize ) as * mut UCA0STATW ) } } # [ doc = "0x0c - eUSCI_Ax Receive Buffer Register" ] # [ inline ( always ) ] pub fn uca0rxbuf_spi ( & self ) -> & UCA0RXBUF_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const UCA0RXBUF_SPI ) } } # [ doc = "0x0c - eUSCI_Ax Receive Buffer Register" ] # [ inline ( always ) ] pub fn uca0rxbuf_spi_mut ( & self ) -> & mut UCA0RXBUF_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut UCA0RXBUF_SPI ) } } # [ doc = "0x0c - eUSCI_Ax Receive Buffer Register" ] # [ inline ( always ) ] pub fn uca0rxbuf ( & self ) -> & UCA0RXBUF { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const UCA0RXBUF ) } } # [ doc = "0x0c - eUSCI_Ax Receive Buffer Register" ] # [ inline ( always ) ] pub fn uca0rxbuf_mut ( & self ) -> & mut UCA0RXBUF { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut UCA0RXBUF ) } } # [ doc = "0x0e - eUSCI_Ax Transmit Buffer Register" ] # [ inline ( always ) ] pub fn uca0txbuf_spi ( & self ) -> & UCA0TXBUF_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 14usize ) as * const UCA0TXBUF_SPI ) } } # [ doc = "0x0e - eUSCI_Ax Transmit Buffer Register" ] # [ inline ( always ) ] pub fn uca0txbuf_spi_mut ( & self ) -> & mut UCA0TXBUF_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 14usize ) as * mut UCA0TXBUF_SPI ) } } # [ doc = "0x0e - eUSCI_Ax Transmit Buffer Register" ] # [ inline ( always ) ] pub fn uca0txbuf ( & self ) -> & UCA0TXBUF { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 14usize ) as * const UCA0TXBUF ) } } # [ doc = "0x0e - eUSCI_Ax Transmit Buffer Register" ] # [ inline ( always ) ] pub fn uca0txbuf_mut ( & self ) -> & mut UCA0TXBUF { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 14usize ) as * mut UCA0TXBUF ) } } # [ doc = "0x1a - eUSCI_Ax Interrupt Enable Register" ] # [ inline ( always ) ] pub fn uca0ie_spi ( & self ) -> & UCA0IE_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 26usize ) as * const UCA0IE_SPI ) } } # [ doc = "0x1a - eUSCI_Ax Interrupt Enable Register" ] # [ inline ( always ) ] pub fn uca0ie_spi_mut ( & self ) -> & mut UCA0IE_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 26usize ) as * mut UCA0IE_SPI ) } } # [ doc = "0x1a - eUSCI_Ax Interrupt Enable Register" ] # [ inline ( always ) ] pub fn uca0ie ( & self ) -> & UCA0IE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 26usize ) as * const UCA0IE ) } } # [ doc = "0x1a - eUSCI_Ax Interrupt Enable Register" ] # [ inline ( always ) ] pub fn uca0ie_mut ( & self ) -> & mut UCA0IE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 26usize ) as * mut UCA0IE ) } } # [ doc = "0x1c - eUSCI_Ax Interrupt Flag Register" ] # [ inline ( always ) ] pub fn uca0ifg_spi ( & self ) -> & UCA0IFG_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 28usize ) as * const UCA0IFG_SPI ) } } # [ doc = "0x1c - eUSCI_Ax Interrupt Flag Register" ] # [ inline ( always ) ] pub fn uca0ifg_spi_mut ( & self ) -> & mut UCA0IFG_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 28usize ) as * mut UCA0IFG_SPI ) } } # [ doc = "0x1c - eUSCI_Ax Interrupt Flag Register" ] # [ inline ( always ) ] pub fn uca0ifg ( & self ) -> & UCA0IFG { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 28usize ) as * const UCA0IFG ) } } # [ doc = "0x1c - eUSCI_Ax Interrupt Flag Register" ] # [ inline ( always ) ] pub fn uca0ifg_mut ( & self ) -> & mut UCA0IFG { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 28usize ) as * mut UCA0IFG ) } } # [ doc = "0x1e - eUSCI_Ax Interrupt Vector Register" ] # [ inline ( always ) ] pub fn uca0iv_spi ( & self ) -> & UCA0IV_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 30usize ) as * const UCA0IV_SPI ) } } # [ doc = "0x1e - eUSCI_Ax Interrupt Vector Register" ] # [ inline ( always ) ] pub fn uca0iv_spi_mut ( & self ) -> & mut UCA0IV_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 30usize ) as * mut UCA0IV_SPI ) } } # [ doc = "0x1e - eUSCI_Ax Interrupt Vector Register" ] # [ inline ( always ) ] pub fn uca0iv ( & self ) -> & UCA0IV { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 30usize ) as * const UCA0IV ) } } # [ doc = "0x1e - eUSCI_Ax Interrupt Vector Register" ] # [ inline ( always ) ] pub fn uca0iv_mut ( & self ) -> & mut UCA0IV { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 30usize ) as * mut UCA0IV ) } } }
# [ doc = "eUSCI_Ax Control Word Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ctlw0](uca0ctlw0) module" ] pub type UCA0CTLW0 = crate :: Reg < u16 , _UCA0CTLW0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0CTLW0 ;
# [ doc = "`read()` method returns [uca0ctlw0::R](uca0ctlw0::R) reader structure" ] impl crate :: Readable for UCA0CTLW0 { }
# [ doc = "`write(|w| ..)` method takes [uca0ctlw0::W](uca0ctlw0::W) writer structure" ] impl crate :: Writable for UCA0CTLW0 { }
# [ doc = "eUSCI_Ax Control Word Register 0" ] pub mod uca0ctlw0 {
# [ doc = "Reader of register UCA0CTLW0" ] pub type R = crate :: R < u16 , super :: UCA0CTLW0 > ;
# [ doc = "Writer for register UCA0CTLW0" ] pub type W = crate :: W < u16 , super :: UCA0CTLW0 > ;
# [ doc = "Register UCA0CTLW0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0CTLW0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Software reset enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSWRST_A { # [ doc = "0: Disabled. eUSCI_A reset released for operation" ] DISABLE = 0 , # [ doc = "1: Enabled. eUSCI_A logic held in reset state" ] ENABLE = 1 } impl From < UCSWRST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSWRST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSWRST`" ] pub type UCSWRST_R = crate :: R < bool , UCSWRST_A > ; impl UCSWRST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSWRST_A { match self . bits { false => UCSWRST_A :: DISABLE , true => UCSWRST_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCSWRST_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCSWRST_A :: ENABLE } }
# [ doc = "Write proxy for field `UCSWRST`" ] pub struct UCSWRST_W < 'a > { w : & 'a mut W , } impl < 'a > UCSWRST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSWRST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled. eUSCI_A reset released for operation" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: DISABLE ) } # [ doc = "Enabled. eUSCI_A logic held in reset state" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit break\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXBRK_A { # [ doc = "0: Next frame transmitted is not a break" ] UCTXBRK_0 = 0 , # [ doc = "1: Next frame transmitted is a break or a break/synch" ] UCTXBRK_1 = 1 } impl From < UCTXBRK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXBRK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXBRK`" ] pub type UCTXBRK_R = crate :: R < bool , UCTXBRK_A > ; impl UCTXBRK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXBRK_A { match self . bits { false => UCTXBRK_A :: UCTXBRK_0 , true => UCTXBRK_A :: UCTXBRK_1 } } # [ doc = "Checks if the value of the field is `UCTXBRK_0`" ] # [ inline ( always ) ] pub fn is_uctxbrk_0 ( & self ) -> bool { * self == UCTXBRK_A :: UCTXBRK_0 } # [ doc = "Checks if the value of the field is `UCTXBRK_1`" ] # [ inline ( always ) ] pub fn is_uctxbrk_1 ( & self ) -> bool { * self == UCTXBRK_A :: UCTXBRK_1 } }
# [ doc = "Write proxy for field `UCTXBRK`" ] pub struct UCTXBRK_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXBRK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXBRK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Next frame transmitted is not a break" ] # [ inline ( always ) ] pub fn uctxbrk_0 ( self ) -> & 'a mut W { self . variant ( UCTXBRK_A :: UCTXBRK_0 ) } # [ doc = "Next frame transmitted is a break or a break/synch" ] # [ inline ( always ) ] pub fn uctxbrk_1 ( self ) -> & 'a mut W { self . variant ( UCTXBRK_A :: UCTXBRK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Transmit address\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXADDR_A { # [ doc = "0: Next frame transmitted is data" ] UCTXADDR_0 = 0 , # [ doc = "1: Next frame transmitted is an address" ] UCTXADDR_1 = 1 } impl From < UCTXADDR_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXADDR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXADDR`" ] pub type UCTXADDR_R = crate :: R < bool , UCTXADDR_A > ; impl UCTXADDR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXADDR_A { match self . bits { false => UCTXADDR_A :: UCTXADDR_0 , true => UCTXADDR_A :: UCTXADDR_1 } } # [ doc = "Checks if the value of the field is `UCTXADDR_0`" ] # [ inline ( always ) ] pub fn is_uctxaddr_0 ( & self ) -> bool { * self == UCTXADDR_A :: UCTXADDR_0 } # [ doc = "Checks if the value of the field is `UCTXADDR_1`" ] # [ inline ( always ) ] pub fn is_uctxaddr_1 ( & self ) -> bool { * self == UCTXADDR_A :: UCTXADDR_1 } }
# [ doc = "Write proxy for field `UCTXADDR`" ] pub struct UCTXADDR_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXADDR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXADDR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Next frame transmitted is data" ] # [ inline ( always ) ] pub fn uctxaddr_0 ( self ) -> & 'a mut W { self . variant ( UCTXADDR_A :: UCTXADDR_0 ) } # [ doc = "Next frame transmitted is an address" ] # [ inline ( always ) ] pub fn uctxaddr_1 ( self ) -> & 'a mut W { self . variant ( UCTXADDR_A :: UCTXADDR_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Dormant\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCDORM_A { # [ doc = "0: Not dormant. All received characters set UCRXIFG." ] UCDORM_0 = 0 , # [ doc = "1: Dormant. Only characters that are preceded by an idle-line or with address bit set UCRXIFG. In UART mode with automatic baud-rate detection, only the combination of a break and synch field sets UCRXIFG." ] UCDORM_1 = 1 } impl From < UCDORM_A > for bool { # [ inline ( always ) ] fn from ( variant : UCDORM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCDORM`" ] pub type UCDORM_R = crate :: R < bool , UCDORM_A > ; impl UCDORM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCDORM_A { match self . bits { false => UCDORM_A :: UCDORM_0 , true => UCDORM_A :: UCDORM_1 } } # [ doc = "Checks if the value of the field is `UCDORM_0`" ] # [ inline ( always ) ] pub fn is_ucdorm_0 ( & self ) -> bool { * self == UCDORM_A :: UCDORM_0 } # [ doc = "Checks if the value of the field is `UCDORM_1`" ] # [ inline ( always ) ] pub fn is_ucdorm_1 ( & self ) -> bool { * self == UCDORM_A :: UCDORM_1 } }
# [ doc = "Write proxy for field `UCDORM`" ] pub struct UCDORM_W < 'a > { w : & 'a mut W , } impl < 'a > UCDORM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCDORM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Not dormant. All received characters set UCRXIFG." ] # [ inline ( always ) ] pub fn ucdorm_0 ( self ) -> & 'a mut W { self . variant ( UCDORM_A :: UCDORM_0 ) } # [ doc = "Dormant. Only characters that are preceded by an idle-line or with address bit set UCRXIFG. In UART mode with automatic baud-rate detection, only the combination of a break and synch field sets UCRXIFG." ] # [ inline ( always ) ] pub fn ucdorm_1 ( self ) -> & 'a mut W { self . variant ( UCDORM_A :: UCDORM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Receive break character interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBRKIE_A { # [ doc = "0: Received break characters do not set UCRXIFG" ] UCBRKIE_0 = 0 , # [ doc = "1: Received break characters set UCRXIFG" ] UCBRKIE_1 = 1 } impl From < UCBRKIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBRKIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBRKIE`" ] pub type UCBRKIE_R = crate :: R < bool , UCBRKIE_A > ; impl UCBRKIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBRKIE_A { match self . bits { false => UCBRKIE_A :: UCBRKIE_0 , true => UCBRKIE_A :: UCBRKIE_1 } } # [ doc = "Checks if the value of the field is `UCBRKIE_0`" ] # [ inline ( always ) ] pub fn is_ucbrkie_0 ( & self ) -> bool { * self == UCBRKIE_A :: UCBRKIE_0 } # [ doc = "Checks if the value of the field is `UCBRKIE_1`" ] # [ inline ( always ) ] pub fn is_ucbrkie_1 ( & self ) -> bool { * self == UCBRKIE_A :: UCBRKIE_1 } }
# [ doc = "Write proxy for field `UCBRKIE`" ] pub struct UCBRKIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCBRKIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBRKIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Received break characters do not set UCRXIFG" ] # [ inline ( always ) ] pub fn ucbrkie_0 ( self ) -> & 'a mut W { self . variant ( UCBRKIE_A :: UCBRKIE_0 ) } # [ doc = "Received break characters set UCRXIFG" ] # [ inline ( always ) ] pub fn ucbrkie_1 ( self ) -> & 'a mut W { self . variant ( UCBRKIE_A :: UCBRKIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Receive erroneous-character interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXEIE_A { # [ doc = "0: Erroneous characters rejected and UCRXIFG is not set" ] UCRXEIE_0 = 0 , # [ doc = "1: Erroneous characters received set UCRXIFG" ] UCRXEIE_1 = 1 } impl From < UCRXEIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXEIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXEIE`" ] pub type UCRXEIE_R = crate :: R < bool , UCRXEIE_A > ; impl UCRXEIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXEIE_A { match self . bits { false => UCRXEIE_A :: UCRXEIE_0 , true => UCRXEIE_A :: UCRXEIE_1 } } # [ doc = "Checks if the value of the field is `UCRXEIE_0`" ] # [ inline ( always ) ] pub fn is_ucrxeie_0 ( & self ) -> bool { * self == UCRXEIE_A :: UCRXEIE_0 } # [ doc = "Checks if the value of the field is `UCRXEIE_1`" ] # [ inline ( always ) ] pub fn is_ucrxeie_1 ( & self ) -> bool { * self == UCRXEIE_A :: UCRXEIE_1 } }
# [ doc = "Write proxy for field `UCRXEIE`" ] pub struct UCRXEIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXEIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXEIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Erroneous characters rejected and UCRXIFG is not set" ] # [ inline ( always ) ] pub fn ucrxeie_0 ( self ) -> & 'a mut W { self . variant ( UCRXEIE_A :: UCRXEIE_0 ) } # [ doc = "Erroneous characters received set UCRXIFG" ] # [ inline ( always ) ] pub fn ucrxeie_1 ( self ) -> & 'a mut W { self . variant ( UCRXEIE_A :: UCRXEIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "eUSCI_A clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCSSEL_A { # [ doc = "0: UCLK" ] UCLK = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: SMCLK" ] UCSSEL_3 = 3 } impl From < UCSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCSSEL`" ] pub type UCSSEL_R = crate :: R < u8 , UCSSEL_A > ; impl UCSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSSEL_A { match self . bits { 0 => UCSSEL_A :: UCLK , 1 => UCSSEL_A :: ACLK , 2 => UCSSEL_A :: SMCLK , 3 => UCSSEL_A :: UCSSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCLK`" ] # [ inline ( always ) ] pub fn is_uclk ( & self ) -> bool { * self == UCSSEL_A :: UCLK } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == UCSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == UCSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `UCSSEL_3`" ] # [ inline ( always ) ] pub fn is_ucssel_3 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_3 } }
# [ doc = "Write proxy for field `UCSSEL`" ] pub struct UCSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > UCSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "UCLK" ] # [ inline ( always ) ] pub fn uclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCLK ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: SMCLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn ucssel_3 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Synchronous mode enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSYNC_A { # [ doc = "0: Asynchronous mode" ] ASYNC = 0 , # [ doc = "1: Synchronous mode" ] SYNC = 1 } impl From < UCSYNC_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSYNC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSYNC`" ] pub type UCSYNC_R = crate :: R < bool , UCSYNC_A > ; impl UCSYNC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSYNC_A { match self . bits { false => UCSYNC_A :: ASYNC , true => UCSYNC_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == UCSYNC_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == UCSYNC_A :: SYNC } }
# [ doc = "Write proxy for field `UCSYNC`" ] pub struct UCSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > UCSYNC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSYNC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous mode" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: ASYNC ) } # [ doc = "Synchronous mode" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "eUSCI_A mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCMODE_A { # [ doc = "0: UART mode" ] UCMODE_0 = 0 , # [ doc = "1: Idle-line multiprocessor mode" ] UCMODE_1 = 1 , # [ doc = "2: Address-bit multiprocessor mode" ] UCMODE_2 = 2 , # [ doc = "3: UART mode with automatic baud-rate detection" ] UCMODE_3 = 3 } impl From < UCMODE_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCMODE_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCMODE`" ] pub type UCMODE_R = crate :: R < u8 , UCMODE_A > ; impl UCMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMODE_A { match self . bits { 0 => UCMODE_A :: UCMODE_0 , 1 => UCMODE_A :: UCMODE_1 , 2 => UCMODE_A :: UCMODE_2 , 3 => UCMODE_A :: UCMODE_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCMODE_0`" ] # [ inline ( always ) ] pub fn is_ucmode_0 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_0 } # [ doc = "Checks if the value of the field is `UCMODE_1`" ] # [ inline ( always ) ] pub fn is_ucmode_1 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_1 } # [ doc = "Checks if the value of the field is `UCMODE_2`" ] # [ inline ( always ) ] pub fn is_ucmode_2 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_2 } # [ doc = "Checks if the value of the field is `UCMODE_3`" ] # [ inline ( always ) ] pub fn is_ucmode_3 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_3 } }
# [ doc = "Write proxy for field `UCMODE`" ] pub struct UCMODE_W < 'a > { w : & 'a mut W , } impl < 'a > UCMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMODE_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "UART mode" ] # [ inline ( always ) ] pub fn ucmode_0 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_0 ) } # [ doc = "Idle-line multiprocessor mode" ] # [ inline ( always ) ] pub fn ucmode_1 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_1 ) } # [ doc = "Address-bit multiprocessor mode" ] # [ inline ( always ) ] pub fn ucmode_2 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_2 ) } # [ doc = "UART mode with automatic baud-rate detection" ] # [ inline ( always ) ] pub fn ucmode_3 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Stop bit select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSPB_A { # [ doc = "0: One stop bit" ] UCSPB_0 = 0 , # [ doc = "1: Two stop bits" ] UCSPB_1 = 1 } impl From < UCSPB_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSPB_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSPB`" ] pub type UCSPB_R = crate :: R < bool , UCSPB_A > ; impl UCSPB_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSPB_A { match self . bits { false => UCSPB_A :: UCSPB_0 , true => UCSPB_A :: UCSPB_1 } } # [ doc = "Checks if the value of the field is `UCSPB_0`" ] # [ inline ( always ) ] pub fn is_ucspb_0 ( & self ) -> bool { * self == UCSPB_A :: UCSPB_0 } # [ doc = "Checks if the value of the field is `UCSPB_1`" ] # [ inline ( always ) ] pub fn is_ucspb_1 ( & self ) -> bool { * self == UCSPB_A :: UCSPB_1 } }
# [ doc = "Write proxy for field `UCSPB`" ] pub struct UCSPB_W < 'a > { w : & 'a mut W , } impl < 'a > UCSPB_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSPB_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "One stop bit" ] # [ inline ( always ) ] pub fn ucspb_0 ( self ) -> & 'a mut W { self . variant ( UCSPB_A :: UCSPB_0 ) } # [ doc = "Two stop bits" ] # [ inline ( always ) ] pub fn ucspb_1 ( self ) -> & 'a mut W { self . variant ( UCSPB_A :: UCSPB_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Character length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UC7BIT_A { # [ doc = "0: 8-bit data" ] _8BIT = 0 , # [ doc = "1: 7-bit data" ] _7BIT = 1 } impl From < UC7BIT_A > for bool { # [ inline ( always ) ] fn from ( variant : UC7BIT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UC7BIT`" ] pub type UC7BIT_R = crate :: R < bool , UC7BIT_A > ; impl UC7BIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UC7BIT_A { match self . bits { false => UC7BIT_A :: _8BIT , true => UC7BIT_A :: _7BIT } } # [ doc = "Checks if the value of the field is `_8BIT`" ] # [ inline ( always ) ] pub fn is_8bit ( & self ) -> bool { * self == UC7BIT_A :: _8BIT } # [ doc = "Checks if the value of the field is `_7BIT`" ] # [ inline ( always ) ] pub fn is_7bit ( & self ) -> bool { * self == UC7BIT_A :: _7BIT } }
# [ doc = "Write proxy for field `UC7BIT`" ] pub struct UC7BIT_W < 'a > { w : & 'a mut W , } impl < 'a > UC7BIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UC7BIT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "8-bit data" ] # [ inline ( always ) ] pub fn _8bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _8BIT ) } # [ doc = "7-bit data" ] # [ inline ( always ) ] pub fn _7bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _7BIT ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "MSB first select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMSB_A { # [ doc = "0: LSB first" ] UCMSB_0 = 0 , # [ doc = "1: MSB first" ] UCMSB_1 = 1 } impl From < UCMSB_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMSB_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMSB`" ] pub type UCMSB_R = crate :: R < bool , UCMSB_A > ; impl UCMSB_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMSB_A { match self . bits { false => UCMSB_A :: UCMSB_0 , true => UCMSB_A :: UCMSB_1 } } # [ doc = "Checks if the value of the field is `UCMSB_0`" ] # [ inline ( always ) ] pub fn is_ucmsb_0 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_0 } # [ doc = "Checks if the value of the field is `UCMSB_1`" ] # [ inline ( always ) ] pub fn is_ucmsb_1 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_1 } }
# [ doc = "Write proxy for field `UCMSB`" ] pub struct UCMSB_W < 'a > { w : & 'a mut W , } impl < 'a > UCMSB_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMSB_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "LSB first" ] # [ inline ( always ) ] pub fn ucmsb_0 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_0 ) } # [ doc = "MSB first" ] # [ inline ( always ) ] pub fn ucmsb_1 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Parity select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCPAR_A { # [ doc = "0: Odd parity" ] ODD = 0 , # [ doc = "1: Even parity" ] EVEN = 1 } impl From < UCPAR_A > for bool { # [ inline ( always ) ] fn from ( variant : UCPAR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCPAR`" ] pub type UCPAR_R = crate :: R < bool , UCPAR_A > ; impl UCPAR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCPAR_A { match self . bits { false => UCPAR_A :: ODD , true => UCPAR_A :: EVEN } } # [ doc = "Checks if the value of the field is `ODD`" ] # [ inline ( always ) ] pub fn is_odd ( & self ) -> bool { * self == UCPAR_A :: ODD } # [ doc = "Checks if the value of the field is `EVEN`" ] # [ inline ( always ) ] pub fn is_even ( & self ) -> bool { * self == UCPAR_A :: EVEN } }
# [ doc = "Write proxy for field `UCPAR`" ] pub struct UCPAR_W < 'a > { w : & 'a mut W , } impl < 'a > UCPAR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCPAR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Odd parity" ] # [ inline ( always ) ] pub fn odd ( self ) -> & 'a mut W { self . variant ( UCPAR_A :: ODD ) } # [ doc = "Even parity" ] # [ inline ( always ) ] pub fn even ( self ) -> & 'a mut W { self . variant ( UCPAR_A :: EVEN ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Parity enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCPEN_A { # [ doc = "0: Parity disabled" ] UCPEN_0 = 0 , # [ doc = "1: Parity enabled. Parity bit is generated (UCAxTXD) and expected (UCAxRXD). In address-bit multiprocessor mode, the address bit is included in the parity calculation." ] UCPEN_1 = 1 } impl From < UCPEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCPEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCPEN`" ] pub type UCPEN_R = crate :: R < bool , UCPEN_A > ; impl UCPEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCPEN_A { match self . bits { false => UCPEN_A :: UCPEN_0 , true => UCPEN_A :: UCPEN_1 } } # [ doc = "Checks if the value of the field is `UCPEN_0`" ] # [ inline ( always ) ] pub fn is_ucpen_0 ( & self ) -> bool { * self == UCPEN_A :: UCPEN_0 } # [ doc = "Checks if the value of the field is `UCPEN_1`" ] # [ inline ( always ) ] pub fn is_ucpen_1 ( & self ) -> bool { * self == UCPEN_A :: UCPEN_1 } }
# [ doc = "Write proxy for field `UCPEN`" ] pub struct UCPEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCPEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCPEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Parity disabled" ] # [ inline ( always ) ] pub fn ucpen_0 ( self ) -> & 'a mut W { self . variant ( UCPEN_A :: UCPEN_0 ) } # [ doc = "Parity enabled. Parity bit is generated (UCAxTXD) and expected (UCAxRXD). In address-bit multiprocessor mode, the address bit is included in the parity calculation." ] # [ inline ( always ) ] pub fn ucpen_1 ( self ) -> & 'a mut W { self . variant ( UCPEN_A :: UCPEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & self ) -> UCSWRST_R { UCSWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit break" ] # [ inline ( always ) ] pub fn uctxbrk ( & self ) -> UCTXBRK_R { UCTXBRK_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Transmit address" ] # [ inline ( always ) ] pub fn uctxaddr ( & self ) -> UCTXADDR_R { UCTXADDR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Dormant" ] # [ inline ( always ) ] pub fn ucdorm ( & self ) -> UCDORM_R { UCDORM_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Receive break character interrupt enable" ] # [ inline ( always ) ] pub fn ucbrkie ( & self ) -> UCBRKIE_R { UCBRKIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Receive erroneous-character interrupt enable" ] # [ inline ( always ) ] pub fn ucrxeie ( & self ) -> UCRXEIE_R { UCRXEIE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - eUSCI_A clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & self ) -> UCSSEL_R { UCSSEL_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & self ) -> UCSYNC_R { UCSYNC_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - eUSCI_A mode" ] # [ inline ( always ) ] pub fn ucmode ( & self ) -> UCMODE_R { UCMODE_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Stop bit select" ] # [ inline ( always ) ] pub fn ucspb ( & self ) -> UCSPB_R { UCSPB_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & self ) -> UC7BIT_R { UC7BIT_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & self ) -> UCMSB_R { UCMSB_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Parity select" ] # [ inline ( always ) ] pub fn ucpar ( & self ) -> UCPAR_R { UCPAR_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Parity enable" ] # [ inline ( always ) ] pub fn ucpen ( & self ) -> UCPEN_R { UCPEN_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & mut self ) -> UCSWRST_W { UCSWRST_W { w : self } }
# [ doc = "Bit 1 - Transmit break" ] # [ inline ( always ) ] pub fn uctxbrk ( & mut self ) -> UCTXBRK_W { UCTXBRK_W { w : self } }
# [ doc = "Bit 2 - Transmit address" ] # [ inline ( always ) ] pub fn uctxaddr ( & mut self ) -> UCTXADDR_W { UCTXADDR_W { w : self } }
# [ doc = "Bit 3 - Dormant" ] # [ inline ( always ) ] pub fn ucdorm ( & mut self ) -> UCDORM_W { UCDORM_W { w : self } }
# [ doc = "Bit 4 - Receive break character interrupt enable" ] # [ inline ( always ) ] pub fn ucbrkie ( & mut self ) -> UCBRKIE_W { UCBRKIE_W { w : self } }
# [ doc = "Bit 5 - Receive erroneous-character interrupt enable" ] # [ inline ( always ) ] pub fn ucrxeie ( & mut self ) -> UCRXEIE_W { UCRXEIE_W { w : self } }
# [ doc = "Bits 6:7 - eUSCI_A clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & mut self ) -> UCSSEL_W { UCSSEL_W { w : self } }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & mut self ) -> UCSYNC_W { UCSYNC_W { w : self } }
# [ doc = "Bits 9:10 - eUSCI_A mode" ] # [ inline ( always ) ] pub fn ucmode ( & mut self ) -> UCMODE_W { UCMODE_W { w : self } }
# [ doc = "Bit 11 - Stop bit select" ] # [ inline ( always ) ] pub fn ucspb ( & mut self ) -> UCSPB_W { UCSPB_W { w : self } }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & mut self ) -> UC7BIT_W { UC7BIT_W { w : self } }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & mut self ) -> UCMSB_W { UCMSB_W { w : self } }
# [ doc = "Bit 14 - Parity select" ] # [ inline ( always ) ] pub fn ucpar ( & mut self ) -> UCPAR_W { UCPAR_W { w : self } }
# [ doc = "Bit 15 - Parity enable" ] # [ inline ( always ) ] pub fn ucpen ( & mut self ) -> UCPEN_W { UCPEN_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Control Word Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ctlw0_spi](uca0ctlw0_spi) module" ] pub type UCA0CTLW0_SPI = crate :: Reg < u16 , _UCA0CTLW0_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0CTLW0_SPI ;
# [ doc = "`read()` method returns [uca0ctlw0_spi::R](uca0ctlw0_spi::R) reader structure" ] impl crate :: Readable for UCA0CTLW0_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca0ctlw0_spi::W](uca0ctlw0_spi::W) writer structure" ] impl crate :: Writable for UCA0CTLW0_SPI { }
# [ doc = "eUSCI_Ax Control Word Register 0" ] pub mod uca0ctlw0_spi {
# [ doc = "Reader of register UCA0CTLW0_SPI" ] pub type R = crate :: R < u16 , super :: UCA0CTLW0_SPI > ;
# [ doc = "Writer for register UCA0CTLW0_SPI" ] pub type W = crate :: W < u16 , super :: UCA0CTLW0_SPI > ;
# [ doc = "Register UCA0CTLW0_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0CTLW0_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Software reset enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSWRST_A { # [ doc = "0: Disabled. eUSCI_A reset released for operation" ] DISABLE = 0 , # [ doc = "1: Enabled. eUSCI_A logic held in reset state" ] ENABLE = 1 } impl From < UCSWRST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSWRST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSWRST`" ] pub type UCSWRST_R = crate :: R < bool , UCSWRST_A > ; impl UCSWRST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSWRST_A { match self . bits { false => UCSWRST_A :: DISABLE , true => UCSWRST_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCSWRST_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCSWRST_A :: ENABLE } }
# [ doc = "Write proxy for field `UCSWRST`" ] pub struct UCSWRST_W < 'a > { w : & 'a mut W , } impl < 'a > UCSWRST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSWRST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled. eUSCI_A reset released for operation" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: DISABLE ) } # [ doc = "Enabled. eUSCI_A logic held in reset state" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "STE mode select in master mode.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTEM_A { # [ doc = "0: STE pin is used to prevent conflicts with other masters" ] UCSTEM_0 = 0 , # [ doc = "1: STE pin is used to generate the enable signal for a 4-wire slave" ] UCSTEM_1 = 1 } impl From < UCSTEM_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTEM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTEM`" ] pub type UCSTEM_R = crate :: R < bool , UCSTEM_A > ; impl UCSTEM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTEM_A { match self . bits { false => UCSTEM_A :: UCSTEM_0 , true => UCSTEM_A :: UCSTEM_1 } } # [ doc = "Checks if the value of the field is `UCSTEM_0`" ] # [ inline ( always ) ] pub fn is_ucstem_0 ( & self ) -> bool { * self == UCSTEM_A :: UCSTEM_0 } # [ doc = "Checks if the value of the field is `UCSTEM_1`" ] # [ inline ( always ) ] pub fn is_ucstem_1 ( & self ) -> bool { * self == UCSTEM_A :: UCSTEM_1 } }
# [ doc = "Write proxy for field `UCSTEM`" ] pub struct UCSTEM_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTEM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTEM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "STE pin is used to prevent conflicts with other masters" ] # [ inline ( always ) ] pub fn ucstem_0 ( self ) -> & 'a mut W { self . variant ( UCSTEM_A :: UCSTEM_0 ) } # [ doc = "STE pin is used to generate the enable signal for a 4-wire slave" ] # [ inline ( always ) ] pub fn ucstem_1 ( self ) -> & 'a mut W { self . variant ( UCSTEM_A :: UCSTEM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "eUSCI_A clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCSSEL_A { # [ doc = "0: Reserved" ] UCSSEL_0 = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: SMCLK" ] UCSSEL_3 = 3 } impl From < UCSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCSSEL`" ] pub type UCSSEL_R = crate :: R < u8 , UCSSEL_A > ; impl UCSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSSEL_A { match self . bits { 0 => UCSSEL_A :: UCSSEL_0 , 1 => UCSSEL_A :: ACLK , 2 => UCSSEL_A :: SMCLK , 3 => UCSSEL_A :: UCSSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCSSEL_0`" ] # [ inline ( always ) ] pub fn is_ucssel_0 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_0 } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == UCSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == UCSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `UCSSEL_3`" ] # [ inline ( always ) ] pub fn is_ucssel_3 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_3 } }
# [ doc = "Write proxy for field `UCSSEL`" ] pub struct UCSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > UCSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn ucssel_0 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_0 ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: SMCLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn ucssel_3 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Synchronous mode enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSYNC_A { # [ doc = "0: Asynchronous mode" ] ASYNC = 0 , # [ doc = "1: Synchronous mode" ] SYNC = 1 } impl From < UCSYNC_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSYNC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSYNC`" ] pub type UCSYNC_R = crate :: R < bool , UCSYNC_A > ; impl UCSYNC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSYNC_A { match self . bits { false => UCSYNC_A :: ASYNC , true => UCSYNC_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == UCSYNC_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == UCSYNC_A :: SYNC } }
# [ doc = "Write proxy for field `UCSYNC`" ] pub struct UCSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > UCSYNC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSYNC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous mode" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: ASYNC ) } # [ doc = "Synchronous mode" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "eUSCI mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCMODE_A { # [ doc = "0: 3-pin SPI" ] UCMODE_0 = 0 , # [ doc = "1: 4-pin SPI with UCxSTE active high: Slave enabled when UCxSTE = 1" ] UCMODE_1 = 1 , # [ doc = "2: 4-pin SPI with UCxSTE active low: Slave enabled when UCxSTE = 0" ] UCMODE_2 = 2 , # [ doc = "3: I2C mode" ] UCMODE_3 = 3 } impl From < UCMODE_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCMODE_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCMODE`" ] pub type UCMODE_R = crate :: R < u8 , UCMODE_A > ; impl UCMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMODE_A { match self . bits { 0 => UCMODE_A :: UCMODE_0 , 1 => UCMODE_A :: UCMODE_1 , 2 => UCMODE_A :: UCMODE_2 , 3 => UCMODE_A :: UCMODE_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCMODE_0`" ] # [ inline ( always ) ] pub fn is_ucmode_0 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_0 } # [ doc = "Checks if the value of the field is `UCMODE_1`" ] # [ inline ( always ) ] pub fn is_ucmode_1 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_1 } # [ doc = "Checks if the value of the field is `UCMODE_2`" ] # [ inline ( always ) ] pub fn is_ucmode_2 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_2 } # [ doc = "Checks if the value of the field is `UCMODE_3`" ] # [ inline ( always ) ] pub fn is_ucmode_3 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_3 } }
# [ doc = "Write proxy for field `UCMODE`" ] pub struct UCMODE_W < 'a > { w : & 'a mut W , } impl < 'a > UCMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMODE_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "3-pin SPI" ] # [ inline ( always ) ] pub fn ucmode_0 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_0 ) } # [ doc = "4-pin SPI with UCxSTE active high: Slave enabled when UCxSTE = 1" ] # [ inline ( always ) ] pub fn ucmode_1 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_1 ) } # [ doc = "4-pin SPI with UCxSTE active low: Slave enabled when UCxSTE = 0" ] # [ inline ( always ) ] pub fn ucmode_2 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_2 ) } # [ doc = "I2C mode" ] # [ inline ( always ) ] pub fn ucmode_3 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Master mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMST_A { # [ doc = "0: Slave mode" ] SLAVE = 0 , # [ doc = "1: Master mode" ] MASTER = 1 } impl From < UCMST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMST`" ] pub type UCMST_R = crate :: R < bool , UCMST_A > ; impl UCMST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMST_A { match self . bits { false => UCMST_A :: SLAVE , true => UCMST_A :: MASTER } } # [ doc = "Checks if the value of the field is `SLAVE`" ] # [ inline ( always ) ] pub fn is_slave ( & self ) -> bool { * self == UCMST_A :: SLAVE } # [ doc = "Checks if the value of the field is `MASTER`" ] # [ inline ( always ) ] pub fn is_master ( & self ) -> bool { * self == UCMST_A :: MASTER } }
# [ doc = "Write proxy for field `UCMST`" ] pub struct UCMST_W < 'a > { w : & 'a mut W , } impl < 'a > UCMST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Slave mode" ] # [ inline ( always ) ] pub fn slave ( self ) -> & 'a mut W { self . variant ( UCMST_A :: SLAVE ) } # [ doc = "Master mode" ] # [ inline ( always ) ] pub fn master ( self ) -> & 'a mut W { self . variant ( UCMST_A :: MASTER ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Character length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UC7BIT_A { # [ doc = "0: 8-bit data" ] _8BIT = 0 , # [ doc = "1: 7-bit data" ] _7BIT = 1 } impl From < UC7BIT_A > for bool { # [ inline ( always ) ] fn from ( variant : UC7BIT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UC7BIT`" ] pub type UC7BIT_R = crate :: R < bool , UC7BIT_A > ; impl UC7BIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UC7BIT_A { match self . bits { false => UC7BIT_A :: _8BIT , true => UC7BIT_A :: _7BIT } } # [ doc = "Checks if the value of the field is `_8BIT`" ] # [ inline ( always ) ] pub fn is_8bit ( & self ) -> bool { * self == UC7BIT_A :: _8BIT } # [ doc = "Checks if the value of the field is `_7BIT`" ] # [ inline ( always ) ] pub fn is_7bit ( & self ) -> bool { * self == UC7BIT_A :: _7BIT } }
# [ doc = "Write proxy for field `UC7BIT`" ] pub struct UC7BIT_W < 'a > { w : & 'a mut W , } impl < 'a > UC7BIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UC7BIT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "8-bit data" ] # [ inline ( always ) ] pub fn _8bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _8BIT ) } # [ doc = "7-bit data" ] # [ inline ( always ) ] pub fn _7bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _7BIT ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "MSB first select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMSB_A { # [ doc = "0: LSB first" ] UCMSB_0 = 0 , # [ doc = "1: MSB first" ] UCMSB_1 = 1 } impl From < UCMSB_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMSB_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMSB`" ] pub type UCMSB_R = crate :: R < bool , UCMSB_A > ; impl UCMSB_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMSB_A { match self . bits { false => UCMSB_A :: UCMSB_0 , true => UCMSB_A :: UCMSB_1 } } # [ doc = "Checks if the value of the field is `UCMSB_0`" ] # [ inline ( always ) ] pub fn is_ucmsb_0 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_0 } # [ doc = "Checks if the value of the field is `UCMSB_1`" ] # [ inline ( always ) ] pub fn is_ucmsb_1 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_1 } }
# [ doc = "Write proxy for field `UCMSB`" ] pub struct UCMSB_W < 'a > { w : & 'a mut W , } impl < 'a > UCMSB_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMSB_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "LSB first" ] # [ inline ( always ) ] pub fn ucmsb_0 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_0 ) } # [ doc = "MSB first" ] # [ inline ( always ) ] pub fn ucmsb_1 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Clock polarity select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCKPL_A { # [ doc = "0: The inactive state is low" ] LOW = 0 , # [ doc = "1: The inactive state is high" ] HIGH = 1 } impl From < UCCKPL_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCKPL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCKPL`" ] pub type UCCKPL_R = crate :: R < bool , UCCKPL_A > ; impl UCCKPL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCKPL_A { match self . bits { false => UCCKPL_A :: LOW , true => UCCKPL_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == UCCKPL_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == UCCKPL_A :: HIGH } }
# [ doc = "Write proxy for field `UCCKPL`" ] pub struct UCCKPL_W < 'a > { w : & 'a mut W , } impl < 'a > UCCKPL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCKPL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The inactive state is low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( UCCKPL_A :: LOW ) } # [ doc = "The inactive state is high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( UCCKPL_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Clock phase select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCKPH_A { # [ doc = "0: Data is changed on the first UCLK edge and captured on the following edge." ] UCCKPH_0 = 0 , # [ doc = "1: Data is captured on the first UCLK edge and changed on the following edge." ] UCCKPH_1 = 1 } impl From < UCCKPH_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCKPH_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCKPH`" ] pub type UCCKPH_R = crate :: R < bool , UCCKPH_A > ; impl UCCKPH_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCKPH_A { match self . bits { false => UCCKPH_A :: UCCKPH_0 , true => UCCKPH_A :: UCCKPH_1 } } # [ doc = "Checks if the value of the field is `UCCKPH_0`" ] # [ inline ( always ) ] pub fn is_ucckph_0 ( & self ) -> bool { * self == UCCKPH_A :: UCCKPH_0 } # [ doc = "Checks if the value of the field is `UCCKPH_1`" ] # [ inline ( always ) ] pub fn is_ucckph_1 ( & self ) -> bool { * self == UCCKPH_A :: UCCKPH_1 } }
# [ doc = "Write proxy for field `UCCKPH`" ] pub struct UCCKPH_W < 'a > { w : & 'a mut W , } impl < 'a > UCCKPH_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCKPH_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Data is changed on the first UCLK edge and captured on the following edge." ] # [ inline ( always ) ] pub fn ucckph_0 ( self ) -> & 'a mut W { self . variant ( UCCKPH_A :: UCCKPH_0 ) } # [ doc = "Data is captured on the first UCLK edge and changed on the following edge." ] # [ inline ( always ) ] pub fn ucckph_1 ( self ) -> & 'a mut W { self . variant ( UCCKPH_A :: UCCKPH_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & self ) -> UCSWRST_R { UCSWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - STE mode select in master mode." ] # [ inline ( always ) ] pub fn ucstem ( & self ) -> UCSTEM_R { UCSTEM_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - eUSCI_A clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & self ) -> UCSSEL_R { UCSSEL_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & self ) -> UCSYNC_R { UCSYNC_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - eUSCI mode" ] # [ inline ( always ) ] pub fn ucmode ( & self ) -> UCMODE_R { UCMODE_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & self ) -> UCMST_R { UCMST_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & self ) -> UC7BIT_R { UC7BIT_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & self ) -> UCMSB_R { UCMSB_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Clock polarity select" ] # [ inline ( always ) ] pub fn ucckpl ( & self ) -> UCCKPL_R { UCCKPL_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Clock phase select" ] # [ inline ( always ) ] pub fn ucckph ( & self ) -> UCCKPH_R { UCCKPH_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & mut self ) -> UCSWRST_W { UCSWRST_W { w : self } }
# [ doc = "Bit 1 - STE mode select in master mode." ] # [ inline ( always ) ] pub fn ucstem ( & mut self ) -> UCSTEM_W { UCSTEM_W { w : self } }
# [ doc = "Bits 6:7 - eUSCI_A clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & mut self ) -> UCSSEL_W { UCSSEL_W { w : self } }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & mut self ) -> UCSYNC_W { UCSYNC_W { w : self } }
# [ doc = "Bits 9:10 - eUSCI mode" ] # [ inline ( always ) ] pub fn ucmode ( & mut self ) -> UCMODE_W { UCMODE_W { w : self } }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & mut self ) -> UCMST_W { UCMST_W { w : self } }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & mut self ) -> UC7BIT_W { UC7BIT_W { w : self } }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & mut self ) -> UCMSB_W { UCMSB_W { w : self } }
# [ doc = "Bit 14 - Clock polarity select" ] # [ inline ( always ) ] pub fn ucckpl ( & mut self ) -> UCCKPL_W { UCCKPL_W { w : self } }
# [ doc = "Bit 15 - Clock phase select" ] # [ inline ( always ) ] pub fn ucckph ( & mut self ) -> UCCKPH_W { UCCKPH_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Control Word Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ctlw1](uca0ctlw1) module" ] pub type UCA0CTLW1 = crate :: Reg < u16 , _UCA0CTLW1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0CTLW1 ;
# [ doc = "`read()` method returns [uca0ctlw1::R](uca0ctlw1::R) reader structure" ] impl crate :: Readable for UCA0CTLW1 { }
# [ doc = "`write(|w| ..)` method takes [uca0ctlw1::W](uca0ctlw1::W) writer structure" ] impl crate :: Writable for UCA0CTLW1 { }
# [ doc = "eUSCI_Ax Control Word Register 1" ] pub mod uca0ctlw1 {
# [ doc = "Reader of register UCA0CTLW1" ] pub type R = crate :: R < u16 , super :: UCA0CTLW1 > ;
# [ doc = "Writer for register UCA0CTLW1" ] pub type W = crate :: W < u16 , super :: UCA0CTLW1 > ;
# [ doc = "Register UCA0CTLW1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0CTLW1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Deglitch time\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCGLIT_A { # [ doc = "0: Approximately 2 ns (equivalent of 1 delay element)" ] UCGLIT_0 = 0 , # [ doc = "1: Approximately 50 ns" ] UCGLIT_1 = 1 , # [ doc = "2: Approximately 100 ns" ] UCGLIT_2 = 2 , # [ doc = "3: Approximately 200 ns" ] UCGLIT_3 = 3 } impl From < UCGLIT_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCGLIT_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCGLIT`" ] pub type UCGLIT_R = crate :: R < u8 , UCGLIT_A > ; impl UCGLIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCGLIT_A { match self . bits { 0 => UCGLIT_A :: UCGLIT_0 , 1 => UCGLIT_A :: UCGLIT_1 , 2 => UCGLIT_A :: UCGLIT_2 , 3 => UCGLIT_A :: UCGLIT_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCGLIT_0`" ] # [ inline ( always ) ] pub fn is_ucglit_0 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_0 } # [ doc = "Checks if the value of the field is `UCGLIT_1`" ] # [ inline ( always ) ] pub fn is_ucglit_1 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_1 } # [ doc = "Checks if the value of the field is `UCGLIT_2`" ] # [ inline ( always ) ] pub fn is_ucglit_2 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_2 } # [ doc = "Checks if the value of the field is `UCGLIT_3`" ] # [ inline ( always ) ] pub fn is_ucglit_3 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_3 } }
# [ doc = "Write proxy for field `UCGLIT`" ] pub struct UCGLIT_W < 'a > { w : & 'a mut W , } impl < 'a > UCGLIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCGLIT_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Approximately 2 ns (equivalent of 1 delay element)" ] # [ inline ( always ) ] pub fn ucglit_0 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_0 ) } # [ doc = "Approximately 50 ns" ] # [ inline ( always ) ] pub fn ucglit_1 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_1 ) } # [ doc = "Approximately 100 ns" ] # [ inline ( always ) ] pub fn ucglit_2 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_2 ) } # [ doc = "Approximately 200 ns" ] # [ inline ( always ) ] pub fn ucglit_3 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Deglitch time" ] # [ inline ( always ) ] pub fn ucglit ( & self ) -> UCGLIT_R { UCGLIT_R :: new ( ( self . bits & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - Deglitch time" ] # [ inline ( always ) ] pub fn ucglit ( & mut self ) -> UCGLIT_W { UCGLIT_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Baud Rate Control Word Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0brw](uca0brw) module" ] pub type UCA0BRW = crate :: Reg < u16 , _UCA0BRW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0BRW ;
# [ doc = "`read()` method returns [uca0brw::R](uca0brw::R) reader structure" ] impl crate :: Readable for UCA0BRW { }
# [ doc = "`write(|w| ..)` method takes [uca0brw::W](uca0brw::W) writer structure" ] impl crate :: Writable for UCA0BRW { }
# [ doc = "eUSCI_Ax Baud Rate Control Word Register" ] pub mod uca0brw {
# [ doc = "Reader of register UCA0BRW" ] pub type R = crate :: R < u16 , super :: UCA0BRW > ;
# [ doc = "Writer for register UCA0BRW" ] pub type W = crate :: W < u16 , super :: UCA0BRW > ;
# [ doc = "Register UCA0BRW `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0BRW { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "eUSCI_Ax Bit Rate Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0brw_spi](uca0brw_spi) module" ] pub type UCA0BRW_SPI = crate :: Reg < u16 , _UCA0BRW_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0BRW_SPI ;
# [ doc = "`read()` method returns [uca0brw_spi::R](uca0brw_spi::R) reader structure" ] impl crate :: Readable for UCA0BRW_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca0brw_spi::W](uca0brw_spi::W) writer structure" ] impl crate :: Writable for UCA0BRW_SPI { }
# [ doc = "eUSCI_Ax Bit Rate Control Register 1" ] pub mod uca0brw_spi {
# [ doc = "Reader of register UCA0BRW_SPI" ] pub type R = crate :: R < u16 , super :: UCA0BRW_SPI > ;
# [ doc = "Writer for register UCA0BRW_SPI" ] pub type W = crate :: W < u16 , super :: UCA0BRW_SPI > ;
# [ doc = "Register UCA0BRW_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0BRW_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "eUSCI_Ax Modulation Control Word Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0mctlw](uca0mctlw) module" ] pub type UCA0MCTLW = crate :: Reg < u16 , _UCA0MCTLW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0MCTLW ;
# [ doc = "`read()` method returns [uca0mctlw::R](uca0mctlw::R) reader structure" ] impl crate :: Readable for UCA0MCTLW { }
# [ doc = "`write(|w| ..)` method takes [uca0mctlw::W](uca0mctlw::W) writer structure" ] impl crate :: Writable for UCA0MCTLW { }
# [ doc = "eUSCI_Ax Modulation Control Word Register" ] pub mod uca0mctlw {
# [ doc = "Reader of register UCA0MCTLW" ] pub type R = crate :: R < u16 , super :: UCA0MCTLW > ;
# [ doc = "Writer for register UCA0MCTLW" ] pub type W = crate :: W < u16 , super :: UCA0MCTLW > ;
# [ doc = "Register UCA0MCTLW `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0MCTLW { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Oversampling mode enabled\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOS16_A { # [ doc = "0: Disabled" ] UCOS16_0 = 0 , # [ doc = "1: Enabled" ] UCOS16_1 = 1 } impl From < UCOS16_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOS16_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOS16`" ] pub type UCOS16_R = crate :: R < bool , UCOS16_A > ; impl UCOS16_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOS16_A { match self . bits { false => UCOS16_A :: UCOS16_0 , true => UCOS16_A :: UCOS16_1 } } # [ doc = "Checks if the value of the field is `UCOS16_0`" ] # [ inline ( always ) ] pub fn is_ucos16_0 ( & self ) -> bool { * self == UCOS16_A :: UCOS16_0 } # [ doc = "Checks if the value of the field is `UCOS16_1`" ] # [ inline ( always ) ] pub fn is_ucos16_1 ( & self ) -> bool { * self == UCOS16_A :: UCOS16_1 } }
# [ doc = "Write proxy for field `UCOS16`" ] pub struct UCOS16_W < 'a > { w : & 'a mut W , } impl < 'a > UCOS16_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOS16_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn ucos16_0 ( self ) -> & 'a mut W { self . variant ( UCOS16_A :: UCOS16_0 ) } # [ doc = "Enabled" ] # [ inline ( always ) ] pub fn ucos16_1 ( self ) -> & 'a mut W { self . variant ( UCOS16_A :: UCOS16_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `UCBRF`" ] pub type UCBRF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCBRF`" ] pub struct UCBRF_W < 'a > { w : & 'a mut W , } impl < 'a > UCBRF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 4 ) ) | ( ( ( value as u16 ) & 0x0f ) << 4 ) ; self . w } }
# [ doc = "Reader of field `UCBRS`" ] pub type UCBRS_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCBRS`" ] pub struct UCBRS_W < 'a > { w : & 'a mut W , } impl < 'a > UCBRS_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 8 ) ) | ( ( ( value as u16 ) & 0xff ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Oversampling mode enabled" ] # [ inline ( always ) ] pub fn ucos16 ( & self ) -> UCOS16_R { UCOS16_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bits 4:7 - First modulation stage select" ] # [ inline ( always ) ] pub fn ucbrf ( & self ) -> UCBRF_R { UCBRF_R :: new ( ( ( self . bits >> 4 ) & 0x0f ) as u8 ) }
# [ doc = "Bits 8:15 - Second modulation stage select" ] # [ inline ( always ) ] pub fn ucbrs ( & self ) -> UCBRS_R { UCBRS_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Oversampling mode enabled" ] # [ inline ( always ) ] pub fn ucos16 ( & mut self ) -> UCOS16_W { UCOS16_W { w : self } }
# [ doc = "Bits 4:7 - First modulation stage select" ] # [ inline ( always ) ] pub fn ucbrf ( & mut self ) -> UCBRF_W { UCBRF_W { w : self } }
# [ doc = "Bits 8:15 - Second modulation stage select" ] # [ inline ( always ) ] pub fn ucbrs ( & mut self ) -> UCBRS_W { UCBRS_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0statw](uca0statw) module" ] pub type UCA0STATW = crate :: Reg < u16 , _UCA0STATW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0STATW ;
# [ doc = "`read()` method returns [uca0statw::R](uca0statw::R) reader structure" ] impl crate :: Readable for UCA0STATW { }
# [ doc = "`write(|w| ..)` method takes [uca0statw::W](uca0statw::W) writer structure" ] impl crate :: Writable for UCA0STATW { }
# [ doc = "eUSCI_Ax Status Register" ] pub mod uca0statw {
# [ doc = "Reader of register UCA0STATW" ] pub type R = crate :: R < u16 , super :: UCA0STATW > ;
# [ doc = "Writer for register UCA0STATW" ] pub type W = crate :: W < u16 , super :: UCA0STATW > ;
# [ doc = "Register UCA0STATW `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0STATW { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "eUSCI_A busy\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBUSY_A { # [ doc = "0: eUSCI_A inactive" ] IDLE = 0 , # [ doc = "1: eUSCI_A transmitting or receiving" ] BUSY = 1 } impl From < UCBUSY_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBUSY_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBUSY`" ] pub type UCBUSY_R = crate :: R < bool , UCBUSY_A > ; impl UCBUSY_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBUSY_A { match self . bits { false => UCBUSY_A :: IDLE , true => UCBUSY_A :: BUSY } } # [ doc = "Checks if the value of the field is `IDLE`" ] # [ inline ( always ) ] pub fn is_idle ( & self ) -> bool { * self == UCBUSY_A :: IDLE } # [ doc = "Checks if the value of the field is `BUSY`" ] # [ inline ( always ) ] pub fn is_busy ( & self ) -> bool { * self == UCBUSY_A :: BUSY } }
# [ doc = "Address received / Idle line detected\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCADDR_UCIDLE_A { # [ doc = "0: UCADDR: Received character is data. UCIDLE: No idle line detected" ] UCADDR_UCIDLE_0 = 0 , # [ doc = "1: UCADDR: Received character is an address. UCIDLE: Idle line detected" ] UCADDR_UCIDLE_1 = 1 } impl From < UCADDR_UCIDLE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCADDR_UCIDLE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCADDR_UCIDLE`" ] pub type UCADDR_UCIDLE_R = crate :: R < bool , UCADDR_UCIDLE_A > ; impl UCADDR_UCIDLE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCADDR_UCIDLE_A { match self . bits { false => UCADDR_UCIDLE_A :: UCADDR_UCIDLE_0 , true => UCADDR_UCIDLE_A :: UCADDR_UCIDLE_1 } } # [ doc = "Checks if the value of the field is `UCADDR_UCIDLE_0`" ] # [ inline ( always ) ] pub fn is_ucaddr_ucidle_0 ( & self ) -> bool { * self == UCADDR_UCIDLE_A :: UCADDR_UCIDLE_0 } # [ doc = "Checks if the value of the field is `UCADDR_UCIDLE_1`" ] # [ inline ( always ) ] pub fn is_ucaddr_ucidle_1 ( & self ) -> bool { * self == UCADDR_UCIDLE_A :: UCADDR_UCIDLE_1 } }
# [ doc = "Write proxy for field `UCADDR_UCIDLE`" ] pub struct UCADDR_UCIDLE_W < 'a > { w : & 'a mut W , } impl < 'a > UCADDR_UCIDLE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCADDR_UCIDLE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "UCADDR: Received character is data. UCIDLE: No idle line detected" ] # [ inline ( always ) ] pub fn ucaddr_ucidle_0 ( self ) -> & 'a mut W { self . variant ( UCADDR_UCIDLE_A :: UCADDR_UCIDLE_0 ) } # [ doc = "UCADDR: Received character is an address. UCIDLE: Idle line detected" ] # [ inline ( always ) ] pub fn ucaddr_ucidle_1 ( self ) -> & 'a mut W { self . variant ( UCADDR_UCIDLE_A :: UCADDR_UCIDLE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Receive error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXERR_A { # [ doc = "0: No receive errors detected" ] UCRXERR_0 = 0 , # [ doc = "1: Receive error detected" ] UCRXERR_1 = 1 } impl From < UCRXERR_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXERR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXERR`" ] pub type UCRXERR_R = crate :: R < bool , UCRXERR_A > ; impl UCRXERR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXERR_A { match self . bits { false => UCRXERR_A :: UCRXERR_0 , true => UCRXERR_A :: UCRXERR_1 } } # [ doc = "Checks if the value of the field is `UCRXERR_0`" ] # [ inline ( always ) ] pub fn is_ucrxerr_0 ( & self ) -> bool { * self == UCRXERR_A :: UCRXERR_0 } # [ doc = "Checks if the value of the field is `UCRXERR_1`" ] # [ inline ( always ) ] pub fn is_ucrxerr_1 ( & self ) -> bool { * self == UCRXERR_A :: UCRXERR_1 } }
# [ doc = "Write proxy for field `UCRXERR`" ] pub struct UCRXERR_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXERR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXERR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No receive errors detected" ] # [ inline ( always ) ] pub fn ucrxerr_0 ( self ) -> & 'a mut W { self . variant ( UCRXERR_A :: UCRXERR_0 ) } # [ doc = "Receive error detected" ] # [ inline ( always ) ] pub fn ucrxerr_1 ( self ) -> & 'a mut W { self . variant ( UCRXERR_A :: UCRXERR_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Break detect flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBRK_A { # [ doc = "0: No break condition" ] UCBRK_0 = 0 , # [ doc = "1: Break condition occurred" ] UCBRK_1 = 1 } impl From < UCBRK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBRK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBRK`" ] pub type UCBRK_R = crate :: R < bool , UCBRK_A > ; impl UCBRK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBRK_A { match self . bits { false => UCBRK_A :: UCBRK_0 , true => UCBRK_A :: UCBRK_1 } } # [ doc = "Checks if the value of the field is `UCBRK_0`" ] # [ inline ( always ) ] pub fn is_ucbrk_0 ( & self ) -> bool { * self == UCBRK_A :: UCBRK_0 } # [ doc = "Checks if the value of the field is `UCBRK_1`" ] # [ inline ( always ) ] pub fn is_ucbrk_1 ( & self ) -> bool { * self == UCBRK_A :: UCBRK_1 } }
# [ doc = "Write proxy for field `UCBRK`" ] pub struct UCBRK_W < 'a > { w : & 'a mut W , } impl < 'a > UCBRK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBRK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No break condition" ] # [ inline ( always ) ] pub fn ucbrk_0 ( self ) -> & 'a mut W { self . variant ( UCBRK_A :: UCBRK_0 ) } # [ doc = "Break condition occurred" ] # [ inline ( always ) ] pub fn ucbrk_1 ( self ) -> & 'a mut W { self . variant ( UCBRK_A :: UCBRK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Parity error flag. When UCPEN = 0, UCPE is read as 0. UCPE is cleared when UCAxRXBUF is read.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCPE_A { # [ doc = "0: No error" ] UCPE_0 = 0 , # [ doc = "1: Character received with parity error" ] UCPE_1 = 1 } impl From < UCPE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCPE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCPE`" ] pub type UCPE_R = crate :: R < bool , UCPE_A > ; impl UCPE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCPE_A { match self . bits { false => UCPE_A :: UCPE_0 , true => UCPE_A :: UCPE_1 } } # [ doc = "Checks if the value of the field is `UCPE_0`" ] # [ inline ( always ) ] pub fn is_ucpe_0 ( & self ) -> bool { * self == UCPE_A :: UCPE_0 } # [ doc = "Checks if the value of the field is `UCPE_1`" ] # [ inline ( always ) ] pub fn is_ucpe_1 ( & self ) -> bool { * self == UCPE_A :: UCPE_1 } }
# [ doc = "Write proxy for field `UCPE`" ] pub struct UCPE_W < 'a > { w : & 'a mut W , } impl < 'a > UCPE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCPE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucpe_0 ( self ) -> & 'a mut W { self . variant ( UCPE_A :: UCPE_0 ) } # [ doc = "Character received with parity error" ] # [ inline ( always ) ] pub fn ucpe_1 ( self ) -> & 'a mut W { self . variant ( UCPE_A :: UCPE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Overrun error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOE_A { # [ doc = "0: No error" ] UCOE_0 = 0 , # [ doc = "1: Overrun error occurred" ] UCOE_1 = 1 } impl From < UCOE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOE`" ] pub type UCOE_R = crate :: R < bool , UCOE_A > ; impl UCOE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOE_A { match self . bits { false => UCOE_A :: UCOE_0 , true => UCOE_A :: UCOE_1 } } # [ doc = "Checks if the value of the field is `UCOE_0`" ] # [ inline ( always ) ] pub fn is_ucoe_0 ( & self ) -> bool { * self == UCOE_A :: UCOE_0 } # [ doc = "Checks if the value of the field is `UCOE_1`" ] # [ inline ( always ) ] pub fn is_ucoe_1 ( & self ) -> bool { * self == UCOE_A :: UCOE_1 } }
# [ doc = "Write proxy for field `UCOE`" ] pub struct UCOE_W < 'a > { w : & 'a mut W , } impl < 'a > UCOE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucoe_0 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_0 ) } # [ doc = "Overrun error occurred" ] # [ inline ( always ) ] pub fn ucoe_1 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Framing error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCFE_A { # [ doc = "0: No error" ] UCFE_0 = 0 , # [ doc = "1: Character received with low stop bit" ] UCFE_1 = 1 } impl From < UCFE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCFE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCFE`" ] pub type UCFE_R = crate :: R < bool , UCFE_A > ; impl UCFE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCFE_A { match self . bits { false => UCFE_A :: UCFE_0 , true => UCFE_A :: UCFE_1 } } # [ doc = "Checks if the value of the field is `UCFE_0`" ] # [ inline ( always ) ] pub fn is_ucfe_0 ( & self ) -> bool { * self == UCFE_A :: UCFE_0 } # [ doc = "Checks if the value of the field is `UCFE_1`" ] # [ inline ( always ) ] pub fn is_ucfe_1 ( & self ) -> bool { * self == UCFE_A :: UCFE_1 } }
# [ doc = "Write proxy for field `UCFE`" ] pub struct UCFE_W < 'a > { w : & 'a mut W , } impl < 'a > UCFE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCFE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucfe_0 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_0 ) } # [ doc = "Character received with low stop bit" ] # [ inline ( always ) ] pub fn ucfe_1 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Listen enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCLISTEN_A { # [ doc = "0: Disabled" ] UCLISTEN_0 = 0 , # [ doc = "1: Enabled. UCAxTXD is internally fed back to the receiver" ] UCLISTEN_1 = 1 } impl From < UCLISTEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCLISTEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCLISTEN`" ] pub type UCLISTEN_R = crate :: R < bool , UCLISTEN_A > ; impl UCLISTEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCLISTEN_A { match self . bits { false => UCLISTEN_A :: UCLISTEN_0 , true => UCLISTEN_A :: UCLISTEN_1 } } # [ doc = "Checks if the value of the field is `UCLISTEN_0`" ] # [ inline ( always ) ] pub fn is_uclisten_0 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_0 } # [ doc = "Checks if the value of the field is `UCLISTEN_1`" ] # [ inline ( always ) ] pub fn is_uclisten_1 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_1 } }
# [ doc = "Write proxy for field `UCLISTEN`" ] pub struct UCLISTEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCLISTEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCLISTEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn uclisten_0 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_0 ) } # [ doc = "Enabled. UCAxTXD is internally fed back to the receiver" ] # [ inline ( always ) ] pub fn uclisten_1 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - eUSCI_A busy" ] # [ inline ( always ) ] pub fn ucbusy ( & self ) -> UCBUSY_R { UCBUSY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Address received / Idle line detected" ] # [ inline ( always ) ] pub fn ucaddr_ucidle ( & self ) -> UCADDR_UCIDLE_R { UCADDR_UCIDLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Receive error flag" ] # [ inline ( always ) ] pub fn ucrxerr ( & self ) -> UCRXERR_R { UCRXERR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Break detect flag" ] # [ inline ( always ) ] pub fn ucbrk ( & self ) -> UCBRK_R { UCBRK_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Parity error flag. When UCPEN = 0, UCPE is read as 0. UCPE is cleared when UCAxRXBUF is read." ] # [ inline ( always ) ] pub fn ucpe ( & self ) -> UCPE_R { UCPE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & self ) -> UCOE_R { UCOE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & self ) -> UCFE_R { UCFE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & self ) -> UCLISTEN_R { UCLISTEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 1 - Address received / Idle line detected" ] # [ inline ( always ) ] pub fn ucaddr_ucidle ( & mut self ) -> UCADDR_UCIDLE_W { UCADDR_UCIDLE_W { w : self } }
# [ doc = "Bit 2 - Receive error flag" ] # [ inline ( always ) ] pub fn ucrxerr ( & mut self ) -> UCRXERR_W { UCRXERR_W { w : self } }
# [ doc = "Bit 3 - Break detect flag" ] # [ inline ( always ) ] pub fn ucbrk ( & mut self ) -> UCBRK_W { UCBRK_W { w : self } }
# [ doc = "Bit 4 - Parity error flag. When UCPEN = 0, UCPE is read as 0. UCPE is cleared when UCAxRXBUF is read." ] # [ inline ( always ) ] pub fn ucpe ( & mut self ) -> UCPE_W { UCPE_W { w : self } }
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & mut self ) -> UCOE_W { UCOE_W { w : self } }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & mut self ) -> UCFE_W { UCFE_W { w : self } }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & mut self ) -> UCLISTEN_W { UCLISTEN_W { w : self } }
}
}
# [ doc = "UCA0STATW_SPI\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0statw_spi](uca0statw_spi) module" ] pub type UCA0STATW_SPI = crate :: Reg < u16 , _UCA0STATW_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0STATW_SPI ;
# [ doc = "`read()` method returns [uca0statw_spi::R](uca0statw_spi::R) reader structure" ] impl crate :: Readable for UCA0STATW_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca0statw_spi::W](uca0statw_spi::W) writer structure" ] impl crate :: Writable for UCA0STATW_SPI { }
# [ doc = "UCA0STATW_SPI" ] pub mod uca0statw_spi {
# [ doc = "Reader of register UCA0STATW_SPI" ] pub type R = crate :: R < u16 , super :: UCA0STATW_SPI > ;
# [ doc = "Writer for register UCA0STATW_SPI" ] pub type W = crate :: W < u16 , super :: UCA0STATW_SPI > ;
# [ doc = "Register UCA0STATW_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0STATW_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Overrun error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOE_A { # [ doc = "0: No error" ] UCOE_0 = 0 , # [ doc = "1: Overrun error occurred" ] UCOE_1 = 1 } impl From < UCOE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOE`" ] pub type UCOE_R = crate :: R < bool , UCOE_A > ; impl UCOE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOE_A { match self . bits { false => UCOE_A :: UCOE_0 , true => UCOE_A :: UCOE_1 } } # [ doc = "Checks if the value of the field is `UCOE_0`" ] # [ inline ( always ) ] pub fn is_ucoe_0 ( & self ) -> bool { * self == UCOE_A :: UCOE_0 } # [ doc = "Checks if the value of the field is `UCOE_1`" ] # [ inline ( always ) ] pub fn is_ucoe_1 ( & self ) -> bool { * self == UCOE_A :: UCOE_1 } }
# [ doc = "Write proxy for field `UCOE`" ] pub struct UCOE_W < 'a > { w : & 'a mut W , } impl < 'a > UCOE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucoe_0 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_0 ) } # [ doc = "Overrun error occurred" ] # [ inline ( always ) ] pub fn ucoe_1 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Framing error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCFE_A { # [ doc = "0: No error" ] UCFE_0 = 0 , # [ doc = "1: Bus conflict occurred" ] UCFE_1 = 1 } impl From < UCFE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCFE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCFE`" ] pub type UCFE_R = crate :: R < bool , UCFE_A > ; impl UCFE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCFE_A { match self . bits { false => UCFE_A :: UCFE_0 , true => UCFE_A :: UCFE_1 } } # [ doc = "Checks if the value of the field is `UCFE_0`" ] # [ inline ( always ) ] pub fn is_ucfe_0 ( & self ) -> bool { * self == UCFE_A :: UCFE_0 } # [ doc = "Checks if the value of the field is `UCFE_1`" ] # [ inline ( always ) ] pub fn is_ucfe_1 ( & self ) -> bool { * self == UCFE_A :: UCFE_1 } }
# [ doc = "Write proxy for field `UCFE`" ] pub struct UCFE_W < 'a > { w : & 'a mut W , } impl < 'a > UCFE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCFE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucfe_0 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_0 ) } # [ doc = "Bus conflict occurred" ] # [ inline ( always ) ] pub fn ucfe_1 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Listen enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCLISTEN_A { # [ doc = "0: Disabled" ] UCLISTEN_0 = 0 , # [ doc = "1: Enabled. UCAxTXD is internally fed back to the receiver" ] UCLISTEN_1 = 1 } impl From < UCLISTEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCLISTEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCLISTEN`" ] pub type UCLISTEN_R = crate :: R < bool , UCLISTEN_A > ; impl UCLISTEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCLISTEN_A { match self . bits { false => UCLISTEN_A :: UCLISTEN_0 , true => UCLISTEN_A :: UCLISTEN_1 } } # [ doc = "Checks if the value of the field is `UCLISTEN_0`" ] # [ inline ( always ) ] pub fn is_uclisten_0 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_0 } # [ doc = "Checks if the value of the field is `UCLISTEN_1`" ] # [ inline ( always ) ] pub fn is_uclisten_1 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_1 } }
# [ doc = "Write proxy for field `UCLISTEN`" ] pub struct UCLISTEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCLISTEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCLISTEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn uclisten_0 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_0 ) } # [ doc = "Enabled. UCAxTXD is internally fed back to the receiver" ] # [ inline ( always ) ] pub fn uclisten_1 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & self ) -> UCOE_R { UCOE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & self ) -> UCFE_R { UCFE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & self ) -> UCLISTEN_R { UCLISTEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & mut self ) -> UCOE_W { UCOE_W { w : self } }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & mut self ) -> UCFE_W { UCFE_W { w : self } }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & mut self ) -> UCLISTEN_W { UCLISTEN_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Receive Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0rxbuf](uca0rxbuf) module" ] pub type UCA0RXBUF = crate :: Reg < u16 , _UCA0RXBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0RXBUF ;
# [ doc = "`read()` method returns [uca0rxbuf::R](uca0rxbuf::R) reader structure" ] impl crate :: Readable for UCA0RXBUF { }
# [ doc = "eUSCI_Ax Receive Buffer Register" ] pub mod uca0rxbuf {
# [ doc = "Reader of register UCA0RXBUF" ] pub type R = crate :: R < u16 , super :: UCA0RXBUF > ;
# [ doc = "Reader of field `UCRXBUF`" ] pub type UCRXBUF_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Receive data buffer" ] # [ inline ( always ) ] pub fn ucrxbuf ( & self ) -> UCRXBUF_R { UCRXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
}
# [ doc = "eUSCI_Ax Receive Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0rxbuf_spi](uca0rxbuf_spi) module" ] pub type UCA0RXBUF_SPI = crate :: Reg < u16 , _UCA0RXBUF_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0RXBUF_SPI ;
# [ doc = "`read()` method returns [uca0rxbuf_spi::R](uca0rxbuf_spi::R) reader structure" ] impl crate :: Readable for UCA0RXBUF_SPI { }
# [ doc = "eUSCI_Ax Receive Buffer Register" ] pub mod uca0rxbuf_spi {
# [ doc = "Reader of register UCA0RXBUF_SPI" ] pub type R = crate :: R < u16 , super :: UCA0RXBUF_SPI > ;
# [ doc = "Reader of field `UCRXBUF`" ] pub type UCRXBUF_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Receive data buffer" ] # [ inline ( always ) ] pub fn ucrxbuf ( & self ) -> UCRXBUF_R { UCRXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
}
# [ doc = "eUSCI_Ax Transmit Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0txbuf](uca0txbuf) module" ] pub type UCA0TXBUF = crate :: Reg < u16 , _UCA0TXBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0TXBUF ;
# [ doc = "`read()` method returns [uca0txbuf::R](uca0txbuf::R) reader structure" ] impl crate :: Readable for UCA0TXBUF { }
# [ doc = "`write(|w| ..)` method takes [uca0txbuf::W](uca0txbuf::W) writer structure" ] impl crate :: Writable for UCA0TXBUF { }
# [ doc = "eUSCI_Ax Transmit Buffer Register" ] pub mod uca0txbuf {
# [ doc = "Reader of register UCA0TXBUF" ] pub type R = crate :: R < u16 , super :: UCA0TXBUF > ;
# [ doc = "Writer for register UCA0TXBUF" ] pub type W = crate :: W < u16 , super :: UCA0TXBUF > ;
# [ doc = "Register UCA0TXBUF `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0TXBUF { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UCTXBUF`" ] pub type UCTXBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCTXBUF`" ] pub struct UCTXBUF_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & self ) -> UCTXBUF_R { UCTXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & mut self ) -> UCTXBUF_W { UCTXBUF_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Transmit Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0txbuf_spi](uca0txbuf_spi) module" ] pub type UCA0TXBUF_SPI = crate :: Reg < u16 , _UCA0TXBUF_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0TXBUF_SPI ;
# [ doc = "`read()` method returns [uca0txbuf_spi::R](uca0txbuf_spi::R) reader structure" ] impl crate :: Readable for UCA0TXBUF_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca0txbuf_spi::W](uca0txbuf_spi::W) writer structure" ] impl crate :: Writable for UCA0TXBUF_SPI { }
# [ doc = "eUSCI_Ax Transmit Buffer Register" ] pub mod uca0txbuf_spi {
# [ doc = "Reader of register UCA0TXBUF_SPI" ] pub type R = crate :: R < u16 , super :: UCA0TXBUF_SPI > ;
# [ doc = "Writer for register UCA0TXBUF_SPI" ] pub type W = crate :: W < u16 , super :: UCA0TXBUF_SPI > ;
# [ doc = "Register UCA0TXBUF_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0TXBUF_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UCTXBUF`" ] pub type UCTXBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCTXBUF`" ] pub struct UCTXBUF_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & self ) -> UCTXBUF_R { UCTXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & mut self ) -> UCTXBUF_W { UCTXBUF_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Auto Baud Rate Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0abctl](uca0abctl) module" ] pub type UCA0ABCTL = crate :: Reg < u16 , _UCA0ABCTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0ABCTL ;
# [ doc = "`read()` method returns [uca0abctl::R](uca0abctl::R) reader structure" ] impl crate :: Readable for UCA0ABCTL { }
# [ doc = "`write(|w| ..)` method takes [uca0abctl::W](uca0abctl::W) writer structure" ] impl crate :: Writable for UCA0ABCTL { }
# [ doc = "eUSCI_Ax Auto Baud Rate Control Register" ] pub mod uca0abctl {
# [ doc = "Reader of register UCA0ABCTL" ] pub type R = crate :: R < u16 , super :: UCA0ABCTL > ;
# [ doc = "Writer for register UCA0ABCTL" ] pub type W = crate :: W < u16 , super :: UCA0ABCTL > ;
# [ doc = "Register UCA0ABCTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0ABCTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Automatic baud-rate detect enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCABDEN_A { # [ doc = "0: Baud-rate detection disabled. Length of break and synch field is not measured." ] UCABDEN_0 = 0 , # [ doc = "1: Baud-rate detection enabled. Length of break and synch field is measured and baud-rate settings are changed accordingly." ] UCABDEN_1 = 1 } impl From < UCABDEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCABDEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCABDEN`" ] pub type UCABDEN_R = crate :: R < bool , UCABDEN_A > ; impl UCABDEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCABDEN_A { match self . bits { false => UCABDEN_A :: UCABDEN_0 , true => UCABDEN_A :: UCABDEN_1 } } # [ doc = "Checks if the value of the field is `UCABDEN_0`" ] # [ inline ( always ) ] pub fn is_ucabden_0 ( & self ) -> bool { * self == UCABDEN_A :: UCABDEN_0 } # [ doc = "Checks if the value of the field is `UCABDEN_1`" ] # [ inline ( always ) ] pub fn is_ucabden_1 ( & self ) -> bool { * self == UCABDEN_A :: UCABDEN_1 } }
# [ doc = "Write proxy for field `UCABDEN`" ] pub struct UCABDEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCABDEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCABDEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Baud-rate detection disabled. Length of break and synch field is not measured." ] # [ inline ( always ) ] pub fn ucabden_0 ( self ) -> & 'a mut W { self . variant ( UCABDEN_A :: UCABDEN_0 ) } # [ doc = "Baud-rate detection enabled. Length of break and synch field is measured and baud-rate settings are changed accordingly." ] # [ inline ( always ) ] pub fn ucabden_1 ( self ) -> & 'a mut W { self . variant ( UCABDEN_A :: UCABDEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Break time out error\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBTOE_A { # [ doc = "0: No error" ] UCBTOE_0 = 0 , # [ doc = "1: Length of break field exceeded 22 bit times" ] UCBTOE_1 = 1 } impl From < UCBTOE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBTOE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBTOE`" ] pub type UCBTOE_R = crate :: R < bool , UCBTOE_A > ; impl UCBTOE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBTOE_A { match self . bits { false => UCBTOE_A :: UCBTOE_0 , true => UCBTOE_A :: UCBTOE_1 } } # [ doc = "Checks if the value of the field is `UCBTOE_0`" ] # [ inline ( always ) ] pub fn is_ucbtoe_0 ( & self ) -> bool { * self == UCBTOE_A :: UCBTOE_0 } # [ doc = "Checks if the value of the field is `UCBTOE_1`" ] # [ inline ( always ) ] pub fn is_ucbtoe_1 ( & self ) -> bool { * self == UCBTOE_A :: UCBTOE_1 } }
# [ doc = "Write proxy for field `UCBTOE`" ] pub struct UCBTOE_W < 'a > { w : & 'a mut W , } impl < 'a > UCBTOE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBTOE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucbtoe_0 ( self ) -> & 'a mut W { self . variant ( UCBTOE_A :: UCBTOE_0 ) } # [ doc = "Length of break field exceeded 22 bit times" ] # [ inline ( always ) ] pub fn ucbtoe_1 ( self ) -> & 'a mut W { self . variant ( UCBTOE_A :: UCBTOE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Synch field time out error\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTOE_A { # [ doc = "0: No error" ] UCSTOE_0 = 0 , # [ doc = "1: Length of synch field exceeded measurable time" ] UCSTOE_1 = 1 } impl From < UCSTOE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTOE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTOE`" ] pub type UCSTOE_R = crate :: R < bool , UCSTOE_A > ; impl UCSTOE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTOE_A { match self . bits { false => UCSTOE_A :: UCSTOE_0 , true => UCSTOE_A :: UCSTOE_1 } } # [ doc = "Checks if the value of the field is `UCSTOE_0`" ] # [ inline ( always ) ] pub fn is_ucstoe_0 ( & self ) -> bool { * self == UCSTOE_A :: UCSTOE_0 } # [ doc = "Checks if the value of the field is `UCSTOE_1`" ] # [ inline ( always ) ] pub fn is_ucstoe_1 ( & self ) -> bool { * self == UCSTOE_A :: UCSTOE_1 } }
# [ doc = "Write proxy for field `UCSTOE`" ] pub struct UCSTOE_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTOE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTOE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucstoe_0 ( self ) -> & 'a mut W { self . variant ( UCSTOE_A :: UCSTOE_0 ) } # [ doc = "Length of synch field exceeded measurable time" ] # [ inline ( always ) ] pub fn ucstoe_1 ( self ) -> & 'a mut W { self . variant ( UCSTOE_A :: UCSTOE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Break/synch delimiter length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCDELIM_A { # [ doc = "0: 1 bit time" ] UCDELIM_0 = 0 , # [ doc = "1: 2 bit times" ] UCDELIM_1 = 1 , # [ doc = "2: 3 bit times" ] UCDELIM_2 = 2 , # [ doc = "3: 4 bit times" ] UCDELIM_3 = 3 } impl From < UCDELIM_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCDELIM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCDELIM`" ] pub type UCDELIM_R = crate :: R < u8 , UCDELIM_A > ; impl UCDELIM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCDELIM_A { match self . bits { 0 => UCDELIM_A :: UCDELIM_0 , 1 => UCDELIM_A :: UCDELIM_1 , 2 => UCDELIM_A :: UCDELIM_2 , 3 => UCDELIM_A :: UCDELIM_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCDELIM_0`" ] # [ inline ( always ) ] pub fn is_ucdelim_0 ( & self ) -> bool { * self == UCDELIM_A :: UCDELIM_0 } # [ doc = "Checks if the value of the field is `UCDELIM_1`" ] # [ inline ( always ) ] pub fn is_ucdelim_1 ( & self ) -> bool { * self == UCDELIM_A :: UCDELIM_1 } # [ doc = "Checks if the value of the field is `UCDELIM_2`" ] # [ inline ( always ) ] pub fn is_ucdelim_2 ( & self ) -> bool { * self == UCDELIM_A :: UCDELIM_2 } # [ doc = "Checks if the value of the field is `UCDELIM_3`" ] # [ inline ( always ) ] pub fn is_ucdelim_3 ( & self ) -> bool { * self == UCDELIM_A :: UCDELIM_3 } }
# [ doc = "Write proxy for field `UCDELIM`" ] pub struct UCDELIM_W < 'a > { w : & 'a mut W , } impl < 'a > UCDELIM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCDELIM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "1 bit time" ] # [ inline ( always ) ] pub fn ucdelim_0 ( self ) -> & 'a mut W { self . variant ( UCDELIM_A :: UCDELIM_0 ) } # [ doc = "2 bit times" ] # [ inline ( always ) ] pub fn ucdelim_1 ( self ) -> & 'a mut W { self . variant ( UCDELIM_A :: UCDELIM_1 ) } # [ doc = "3 bit times" ] # [ inline ( always ) ] pub fn ucdelim_2 ( self ) -> & 'a mut W { self . variant ( UCDELIM_A :: UCDELIM_2 ) } # [ doc = "4 bit times" ] # [ inline ( always ) ] pub fn ucdelim_3 ( self ) -> & 'a mut W { self . variant ( UCDELIM_A :: UCDELIM_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Automatic baud-rate detect enable" ] # [ inline ( always ) ] pub fn ucabden ( & self ) -> UCABDEN_R { UCABDEN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Break time out error" ] # [ inline ( always ) ] pub fn ucbtoe ( & self ) -> UCBTOE_R { UCBTOE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Synch field time out error" ] # [ inline ( always ) ] pub fn ucstoe ( & self ) -> UCSTOE_R { UCSTOE_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - Break/synch delimiter length" ] # [ inline ( always ) ] pub fn ucdelim ( & self ) -> UCDELIM_R { UCDELIM_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Automatic baud-rate detect enable" ] # [ inline ( always ) ] pub fn ucabden ( & mut self ) -> UCABDEN_W { UCABDEN_W { w : self } }
# [ doc = "Bit 2 - Break time out error" ] # [ inline ( always ) ] pub fn ucbtoe ( & mut self ) -> UCBTOE_W { UCBTOE_W { w : self } }
# [ doc = "Bit 3 - Synch field time out error" ] # [ inline ( always ) ] pub fn ucstoe ( & mut self ) -> UCSTOE_W { UCSTOE_W { w : self } }
# [ doc = "Bits 4:5 - Break/synch delimiter length" ] # [ inline ( always ) ] pub fn ucdelim ( & mut self ) -> UCDELIM_W { UCDELIM_W { w : self } }
}
}
# [ doc = "eUSCI_Ax IrDA Control Word Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0irctl](uca0irctl) module" ] pub type UCA0IRCTL = crate :: Reg < u16 , _UCA0IRCTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0IRCTL ;
# [ doc = "`read()` method returns [uca0irctl::R](uca0irctl::R) reader structure" ] impl crate :: Readable for UCA0IRCTL { }
# [ doc = "`write(|w| ..)` method takes [uca0irctl::W](uca0irctl::W) writer structure" ] impl crate :: Writable for UCA0IRCTL { }
# [ doc = "eUSCI_Ax IrDA Control Word Register" ] pub mod uca0irctl {
# [ doc = "Reader of register UCA0IRCTL" ] pub type R = crate :: R < u16 , super :: UCA0IRCTL > ;
# [ doc = "Writer for register UCA0IRCTL" ] pub type W = crate :: W < u16 , super :: UCA0IRCTL > ;
# [ doc = "Register UCA0IRCTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0IRCTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "IrDA encoder/decoder enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCIREN_A { # [ doc = "0: IrDA encoder/decoder disabled" ] UCIREN_0 = 0 , # [ doc = "1: IrDA encoder/decoder enabled" ] UCIREN_1 = 1 } impl From < UCIREN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCIREN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCIREN`" ] pub type UCIREN_R = crate :: R < bool , UCIREN_A > ; impl UCIREN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCIREN_A { match self . bits { false => UCIREN_A :: UCIREN_0 , true => UCIREN_A :: UCIREN_1 } } # [ doc = "Checks if the value of the field is `UCIREN_0`" ] # [ inline ( always ) ] pub fn is_uciren_0 ( & self ) -> bool { * self == UCIREN_A :: UCIREN_0 } # [ doc = "Checks if the value of the field is `UCIREN_1`" ] # [ inline ( always ) ] pub fn is_uciren_1 ( & self ) -> bool { * self == UCIREN_A :: UCIREN_1 } }
# [ doc = "Write proxy for field `UCIREN`" ] pub struct UCIREN_W < 'a > { w : & 'a mut W , } impl < 'a > UCIREN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCIREN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "IrDA encoder/decoder disabled" ] # [ inline ( always ) ] pub fn uciren_0 ( self ) -> & 'a mut W { self . variant ( UCIREN_A :: UCIREN_0 ) } # [ doc = "IrDA encoder/decoder enabled" ] # [ inline ( always ) ] pub fn uciren_1 ( self ) -> & 'a mut W { self . variant ( UCIREN_A :: UCIREN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "IrDA transmit pulse clock select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCIRTXCLK_A { # [ doc = "0: BRCLK" ] UCIRTXCLK_0 = 0 , # [ doc = "1: BITCLK16 when UCOS16 = 1. Otherwise, BRCLK." ] UCIRTXCLK_1 = 1 } impl From < UCIRTXCLK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCIRTXCLK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCIRTXCLK`" ] pub type UCIRTXCLK_R = crate :: R < bool , UCIRTXCLK_A > ; impl UCIRTXCLK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCIRTXCLK_A { match self . bits { false => UCIRTXCLK_A :: UCIRTXCLK_0 , true => UCIRTXCLK_A :: UCIRTXCLK_1 } } # [ doc = "Checks if the value of the field is `UCIRTXCLK_0`" ] # [ inline ( always ) ] pub fn is_ucirtxclk_0 ( & self ) -> bool { * self == UCIRTXCLK_A :: UCIRTXCLK_0 } # [ doc = "Checks if the value of the field is `UCIRTXCLK_1`" ] # [ inline ( always ) ] pub fn is_ucirtxclk_1 ( & self ) -> bool { * self == UCIRTXCLK_A :: UCIRTXCLK_1 } }
# [ doc = "Write proxy for field `UCIRTXCLK`" ] pub struct UCIRTXCLK_W < 'a > { w : & 'a mut W , } impl < 'a > UCIRTXCLK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCIRTXCLK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "BRCLK" ] # [ inline ( always ) ] pub fn ucirtxclk_0 ( self ) -> & 'a mut W { self . variant ( UCIRTXCLK_A :: UCIRTXCLK_0 ) } # [ doc = "BITCLK16 when UCOS16 = 1. Otherwise, BRCLK." ] # [ inline ( always ) ] pub fn ucirtxclk_1 ( self ) -> & 'a mut W { self . variant ( UCIRTXCLK_A :: UCIRTXCLK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `UCIRTXPL`" ] pub type UCIRTXPL_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCIRTXPL`" ] pub struct UCIRTXPL_W < 'a > { w : & 'a mut W , } impl < 'a > UCIRTXPL_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 2 ) ) | ( ( ( value as u16 ) & 0x3f ) << 2 ) ; self . w } }
# [ doc = "IrDA receive filter enabled\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCIRRXFE_A { # [ doc = "0: Receive filter disabled" ] UCIRRXFE_0 = 0 , # [ doc = "1: Receive filter enabled" ] UCIRRXFE_1 = 1 } impl From < UCIRRXFE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCIRRXFE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCIRRXFE`" ] pub type UCIRRXFE_R = crate :: R < bool , UCIRRXFE_A > ; impl UCIRRXFE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCIRRXFE_A { match self . bits { false => UCIRRXFE_A :: UCIRRXFE_0 , true => UCIRRXFE_A :: UCIRRXFE_1 } } # [ doc = "Checks if the value of the field is `UCIRRXFE_0`" ] # [ inline ( always ) ] pub fn is_ucirrxfe_0 ( & self ) -> bool { * self == UCIRRXFE_A :: UCIRRXFE_0 } # [ doc = "Checks if the value of the field is `UCIRRXFE_1`" ] # [ inline ( always ) ] pub fn is_ucirrxfe_1 ( & self ) -> bool { * self == UCIRRXFE_A :: UCIRRXFE_1 } }
# [ doc = "Write proxy for field `UCIRRXFE`" ] pub struct UCIRRXFE_W < 'a > { w : & 'a mut W , } impl < 'a > UCIRRXFE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCIRRXFE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Receive filter disabled" ] # [ inline ( always ) ] pub fn ucirrxfe_0 ( self ) -> & 'a mut W { self . variant ( UCIRRXFE_A :: UCIRRXFE_0 ) } # [ doc = "Receive filter enabled" ] # [ inline ( always ) ] pub fn ucirrxfe_1 ( self ) -> & 'a mut W { self . variant ( UCIRRXFE_A :: UCIRRXFE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "IrDA receive input UCAxRXD polarity\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCIRRXPL_A { # [ doc = "0: IrDA transceiver delivers a high pulse when a light pulse is seen" ] HIGH = 0 , # [ doc = "1: IrDA transceiver delivers a low pulse when a light pulse is seen" ] LOW = 1 } impl From < UCIRRXPL_A > for bool { # [ inline ( always ) ] fn from ( variant : UCIRRXPL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCIRRXPL`" ] pub type UCIRRXPL_R = crate :: R < bool , UCIRRXPL_A > ; impl UCIRRXPL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCIRRXPL_A { match self . bits { false => UCIRRXPL_A :: HIGH , true => UCIRRXPL_A :: LOW } } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == UCIRRXPL_A :: HIGH } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == UCIRRXPL_A :: LOW } }
# [ doc = "Write proxy for field `UCIRRXPL`" ] pub struct UCIRRXPL_W < 'a > { w : & 'a mut W , } impl < 'a > UCIRRXPL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCIRRXPL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "IrDA transceiver delivers a high pulse when a light pulse is seen" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( UCIRRXPL_A :: HIGH ) } # [ doc = "IrDA transceiver delivers a low pulse when a light pulse is seen" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( UCIRRXPL_A :: LOW ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `UCIRRXFL`" ] pub type UCIRRXFL_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCIRRXFL`" ] pub struct UCIRRXFL_W < 'a > { w : & 'a mut W , } impl < 'a > UCIRRXFL_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 10 ) ) | ( ( ( value as u16 ) & 0x3f ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - IrDA encoder/decoder enable" ] # [ inline ( always ) ] pub fn uciren ( & self ) -> UCIREN_R { UCIREN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - IrDA transmit pulse clock select" ] # [ inline ( always ) ] pub fn ucirtxclk ( & self ) -> UCIRTXCLK_R { UCIRTXCLK_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 2:7 - Transmit pulse length" ] # [ inline ( always ) ] pub fn ucirtxpl ( & self ) -> UCIRTXPL_R { UCIRTXPL_R :: new ( ( ( self . bits >> 2 ) & 0x3f ) as u8 ) }
# [ doc = "Bit 8 - IrDA receive filter enabled" ] # [ inline ( always ) ] pub fn ucirrxfe ( & self ) -> UCIRRXFE_R { UCIRRXFE_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - IrDA receive input UCAxRXD polarity" ] # [ inline ( always ) ] pub fn ucirrxpl ( & self ) -> UCIRRXPL_R { UCIRRXPL_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 10:15 - Receive filter length" ] # [ inline ( always ) ] pub fn ucirrxfl ( & self ) -> UCIRRXFL_R { UCIRRXFL_R :: new ( ( ( self . bits >> 10 ) & 0x3f ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - IrDA encoder/decoder enable" ] # [ inline ( always ) ] pub fn uciren ( & mut self ) -> UCIREN_W { UCIREN_W { w : self } }
# [ doc = "Bit 1 - IrDA transmit pulse clock select" ] # [ inline ( always ) ] pub fn ucirtxclk ( & mut self ) -> UCIRTXCLK_W { UCIRTXCLK_W { w : self } }
# [ doc = "Bits 2:7 - Transmit pulse length" ] # [ inline ( always ) ] pub fn ucirtxpl ( & mut self ) -> UCIRTXPL_W { UCIRTXPL_W { w : self } }
# [ doc = "Bit 8 - IrDA receive filter enabled" ] # [ inline ( always ) ] pub fn ucirrxfe ( & mut self ) -> UCIRRXFE_W { UCIRRXFE_W { w : self } }
# [ doc = "Bit 9 - IrDA receive input UCAxRXD polarity" ] # [ inline ( always ) ] pub fn ucirrxpl ( & mut self ) -> UCIRRXPL_W { UCIRRXPL_W { w : self } }
# [ doc = "Bits 10:15 - Receive filter length" ] # [ inline ( always ) ] pub fn ucirrxfl ( & mut self ) -> UCIRRXFL_W { UCIRRXFL_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ie](uca0ie) module" ] pub type UCA0IE = crate :: Reg < u16 , _UCA0IE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0IE ;
# [ doc = "`read()` method returns [uca0ie::R](uca0ie::R) reader structure" ] impl crate :: Readable for UCA0IE { }
# [ doc = "`write(|w| ..)` method takes [uca0ie::W](uca0ie::W) writer structure" ] impl crate :: Writable for UCA0IE { }
# [ doc = "eUSCI_Ax Interrupt Enable Register" ] pub mod uca0ie {
# [ doc = "Reader of register UCA0IE" ] pub type R = crate :: R < u16 , super :: UCA0IE > ;
# [ doc = "Writer for register UCA0IE" ] pub type W = crate :: W < u16 , super :: UCA0IE > ;
# [ doc = "Register UCA0IE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0IE { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE_A { # [ doc = "0: Interrupt disabled" ] UCRXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE_1 = 1 } impl From < UCRXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE`" ] pub type UCRXIE_R = crate :: R < bool , UCRXIE_A > ; impl UCRXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE_A { match self . bits { false => UCRXIE_A :: UCRXIE_0 , true => UCRXIE_A :: UCRXIE_1 } } # [ doc = "Checks if the value of the field is `UCRXIE_0`" ] # [ inline ( always ) ] pub fn is_ucrxie_0 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_0 } # [ doc = "Checks if the value of the field is `UCRXIE_1`" ] # [ inline ( always ) ] pub fn is_ucrxie_1 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_1 } }
# [ doc = "Write proxy for field `UCRXIE`" ] pub struct UCRXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE_A { # [ doc = "0: Interrupt disabled" ] UCTXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE_1 = 1 } impl From < UCTXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE`" ] pub type UCTXIE_R = crate :: R < bool , UCTXIE_A > ; impl UCTXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE_A { match self . bits { false => UCTXIE_A :: UCTXIE_0 , true => UCTXIE_A :: UCTXIE_1 } } # [ doc = "Checks if the value of the field is `UCTXIE_0`" ] # [ inline ( always ) ] pub fn is_uctxie_0 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_0 } # [ doc = "Checks if the value of the field is `UCTXIE_1`" ] # [ inline ( always ) ] pub fn is_uctxie_1 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_1 } }
# [ doc = "Write proxy for field `UCTXIE`" ] pub struct UCTXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Start bit interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTTIE_A { # [ doc = "0: Interrupt disabled" ] UCSTTIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCSTTIE_1 = 1 } impl From < UCSTTIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTTIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTTIE`" ] pub type UCSTTIE_R = crate :: R < bool , UCSTTIE_A > ; impl UCSTTIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTTIE_A { match self . bits { false => UCSTTIE_A :: UCSTTIE_0 , true => UCSTTIE_A :: UCSTTIE_1 } } # [ doc = "Checks if the value of the field is `UCSTTIE_0`" ] # [ inline ( always ) ] pub fn is_ucsttie_0 ( & self ) -> bool { * self == UCSTTIE_A :: UCSTTIE_0 } # [ doc = "Checks if the value of the field is `UCSTTIE_1`" ] # [ inline ( always ) ] pub fn is_ucsttie_1 ( & self ) -> bool { * self == UCSTTIE_A :: UCSTTIE_1 } }
# [ doc = "Write proxy for field `UCSTTIE`" ] pub struct UCSTTIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTTIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTTIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucsttie_0 ( self ) -> & 'a mut W { self . variant ( UCSTTIE_A :: UCSTTIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucsttie_1 ( self ) -> & 'a mut W { self . variant ( UCSTTIE_A :: UCSTTIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Transmit complete interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXCPTIE_A { # [ doc = "0: Interrupt disabled" ] UCTXCPTIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXCPTIE_1 = 1 } impl From < UCTXCPTIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXCPTIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXCPTIE`" ] pub type UCTXCPTIE_R = crate :: R < bool , UCTXCPTIE_A > ; impl UCTXCPTIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXCPTIE_A { match self . bits { false => UCTXCPTIE_A :: UCTXCPTIE_0 , true => UCTXCPTIE_A :: UCTXCPTIE_1 } } # [ doc = "Checks if the value of the field is `UCTXCPTIE_0`" ] # [ inline ( always ) ] pub fn is_uctxcptie_0 ( & self ) -> bool { * self == UCTXCPTIE_A :: UCTXCPTIE_0 } # [ doc = "Checks if the value of the field is `UCTXCPTIE_1`" ] # [ inline ( always ) ] pub fn is_uctxcptie_1 ( & self ) -> bool { * self == UCTXCPTIE_A :: UCTXCPTIE_1 } }
# [ doc = "Write proxy for field `UCTXCPTIE`" ] pub struct UCTXCPTIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXCPTIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXCPTIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxcptie_0 ( self ) -> & 'a mut W { self . variant ( UCTXCPTIE_A :: UCTXCPTIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxcptie_1 ( self ) -> & 'a mut W { self . variant ( UCTXCPTIE_A :: UCTXCPTIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & self ) -> UCRXIE_R { UCRXIE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & self ) -> UCTXIE_R { UCTXIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Start bit interrupt enable" ] # [ inline ( always ) ] pub fn ucsttie ( & self ) -> UCSTTIE_R { UCSTTIE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Transmit complete interrupt enable" ] # [ inline ( always ) ] pub fn uctxcptie ( & self ) -> UCTXCPTIE_R { UCTXCPTIE_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & mut self ) -> UCRXIE_W { UCRXIE_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & mut self ) -> UCTXIE_W { UCTXIE_W { w : self } }
# [ doc = "Bit 2 - Start bit interrupt enable" ] # [ inline ( always ) ] pub fn ucsttie ( & mut self ) -> UCSTTIE_W { UCSTTIE_W { w : self } }
# [ doc = "Bit 3 - Transmit complete interrupt enable" ] # [ inline ( always ) ] pub fn uctxcptie ( & mut self ) -> UCTXCPTIE_W { UCTXCPTIE_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ie_spi](uca0ie_spi) module" ] pub type UCA0IE_SPI = crate :: Reg < u16 , _UCA0IE_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0IE_SPI ;
# [ doc = "`read()` method returns [uca0ie_spi::R](uca0ie_spi::R) reader structure" ] impl crate :: Readable for UCA0IE_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca0ie_spi::W](uca0ie_spi::W) writer structure" ] impl crate :: Writable for UCA0IE_SPI { }
# [ doc = "eUSCI_Ax Interrupt Enable Register" ] pub mod uca0ie_spi {
# [ doc = "Reader of register UCA0IE_SPI" ] pub type R = crate :: R < u16 , super :: UCA0IE_SPI > ;
# [ doc = "Writer for register UCA0IE_SPI" ] pub type W = crate :: W < u16 , super :: UCA0IE_SPI > ;
# [ doc = "Register UCA0IE_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0IE_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE_A { # [ doc = "0: Interrupt disabled" ] UCRXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE_1 = 1 } impl From < UCRXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE`" ] pub type UCRXIE_R = crate :: R < bool , UCRXIE_A > ; impl UCRXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE_A { match self . bits { false => UCRXIE_A :: UCRXIE_0 , true => UCRXIE_A :: UCRXIE_1 } } # [ doc = "Checks if the value of the field is `UCRXIE_0`" ] # [ inline ( always ) ] pub fn is_ucrxie_0 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_0 } # [ doc = "Checks if the value of the field is `UCRXIE_1`" ] # [ inline ( always ) ] pub fn is_ucrxie_1 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_1 } }
# [ doc = "Write proxy for field `UCRXIE`" ] pub struct UCRXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE_A { # [ doc = "0: Interrupt disabled" ] UCTXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE_1 = 1 } impl From < UCTXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE`" ] pub type UCTXIE_R = crate :: R < bool , UCTXIE_A > ; impl UCTXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE_A { match self . bits { false => UCTXIE_A :: UCTXIE_0 , true => UCTXIE_A :: UCTXIE_1 } } # [ doc = "Checks if the value of the field is `UCTXIE_0`" ] # [ inline ( always ) ] pub fn is_uctxie_0 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_0 } # [ doc = "Checks if the value of the field is `UCTXIE_1`" ] # [ inline ( always ) ] pub fn is_uctxie_1 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_1 } }
# [ doc = "Write proxy for field `UCTXIE`" ] pub struct UCTXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & self ) -> UCRXIE_R { UCRXIE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & self ) -> UCTXIE_R { UCTXIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & mut self ) -> UCRXIE_W { UCRXIE_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & mut self ) -> UCTXIE_W { UCTXIE_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ifg](uca0ifg) module" ] pub type UCA0IFG = crate :: Reg < u16 , _UCA0IFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0IFG ;
# [ doc = "`read()` method returns [uca0ifg::R](uca0ifg::R) reader structure" ] impl crate :: Readable for UCA0IFG { }
# [ doc = "`write(|w| ..)` method takes [uca0ifg::W](uca0ifg::W) writer structure" ] impl crate :: Writable for UCA0IFG { }
# [ doc = "eUSCI_Ax Interrupt Flag Register" ] pub mod uca0ifg {
# [ doc = "Reader of register UCA0IFG" ] pub type R = crate :: R < u16 , super :: UCA0IFG > ;
# [ doc = "Writer for register UCA0IFG" ] pub type W = crate :: W < u16 , super :: UCA0IFG > ;
# [ doc = "Register UCA0IFG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0IFG { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG_A { # [ doc = "0: No interrupt pending" ] UCRXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG_1 = 1 } impl From < UCRXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG`" ] pub type UCRXIFG_R = crate :: R < bool , UCRXIFG_A > ; impl UCRXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG_A { match self . bits { false => UCRXIFG_A :: UCRXIFG_0 , true => UCRXIFG_A :: UCRXIFG_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg_0 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_0 } # [ doc = "Checks if the value of the field is `UCRXIFG_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg_1 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_1 } }
# [ doc = "Write proxy for field `UCRXIFG`" ] pub struct UCRXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG_A { # [ doc = "0: No interrupt pending" ] UCTXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG_1 = 1 } impl From < UCTXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG`" ] pub type UCTXIFG_R = crate :: R < bool , UCTXIFG_A > ; impl UCTXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG_A { match self . bits { false => UCTXIFG_A :: UCTXIFG_0 , true => UCTXIFG_A :: UCTXIFG_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG_0`" ] # [ inline ( always ) ] pub fn is_uctxifg_0 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_0 } # [ doc = "Checks if the value of the field is `UCTXIFG_1`" ] # [ inline ( always ) ] pub fn is_uctxifg_1 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_1 } }
# [ doc = "Write proxy for field `UCTXIFG`" ] pub struct UCTXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Start bit interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTTIFG_A { # [ doc = "0: No interrupt pending" ] UCSTTIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCSTTIFG_1 = 1 } impl From < UCSTTIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTTIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTTIFG`" ] pub type UCSTTIFG_R = crate :: R < bool , UCSTTIFG_A > ; impl UCSTTIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTTIFG_A { match self . bits { false => UCSTTIFG_A :: UCSTTIFG_0 , true => UCSTTIFG_A :: UCSTTIFG_1 } } # [ doc = "Checks if the value of the field is `UCSTTIFG_0`" ] # [ inline ( always ) ] pub fn is_ucsttifg_0 ( & self ) -> bool { * self == UCSTTIFG_A :: UCSTTIFG_0 } # [ doc = "Checks if the value of the field is `UCSTTIFG_1`" ] # [ inline ( always ) ] pub fn is_ucsttifg_1 ( & self ) -> bool { * self == UCSTTIFG_A :: UCSTTIFG_1 } }
# [ doc = "Write proxy for field `UCSTTIFG`" ] pub struct UCSTTIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTTIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTTIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucsttifg_0 ( self ) -> & 'a mut W { self . variant ( UCSTTIFG_A :: UCSTTIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucsttifg_1 ( self ) -> & 'a mut W { self . variant ( UCSTTIFG_A :: UCSTTIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Transmit ready interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXCPTIFG_A { # [ doc = "0: No interrupt pending" ] UCTXCPTIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXCPTIFG_1 = 1 } impl From < UCTXCPTIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXCPTIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXCPTIFG`" ] pub type UCTXCPTIFG_R = crate :: R < bool , UCTXCPTIFG_A > ; impl UCTXCPTIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXCPTIFG_A { match self . bits { false => UCTXCPTIFG_A :: UCTXCPTIFG_0 , true => UCTXCPTIFG_A :: UCTXCPTIFG_1 } } # [ doc = "Checks if the value of the field is `UCTXCPTIFG_0`" ] # [ inline ( always ) ] pub fn is_uctxcptifg_0 ( & self ) -> bool { * self == UCTXCPTIFG_A :: UCTXCPTIFG_0 } # [ doc = "Checks if the value of the field is `UCTXCPTIFG_1`" ] # [ inline ( always ) ] pub fn is_uctxcptifg_1 ( & self ) -> bool { * self == UCTXCPTIFG_A :: UCTXCPTIFG_1 } }
# [ doc = "Write proxy for field `UCTXCPTIFG`" ] pub struct UCTXCPTIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXCPTIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXCPTIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxcptifg_0 ( self ) -> & 'a mut W { self . variant ( UCTXCPTIFG_A :: UCTXCPTIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxcptifg_1 ( self ) -> & 'a mut W { self . variant ( UCTXCPTIFG_A :: UCTXCPTIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & self ) -> UCRXIFG_R { UCRXIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & self ) -> UCTXIFG_R { UCTXIFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Start bit interrupt flag" ] # [ inline ( always ) ] pub fn ucsttifg ( & self ) -> UCSTTIFG_R { UCSTTIFG_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Transmit ready interrupt enable" ] # [ inline ( always ) ] pub fn uctxcptifg ( & self ) -> UCTXCPTIFG_R { UCTXCPTIFG_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & mut self ) -> UCRXIFG_W { UCRXIFG_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & mut self ) -> UCTXIFG_W { UCTXIFG_W { w : self } }
# [ doc = "Bit 2 - Start bit interrupt flag" ] # [ inline ( always ) ] pub fn ucsttifg ( & mut self ) -> UCSTTIFG_W { UCSTTIFG_W { w : self } }
# [ doc = "Bit 3 - Transmit ready interrupt enable" ] # [ inline ( always ) ] pub fn uctxcptifg ( & mut self ) -> UCTXCPTIFG_W { UCTXCPTIFG_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ifg_spi](uca0ifg_spi) module" ] pub type UCA0IFG_SPI = crate :: Reg < u16 , _UCA0IFG_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0IFG_SPI ;
# [ doc = "`read()` method returns [uca0ifg_spi::R](uca0ifg_spi::R) reader structure" ] impl crate :: Readable for UCA0IFG_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca0ifg_spi::W](uca0ifg_spi::W) writer structure" ] impl crate :: Writable for UCA0IFG_SPI { }
# [ doc = "eUSCI_Ax Interrupt Flag Register" ] pub mod uca0ifg_spi {
# [ doc = "Reader of register UCA0IFG_SPI" ] pub type R = crate :: R < u16 , super :: UCA0IFG_SPI > ;
# [ doc = "Writer for register UCA0IFG_SPI" ] pub type W = crate :: W < u16 , super :: UCA0IFG_SPI > ;
# [ doc = "Register UCA0IFG_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0IFG_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG_A { # [ doc = "0: No interrupt pending" ] UCRXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG_1 = 1 } impl From < UCRXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG`" ] pub type UCRXIFG_R = crate :: R < bool , UCRXIFG_A > ; impl UCRXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG_A { match self . bits { false => UCRXIFG_A :: UCRXIFG_0 , true => UCRXIFG_A :: UCRXIFG_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg_0 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_0 } # [ doc = "Checks if the value of the field is `UCRXIFG_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg_1 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_1 } }
# [ doc = "Write proxy for field `UCRXIFG`" ] pub struct UCRXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG_A { # [ doc = "0: No interrupt pending" ] UCTXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG_1 = 1 } impl From < UCTXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG`" ] pub type UCTXIFG_R = crate :: R < bool , UCTXIFG_A > ; impl UCTXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG_A { match self . bits { false => UCTXIFG_A :: UCTXIFG_0 , true => UCTXIFG_A :: UCTXIFG_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG_0`" ] # [ inline ( always ) ] pub fn is_uctxifg_0 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_0 } # [ doc = "Checks if the value of the field is `UCTXIFG_1`" ] # [ inline ( always ) ] pub fn is_uctxifg_1 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_1 } }
# [ doc = "Write proxy for field `UCTXIFG`" ] pub struct UCTXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & self ) -> UCRXIFG_R { UCRXIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & self ) -> UCTXIFG_R { UCTXIFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & mut self ) -> UCRXIFG_W { UCRXIFG_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & mut self ) -> UCTXIFG_W { UCTXIFG_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0iv](uca0iv) module" ] pub type UCA0IV = crate :: Reg < u16 , _UCA0IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0IV ;
# [ doc = "`read()` method returns [uca0iv::R](uca0iv::R) reader structure" ] impl crate :: Readable for UCA0IV { }
# [ doc = "eUSCI_Ax Interrupt Vector Register" ] pub mod uca0iv {
# [ doc = "Reader of register UCA0IV" ] pub type R = crate :: R < u16 , super :: UCA0IV > ;
# [ doc = "eUSCI_A interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum UCIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Receive buffer full; Interrupt Flag: UCRXIFG; Interrupt Priority: Highest" ] UCRXIFG = 2 , # [ doc = "4: Interrupt Source: Transmit buffer empty; Interrupt Flag: UCTXIFG" ] UCTXIFG = 4 , # [ doc = "6: Interrupt Source: Start bit received; Interrupt Flag: UCSTTIFG" ] UCSTTIFG = 6 , # [ doc = "8: Interrupt Source: Transmit complete; Interrupt Flag: UCTXCPTIFG; Interrupt Priority: Lowest" ] UCTXCPTIFG = 8 } impl From < UCIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : UCIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCIV`" ] pub type UCIV_R = crate :: R < u16 , UCIV_A > ; impl UCIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , UCIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( UCIV_A :: NONE ) , 2 => Val ( UCIV_A :: UCRXIFG ) , 4 => Val ( UCIV_A :: UCTXIFG ) , 6 => Val ( UCIV_A :: UCSTTIFG ) , 8 => Val ( UCIV_A :: UCTXCPTIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == UCIV_A :: NONE } # [ doc = "Checks if the value of the field is `UCRXIFG`" ] # [ inline ( always ) ] pub fn is_ucrxifg ( & self ) -> bool { * self == UCIV_A :: UCRXIFG } # [ doc = "Checks if the value of the field is `UCTXIFG`" ] # [ inline ( always ) ] pub fn is_uctxifg ( & self ) -> bool { * self == UCIV_A :: UCTXIFG } # [ doc = "Checks if the value of the field is `UCSTTIFG`" ] # [ inline ( always ) ] pub fn is_ucsttifg ( & self ) -> bool { * self == UCIV_A :: UCSTTIFG } # [ doc = "Checks if the value of the field is `UCTXCPTIFG`" ] # [ inline ( always ) ] pub fn is_uctxcptifg ( & self ) -> bool { * self == UCIV_A :: UCTXCPTIFG } }
impl R {
# [ doc = "Bits 0:15 - eUSCI_A interrupt vector value" ] # [ inline ( always ) ] pub fn uciv ( & self ) -> UCIV_R { UCIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
# [ doc = "eUSCI_Ax Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0iv_spi](uca0iv_spi) module" ] pub type UCA0IV_SPI = crate :: Reg < u16 , _UCA0IV_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0IV_SPI ;
# [ doc = "`read()` method returns [uca0iv_spi::R](uca0iv_spi::R) reader structure" ] impl crate :: Readable for UCA0IV_SPI { }
# [ doc = "eUSCI_Ax Interrupt Vector Register" ] pub mod uca0iv_spi {
# [ doc = "Reader of register UCA0IV_SPI" ] pub type R = crate :: R < u16 , super :: UCA0IV_SPI > ;
# [ doc = "eUSCI_A interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum UCIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Data received; Interrupt Flag: UCRXIFG; Interrupt Priority: Highest" ] UCRXIFG = 2 , # [ doc = "4: Interrupt Source: Transmit buffer empty; Interrupt Flag: UCTXIFG; Interrupt Priority: Lowest" ] UCTXIFG = 4 } impl From < UCIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : UCIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCIV`" ] pub type UCIV_R = crate :: R < u16 , UCIV_A > ; impl UCIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , UCIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( UCIV_A :: NONE ) , 2 => Val ( UCIV_A :: UCRXIFG ) , 4 => Val ( UCIV_A :: UCTXIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == UCIV_A :: NONE } # [ doc = "Checks if the value of the field is `UCRXIFG`" ] # [ inline ( always ) ] pub fn is_ucrxifg ( & self ) -> bool { * self == UCIV_A :: UCRXIFG } # [ doc = "Checks if the value of the field is `UCTXIFG`" ] # [ inline ( always ) ] pub fn is_uctxifg ( & self ) -> bool { * self == UCIV_A :: UCTXIFG } }
impl R {
# [ doc = "Bits 0:15 - eUSCI_A interrupt vector value" ] # [ inline ( always ) ] pub fn uciv ( & self ) -> UCIV_R { UCIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "eUSCI_B0" ] pub struct E_USCI_B0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for E_USCI_B0 { } impl E_USCI_B0 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const e_usci_b0 :: RegisterBlock { 0x0540 as * const _ } } impl Deref for E_USCI_B0 { type Target = e_usci_b0 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * E_USCI_B0 :: ptr ( ) } } }
# [ doc = "eUSCI_B0" ] pub mod e_usci_b0 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved_0_ucb0ctlw : [ u8 ; 2usize ] , # [ doc = "0x02 - eUSCI_Bx Control Word Register 1" ] pub ucb0ctlw1 : UCB0CTLW1 , _reserved2 : [ u8 ; 2usize ] , _reserved_2_ucb0 : [ u8 ; 2usize ] , _reserved_3_ucb0 : [ u8 ; 2usize ] , # [ doc = "0x0a - eUSCI_Bx Byte Counter Threshold Register" ] pub ucb0tbcnt : UCB0TBCNT , _reserved_5_ucb0 : [ u8 ; 2usize ] , _reserved_6_ucb0 : [ u8 ; 2usize ] , _reserved7 : [ u8 ; 4usize ] , # [ doc = "0x14 - eUSCI_Bx I2C Own Address 0 Register" ] pub ucb0i2coa0 : UCB0I2COA0 , # [ doc = "0x16 - eUSCI_Bx I2C Own Address 1 Register" ] pub ucb0i2coa1 : UCB0I2COA1 , # [ doc = "0x18 - eUSCI_Bx I2C Own Address 2 Register" ] pub ucb0i2coa2 : UCB0I2COA2 , # [ doc = "0x1a - eUSCI_Bx I2C Own Address 3 Register" ] pub ucb0i2coa3 : UCB0I2COA3 , # [ doc = "0x1c - eUSCI_Bx I2C Received Address Register" ] pub ucb0addrx : UCB0ADDRX , # [ doc = "0x1e - eUSCI_Bx I2C Address Mask Register" ] pub ucb0addmask : UCB0ADDMASK , # [ doc = "0x20 - eUSCI_Bx I2C Slave Address Register" ] pub ucb0i2csa : UCB0I2CSA , _reserved14 : [ u8 ; 8usize ] , _reserved_14_ucb0 : [ u8 ; 2usize ] , _reserved_15_ucb0 : [ u8 ; 2usize ] , _reserved_16_ucb0 : [ u8 ; 2usize ] , } impl RegisterBlock { # [ doc = "0x00 - eUSCI_Bx Control Word Register 0" ] # [ inline ( always ) ] pub fn ucb0ctlw0_spi ( & self ) -> & UCB0CTLW0_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const UCB0CTLW0_SPI ) } } # [ doc = "0x00 - eUSCI_Bx Control Word Register 0" ] # [ inline ( always ) ] pub fn ucb0ctlw0_spi_mut ( & self ) -> & mut UCB0CTLW0_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut UCB0CTLW0_SPI ) } } # [ doc = "0x00 - eUSCI_Bx Control Word Register 0" ] # [ inline ( always ) ] pub fn ucb0ctlw0 ( & self ) -> & UCB0CTLW0 { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const UCB0CTLW0 ) } } # [ doc = "0x00 - eUSCI_Bx Control Word Register 0" ] # [ inline ( always ) ] pub fn ucb0ctlw0_mut ( & self ) -> & mut UCB0CTLW0 { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut UCB0CTLW0 ) } } # [ doc = "0x06 - eUSCI_Bx Bit Rate Control Register 1" ] # [ inline ( always ) ] pub fn ucb0brw_spi ( & self ) -> & UCB0BRW_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 6usize ) as * const UCB0BRW_SPI ) } } # [ doc = "0x06 - eUSCI_Bx Bit Rate Control Register 1" ] # [ inline ( always ) ] pub fn ucb0brw_spi_mut ( & self ) -> & mut UCB0BRW_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 6usize ) as * mut UCB0BRW_SPI ) } } # [ doc = "0x06 - eUSCI_Bx Baud Rate Control Word Register" ] # [ inline ( always ) ] pub fn ucb0brw ( & self ) -> & UCB0BRW { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 6usize ) as * const UCB0BRW ) } } # [ doc = "0x06 - eUSCI_Bx Baud Rate Control Word Register" ] # [ inline ( always ) ] pub fn ucb0brw_mut ( & self ) -> & mut UCB0BRW { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 6usize ) as * mut UCB0BRW ) } } # [ doc = "0x08 - UCB0STATW_SPI" ] # [ inline ( always ) ] pub fn ucb0statw_spi ( & self ) -> & UCB0STATW_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 8usize ) as * const UCB0STATW_SPI ) } } # [ doc = "0x08 - UCB0STATW_SPI" ] # [ inline ( always ) ] pub fn ucb0statw_spi_mut ( & self ) -> & mut UCB0STATW_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 8usize ) as * mut UCB0STATW_SPI ) } } # [ doc = "0x08 - eUSCI_Bx Status Register" ] # [ inline ( always ) ] pub fn ucb0statw ( & self ) -> & UCB0STATW { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 8usize ) as * const UCB0STATW ) } } # [ doc = "0x08 - eUSCI_Bx Status Register" ] # [ inline ( always ) ] pub fn ucb0statw_mut ( & self ) -> & mut UCB0STATW { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 8usize ) as * mut UCB0STATW ) } } # [ doc = "0x0c - eUSCI_Bx Receive Buffer Register" ] # [ inline ( always ) ] pub fn ucb0rxbuf_spi ( & self ) -> & UCB0RXBUF_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const UCB0RXBUF_SPI ) } } # [ doc = "0x0c - eUSCI_Bx Receive Buffer Register" ] # [ inline ( always ) ] pub fn ucb0rxbuf_spi_mut ( & self ) -> & mut UCB0RXBUF_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut UCB0RXBUF_SPI ) } } # [ doc = "0x0c - eUSCI_Bx Receive Buffer Register" ] # [ inline ( always ) ] pub fn ucb0rxbuf ( & self ) -> & UCB0RXBUF { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const UCB0RXBUF ) } } # [ doc = "0x0c - eUSCI_Bx Receive Buffer Register" ] # [ inline ( always ) ] pub fn ucb0rxbuf_mut ( & self ) -> & mut UCB0RXBUF { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut UCB0RXBUF ) } } # [ doc = "0x0e - eUSCI_Bx Transmit Buffer Register" ] # [ inline ( always ) ] pub fn ucb0txbuf_spi ( & self ) -> & UCB0TXBUF_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 14usize ) as * const UCB0TXBUF_SPI ) } } # [ doc = "0x0e - eUSCI_Bx Transmit Buffer Register" ] # [ inline ( always ) ] pub fn ucb0txbuf_spi_mut ( & self ) -> & mut UCB0TXBUF_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 14usize ) as * mut UCB0TXBUF_SPI ) } } # [ doc = "0x0e - eUSCI_Bx Transmit Buffer Register" ] # [ inline ( always ) ] pub fn ucb0txbuf ( & self ) -> & UCB0TXBUF { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 14usize ) as * const UCB0TXBUF ) } } # [ doc = "0x0e - eUSCI_Bx Transmit Buffer Register" ] # [ inline ( always ) ] pub fn ucb0txbuf_mut ( & self ) -> & mut UCB0TXBUF { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 14usize ) as * mut UCB0TXBUF ) } } # [ doc = "0x2a - eUSCI_Bx Interrupt Enable Register" ] # [ inline ( always ) ] pub fn ucb0ie_spi ( & self ) -> & UCB0IE_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 42usize ) as * const UCB0IE_SPI ) } } # [ doc = "0x2a - eUSCI_Bx Interrupt Enable Register" ] # [ inline ( always ) ] pub fn ucb0ie_spi_mut ( & self ) -> & mut UCB0IE_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 42usize ) as * mut UCB0IE_SPI ) } } # [ doc = "0x2a - eUSCI_Bx Interrupt Enable Register" ] # [ inline ( always ) ] pub fn ucb0ie ( & self ) -> & UCB0IE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 42usize ) as * const UCB0IE ) } } # [ doc = "0x2a - eUSCI_Bx Interrupt Enable Register" ] # [ inline ( always ) ] pub fn ucb0ie_mut ( & self ) -> & mut UCB0IE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 42usize ) as * mut UCB0IE ) } } # [ doc = "0x2c - eUSCI_Bx Interrupt Flag Register" ] # [ inline ( always ) ] pub fn ucb0ifg_spi ( & self ) -> & UCB0IFG_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 44usize ) as * const UCB0IFG_SPI ) } } # [ doc = "0x2c - eUSCI_Bx Interrupt Flag Register" ] # [ inline ( always ) ] pub fn ucb0ifg_spi_mut ( & self ) -> & mut UCB0IFG_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 44usize ) as * mut UCB0IFG_SPI ) } } # [ doc = "0x2c - eUSCI_Bx Interrupt Flag Register" ] # [ inline ( always ) ] pub fn ucb0ifg ( & self ) -> & UCB0IFG { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 44usize ) as * const UCB0IFG ) } } # [ doc = "0x2c - eUSCI_Bx Interrupt Flag Register" ] # [ inline ( always ) ] pub fn ucb0ifg_mut ( & self ) -> & mut UCB0IFG { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 44usize ) as * mut UCB0IFG ) } } # [ doc = "0x2e - eUSCI_Bx Interrupt Vector Register" ] # [ inline ( always ) ] pub fn ucb0iv_spi ( & self ) -> & UCB0IV_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 46usize ) as * const UCB0IV_SPI ) } } # [ doc = "0x2e - eUSCI_Bx Interrupt Vector Register" ] # [ inline ( always ) ] pub fn ucb0iv_spi_mut ( & self ) -> & mut UCB0IV_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 46usize ) as * mut UCB0IV_SPI ) } } # [ doc = "0x2e - eUSCI_Bx Interrupt Vector Register" ] # [ inline ( always ) ] pub fn ucb0iv ( & self ) -> & UCB0IV { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 46usize ) as * const UCB0IV ) } } # [ doc = "0x2e - eUSCI_Bx Interrupt Vector Register" ] # [ inline ( always ) ] pub fn ucb0iv_mut ( & self ) -> & mut UCB0IV { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 46usize ) as * mut UCB0IV ) } } }
# [ doc = "eUSCI_Bx Control Word Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ctlw0](ucb0ctlw0) module" ] pub type UCB0CTLW0 = crate :: Reg < u16 , _UCB0CTLW0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0CTLW0 ;
# [ doc = "`read()` method returns [ucb0ctlw0::R](ucb0ctlw0::R) reader structure" ] impl crate :: Readable for UCB0CTLW0 { }
# [ doc = "`write(|w| ..)` method takes [ucb0ctlw0::W](ucb0ctlw0::W) writer structure" ] impl crate :: Writable for UCB0CTLW0 { }
# [ doc = "eUSCI_Bx Control Word Register 0" ] pub mod ucb0ctlw0 {
# [ doc = "Reader of register UCB0CTLW0" ] pub type R = crate :: R < u16 , super :: UCB0CTLW0 > ;
# [ doc = "Writer for register UCB0CTLW0" ] pub type W = crate :: W < u16 , super :: UCB0CTLW0 > ;
# [ doc = "Register UCB0CTLW0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0CTLW0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Software reset enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSWRST_A { # [ doc = "0: Disabled. eUSCI_B reset released for operation" ] DISABLE = 0 , # [ doc = "1: Enabled. eUSCI_B logic held in reset state" ] ENABLE = 1 } impl From < UCSWRST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSWRST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSWRST`" ] pub type UCSWRST_R = crate :: R < bool , UCSWRST_A > ; impl UCSWRST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSWRST_A { match self . bits { false => UCSWRST_A :: DISABLE , true => UCSWRST_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCSWRST_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCSWRST_A :: ENABLE } }
# [ doc = "Write proxy for field `UCSWRST`" ] pub struct UCSWRST_W < 'a > { w : & 'a mut W , } impl < 'a > UCSWRST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSWRST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled. eUSCI_B reset released for operation" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: DISABLE ) } # [ doc = "Enabled. eUSCI_B logic held in reset state" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit START condition in master mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXSTT_A { # [ doc = "0: Do not generate START condition" ] UCTXSTT_0 = 0 , # [ doc = "1: Generate START condition" ] UCTXSTT_1 = 1 } impl From < UCTXSTT_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXSTT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXSTT`" ] pub type UCTXSTT_R = crate :: R < bool , UCTXSTT_A > ; impl UCTXSTT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXSTT_A { match self . bits { false => UCTXSTT_A :: UCTXSTT_0 , true => UCTXSTT_A :: UCTXSTT_1 } } # [ doc = "Checks if the value of the field is `UCTXSTT_0`" ] # [ inline ( always ) ] pub fn is_uctxstt_0 ( & self ) -> bool { * self == UCTXSTT_A :: UCTXSTT_0 } # [ doc = "Checks if the value of the field is `UCTXSTT_1`" ] # [ inline ( always ) ] pub fn is_uctxstt_1 ( & self ) -> bool { * self == UCTXSTT_A :: UCTXSTT_1 } }
# [ doc = "Write proxy for field `UCTXSTT`" ] pub struct UCTXSTT_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXSTT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXSTT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Do not generate START condition" ] # [ inline ( always ) ] pub fn uctxstt_0 ( self ) -> & 'a mut W { self . variant ( UCTXSTT_A :: UCTXSTT_0 ) } # [ doc = "Generate START condition" ] # [ inline ( always ) ] pub fn uctxstt_1 ( self ) -> & 'a mut W { self . variant ( UCTXSTT_A :: UCTXSTT_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Transmit STOP condition in master mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXSTP_A { # [ doc = "0: No STOP generated" ] UCTXSTP_0 = 0 , # [ doc = "1: Generate STOP" ] UCTXSTP_1 = 1 } impl From < UCTXSTP_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXSTP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXSTP`" ] pub type UCTXSTP_R = crate :: R < bool , UCTXSTP_A > ; impl UCTXSTP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXSTP_A { match self . bits { false => UCTXSTP_A :: UCTXSTP_0 , true => UCTXSTP_A :: UCTXSTP_1 } } # [ doc = "Checks if the value of the field is `UCTXSTP_0`" ] # [ inline ( always ) ] pub fn is_uctxstp_0 ( & self ) -> bool { * self == UCTXSTP_A :: UCTXSTP_0 } # [ doc = "Checks if the value of the field is `UCTXSTP_1`" ] # [ inline ( always ) ] pub fn is_uctxstp_1 ( & self ) -> bool { * self == UCTXSTP_A :: UCTXSTP_1 } }
# [ doc = "Write proxy for field `UCTXSTP`" ] pub struct UCTXSTP_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXSTP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXSTP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No STOP generated" ] # [ inline ( always ) ] pub fn uctxstp_0 ( self ) -> & 'a mut W { self . variant ( UCTXSTP_A :: UCTXSTP_0 ) } # [ doc = "Generate STOP" ] # [ inline ( always ) ] pub fn uctxstp_1 ( self ) -> & 'a mut W { self . variant ( UCTXSTP_A :: UCTXSTP_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Transmit a NACK\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXNACK_A { # [ doc = "0: Acknowledge normally" ] UCTXNACK_0 = 0 , # [ doc = "1: Generate NACK" ] UCTXNACK_1 = 1 } impl From < UCTXNACK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXNACK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXNACK`" ] pub type UCTXNACK_R = crate :: R < bool , UCTXNACK_A > ; impl UCTXNACK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXNACK_A { match self . bits { false => UCTXNACK_A :: UCTXNACK_0 , true => UCTXNACK_A :: UCTXNACK_1 } } # [ doc = "Checks if the value of the field is `UCTXNACK_0`" ] # [ inline ( always ) ] pub fn is_uctxnack_0 ( & self ) -> bool { * self == UCTXNACK_A :: UCTXNACK_0 } # [ doc = "Checks if the value of the field is `UCTXNACK_1`" ] # [ inline ( always ) ] pub fn is_uctxnack_1 ( & self ) -> bool { * self == UCTXNACK_A :: UCTXNACK_1 } }
# [ doc = "Write proxy for field `UCTXNACK`" ] pub struct UCTXNACK_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXNACK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXNACK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Acknowledge normally" ] # [ inline ( always ) ] pub fn uctxnack_0 ( self ) -> & 'a mut W { self . variant ( UCTXNACK_A :: UCTXNACK_0 ) } # [ doc = "Generate NACK" ] # [ inline ( always ) ] pub fn uctxnack_1 ( self ) -> & 'a mut W { self . variant ( UCTXNACK_A :: UCTXNACK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Transmitter/receiver\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTR_A { # [ doc = "0: Receiver" ] RX = 0 , # [ doc = "1: Transmitter" ] TX = 1 } impl From < UCTR_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTR`" ] pub type UCTR_R = crate :: R < bool , UCTR_A > ; impl UCTR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTR_A { match self . bits { false => UCTR_A :: RX , true => UCTR_A :: TX } } # [ doc = "Checks if the value of the field is `RX`" ] # [ inline ( always ) ] pub fn is_rx ( & self ) -> bool { * self == UCTR_A :: RX } # [ doc = "Checks if the value of the field is `TX`" ] # [ inline ( always ) ] pub fn is_tx ( & self ) -> bool { * self == UCTR_A :: TX } }
# [ doc = "Write proxy for field `UCTR`" ] pub struct UCTR_W < 'a > { w : & 'a mut W , } impl < 'a > UCTR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Receiver" ] # [ inline ( always ) ] pub fn rx ( self ) -> & 'a mut W { self . variant ( UCTR_A :: RX ) } # [ doc = "Transmitter" ] # [ inline ( always ) ] pub fn tx ( self ) -> & 'a mut W { self . variant ( UCTR_A :: TX ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Transmit ACK condition in slave mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXACK_A { # [ doc = "0: Do not acknowledge the slave address" ] UCTXACK_0 = 0 , # [ doc = "1: Acknowledge the slave address" ] UCTXACK_1 = 1 } impl From < UCTXACK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXACK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXACK`" ] pub type UCTXACK_R = crate :: R < bool , UCTXACK_A > ; impl UCTXACK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXACK_A { match self . bits { false => UCTXACK_A :: UCTXACK_0 , true => UCTXACK_A :: UCTXACK_1 } } # [ doc = "Checks if the value of the field is `UCTXACK_0`" ] # [ inline ( always ) ] pub fn is_uctxack_0 ( & self ) -> bool { * self == UCTXACK_A :: UCTXACK_0 } # [ doc = "Checks if the value of the field is `UCTXACK_1`" ] # [ inline ( always ) ] pub fn is_uctxack_1 ( & self ) -> bool { * self == UCTXACK_A :: UCTXACK_1 } }
# [ doc = "Write proxy for field `UCTXACK`" ] pub struct UCTXACK_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXACK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXACK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Do not acknowledge the slave address" ] # [ inline ( always ) ] pub fn uctxack_0 ( self ) -> & 'a mut W { self . variant ( UCTXACK_A :: UCTXACK_0 ) } # [ doc = "Acknowledge the slave address" ] # [ inline ( always ) ] pub fn uctxack_1 ( self ) -> & 'a mut W { self . variant ( UCTXACK_A :: UCTXACK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "eUSCI_B clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCSSEL_A { # [ doc = "0: UCLKI" ] UCLKI = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: SMCLK" ] UCSSEL_3 = 3 } impl From < UCSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCSSEL`" ] pub type UCSSEL_R = crate :: R < u8 , UCSSEL_A > ; impl UCSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSSEL_A { match self . bits { 0 => UCSSEL_A :: UCLKI , 1 => UCSSEL_A :: ACLK , 2 => UCSSEL_A :: SMCLK , 3 => UCSSEL_A :: UCSSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCLKI`" ] # [ inline ( always ) ] pub fn is_uclki ( & self ) -> bool { * self == UCSSEL_A :: UCLKI } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == UCSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == UCSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `UCSSEL_3`" ] # [ inline ( always ) ] pub fn is_ucssel_3 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_3 } }
# [ doc = "Write proxy for field `UCSSEL`" ] pub struct UCSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > UCSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "UCLKI" ] # [ inline ( always ) ] pub fn uclki ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCLKI ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: SMCLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn ucssel_3 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Synchronous mode enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSYNC_A { # [ doc = "0: Asynchronous mode" ] ASYNC = 0 , # [ doc = "1: Synchronous mode" ] SYNC = 1 } impl From < UCSYNC_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSYNC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSYNC`" ] pub type UCSYNC_R = crate :: R < bool , UCSYNC_A > ; impl UCSYNC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSYNC_A { match self . bits { false => UCSYNC_A :: ASYNC , true => UCSYNC_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == UCSYNC_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == UCSYNC_A :: SYNC } }
# [ doc = "Write proxy for field `UCSYNC`" ] pub struct UCSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > UCSYNC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSYNC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous mode" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: ASYNC ) } # [ doc = "Synchronous mode" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "eUSCI_B mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCMODE_A { # [ doc = "0: 3-pin SPI" ] UCMODE_0 = 0 , # [ doc = "1: 4-pin SPI (master or slave enabled if STE = 1)" ] UCMODE_1 = 1 , # [ doc = "2: 4-pin SPI (master or slave enabled if STE = 0)" ] UCMODE_2 = 2 , # [ doc = "3: I2C mode" ] UCMODE_3 = 3 } impl From < UCMODE_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCMODE_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCMODE`" ] pub type UCMODE_R = crate :: R < u8 , UCMODE_A > ; impl UCMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMODE_A { match self . bits { 0 => UCMODE_A :: UCMODE_0 , 1 => UCMODE_A :: UCMODE_1 , 2 => UCMODE_A :: UCMODE_2 , 3 => UCMODE_A :: UCMODE_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCMODE_0`" ] # [ inline ( always ) ] pub fn is_ucmode_0 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_0 } # [ doc = "Checks if the value of the field is `UCMODE_1`" ] # [ inline ( always ) ] pub fn is_ucmode_1 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_1 } # [ doc = "Checks if the value of the field is `UCMODE_2`" ] # [ inline ( always ) ] pub fn is_ucmode_2 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_2 } # [ doc = "Checks if the value of the field is `UCMODE_3`" ] # [ inline ( always ) ] pub fn is_ucmode_3 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_3 } }
# [ doc = "Write proxy for field `UCMODE`" ] pub struct UCMODE_W < 'a > { w : & 'a mut W , } impl < 'a > UCMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMODE_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "3-pin SPI" ] # [ inline ( always ) ] pub fn ucmode_0 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_0 ) } # [ doc = "4-pin SPI (master or slave enabled if STE = 1)" ] # [ inline ( always ) ] pub fn ucmode_1 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_1 ) } # [ doc = "4-pin SPI (master or slave enabled if STE = 0)" ] # [ inline ( always ) ] pub fn ucmode_2 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_2 ) } # [ doc = "I2C mode" ] # [ inline ( always ) ] pub fn ucmode_3 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Master mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMST_A { # [ doc = "0: Slave mode" ] SLAVE = 0 , # [ doc = "1: Master mode" ] MASTER = 1 } impl From < UCMST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMST`" ] pub type UCMST_R = crate :: R < bool , UCMST_A > ; impl UCMST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMST_A { match self . bits { false => UCMST_A :: SLAVE , true => UCMST_A :: MASTER } } # [ doc = "Checks if the value of the field is `SLAVE`" ] # [ inline ( always ) ] pub fn is_slave ( & self ) -> bool { * self == UCMST_A :: SLAVE } # [ doc = "Checks if the value of the field is `MASTER`" ] # [ inline ( always ) ] pub fn is_master ( & self ) -> bool { * self == UCMST_A :: MASTER } }
# [ doc = "Write proxy for field `UCMST`" ] pub struct UCMST_W < 'a > { w : & 'a mut W , } impl < 'a > UCMST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Slave mode" ] # [ inline ( always ) ] pub fn slave ( self ) -> & 'a mut W { self . variant ( UCMST_A :: SLAVE ) } # [ doc = "Master mode" ] # [ inline ( always ) ] pub fn master ( self ) -> & 'a mut W { self . variant ( UCMST_A :: MASTER ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Multi-master environment select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMM_A { # [ doc = "0: Single master environment. There is no other master in the system. The address compare unit is disabled." ] SINGLE = 0 , # [ doc = "1: Multi-master environment" ] MULTI = 1 } impl From < UCMM_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMM`" ] pub type UCMM_R = crate :: R < bool , UCMM_A > ; impl UCMM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMM_A { match self . bits { false => UCMM_A :: SINGLE , true => UCMM_A :: MULTI } } # [ doc = "Checks if the value of the field is `SINGLE`" ] # [ inline ( always ) ] pub fn is_single ( & self ) -> bool { * self == UCMM_A :: SINGLE } # [ doc = "Checks if the value of the field is `MULTI`" ] # [ inline ( always ) ] pub fn is_multi ( & self ) -> bool { * self == UCMM_A :: MULTI } }
# [ doc = "Write proxy for field `UCMM`" ] pub struct UCMM_W < 'a > { w : & 'a mut W , } impl < 'a > UCMM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Single master environment. There is no other master in the system. The address compare unit is disabled." ] # [ inline ( always ) ] pub fn single ( self ) -> & 'a mut W { self . variant ( UCMM_A :: SINGLE ) } # [ doc = "Multi-master environment" ] # [ inline ( always ) ] pub fn multi ( self ) -> & 'a mut W { self . variant ( UCMM_A :: MULTI ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Slave addressing mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSLA10_A { # [ doc = "0: Address slave with 7-bit address" ] _7BIT = 0 , # [ doc = "1: Address slave with 10-bit address" ] _10BIT = 1 } impl From < UCSLA10_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSLA10_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSLA10`" ] pub type UCSLA10_R = crate :: R < bool , UCSLA10_A > ; impl UCSLA10_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSLA10_A { match self . bits { false => UCSLA10_A :: _7BIT , true => UCSLA10_A :: _10BIT } } # [ doc = "Checks if the value of the field is `_7BIT`" ] # [ inline ( always ) ] pub fn is_7bit ( & self ) -> bool { * self == UCSLA10_A :: _7BIT } # [ doc = "Checks if the value of the field is `_10BIT`" ] # [ inline ( always ) ] pub fn is_10bit ( & self ) -> bool { * self == UCSLA10_A :: _10BIT } }
# [ doc = "Write proxy for field `UCSLA10`" ] pub struct UCSLA10_W < 'a > { w : & 'a mut W , } impl < 'a > UCSLA10_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSLA10_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Address slave with 7-bit address" ] # [ inline ( always ) ] pub fn _7bit ( self ) -> & 'a mut W { self . variant ( UCSLA10_A :: _7BIT ) } # [ doc = "Address slave with 10-bit address" ] # [ inline ( always ) ] pub fn _10bit ( self ) -> & 'a mut W { self . variant ( UCSLA10_A :: _10BIT ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Own addressing mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCA10_A { # [ doc = "0: Own address is a 7-bit address" ] UCA10_0 = 0 , # [ doc = "1: Own address is a 10-bit address" ] UCA10_1 = 1 } impl From < UCA10_A > for bool { # [ inline ( always ) ] fn from ( variant : UCA10_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCA10`" ] pub type UCA10_R = crate :: R < bool , UCA10_A > ; impl UCA10_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCA10_A { match self . bits { false => UCA10_A :: UCA10_0 , true => UCA10_A :: UCA10_1 } } # [ doc = "Checks if the value of the field is `UCA10_0`" ] # [ inline ( always ) ] pub fn is_uca10_0 ( & self ) -> bool { * self == UCA10_A :: UCA10_0 } # [ doc = "Checks if the value of the field is `UCA10_1`" ] # [ inline ( always ) ] pub fn is_uca10_1 ( & self ) -> bool { * self == UCA10_A :: UCA10_1 } }
# [ doc = "Write proxy for field `UCA10`" ] pub struct UCA10_W < 'a > { w : & 'a mut W , } impl < 'a > UCA10_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCA10_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Own address is a 7-bit address" ] # [ inline ( always ) ] pub fn uca10_0 ( self ) -> & 'a mut W { self . variant ( UCA10_A :: UCA10_0 ) } # [ doc = "Own address is a 10-bit address" ] # [ inline ( always ) ] pub fn uca10_1 ( self ) -> & 'a mut W { self . variant ( UCA10_A :: UCA10_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & self ) -> UCSWRST_R { UCSWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit START condition in master mode" ] # [ inline ( always ) ] pub fn uctxstt ( & self ) -> UCTXSTT_R { UCTXSTT_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Transmit STOP condition in master mode" ] # [ inline ( always ) ] pub fn uctxstp ( & self ) -> UCTXSTP_R { UCTXSTP_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Transmit a NACK" ] # [ inline ( always ) ] pub fn uctxnack ( & self ) -> UCTXNACK_R { UCTXNACK_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Transmitter/receiver" ] # [ inline ( always ) ] pub fn uctr ( & self ) -> UCTR_R { UCTR_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Transmit ACK condition in slave mode" ] # [ inline ( always ) ] pub fn uctxack ( & self ) -> UCTXACK_R { UCTXACK_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - eUSCI_B clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & self ) -> UCSSEL_R { UCSSEL_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & self ) -> UCSYNC_R { UCSYNC_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - eUSCI_B mode" ] # [ inline ( always ) ] pub fn ucmode ( & self ) -> UCMODE_R { UCMODE_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & self ) -> UCMST_R { UCMST_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Multi-master environment select" ] # [ inline ( always ) ] pub fn ucmm ( & self ) -> UCMM_R { UCMM_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Slave addressing mode select" ] # [ inline ( always ) ] pub fn ucsla10 ( & self ) -> UCSLA10_R { UCSLA10_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Own addressing mode select" ] # [ inline ( always ) ] pub fn uca10 ( & self ) -> UCA10_R { UCA10_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & mut self ) -> UCSWRST_W { UCSWRST_W { w : self } }
# [ doc = "Bit 1 - Transmit START condition in master mode" ] # [ inline ( always ) ] pub fn uctxstt ( & mut self ) -> UCTXSTT_W { UCTXSTT_W { w : self } }
# [ doc = "Bit 2 - Transmit STOP condition in master mode" ] # [ inline ( always ) ] pub fn uctxstp ( & mut self ) -> UCTXSTP_W { UCTXSTP_W { w : self } }
# [ doc = "Bit 3 - Transmit a NACK" ] # [ inline ( always ) ] pub fn uctxnack ( & mut self ) -> UCTXNACK_W { UCTXNACK_W { w : self } }
# [ doc = "Bit 4 - Transmitter/receiver" ] # [ inline ( always ) ] pub fn uctr ( & mut self ) -> UCTR_W { UCTR_W { w : self } }
# [ doc = "Bit 5 - Transmit ACK condition in slave mode" ] # [ inline ( always ) ] pub fn uctxack ( & mut self ) -> UCTXACK_W { UCTXACK_W { w : self } }
# [ doc = "Bits 6:7 - eUSCI_B clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & mut self ) -> UCSSEL_W { UCSSEL_W { w : self } }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & mut self ) -> UCSYNC_W { UCSYNC_W { w : self } }
# [ doc = "Bits 9:10 - eUSCI_B mode" ] # [ inline ( always ) ] pub fn ucmode ( & mut self ) -> UCMODE_W { UCMODE_W { w : self } }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & mut self ) -> UCMST_W { UCMST_W { w : self } }
# [ doc = "Bit 13 - Multi-master environment select" ] # [ inline ( always ) ] pub fn ucmm ( & mut self ) -> UCMM_W { UCMM_W { w : self } }
# [ doc = "Bit 14 - Slave addressing mode select" ] # [ inline ( always ) ] pub fn ucsla10 ( & mut self ) -> UCSLA10_W { UCSLA10_W { w : self } }
# [ doc = "Bit 15 - Own addressing mode select" ] # [ inline ( always ) ] pub fn uca10 ( & mut self ) -> UCA10_W { UCA10_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Control Word Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ctlw0_spi](ucb0ctlw0_spi) module" ] pub type UCB0CTLW0_SPI = crate :: Reg < u16 , _UCB0CTLW0_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0CTLW0_SPI ;
# [ doc = "`read()` method returns [ucb0ctlw0_spi::R](ucb0ctlw0_spi::R) reader structure" ] impl crate :: Readable for UCB0CTLW0_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb0ctlw0_spi::W](ucb0ctlw0_spi::W) writer structure" ] impl crate :: Writable for UCB0CTLW0_SPI { }
# [ doc = "eUSCI_Bx Control Word Register 0" ] pub mod ucb0ctlw0_spi {
# [ doc = "Reader of register UCB0CTLW0_SPI" ] pub type R = crate :: R < u16 , super :: UCB0CTLW0_SPI > ;
# [ doc = "Writer for register UCB0CTLW0_SPI" ] pub type W = crate :: W < u16 , super :: UCB0CTLW0_SPI > ;
# [ doc = "Register UCB0CTLW0_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0CTLW0_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Software reset enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSWRST_A { # [ doc = "0: Disabled. eUSCI_B reset released for operation" ] DISABLE = 0 , # [ doc = "1: Enabled. eUSCI_B logic held in reset state" ] ENABLE = 1 } impl From < UCSWRST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSWRST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSWRST`" ] pub type UCSWRST_R = crate :: R < bool , UCSWRST_A > ; impl UCSWRST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSWRST_A { match self . bits { false => UCSWRST_A :: DISABLE , true => UCSWRST_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCSWRST_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCSWRST_A :: ENABLE } }
# [ doc = "Write proxy for field `UCSWRST`" ] pub struct UCSWRST_W < 'a > { w : & 'a mut W , } impl < 'a > UCSWRST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSWRST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled. eUSCI_B reset released for operation" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: DISABLE ) } # [ doc = "Enabled. eUSCI_B logic held in reset state" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "STE mode select in master mode.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTEM_A { # [ doc = "0: STE pin is used to prevent conflicts with other masters" ] UCSTEM_0 = 0 , # [ doc = "1: STE pin is used to generate the enable signal for a 4-wire slave" ] UCSTEM_1 = 1 } impl From < UCSTEM_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTEM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTEM`" ] pub type UCSTEM_R = crate :: R < bool , UCSTEM_A > ; impl UCSTEM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTEM_A { match self . bits { false => UCSTEM_A :: UCSTEM_0 , true => UCSTEM_A :: UCSTEM_1 } } # [ doc = "Checks if the value of the field is `UCSTEM_0`" ] # [ inline ( always ) ] pub fn is_ucstem_0 ( & self ) -> bool { * self == UCSTEM_A :: UCSTEM_0 } # [ doc = "Checks if the value of the field is `UCSTEM_1`" ] # [ inline ( always ) ] pub fn is_ucstem_1 ( & self ) -> bool { * self == UCSTEM_A :: UCSTEM_1 } }
# [ doc = "Write proxy for field `UCSTEM`" ] pub struct UCSTEM_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTEM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTEM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "STE pin is used to prevent conflicts with other masters" ] # [ inline ( always ) ] pub fn ucstem_0 ( self ) -> & 'a mut W { self . variant ( UCSTEM_A :: UCSTEM_0 ) } # [ doc = "STE pin is used to generate the enable signal for a 4-wire slave" ] # [ inline ( always ) ] pub fn ucstem_1 ( self ) -> & 'a mut W { self . variant ( UCSTEM_A :: UCSTEM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "eUSCI_B clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCSSEL_A { # [ doc = "0: Reserved" ] UCSSEL_0 = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: SMCLK" ] UCSSEL_3 = 3 } impl From < UCSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCSSEL`" ] pub type UCSSEL_R = crate :: R < u8 , UCSSEL_A > ; impl UCSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSSEL_A { match self . bits { 0 => UCSSEL_A :: UCSSEL_0 , 1 => UCSSEL_A :: ACLK , 2 => UCSSEL_A :: SMCLK , 3 => UCSSEL_A :: UCSSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCSSEL_0`" ] # [ inline ( always ) ] pub fn is_ucssel_0 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_0 } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == UCSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == UCSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `UCSSEL_3`" ] # [ inline ( always ) ] pub fn is_ucssel_3 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_3 } }
# [ doc = "Write proxy for field `UCSSEL`" ] pub struct UCSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > UCSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn ucssel_0 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_0 ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: SMCLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn ucssel_3 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Synchronous mode enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSYNC_A { # [ doc = "0: Asynchronous mode" ] ASYNC = 0 , # [ doc = "1: Synchronous mode" ] SYNC = 1 } impl From < UCSYNC_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSYNC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSYNC`" ] pub type UCSYNC_R = crate :: R < bool , UCSYNC_A > ; impl UCSYNC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSYNC_A { match self . bits { false => UCSYNC_A :: ASYNC , true => UCSYNC_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == UCSYNC_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == UCSYNC_A :: SYNC } }
# [ doc = "Write proxy for field `UCSYNC`" ] pub struct UCSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > UCSYNC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSYNC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous mode" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: ASYNC ) } # [ doc = "Synchronous mode" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "eUSCI mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCMODE_A { # [ doc = "0: 3-pin SPI" ] UCMODE_0 = 0 , # [ doc = "1: 4-pin SPI with UCxSTE active high: Slave enabled when UCxSTE = 1" ] UCMODE_1 = 1 , # [ doc = "2: 4-pin SPI with UCxSTE active low: Slave enabled when UCxSTE = 0" ] UCMODE_2 = 2 , # [ doc = "3: I2C mode" ] UCMODE_3 = 3 } impl From < UCMODE_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCMODE_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCMODE`" ] pub type UCMODE_R = crate :: R < u8 , UCMODE_A > ; impl UCMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMODE_A { match self . bits { 0 => UCMODE_A :: UCMODE_0 , 1 => UCMODE_A :: UCMODE_1 , 2 => UCMODE_A :: UCMODE_2 , 3 => UCMODE_A :: UCMODE_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCMODE_0`" ] # [ inline ( always ) ] pub fn is_ucmode_0 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_0 } # [ doc = "Checks if the value of the field is `UCMODE_1`" ] # [ inline ( always ) ] pub fn is_ucmode_1 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_1 } # [ doc = "Checks if the value of the field is `UCMODE_2`" ] # [ inline ( always ) ] pub fn is_ucmode_2 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_2 } # [ doc = "Checks if the value of the field is `UCMODE_3`" ] # [ inline ( always ) ] pub fn is_ucmode_3 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_3 } }
# [ doc = "Write proxy for field `UCMODE`" ] pub struct UCMODE_W < 'a > { w : & 'a mut W , } impl < 'a > UCMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMODE_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "3-pin SPI" ] # [ inline ( always ) ] pub fn ucmode_0 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_0 ) } # [ doc = "4-pin SPI with UCxSTE active high: Slave enabled when UCxSTE = 1" ] # [ inline ( always ) ] pub fn ucmode_1 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_1 ) } # [ doc = "4-pin SPI with UCxSTE active low: Slave enabled when UCxSTE = 0" ] # [ inline ( always ) ] pub fn ucmode_2 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_2 ) } # [ doc = "I2C mode" ] # [ inline ( always ) ] pub fn ucmode_3 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Master mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMST_A { # [ doc = "0: Slave mode" ] SLAVE = 0 , # [ doc = "1: Master mode" ] MASTER = 1 } impl From < UCMST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMST`" ] pub type UCMST_R = crate :: R < bool , UCMST_A > ; impl UCMST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMST_A { match self . bits { false => UCMST_A :: SLAVE , true => UCMST_A :: MASTER } } # [ doc = "Checks if the value of the field is `SLAVE`" ] # [ inline ( always ) ] pub fn is_slave ( & self ) -> bool { * self == UCMST_A :: SLAVE } # [ doc = "Checks if the value of the field is `MASTER`" ] # [ inline ( always ) ] pub fn is_master ( & self ) -> bool { * self == UCMST_A :: MASTER } }
# [ doc = "Write proxy for field `UCMST`" ] pub struct UCMST_W < 'a > { w : & 'a mut W , } impl < 'a > UCMST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Slave mode" ] # [ inline ( always ) ] pub fn slave ( self ) -> & 'a mut W { self . variant ( UCMST_A :: SLAVE ) } # [ doc = "Master mode" ] # [ inline ( always ) ] pub fn master ( self ) -> & 'a mut W { self . variant ( UCMST_A :: MASTER ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Character length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UC7BIT_A { # [ doc = "0: 8-bit data" ] _8BIT = 0 , # [ doc = "1: 7-bit data" ] _7BIT = 1 } impl From < UC7BIT_A > for bool { # [ inline ( always ) ] fn from ( variant : UC7BIT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UC7BIT`" ] pub type UC7BIT_R = crate :: R < bool , UC7BIT_A > ; impl UC7BIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UC7BIT_A { match self . bits { false => UC7BIT_A :: _8BIT , true => UC7BIT_A :: _7BIT } } # [ doc = "Checks if the value of the field is `_8BIT`" ] # [ inline ( always ) ] pub fn is_8bit ( & self ) -> bool { * self == UC7BIT_A :: _8BIT } # [ doc = "Checks if the value of the field is `_7BIT`" ] # [ inline ( always ) ] pub fn is_7bit ( & self ) -> bool { * self == UC7BIT_A :: _7BIT } }
# [ doc = "Write proxy for field `UC7BIT`" ] pub struct UC7BIT_W < 'a > { w : & 'a mut W , } impl < 'a > UC7BIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UC7BIT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "8-bit data" ] # [ inline ( always ) ] pub fn _8bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _8BIT ) } # [ doc = "7-bit data" ] # [ inline ( always ) ] pub fn _7bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _7BIT ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "MSB first select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMSB_A { # [ doc = "0: LSB first" ] UCMSB_0 = 0 , # [ doc = "1: MSB first" ] UCMSB_1 = 1 } impl From < UCMSB_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMSB_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMSB`" ] pub type UCMSB_R = crate :: R < bool , UCMSB_A > ; impl UCMSB_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMSB_A { match self . bits { false => UCMSB_A :: UCMSB_0 , true => UCMSB_A :: UCMSB_1 } } # [ doc = "Checks if the value of the field is `UCMSB_0`" ] # [ inline ( always ) ] pub fn is_ucmsb_0 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_0 } # [ doc = "Checks if the value of the field is `UCMSB_1`" ] # [ inline ( always ) ] pub fn is_ucmsb_1 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_1 } }
# [ doc = "Write proxy for field `UCMSB`" ] pub struct UCMSB_W < 'a > { w : & 'a mut W , } impl < 'a > UCMSB_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMSB_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "LSB first" ] # [ inline ( always ) ] pub fn ucmsb_0 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_0 ) } # [ doc = "MSB first" ] # [ inline ( always ) ] pub fn ucmsb_1 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Clock polarity select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCKPL_A { # [ doc = "0: The inactive state is low" ] LOW = 0 , # [ doc = "1: The inactive state is high" ] HIGH = 1 } impl From < UCCKPL_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCKPL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCKPL`" ] pub type UCCKPL_R = crate :: R < bool , UCCKPL_A > ; impl UCCKPL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCKPL_A { match self . bits { false => UCCKPL_A :: LOW , true => UCCKPL_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == UCCKPL_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == UCCKPL_A :: HIGH } }
# [ doc = "Write proxy for field `UCCKPL`" ] pub struct UCCKPL_W < 'a > { w : & 'a mut W , } impl < 'a > UCCKPL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCKPL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The inactive state is low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( UCCKPL_A :: LOW ) } # [ doc = "The inactive state is high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( UCCKPL_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Clock phase select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCKPH_A { # [ doc = "0: Data is changed on the first UCLK edge and captured on the following edge." ] UCCKPH_0 = 0 , # [ doc = "1: Data is captured on the first UCLK edge and changed on the following edge." ] UCCKPH_1 = 1 } impl From < UCCKPH_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCKPH_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCKPH`" ] pub type UCCKPH_R = crate :: R < bool , UCCKPH_A > ; impl UCCKPH_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCKPH_A { match self . bits { false => UCCKPH_A :: UCCKPH_0 , true => UCCKPH_A :: UCCKPH_1 } } # [ doc = "Checks if the value of the field is `UCCKPH_0`" ] # [ inline ( always ) ] pub fn is_ucckph_0 ( & self ) -> bool { * self == UCCKPH_A :: UCCKPH_0 } # [ doc = "Checks if the value of the field is `UCCKPH_1`" ] # [ inline ( always ) ] pub fn is_ucckph_1 ( & self ) -> bool { * self == UCCKPH_A :: UCCKPH_1 } }
# [ doc = "Write proxy for field `UCCKPH`" ] pub struct UCCKPH_W < 'a > { w : & 'a mut W , } impl < 'a > UCCKPH_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCKPH_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Data is changed on the first UCLK edge and captured on the following edge." ] # [ inline ( always ) ] pub fn ucckph_0 ( self ) -> & 'a mut W { self . variant ( UCCKPH_A :: UCCKPH_0 ) } # [ doc = "Data is captured on the first UCLK edge and changed on the following edge." ] # [ inline ( always ) ] pub fn ucckph_1 ( self ) -> & 'a mut W { self . variant ( UCCKPH_A :: UCCKPH_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & self ) -> UCSWRST_R { UCSWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - STE mode select in master mode." ] # [ inline ( always ) ] pub fn ucstem ( & self ) -> UCSTEM_R { UCSTEM_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - eUSCI_B clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & self ) -> UCSSEL_R { UCSSEL_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & self ) -> UCSYNC_R { UCSYNC_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - eUSCI mode" ] # [ inline ( always ) ] pub fn ucmode ( & self ) -> UCMODE_R { UCMODE_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & self ) -> UCMST_R { UCMST_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & self ) -> UC7BIT_R { UC7BIT_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & self ) -> UCMSB_R { UCMSB_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Clock polarity select" ] # [ inline ( always ) ] pub fn ucckpl ( & self ) -> UCCKPL_R { UCCKPL_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Clock phase select" ] # [ inline ( always ) ] pub fn ucckph ( & self ) -> UCCKPH_R { UCCKPH_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & mut self ) -> UCSWRST_W { UCSWRST_W { w : self } }
# [ doc = "Bit 1 - STE mode select in master mode." ] # [ inline ( always ) ] pub fn ucstem ( & mut self ) -> UCSTEM_W { UCSTEM_W { w : self } }
# [ doc = "Bits 6:7 - eUSCI_B clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & mut self ) -> UCSSEL_W { UCSSEL_W { w : self } }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & mut self ) -> UCSYNC_W { UCSYNC_W { w : self } }
# [ doc = "Bits 9:10 - eUSCI mode" ] # [ inline ( always ) ] pub fn ucmode ( & mut self ) -> UCMODE_W { UCMODE_W { w : self } }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & mut self ) -> UCMST_W { UCMST_W { w : self } }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & mut self ) -> UC7BIT_W { UC7BIT_W { w : self } }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & mut self ) -> UCMSB_W { UCMSB_W { w : self } }
# [ doc = "Bit 14 - Clock polarity select" ] # [ inline ( always ) ] pub fn ucckpl ( & mut self ) -> UCCKPL_W { UCCKPL_W { w : self } }
# [ doc = "Bit 15 - Clock phase select" ] # [ inline ( always ) ] pub fn ucckph ( & mut self ) -> UCCKPH_W { UCCKPH_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Control Word Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ctlw1](ucb0ctlw1) module" ] pub type UCB0CTLW1 = crate :: Reg < u16 , _UCB0CTLW1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0CTLW1 ;
# [ doc = "`read()` method returns [ucb0ctlw1::R](ucb0ctlw1::R) reader structure" ] impl crate :: Readable for UCB0CTLW1 { }
# [ doc = "`write(|w| ..)` method takes [ucb0ctlw1::W](ucb0ctlw1::W) writer structure" ] impl crate :: Writable for UCB0CTLW1 { }
# [ doc = "eUSCI_Bx Control Word Register 1" ] pub mod ucb0ctlw1 {
# [ doc = "Reader of register UCB0CTLW1" ] pub type R = crate :: R < u16 , super :: UCB0CTLW1 > ;
# [ doc = "Writer for register UCB0CTLW1" ] pub type W = crate :: W < u16 , super :: UCB0CTLW1 > ;
# [ doc = "Register UCB0CTLW1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0CTLW1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Deglitch time\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCGLIT_A { # [ doc = "0: 50 ns" ] UCGLIT_0 = 0 , # [ doc = "1: 25 ns" ] UCGLIT_1 = 1 , # [ doc = "2: 12.5 ns" ] UCGLIT_2 = 2 , # [ doc = "3: 6.25 ns" ] UCGLIT_3 = 3 } impl From < UCGLIT_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCGLIT_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCGLIT`" ] pub type UCGLIT_R = crate :: R < u8 , UCGLIT_A > ; impl UCGLIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCGLIT_A { match self . bits { 0 => UCGLIT_A :: UCGLIT_0 , 1 => UCGLIT_A :: UCGLIT_1 , 2 => UCGLIT_A :: UCGLIT_2 , 3 => UCGLIT_A :: UCGLIT_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCGLIT_0`" ] # [ inline ( always ) ] pub fn is_ucglit_0 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_0 } # [ doc = "Checks if the value of the field is `UCGLIT_1`" ] # [ inline ( always ) ] pub fn is_ucglit_1 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_1 } # [ doc = "Checks if the value of the field is `UCGLIT_2`" ] # [ inline ( always ) ] pub fn is_ucglit_2 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_2 } # [ doc = "Checks if the value of the field is `UCGLIT_3`" ] # [ inline ( always ) ] pub fn is_ucglit_3 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_3 } }
# [ doc = "Write proxy for field `UCGLIT`" ] pub struct UCGLIT_W < 'a > { w : & 'a mut W , } impl < 'a > UCGLIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCGLIT_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "50 ns" ] # [ inline ( always ) ] pub fn ucglit_0 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_0 ) } # [ doc = "25 ns" ] # [ inline ( always ) ] pub fn ucglit_1 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_1 ) } # [ doc = "12.5 ns" ] # [ inline ( always ) ] pub fn ucglit_2 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_2 ) } # [ doc = "6.25 ns" ] # [ inline ( always ) ] pub fn ucglit_3 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Automatic STOP condition generation\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCASTP_A { # [ doc = "0: No automatic STOP generation. The STOP condition is generated after the user sets the UCTXSTP bit. The value in UCBxTBCNT is a don't care." ] UCASTP_0 = 0 , # [ doc = "1: UCBCNTIFG is set with the byte counter reaches the threshold defined in UCBxTBCNT" ] UCASTP_1 = 1 , # [ doc = "2: A STOP condition is generated automatically after the byte counter value reached UCBxTBCNT. UCBCNTIFG is set with the byte counter reaching the threshold" ] UCASTP_2 = 2 , # [ doc = "3: Reserved" ] UCASTP_3 = 3 } impl From < UCASTP_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCASTP_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCASTP`" ] pub type UCASTP_R = crate :: R < u8 , UCASTP_A > ; impl UCASTP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCASTP_A { match self . bits { 0 => UCASTP_A :: UCASTP_0 , 1 => UCASTP_A :: UCASTP_1 , 2 => UCASTP_A :: UCASTP_2 , 3 => UCASTP_A :: UCASTP_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCASTP_0`" ] # [ inline ( always ) ] pub fn is_ucastp_0 ( & self ) -> bool { * self == UCASTP_A :: UCASTP_0 } # [ doc = "Checks if the value of the field is `UCASTP_1`" ] # [ inline ( always ) ] pub fn is_ucastp_1 ( & self ) -> bool { * self == UCASTP_A :: UCASTP_1 } # [ doc = "Checks if the value of the field is `UCASTP_2`" ] # [ inline ( always ) ] pub fn is_ucastp_2 ( & self ) -> bool { * self == UCASTP_A :: UCASTP_2 } # [ doc = "Checks if the value of the field is `UCASTP_3`" ] # [ inline ( always ) ] pub fn is_ucastp_3 ( & self ) -> bool { * self == UCASTP_A :: UCASTP_3 } }
# [ doc = "Write proxy for field `UCASTP`" ] pub struct UCASTP_W < 'a > { w : & 'a mut W , } impl < 'a > UCASTP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCASTP_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No automatic STOP generation. The STOP condition is generated after the user sets the UCTXSTP bit. The value in UCBxTBCNT is a don't care." ] # [ inline ( always ) ] pub fn ucastp_0 ( self ) -> & 'a mut W { self . variant ( UCASTP_A :: UCASTP_0 ) } # [ doc = "UCBCNTIFG is set with the byte counter reaches the threshold defined in UCBxTBCNT" ] # [ inline ( always ) ] pub fn ucastp_1 ( self ) -> & 'a mut W { self . variant ( UCASTP_A :: UCASTP_1 ) } # [ doc = "A STOP condition is generated automatically after the byte counter value reached UCBxTBCNT. UCBCNTIFG is set with the byte counter reaching the threshold" ] # [ inline ( always ) ] pub fn ucastp_2 ( self ) -> & 'a mut W { self . variant ( UCASTP_A :: UCASTP_2 ) } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn ucastp_3 ( self ) -> & 'a mut W { self . variant ( UCASTP_A :: UCASTP_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u16 ) & 0x03 ) << 2 ) ; self . w } }
# [ doc = "SW or HW ACK control\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSWACK_A { # [ doc = "0: The address acknowledge of the slave is controlled by the eUSCI_B module" ] UCSWACK_0 = 0 , # [ doc = "1: The user needs to trigger the sending of the address ACK by issuing UCTXACK" ] UCSWACK_1 = 1 } impl From < UCSWACK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSWACK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSWACK`" ] pub type UCSWACK_R = crate :: R < bool , UCSWACK_A > ; impl UCSWACK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSWACK_A { match self . bits { false => UCSWACK_A :: UCSWACK_0 , true => UCSWACK_A :: UCSWACK_1 } } # [ doc = "Checks if the value of the field is `UCSWACK_0`" ] # [ inline ( always ) ] pub fn is_ucswack_0 ( & self ) -> bool { * self == UCSWACK_A :: UCSWACK_0 } # [ doc = "Checks if the value of the field is `UCSWACK_1`" ] # [ inline ( always ) ] pub fn is_ucswack_1 ( & self ) -> bool { * self == UCSWACK_A :: UCSWACK_1 } }
# [ doc = "Write proxy for field `UCSWACK`" ] pub struct UCSWACK_W < 'a > { w : & 'a mut W , } impl < 'a > UCSWACK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSWACK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The address acknowledge of the slave is controlled by the eUSCI_B module" ] # [ inline ( always ) ] pub fn ucswack_0 ( self ) -> & 'a mut W { self . variant ( UCSWACK_A :: UCSWACK_0 ) } # [ doc = "The user needs to trigger the sending of the address ACK by issuing UCTXACK" ] # [ inline ( always ) ] pub fn ucswack_1 ( self ) -> & 'a mut W { self . variant ( UCSWACK_A :: UCSWACK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "ACK all master bytes\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTPNACK_A { # [ doc = "0: Send a non-acknowledge before the STOP condition as a master receiver (conform to I2C standard)" ] UCSTPNACK_0 = 0 , # [ doc = "1: All bytes are acknowledged by the eUSCI_B when configured as master receiver" ] UCSTPNACK_1 = 1 } impl From < UCSTPNACK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTPNACK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTPNACK`" ] pub type UCSTPNACK_R = crate :: R < bool , UCSTPNACK_A > ; impl UCSTPNACK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTPNACK_A { match self . bits { false => UCSTPNACK_A :: UCSTPNACK_0 , true => UCSTPNACK_A :: UCSTPNACK_1 } } # [ doc = "Checks if the value of the field is `UCSTPNACK_0`" ] # [ inline ( always ) ] pub fn is_ucstpnack_0 ( & self ) -> bool { * self == UCSTPNACK_A :: UCSTPNACK_0 } # [ doc = "Checks if the value of the field is `UCSTPNACK_1`" ] # [ inline ( always ) ] pub fn is_ucstpnack_1 ( & self ) -> bool { * self == UCSTPNACK_A :: UCSTPNACK_1 } }
# [ doc = "Write proxy for field `UCSTPNACK`" ] pub struct UCSTPNACK_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTPNACK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTPNACK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Send a non-acknowledge before the STOP condition as a master receiver (conform to I2C standard)" ] # [ inline ( always ) ] pub fn ucstpnack_0 ( self ) -> & 'a mut W { self . variant ( UCSTPNACK_A :: UCSTPNACK_0 ) } # [ doc = "All bytes are acknowledged by the eUSCI_B when configured as master receiver" ] # [ inline ( always ) ] pub fn ucstpnack_1 ( self ) -> & 'a mut W { self . variant ( UCSTPNACK_A :: UCSTPNACK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Clock low timeout select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCCLTO_A { # [ doc = "0: Disable clock low timeout counter" ] UCCLTO_0 = 0 , # [ doc = "1: 135 000 SYSCLK cycles (approximately 28 ms)" ] UCCLTO_1 = 1 , # [ doc = "2: 150 000 SYSCLK cycles (approximately 31 ms)" ] UCCLTO_2 = 2 , # [ doc = "3: 165 000 SYSCLK cycles (approximately 34 ms)" ] UCCLTO_3 = 3 } impl From < UCCLTO_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCCLTO_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCCLTO`" ] pub type UCCLTO_R = crate :: R < u8 , UCCLTO_A > ; impl UCCLTO_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCLTO_A { match self . bits { 0 => UCCLTO_A :: UCCLTO_0 , 1 => UCCLTO_A :: UCCLTO_1 , 2 => UCCLTO_A :: UCCLTO_2 , 3 => UCCLTO_A :: UCCLTO_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCCLTO_0`" ] # [ inline ( always ) ] pub fn is_ucclto_0 ( & self ) -> bool { * self == UCCLTO_A :: UCCLTO_0 } # [ doc = "Checks if the value of the field is `UCCLTO_1`" ] # [ inline ( always ) ] pub fn is_ucclto_1 ( & self ) -> bool { * self == UCCLTO_A :: UCCLTO_1 } # [ doc = "Checks if the value of the field is `UCCLTO_2`" ] # [ inline ( always ) ] pub fn is_ucclto_2 ( & self ) -> bool { * self == UCCLTO_A :: UCCLTO_2 } # [ doc = "Checks if the value of the field is `UCCLTO_3`" ] # [ inline ( always ) ] pub fn is_ucclto_3 ( & self ) -> bool { * self == UCCLTO_A :: UCCLTO_3 } }
# [ doc = "Write proxy for field `UCCLTO`" ] pub struct UCCLTO_W < 'a > { w : & 'a mut W , } impl < 'a > UCCLTO_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCLTO_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Disable clock low timeout counter" ] # [ inline ( always ) ] pub fn ucclto_0 ( self ) -> & 'a mut W { self . variant ( UCCLTO_A :: UCCLTO_0 ) } # [ doc = "135 000 SYSCLK cycles (approximately 28 ms)" ] # [ inline ( always ) ] pub fn ucclto_1 ( self ) -> & 'a mut W { self . variant ( UCCLTO_A :: UCCLTO_1 ) } # [ doc = "150 000 SYSCLK cycles (approximately 31 ms)" ] # [ inline ( always ) ] pub fn ucclto_2 ( self ) -> & 'a mut W { self . variant ( UCCLTO_A :: UCCLTO_2 ) } # [ doc = "165 000 SYSCLK cycles (approximately 34 ms)" ] # [ inline ( always ) ] pub fn ucclto_3 ( self ) -> & 'a mut W { self . variant ( UCCLTO_A :: UCCLTO_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Early UCTXIFG0\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCETXINT_A { # [ doc = "0: UCTXIFGx is set after an address match with UCxI2COAx and the direction bit indicating slave transmit" ] UCETXINT_0 = 0 , # [ doc = "1: UCTXIFG0 is set for each START condition" ] UCETXINT_1 = 1 } impl From < UCETXINT_A > for bool { # [ inline ( always ) ] fn from ( variant : UCETXINT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCETXINT`" ] pub type UCETXINT_R = crate :: R < bool , UCETXINT_A > ; impl UCETXINT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCETXINT_A { match self . bits { false => UCETXINT_A :: UCETXINT_0 , true => UCETXINT_A :: UCETXINT_1 } } # [ doc = "Checks if the value of the field is `UCETXINT_0`" ] # [ inline ( always ) ] pub fn is_ucetxint_0 ( & self ) -> bool { * self == UCETXINT_A :: UCETXINT_0 } # [ doc = "Checks if the value of the field is `UCETXINT_1`" ] # [ inline ( always ) ] pub fn is_ucetxint_1 ( & self ) -> bool { * self == UCETXINT_A :: UCETXINT_1 } }
# [ doc = "Write proxy for field `UCETXINT`" ] pub struct UCETXINT_W < 'a > { w : & 'a mut W , } impl < 'a > UCETXINT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCETXINT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "UCTXIFGx is set after an address match with UCxI2COAx and the direction bit indicating slave transmit" ] # [ inline ( always ) ] pub fn ucetxint_0 ( self ) -> & 'a mut W { self . variant ( UCETXINT_A :: UCETXINT_0 ) } # [ doc = "UCTXIFG0 is set for each START condition" ] # [ inline ( always ) ] pub fn ucetxint_1 ( self ) -> & 'a mut W { self . variant ( UCETXINT_A :: UCETXINT_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Deglitch time" ] # [ inline ( always ) ] pub fn ucglit ( & self ) -> UCGLIT_R { UCGLIT_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 2:3 - Automatic STOP condition generation" ] # [ inline ( always ) ] pub fn ucastp ( & self ) -> UCASTP_R { UCASTP_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 4 - SW or HW ACK control" ] # [ inline ( always ) ] pub fn ucswack ( & self ) -> UCSWACK_R { UCSWACK_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - ACK all master bytes" ] # [ inline ( always ) ] pub fn ucstpnack ( & self ) -> UCSTPNACK_R { UCSTPNACK_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - Clock low timeout select" ] # [ inline ( always ) ] pub fn ucclto ( & self ) -> UCCLTO_R { UCCLTO_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Early UCTXIFG0" ] # [ inline ( always ) ] pub fn ucetxint ( & self ) -> UCETXINT_R { UCETXINT_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:1 - Deglitch time" ] # [ inline ( always ) ] pub fn ucglit ( & mut self ) -> UCGLIT_W { UCGLIT_W { w : self } }
# [ doc = "Bits 2:3 - Automatic STOP condition generation" ] # [ inline ( always ) ] pub fn ucastp ( & mut self ) -> UCASTP_W { UCASTP_W { w : self } }
# [ doc = "Bit 4 - SW or HW ACK control" ] # [ inline ( always ) ] pub fn ucswack ( & mut self ) -> UCSWACK_W { UCSWACK_W { w : self } }
# [ doc = "Bit 5 - ACK all master bytes" ] # [ inline ( always ) ] pub fn ucstpnack ( & mut self ) -> UCSTPNACK_W { UCSTPNACK_W { w : self } }
# [ doc = "Bits 6:7 - Clock low timeout select" ] # [ inline ( always ) ] pub fn ucclto ( & mut self ) -> UCCLTO_W { UCCLTO_W { w : self } }
# [ doc = "Bit 8 - Early UCTXIFG0" ] # [ inline ( always ) ] pub fn ucetxint ( & mut self ) -> UCETXINT_W { UCETXINT_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Baud Rate Control Word Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0brw](ucb0brw) module" ] pub type UCB0BRW = crate :: Reg < u16 , _UCB0BRW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0BRW ;
# [ doc = "`read()` method returns [ucb0brw::R](ucb0brw::R) reader structure" ] impl crate :: Readable for UCB0BRW { }
# [ doc = "`write(|w| ..)` method takes [ucb0brw::W](ucb0brw::W) writer structure" ] impl crate :: Writable for UCB0BRW { }
# [ doc = "eUSCI_Bx Baud Rate Control Word Register" ] pub mod ucb0brw {
# [ doc = "Reader of register UCB0BRW" ] pub type R = crate :: R < u16 , super :: UCB0BRW > ;
# [ doc = "Writer for register UCB0BRW" ] pub type W = crate :: W < u16 , super :: UCB0BRW > ;
# [ doc = "Register UCB0BRW `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0BRW { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "eUSCI_Bx Bit Rate Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0brw_spi](ucb0brw_spi) module" ] pub type UCB0BRW_SPI = crate :: Reg < u16 , _UCB0BRW_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0BRW_SPI ;
# [ doc = "`read()` method returns [ucb0brw_spi::R](ucb0brw_spi::R) reader structure" ] impl crate :: Readable for UCB0BRW_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb0brw_spi::W](ucb0brw_spi::W) writer structure" ] impl crate :: Writable for UCB0BRW_SPI { }
# [ doc = "eUSCI_Bx Bit Rate Control Register 1" ] pub mod ucb0brw_spi {
# [ doc = "Reader of register UCB0BRW_SPI" ] pub type R = crate :: R < u16 , super :: UCB0BRW_SPI > ;
# [ doc = "Writer for register UCB0BRW_SPI" ] pub type W = crate :: W < u16 , super :: UCB0BRW_SPI > ;
# [ doc = "Register UCB0BRW_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0BRW_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "eUSCI_Bx Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0statw](ucb0statw) module" ] pub type UCB0STATW = crate :: Reg < u16 , _UCB0STATW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0STATW ;
# [ doc = "`read()` method returns [ucb0statw::R](ucb0statw::R) reader structure" ] impl crate :: Readable for UCB0STATW { }
# [ doc = "eUSCI_Bx Status Register" ] pub mod ucb0statw {
# [ doc = "Reader of register UCB0STATW" ] pub type R = crate :: R < u16 , super :: UCB0STATW > ;
# [ doc = "Bus busy\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBBUSY_A { # [ doc = "0: Bus inactive" ] IDLE = 0 , # [ doc = "1: Bus busy" ] BUSY = 1 } impl From < UCBBUSY_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBBUSY_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBBUSY`" ] pub type UCBBUSY_R = crate :: R < bool , UCBBUSY_A > ; impl UCBBUSY_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBBUSY_A { match self . bits { false => UCBBUSY_A :: IDLE , true => UCBBUSY_A :: BUSY } } # [ doc = "Checks if the value of the field is `IDLE`" ] # [ inline ( always ) ] pub fn is_idle ( & self ) -> bool { * self == UCBBUSY_A :: IDLE } # [ doc = "Checks if the value of the field is `BUSY`" ] # [ inline ( always ) ] pub fn is_busy ( & self ) -> bool { * self == UCBBUSY_A :: BUSY } }
# [ doc = "General call address received\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCGC_A { # [ doc = "0: No general call address received" ] UCGC_0 = 0 , # [ doc = "1: General call address received" ] UCGC_1 = 1 } impl From < UCGC_A > for bool { # [ inline ( always ) ] fn from ( variant : UCGC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCGC`" ] pub type UCGC_R = crate :: R < bool , UCGC_A > ; impl UCGC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCGC_A { match self . bits { false => UCGC_A :: UCGC_0 , true => UCGC_A :: UCGC_1 } } # [ doc = "Checks if the value of the field is `UCGC_0`" ] # [ inline ( always ) ] pub fn is_ucgc_0 ( & self ) -> bool { * self == UCGC_A :: UCGC_0 } # [ doc = "Checks if the value of the field is `UCGC_1`" ] # [ inline ( always ) ] pub fn is_ucgc_1 ( & self ) -> bool { * self == UCGC_A :: UCGC_1 } }
# [ doc = "SCL low\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSCLLOW_A { # [ doc = "0: SCL is not held low" ] UCSCLLOW_0 = 0 , # [ doc = "1: SCL is held low" ] UCSCLLOW_1 = 1 } impl From < UCSCLLOW_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSCLLOW_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSCLLOW`" ] pub type UCSCLLOW_R = crate :: R < bool , UCSCLLOW_A > ; impl UCSCLLOW_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSCLLOW_A { match self . bits { false => UCSCLLOW_A :: UCSCLLOW_0 , true => UCSCLLOW_A :: UCSCLLOW_1 } } # [ doc = "Checks if the value of the field is `UCSCLLOW_0`" ] # [ inline ( always ) ] pub fn is_ucscllow_0 ( & self ) -> bool { * self == UCSCLLOW_A :: UCSCLLOW_0 } # [ doc = "Checks if the value of the field is `UCSCLLOW_1`" ] # [ inline ( always ) ] pub fn is_ucscllow_1 ( & self ) -> bool { * self == UCSCLLOW_A :: UCSCLLOW_1 } }
# [ doc = "Reader of field `UCBCNT`" ] pub type UCBCNT_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bit 4 - Bus busy" ] # [ inline ( always ) ] pub fn ucbbusy ( & self ) -> UCBBUSY_R { UCBBUSY_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - General call address received" ] # [ inline ( always ) ] pub fn ucgc ( & self ) -> UCGC_R { UCGC_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - SCL low" ] # [ inline ( always ) ] pub fn ucscllow ( & self ) -> UCSCLLOW_R { UCSCLLOW_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:15 - Hardware byte counter value" ] # [ inline ( always ) ] pub fn ucbcnt ( & self ) -> UCBCNT_R { UCBCNT_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
}
}
# [ doc = "UCB0STATW_SPI\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0statw_spi](ucb0statw_spi) module" ] pub type UCB0STATW_SPI = crate :: Reg < u16 , _UCB0STATW_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0STATW_SPI ;
# [ doc = "`read()` method returns [ucb0statw_spi::R](ucb0statw_spi::R) reader structure" ] impl crate :: Readable for UCB0STATW_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb0statw_spi::W](ucb0statw_spi::W) writer structure" ] impl crate :: Writable for UCB0STATW_SPI { }
# [ doc = "UCB0STATW_SPI" ] pub mod ucb0statw_spi {
# [ doc = "Reader of register UCB0STATW_SPI" ] pub type R = crate :: R < u16 , super :: UCB0STATW_SPI > ;
# [ doc = "Writer for register UCB0STATW_SPI" ] pub type W = crate :: W < u16 , super :: UCB0STATW_SPI > ;
# [ doc = "Register UCB0STATW_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0STATW_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Overrun error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOE_A { # [ doc = "0: No error" ] UCOE_0 = 0 , # [ doc = "1: Overrun error occurred" ] UCOE_1 = 1 } impl From < UCOE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOE`" ] pub type UCOE_R = crate :: R < bool , UCOE_A > ; impl UCOE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOE_A { match self . bits { false => UCOE_A :: UCOE_0 , true => UCOE_A :: UCOE_1 } } # [ doc = "Checks if the value of the field is `UCOE_0`" ] # [ inline ( always ) ] pub fn is_ucoe_0 ( & self ) -> bool { * self == UCOE_A :: UCOE_0 } # [ doc = "Checks if the value of the field is `UCOE_1`" ] # [ inline ( always ) ] pub fn is_ucoe_1 ( & self ) -> bool { * self == UCOE_A :: UCOE_1 } }
# [ doc = "Write proxy for field `UCOE`" ] pub struct UCOE_W < 'a > { w : & 'a mut W , } impl < 'a > UCOE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucoe_0 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_0 ) } # [ doc = "Overrun error occurred" ] # [ inline ( always ) ] pub fn ucoe_1 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Framing error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCFE_A { # [ doc = "0: No error" ] UCFE_0 = 0 , # [ doc = "1: Bus conflict occurred" ] UCFE_1 = 1 } impl From < UCFE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCFE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCFE`" ] pub type UCFE_R = crate :: R < bool , UCFE_A > ; impl UCFE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCFE_A { match self . bits { false => UCFE_A :: UCFE_0 , true => UCFE_A :: UCFE_1 } } # [ doc = "Checks if the value of the field is `UCFE_0`" ] # [ inline ( always ) ] pub fn is_ucfe_0 ( & self ) -> bool { * self == UCFE_A :: UCFE_0 } # [ doc = "Checks if the value of the field is `UCFE_1`" ] # [ inline ( always ) ] pub fn is_ucfe_1 ( & self ) -> bool { * self == UCFE_A :: UCFE_1 } }
# [ doc = "Write proxy for field `UCFE`" ] pub struct UCFE_W < 'a > { w : & 'a mut W , } impl < 'a > UCFE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCFE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucfe_0 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_0 ) } # [ doc = "Bus conflict occurred" ] # [ inline ( always ) ] pub fn ucfe_1 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Listen enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCLISTEN_A { # [ doc = "0: Disabled" ] UCLISTEN_0 = 0 , # [ doc = "1: Enabled. UCBxTXD is internally fed back to the receiver" ] UCLISTEN_1 = 1 } impl From < UCLISTEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCLISTEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCLISTEN`" ] pub type UCLISTEN_R = crate :: R < bool , UCLISTEN_A > ; impl UCLISTEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCLISTEN_A { match self . bits { false => UCLISTEN_A :: UCLISTEN_0 , true => UCLISTEN_A :: UCLISTEN_1 } } # [ doc = "Checks if the value of the field is `UCLISTEN_0`" ] # [ inline ( always ) ] pub fn is_uclisten_0 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_0 } # [ doc = "Checks if the value of the field is `UCLISTEN_1`" ] # [ inline ( always ) ] pub fn is_uclisten_1 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_1 } }
# [ doc = "Write proxy for field `UCLISTEN`" ] pub struct UCLISTEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCLISTEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCLISTEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn uclisten_0 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_0 ) } # [ doc = "Enabled. UCBxTXD is internally fed back to the receiver" ] # [ inline ( always ) ] pub fn uclisten_1 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & self ) -> UCOE_R { UCOE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & self ) -> UCFE_R { UCFE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & self ) -> UCLISTEN_R { UCLISTEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & mut self ) -> UCOE_W { UCOE_W { w : self } }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & mut self ) -> UCFE_W { UCFE_W { w : self } }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & mut self ) -> UCLISTEN_W { UCLISTEN_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Byte Counter Threshold Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0tbcnt](ucb0tbcnt) module" ] pub type UCB0TBCNT = crate :: Reg < u16 , _UCB0TBCNT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0TBCNT ;
# [ doc = "`read()` method returns [ucb0tbcnt::R](ucb0tbcnt::R) reader structure" ] impl crate :: Readable for UCB0TBCNT { }
# [ doc = "`write(|w| ..)` method takes [ucb0tbcnt::W](ucb0tbcnt::W) writer structure" ] impl crate :: Writable for UCB0TBCNT { }
# [ doc = "eUSCI_Bx Byte Counter Threshold Register" ] pub mod ucb0tbcnt {
# [ doc = "Reader of register UCB0TBCNT" ] pub type R = crate :: R < u16 , super :: UCB0TBCNT > ;
# [ doc = "Writer for register UCB0TBCNT" ] pub type W = crate :: W < u16 , super :: UCB0TBCNT > ;
# [ doc = "Register UCB0TBCNT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0TBCNT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UCTBCNT`" ] pub type UCTBCNT_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCTBCNT`" ] pub struct UCTBCNT_W < 'a > { w : & 'a mut W , } impl < 'a > UCTBCNT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Byte counter threshold value" ] # [ inline ( always ) ] pub fn uctbcnt ( & self ) -> UCTBCNT_R { UCTBCNT_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Byte counter threshold value" ] # [ inline ( always ) ] pub fn uctbcnt ( & mut self ) -> UCTBCNT_W { UCTBCNT_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Receive Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0rxbuf](ucb0rxbuf) module" ] pub type UCB0RXBUF = crate :: Reg < u16 , _UCB0RXBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0RXBUF ;
# [ doc = "`read()` method returns [ucb0rxbuf::R](ucb0rxbuf::R) reader structure" ] impl crate :: Readable for UCB0RXBUF { }
# [ doc = "eUSCI_Bx Receive Buffer Register" ] pub mod ucb0rxbuf {
# [ doc = "Reader of register UCB0RXBUF" ] pub type R = crate :: R < u16 , super :: UCB0RXBUF > ;
# [ doc = "Reader of field `UCRXBUF`" ] pub type UCRXBUF_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Receive data buffer" ] # [ inline ( always ) ] pub fn ucrxbuf ( & self ) -> UCRXBUF_R { UCRXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
}
# [ doc = "eUSCI_Bx Receive Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0rxbuf_spi](ucb0rxbuf_spi) module" ] pub type UCB0RXBUF_SPI = crate :: Reg < u16 , _UCB0RXBUF_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0RXBUF_SPI ;
# [ doc = "`read()` method returns [ucb0rxbuf_spi::R](ucb0rxbuf_spi::R) reader structure" ] impl crate :: Readable for UCB0RXBUF_SPI { }
# [ doc = "eUSCI_Bx Receive Buffer Register" ] pub mod ucb0rxbuf_spi {
# [ doc = "Reader of register UCB0RXBUF_SPI" ] pub type R = crate :: R < u16 , super :: UCB0RXBUF_SPI > ;
# [ doc = "Reader of field `UCRXBUF`" ] pub type UCRXBUF_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Receive data buffer" ] # [ inline ( always ) ] pub fn ucrxbuf ( & self ) -> UCRXBUF_R { UCRXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
}
# [ doc = "eUSCI_Bx Transmit Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0txbuf](ucb0txbuf) module" ] pub type UCB0TXBUF = crate :: Reg < u16 , _UCB0TXBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0TXBUF ;
# [ doc = "`read()` method returns [ucb0txbuf::R](ucb0txbuf::R) reader structure" ] impl crate :: Readable for UCB0TXBUF { }
# [ doc = "`write(|w| ..)` method takes [ucb0txbuf::W](ucb0txbuf::W) writer structure" ] impl crate :: Writable for UCB0TXBUF { }
# [ doc = "eUSCI_Bx Transmit Buffer Register" ] pub mod ucb0txbuf {
# [ doc = "Reader of register UCB0TXBUF" ] pub type R = crate :: R < u16 , super :: UCB0TXBUF > ;
# [ doc = "Writer for register UCB0TXBUF" ] pub type W = crate :: W < u16 , super :: UCB0TXBUF > ;
# [ doc = "Register UCB0TXBUF `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0TXBUF { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UCTXBUF`" ] pub type UCTXBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCTXBUF`" ] pub struct UCTXBUF_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & self ) -> UCTXBUF_R { UCTXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & mut self ) -> UCTXBUF_W { UCTXBUF_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Transmit Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0txbuf_spi](ucb0txbuf_spi) module" ] pub type UCB0TXBUF_SPI = crate :: Reg < u16 , _UCB0TXBUF_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0TXBUF_SPI ;
# [ doc = "`read()` method returns [ucb0txbuf_spi::R](ucb0txbuf_spi::R) reader structure" ] impl crate :: Readable for UCB0TXBUF_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb0txbuf_spi::W](ucb0txbuf_spi::W) writer structure" ] impl crate :: Writable for UCB0TXBUF_SPI { }
# [ doc = "eUSCI_Bx Transmit Buffer Register" ] pub mod ucb0txbuf_spi {
# [ doc = "Reader of register UCB0TXBUF_SPI" ] pub type R = crate :: R < u16 , super :: UCB0TXBUF_SPI > ;
# [ doc = "Writer for register UCB0TXBUF_SPI" ] pub type W = crate :: W < u16 , super :: UCB0TXBUF_SPI > ;
# [ doc = "Register UCB0TXBUF_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0TXBUF_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UCTXBUF`" ] pub type UCTXBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCTXBUF`" ] pub struct UCTXBUF_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & self ) -> UCTXBUF_R { UCTXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & mut self ) -> UCTXBUF_W { UCTXBUF_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Own Address 0 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0i2coa0](ucb0i2coa0) module" ] pub type UCB0I2COA0 = crate :: Reg < u16 , _UCB0I2COA0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0I2COA0 ;
# [ doc = "`read()` method returns [ucb0i2coa0::R](ucb0i2coa0::R) reader structure" ] impl crate :: Readable for UCB0I2COA0 { }
# [ doc = "`write(|w| ..)` method takes [ucb0i2coa0::W](ucb0i2coa0::W) writer structure" ] impl crate :: Writable for UCB0I2COA0 { }
# [ doc = "eUSCI_Bx I2C Own Address 0 Register" ] pub mod ucb0i2coa0 {
# [ doc = "Reader of register UCB0I2COA0" ] pub type R = crate :: R < u16 , super :: UCB0I2COA0 > ;
# [ doc = "Writer for register UCB0I2COA0" ] pub type W = crate :: W < u16 , super :: UCB0I2COA0 > ;
# [ doc = "Register UCB0I2COA0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0I2COA0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `I2COA0`" ] pub type I2COA0_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `I2COA0`" ] pub struct I2COA0_W < 'a > { w : & 'a mut W , } impl < 'a > I2COA0_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
# [ doc = "Own Address enable register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOAEN_A { # [ doc = "0: The slave address defined in I2COA0 is disabled" ] DISABLE = 0 , # [ doc = "1: The slave address defined in I2COA0 is enabled" ] ENABLE = 1 } impl From < UCOAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOAEN`" ] pub type UCOAEN_R = crate :: R < bool , UCOAEN_A > ; impl UCOAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOAEN_A { match self . bits { false => UCOAEN_A :: DISABLE , true => UCOAEN_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCOAEN_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCOAEN_A :: ENABLE } }
# [ doc = "Write proxy for field `UCOAEN`" ] pub struct UCOAEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCOAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The slave address defined in I2COA0 is disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: DISABLE ) } # [ doc = "The slave address defined in I2COA0 is enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "General call response enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCGCEN_A { # [ doc = "0: Do not respond to a general call" ] UCGCEN_0 = 0 , # [ doc = "1: Respond to a general call" ] UCGCEN_1 = 1 } impl From < UCGCEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCGCEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCGCEN`" ] pub type UCGCEN_R = crate :: R < bool , UCGCEN_A > ; impl UCGCEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCGCEN_A { match self . bits { false => UCGCEN_A :: UCGCEN_0 , true => UCGCEN_A :: UCGCEN_1 } } # [ doc = "Checks if the value of the field is `UCGCEN_0`" ] # [ inline ( always ) ] pub fn is_ucgcen_0 ( & self ) -> bool { * self == UCGCEN_A :: UCGCEN_0 } # [ doc = "Checks if the value of the field is `UCGCEN_1`" ] # [ inline ( always ) ] pub fn is_ucgcen_1 ( & self ) -> bool { * self == UCGCEN_A :: UCGCEN_1 } }
# [ doc = "Write proxy for field `UCGCEN`" ] pub struct UCGCEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCGCEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCGCEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Do not respond to a general call" ] # [ inline ( always ) ] pub fn ucgcen_0 ( self ) -> & 'a mut W { self . variant ( UCGCEN_A :: UCGCEN_0 ) } # [ doc = "Respond to a general call" ] # [ inline ( always ) ] pub fn ucgcen_1 ( self ) -> & 'a mut W { self . variant ( UCGCEN_A :: UCGCEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa0 ( & self ) -> I2COA0_R { I2COA0_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & self ) -> UCOAEN_R { UCOAEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - General call response enable" ] # [ inline ( always ) ] pub fn ucgcen ( & self ) -> UCGCEN_R { UCGCEN_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa0 ( & mut self ) -> I2COA0_W { I2COA0_W { w : self } }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & mut self ) -> UCOAEN_W { UCOAEN_W { w : self } }
# [ doc = "Bit 15 - General call response enable" ] # [ inline ( always ) ] pub fn ucgcen ( & mut self ) -> UCGCEN_W { UCGCEN_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Own Address 1 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0i2coa1](ucb0i2coa1) module" ] pub type UCB0I2COA1 = crate :: Reg < u16 , _UCB0I2COA1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0I2COA1 ;
# [ doc = "`read()` method returns [ucb0i2coa1::R](ucb0i2coa1::R) reader structure" ] impl crate :: Readable for UCB0I2COA1 { }
# [ doc = "`write(|w| ..)` method takes [ucb0i2coa1::W](ucb0i2coa1::W) writer structure" ] impl crate :: Writable for UCB0I2COA1 { }
# [ doc = "eUSCI_Bx I2C Own Address 1 Register" ] pub mod ucb0i2coa1 {
# [ doc = "Reader of register UCB0I2COA1" ] pub type R = crate :: R < u16 , super :: UCB0I2COA1 > ;
# [ doc = "Writer for register UCB0I2COA1" ] pub type W = crate :: W < u16 , super :: UCB0I2COA1 > ;
# [ doc = "Register UCB0I2COA1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0I2COA1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `I2COA1`" ] pub type I2COA1_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `I2COA1`" ] pub struct I2COA1_W < 'a > { w : & 'a mut W , } impl < 'a > I2COA1_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
# [ doc = "Own Address enable register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOAEN_A { # [ doc = "0: The slave address defined in I2COA1 is disabled" ] DISABLE = 0 , # [ doc = "1: The slave address defined in I2COA1 is enabled" ] ENABLE = 1 } impl From < UCOAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOAEN`" ] pub type UCOAEN_R = crate :: R < bool , UCOAEN_A > ; impl UCOAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOAEN_A { match self . bits { false => UCOAEN_A :: DISABLE , true => UCOAEN_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCOAEN_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCOAEN_A :: ENABLE } }
# [ doc = "Write proxy for field `UCOAEN`" ] pub struct UCOAEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCOAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The slave address defined in I2COA1 is disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: DISABLE ) } # [ doc = "The slave address defined in I2COA1 is enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa1 ( & self ) -> I2COA1_R { I2COA1_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & self ) -> UCOAEN_R { UCOAEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa1 ( & mut self ) -> I2COA1_W { I2COA1_W { w : self } }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & mut self ) -> UCOAEN_W { UCOAEN_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Own Address 2 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0i2coa2](ucb0i2coa2) module" ] pub type UCB0I2COA2 = crate :: Reg < u16 , _UCB0I2COA2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0I2COA2 ;
# [ doc = "`read()` method returns [ucb0i2coa2::R](ucb0i2coa2::R) reader structure" ] impl crate :: Readable for UCB0I2COA2 { }
# [ doc = "`write(|w| ..)` method takes [ucb0i2coa2::W](ucb0i2coa2::W) writer structure" ] impl crate :: Writable for UCB0I2COA2 { }
# [ doc = "eUSCI_Bx I2C Own Address 2 Register" ] pub mod ucb0i2coa2 {
# [ doc = "Reader of register UCB0I2COA2" ] pub type R = crate :: R < u16 , super :: UCB0I2COA2 > ;
# [ doc = "Writer for register UCB0I2COA2" ] pub type W = crate :: W < u16 , super :: UCB0I2COA2 > ;
# [ doc = "Register UCB0I2COA2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0I2COA2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `I2COA2`" ] pub type I2COA2_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `I2COA2`" ] pub struct I2COA2_W < 'a > { w : & 'a mut W , } impl < 'a > I2COA2_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
# [ doc = "Own Address enable register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOAEN_A { # [ doc = "0: The slave address defined in I2COA2 is disabled" ] DISABLE = 0 , # [ doc = "1: The slave address defined in I2COA2 is enabled" ] ENABLE = 1 } impl From < UCOAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOAEN`" ] pub type UCOAEN_R = crate :: R < bool , UCOAEN_A > ; impl UCOAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOAEN_A { match self . bits { false => UCOAEN_A :: DISABLE , true => UCOAEN_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCOAEN_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCOAEN_A :: ENABLE } }
# [ doc = "Write proxy for field `UCOAEN`" ] pub struct UCOAEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCOAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The slave address defined in I2COA2 is disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: DISABLE ) } # [ doc = "The slave address defined in I2COA2 is enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa2 ( & self ) -> I2COA2_R { I2COA2_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & self ) -> UCOAEN_R { UCOAEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa2 ( & mut self ) -> I2COA2_W { I2COA2_W { w : self } }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & mut self ) -> UCOAEN_W { UCOAEN_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Own Address 3 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0i2coa3](ucb0i2coa3) module" ] pub type UCB0I2COA3 = crate :: Reg < u16 , _UCB0I2COA3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0I2COA3 ;
# [ doc = "`read()` method returns [ucb0i2coa3::R](ucb0i2coa3::R) reader structure" ] impl crate :: Readable for UCB0I2COA3 { }
# [ doc = "`write(|w| ..)` method takes [ucb0i2coa3::W](ucb0i2coa3::W) writer structure" ] impl crate :: Writable for UCB0I2COA3 { }
# [ doc = "eUSCI_Bx I2C Own Address 3 Register" ] pub mod ucb0i2coa3 {
# [ doc = "Reader of register UCB0I2COA3" ] pub type R = crate :: R < u16 , super :: UCB0I2COA3 > ;
# [ doc = "Writer for register UCB0I2COA3" ] pub type W = crate :: W < u16 , super :: UCB0I2COA3 > ;
# [ doc = "Register UCB0I2COA3 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0I2COA3 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `I2COA3`" ] pub type I2COA3_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `I2COA3`" ] pub struct I2COA3_W < 'a > { w : & 'a mut W , } impl < 'a > I2COA3_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
# [ doc = "Own Address enable register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOAEN_A { # [ doc = "0: The slave address defined in I2COA3 is disabled" ] DISABLE = 0 , # [ doc = "1: The slave address defined in I2COA3 is enabled" ] ENABLE = 1 } impl From < UCOAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOAEN`" ] pub type UCOAEN_R = crate :: R < bool , UCOAEN_A > ; impl UCOAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOAEN_A { match self . bits { false => UCOAEN_A :: DISABLE , true => UCOAEN_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCOAEN_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCOAEN_A :: ENABLE } }
# [ doc = "Write proxy for field `UCOAEN`" ] pub struct UCOAEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCOAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The slave address defined in I2COA3 is disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: DISABLE ) } # [ doc = "The slave address defined in I2COA3 is enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa3 ( & self ) -> I2COA3_R { I2COA3_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & self ) -> UCOAEN_R { UCOAEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa3 ( & mut self ) -> I2COA3_W { I2COA3_W { w : self } }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & mut self ) -> UCOAEN_W { UCOAEN_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Received Address Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0addrx](ucb0addrx) module" ] pub type UCB0ADDRX = crate :: Reg < u16 , _UCB0ADDRX > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0ADDRX ;
# [ doc = "`read()` method returns [ucb0addrx::R](ucb0addrx::R) reader structure" ] impl crate :: Readable for UCB0ADDRX { }
# [ doc = "eUSCI_Bx I2C Received Address Register" ] pub mod ucb0addrx {
# [ doc = "Reader of register UCB0ADDRX" ] pub type R = crate :: R < u16 , super :: UCB0ADDRX > ;
# [ doc = "Reader of field `ADDRX`" ] pub type ADDRX_R = crate :: R < u16 , u16 > ;
impl R {
# [ doc = "Bits 0:9 - Received Address Register" ] # [ inline ( always ) ] pub fn addrx ( & self ) -> ADDRX_R { ADDRX_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
}
}
# [ doc = "eUSCI_Bx I2C Address Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0addmask](ucb0addmask) module" ] pub type UCB0ADDMASK = crate :: Reg < u16 , _UCB0ADDMASK > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0ADDMASK ;
# [ doc = "`read()` method returns [ucb0addmask::R](ucb0addmask::R) reader structure" ] impl crate :: Readable for UCB0ADDMASK { }
# [ doc = "`write(|w| ..)` method takes [ucb0addmask::W](ucb0addmask::W) writer structure" ] impl crate :: Writable for UCB0ADDMASK { }
# [ doc = "eUSCI_Bx I2C Address Mask Register" ] pub mod ucb0addmask {
# [ doc = "Reader of register UCB0ADDMASK" ] pub type R = crate :: R < u16 , super :: UCB0ADDMASK > ;
# [ doc = "Writer for register UCB0ADDMASK" ] pub type W = crate :: W < u16 , super :: UCB0ADDMASK > ;
# [ doc = "Register UCB0ADDMASK `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0ADDMASK { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ADDMASK`" ] pub type ADDMASK_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `ADDMASK`" ] pub struct ADDMASK_W < 'a > { w : & 'a mut W , } impl < 'a > ADDMASK_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - Address Mask Register. By clearing the corresponding bit of the own address, this bit is a don't care when comparing the address on the bus to the own address. Using this method, it is possible to react on more than one slave address. When all bits of ADDMASKx are set, the address mask feature is deactivated. Modify only when UCSWRST = 1." ] # [ inline ( always ) ] pub fn addmask ( & self ) -> ADDMASK_R { ADDMASK_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:9 - Address Mask Register. By clearing the corresponding bit of the own address, this bit is a don't care when comparing the address on the bus to the own address. Using this method, it is possible to react on more than one slave address. When all bits of ADDMASKx are set, the address mask feature is deactivated. Modify only when UCSWRST = 1." ] # [ inline ( always ) ] pub fn addmask ( & mut self ) -> ADDMASK_W { ADDMASK_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Slave Address Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0i2csa](ucb0i2csa) module" ] pub type UCB0I2CSA = crate :: Reg < u16 , _UCB0I2CSA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0I2CSA ;
# [ doc = "`read()` method returns [ucb0i2csa::R](ucb0i2csa::R) reader structure" ] impl crate :: Readable for UCB0I2CSA { }
# [ doc = "`write(|w| ..)` method takes [ucb0i2csa::W](ucb0i2csa::W) writer structure" ] impl crate :: Writable for UCB0I2CSA { }
# [ doc = "eUSCI_Bx I2C Slave Address Register" ] pub mod ucb0i2csa {
# [ doc = "Reader of register UCB0I2CSA" ] pub type R = crate :: R < u16 , super :: UCB0I2CSA > ;
# [ doc = "Writer for register UCB0I2CSA" ] pub type W = crate :: W < u16 , super :: UCB0I2CSA > ;
# [ doc = "Register UCB0I2CSA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0I2CSA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `I2CSA`" ] pub type I2CSA_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `I2CSA`" ] pub struct I2CSA_W < 'a > { w : & 'a mut W , } impl < 'a > I2CSA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - I2C slave address" ] # [ inline ( always ) ] pub fn i2csa ( & self ) -> I2CSA_R { I2CSA_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:9 - I2C slave address" ] # [ inline ( always ) ] pub fn i2csa ( & mut self ) -> I2CSA_W { I2CSA_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ie](ucb0ie) module" ] pub type UCB0IE = crate :: Reg < u16 , _UCB0IE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0IE ;
# [ doc = "`read()` method returns [ucb0ie::R](ucb0ie::R) reader structure" ] impl crate :: Readable for UCB0IE { }
# [ doc = "`write(|w| ..)` method takes [ucb0ie::W](ucb0ie::W) writer structure" ] impl crate :: Writable for UCB0IE { }
# [ doc = "eUSCI_Bx Interrupt Enable Register" ] pub mod ucb0ie {
# [ doc = "Reader of register UCB0IE" ] pub type R = crate :: R < u16 , super :: UCB0IE > ;
# [ doc = "Writer for register UCB0IE" ] pub type W = crate :: W < u16 , super :: UCB0IE > ;
# [ doc = "Register UCB0IE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0IE { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt enable 0\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE0_A { # [ doc = "0: Interrupt disabled" ] UCRXIE0_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE0_1 = 1 } impl From < UCRXIE0_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE0`" ] pub type UCRXIE0_R = crate :: R < bool , UCRXIE0_A > ; impl UCRXIE0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE0_A { match self . bits { false => UCRXIE0_A :: UCRXIE0_0 , true => UCRXIE0_A :: UCRXIE0_1 } } # [ doc = "Checks if the value of the field is `UCRXIE0_0`" ] # [ inline ( always ) ] pub fn is_ucrxie0_0 ( & self ) -> bool { * self == UCRXIE0_A :: UCRXIE0_0 } # [ doc = "Checks if the value of the field is `UCRXIE0_1`" ] # [ inline ( always ) ] pub fn is_ucrxie0_1 ( & self ) -> bool { * self == UCRXIE0_A :: UCRXIE0_1 } }
# [ doc = "Write proxy for field `UCRXIE0`" ] pub struct UCRXIE0_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie0_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE0_A :: UCRXIE0_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie0_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE0_A :: UCRXIE0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt enable 0\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE0_A { # [ doc = "0: Interrupt disabled" ] UCTXIE0_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE0_1 = 1 } impl From < UCTXIE0_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE0`" ] pub type UCTXIE0_R = crate :: R < bool , UCTXIE0_A > ; impl UCTXIE0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE0_A { match self . bits { false => UCTXIE0_A :: UCTXIE0_0 , true => UCTXIE0_A :: UCTXIE0_1 } } # [ doc = "Checks if the value of the field is `UCTXIE0_0`" ] # [ inline ( always ) ] pub fn is_uctxie0_0 ( & self ) -> bool { * self == UCTXIE0_A :: UCTXIE0_0 } # [ doc = "Checks if the value of the field is `UCTXIE0_1`" ] # [ inline ( always ) ] pub fn is_uctxie0_1 ( & self ) -> bool { * self == UCTXIE0_A :: UCTXIE0_1 } }
# [ doc = "Write proxy for field `UCTXIE0`" ] pub struct UCTXIE0_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie0_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE0_A :: UCTXIE0_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie0_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE0_A :: UCTXIE0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "START condition interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTTIE_A { # [ doc = "0: Interrupt disabled" ] UCSTTIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCSTTIE_1 = 1 } impl From < UCSTTIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTTIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTTIE`" ] pub type UCSTTIE_R = crate :: R < bool , UCSTTIE_A > ; impl UCSTTIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTTIE_A { match self . bits { false => UCSTTIE_A :: UCSTTIE_0 , true => UCSTTIE_A :: UCSTTIE_1 } } # [ doc = "Checks if the value of the field is `UCSTTIE_0`" ] # [ inline ( always ) ] pub fn is_ucsttie_0 ( & self ) -> bool { * self == UCSTTIE_A :: UCSTTIE_0 } # [ doc = "Checks if the value of the field is `UCSTTIE_1`" ] # [ inline ( always ) ] pub fn is_ucsttie_1 ( & self ) -> bool { * self == UCSTTIE_A :: UCSTTIE_1 } }
# [ doc = "Write proxy for field `UCSTTIE`" ] pub struct UCSTTIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTTIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTTIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucsttie_0 ( self ) -> & 'a mut W { self . variant ( UCSTTIE_A :: UCSTTIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucsttie_1 ( self ) -> & 'a mut W { self . variant ( UCSTTIE_A :: UCSTTIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "STOP condition interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTPIE_A { # [ doc = "0: Interrupt disabled" ] UCSTPIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCSTPIE_1 = 1 } impl From < UCSTPIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTPIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTPIE`" ] pub type UCSTPIE_R = crate :: R < bool , UCSTPIE_A > ; impl UCSTPIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTPIE_A { match self . bits { false => UCSTPIE_A :: UCSTPIE_0 , true => UCSTPIE_A :: UCSTPIE_1 } } # [ doc = "Checks if the value of the field is `UCSTPIE_0`" ] # [ inline ( always ) ] pub fn is_ucstpie_0 ( & self ) -> bool { * self == UCSTPIE_A :: UCSTPIE_0 } # [ doc = "Checks if the value of the field is `UCSTPIE_1`" ] # [ inline ( always ) ] pub fn is_ucstpie_1 ( & self ) -> bool { * self == UCSTPIE_A :: UCSTPIE_1 } }
# [ doc = "Write proxy for field `UCSTPIE`" ] pub struct UCSTPIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTPIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTPIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucstpie_0 ( self ) -> & 'a mut W { self . variant ( UCSTPIE_A :: UCSTPIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucstpie_1 ( self ) -> & 'a mut W { self . variant ( UCSTPIE_A :: UCSTPIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Arbitration lost interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCALIE_A { # [ doc = "0: Interrupt disabled" ] UCALIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCALIE_1 = 1 } impl From < UCALIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCALIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCALIE`" ] pub type UCALIE_R = crate :: R < bool , UCALIE_A > ; impl UCALIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCALIE_A { match self . bits { false => UCALIE_A :: UCALIE_0 , true => UCALIE_A :: UCALIE_1 } } # [ doc = "Checks if the value of the field is `UCALIE_0`" ] # [ inline ( always ) ] pub fn is_ucalie_0 ( & self ) -> bool { * self == UCALIE_A :: UCALIE_0 } # [ doc = "Checks if the value of the field is `UCALIE_1`" ] # [ inline ( always ) ] pub fn is_ucalie_1 ( & self ) -> bool { * self == UCALIE_A :: UCALIE_1 } }
# [ doc = "Write proxy for field `UCALIE`" ] pub struct UCALIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCALIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCALIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucalie_0 ( self ) -> & 'a mut W { self . variant ( UCALIE_A :: UCALIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucalie_1 ( self ) -> & 'a mut W { self . variant ( UCALIE_A :: UCALIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Not-acknowledge interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCNACKIE_A { # [ doc = "0: Interrupt disabled" ] UCNACKIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCNACKIE_1 = 1 } impl From < UCNACKIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCNACKIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCNACKIE`" ] pub type UCNACKIE_R = crate :: R < bool , UCNACKIE_A > ; impl UCNACKIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCNACKIE_A { match self . bits { false => UCNACKIE_A :: UCNACKIE_0 , true => UCNACKIE_A :: UCNACKIE_1 } } # [ doc = "Checks if the value of the field is `UCNACKIE_0`" ] # [ inline ( always ) ] pub fn is_ucnackie_0 ( & self ) -> bool { * self == UCNACKIE_A :: UCNACKIE_0 } # [ doc = "Checks if the value of the field is `UCNACKIE_1`" ] # [ inline ( always ) ] pub fn is_ucnackie_1 ( & self ) -> bool { * self == UCNACKIE_A :: UCNACKIE_1 } }
# [ doc = "Write proxy for field `UCNACKIE`" ] pub struct UCNACKIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCNACKIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCNACKIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucnackie_0 ( self ) -> & 'a mut W { self . variant ( UCNACKIE_A :: UCNACKIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucnackie_1 ( self ) -> & 'a mut W { self . variant ( UCNACKIE_A :: UCNACKIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Byte counter interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBCNTIE_A { # [ doc = "0: Interrupt disabled" ] UCBCNTIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCBCNTIE_1 = 1 } impl From < UCBCNTIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBCNTIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBCNTIE`" ] pub type UCBCNTIE_R = crate :: R < bool , UCBCNTIE_A > ; impl UCBCNTIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBCNTIE_A { match self . bits { false => UCBCNTIE_A :: UCBCNTIE_0 , true => UCBCNTIE_A :: UCBCNTIE_1 } } # [ doc = "Checks if the value of the field is `UCBCNTIE_0`" ] # [ inline ( always ) ] pub fn is_ucbcntie_0 ( & self ) -> bool { * self == UCBCNTIE_A :: UCBCNTIE_0 } # [ doc = "Checks if the value of the field is `UCBCNTIE_1`" ] # [ inline ( always ) ] pub fn is_ucbcntie_1 ( & self ) -> bool { * self == UCBCNTIE_A :: UCBCNTIE_1 } }
# [ doc = "Write proxy for field `UCBCNTIE`" ] pub struct UCBCNTIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCBCNTIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBCNTIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucbcntie_0 ( self ) -> & 'a mut W { self . variant ( UCBCNTIE_A :: UCBCNTIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucbcntie_1 ( self ) -> & 'a mut W { self . variant ( UCBCNTIE_A :: UCBCNTIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Clock low timeout interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCLTOIE_A { # [ doc = "0: Interrupt disabled" ] UCCLTOIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCCLTOIE_1 = 1 } impl From < UCCLTOIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCLTOIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCLTOIE`" ] pub type UCCLTOIE_R = crate :: R < bool , UCCLTOIE_A > ; impl UCCLTOIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCLTOIE_A { match self . bits { false => UCCLTOIE_A :: UCCLTOIE_0 , true => UCCLTOIE_A :: UCCLTOIE_1 } } # [ doc = "Checks if the value of the field is `UCCLTOIE_0`" ] # [ inline ( always ) ] pub fn is_uccltoie_0 ( & self ) -> bool { * self == UCCLTOIE_A :: UCCLTOIE_0 } # [ doc = "Checks if the value of the field is `UCCLTOIE_1`" ] # [ inline ( always ) ] pub fn is_uccltoie_1 ( & self ) -> bool { * self == UCCLTOIE_A :: UCCLTOIE_1 } }
# [ doc = "Write proxy for field `UCCLTOIE`" ] pub struct UCCLTOIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCCLTOIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCLTOIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uccltoie_0 ( self ) -> & 'a mut W { self . variant ( UCCLTOIE_A :: UCCLTOIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uccltoie_1 ( self ) -> & 'a mut W { self . variant ( UCCLTOIE_A :: UCCLTOIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Receive interrupt enable 1\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE1_A { # [ doc = "0: Interrupt disabled" ] UCRXIE1_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE1_1 = 1 } impl From < UCRXIE1_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE1_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE1`" ] pub type UCRXIE1_R = crate :: R < bool , UCRXIE1_A > ; impl UCRXIE1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE1_A { match self . bits { false => UCRXIE1_A :: UCRXIE1_0 , true => UCRXIE1_A :: UCRXIE1_1 } } # [ doc = "Checks if the value of the field is `UCRXIE1_0`" ] # [ inline ( always ) ] pub fn is_ucrxie1_0 ( & self ) -> bool { * self == UCRXIE1_A :: UCRXIE1_0 } # [ doc = "Checks if the value of the field is `UCRXIE1_1`" ] # [ inline ( always ) ] pub fn is_ucrxie1_1 ( & self ) -> bool { * self == UCRXIE1_A :: UCRXIE1_1 } }
# [ doc = "Write proxy for field `UCRXIE1`" ] pub struct UCRXIE1_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE1_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie1_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE1_A :: UCRXIE1_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie1_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE1_A :: UCRXIE1_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Transmit interrupt enable 1\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE1_A { # [ doc = "0: Interrupt disabled" ] UCTXIE1_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE1_1 = 1 } impl From < UCTXIE1_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE1_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE1`" ] pub type UCTXIE1_R = crate :: R < bool , UCTXIE1_A > ; impl UCTXIE1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE1_A { match self . bits { false => UCTXIE1_A :: UCTXIE1_0 , true => UCTXIE1_A :: UCTXIE1_1 } } # [ doc = "Checks if the value of the field is `UCTXIE1_0`" ] # [ inline ( always ) ] pub fn is_uctxie1_0 ( & self ) -> bool { * self == UCTXIE1_A :: UCTXIE1_0 } # [ doc = "Checks if the value of the field is `UCTXIE1_1`" ] # [ inline ( always ) ] pub fn is_uctxie1_1 ( & self ) -> bool { * self == UCTXIE1_A :: UCTXIE1_1 } }
# [ doc = "Write proxy for field `UCTXIE1`" ] pub struct UCTXIE1_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE1_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie1_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE1_A :: UCTXIE1_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie1_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE1_A :: UCTXIE1_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Receive interrupt enable 2\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE2_A { # [ doc = "0: Interrupt disabled" ] UCRXIE2_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE2_1 = 1 } impl From < UCRXIE2_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE2_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE2`" ] pub type UCRXIE2_R = crate :: R < bool , UCRXIE2_A > ; impl UCRXIE2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE2_A { match self . bits { false => UCRXIE2_A :: UCRXIE2_0 , true => UCRXIE2_A :: UCRXIE2_1 } } # [ doc = "Checks if the value of the field is `UCRXIE2_0`" ] # [ inline ( always ) ] pub fn is_ucrxie2_0 ( & self ) -> bool { * self == UCRXIE2_A :: UCRXIE2_0 } # [ doc = "Checks if the value of the field is `UCRXIE2_1`" ] # [ inline ( always ) ] pub fn is_ucrxie2_1 ( & self ) -> bool { * self == UCRXIE2_A :: UCRXIE2_1 } }
# [ doc = "Write proxy for field `UCRXIE2`" ] pub struct UCRXIE2_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE2_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie2_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE2_A :: UCRXIE2_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie2_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE2_A :: UCRXIE2_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Transmit interrupt enable 2\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE2_A { # [ doc = "0: Interrupt disabled" ] UCTXIE2_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE2_1 = 1 } impl From < UCTXIE2_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE2_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE2`" ] pub type UCTXIE2_R = crate :: R < bool , UCTXIE2_A > ; impl UCTXIE2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE2_A { match self . bits { false => UCTXIE2_A :: UCTXIE2_0 , true => UCTXIE2_A :: UCTXIE2_1 } } # [ doc = "Checks if the value of the field is `UCTXIE2_0`" ] # [ inline ( always ) ] pub fn is_uctxie2_0 ( & self ) -> bool { * self == UCTXIE2_A :: UCTXIE2_0 } # [ doc = "Checks if the value of the field is `UCTXIE2_1`" ] # [ inline ( always ) ] pub fn is_uctxie2_1 ( & self ) -> bool { * self == UCTXIE2_A :: UCTXIE2_1 } }
# [ doc = "Write proxy for field `UCTXIE2`" ] pub struct UCTXIE2_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE2_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie2_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE2_A :: UCTXIE2_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie2_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE2_A :: UCTXIE2_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Receive interrupt enable 3\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE3_A { # [ doc = "0: Interrupt disabled" ] UCRXIE3_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE3_1 = 1 } impl From < UCRXIE3_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE3_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE3`" ] pub type UCRXIE3_R = crate :: R < bool , UCRXIE3_A > ; impl UCRXIE3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE3_A { match self . bits { false => UCRXIE3_A :: UCRXIE3_0 , true => UCRXIE3_A :: UCRXIE3_1 } } # [ doc = "Checks if the value of the field is `UCRXIE3_0`" ] # [ inline ( always ) ] pub fn is_ucrxie3_0 ( & self ) -> bool { * self == UCRXIE3_A :: UCRXIE3_0 } # [ doc = "Checks if the value of the field is `UCRXIE3_1`" ] # [ inline ( always ) ] pub fn is_ucrxie3_1 ( & self ) -> bool { * self == UCRXIE3_A :: UCRXIE3_1 } }
# [ doc = "Write proxy for field `UCRXIE3`" ] pub struct UCRXIE3_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE3_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE3_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie3_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE3_A :: UCRXIE3_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie3_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE3_A :: UCRXIE3_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Transmit interrupt enable 3\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE3_A { # [ doc = "0: Interrupt disabled" ] UCTXIE3_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE3_1 = 1 } impl From < UCTXIE3_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE3_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE3`" ] pub type UCTXIE3_R = crate :: R < bool , UCTXIE3_A > ; impl UCTXIE3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE3_A { match self . bits { false => UCTXIE3_A :: UCTXIE3_0 , true => UCTXIE3_A :: UCTXIE3_1 } } # [ doc = "Checks if the value of the field is `UCTXIE3_0`" ] # [ inline ( always ) ] pub fn is_uctxie3_0 ( & self ) -> bool { * self == UCTXIE3_A :: UCTXIE3_0 } # [ doc = "Checks if the value of the field is `UCTXIE3_1`" ] # [ inline ( always ) ] pub fn is_uctxie3_1 ( & self ) -> bool { * self == UCTXIE3_A :: UCTXIE3_1 } }
# [ doc = "Write proxy for field `UCTXIE3`" ] pub struct UCTXIE3_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE3_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE3_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie3_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE3_A :: UCTXIE3_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie3_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE3_A :: UCTXIE3_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Bit position 9 interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBIT9IE_A { # [ doc = "0: Interrupt disabled" ] UCBIT9IE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCBIT9IE_1 = 1 } impl From < UCBIT9IE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBIT9IE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBIT9IE`" ] pub type UCBIT9IE_R = crate :: R < bool , UCBIT9IE_A > ; impl UCBIT9IE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBIT9IE_A { match self . bits { false => UCBIT9IE_A :: UCBIT9IE_0 , true => UCBIT9IE_A :: UCBIT9IE_1 } } # [ doc = "Checks if the value of the field is `UCBIT9IE_0`" ] # [ inline ( always ) ] pub fn is_ucbit9ie_0 ( & self ) -> bool { * self == UCBIT9IE_A :: UCBIT9IE_0 } # [ doc = "Checks if the value of the field is `UCBIT9IE_1`" ] # [ inline ( always ) ] pub fn is_ucbit9ie_1 ( & self ) -> bool { * self == UCBIT9IE_A :: UCBIT9IE_1 } }
# [ doc = "Write proxy for field `UCBIT9IE`" ] pub struct UCBIT9IE_W < 'a > { w : & 'a mut W , } impl < 'a > UCBIT9IE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBIT9IE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucbit9ie_0 ( self ) -> & 'a mut W { self . variant ( UCBIT9IE_A :: UCBIT9IE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucbit9ie_1 ( self ) -> & 'a mut W { self . variant ( UCBIT9IE_A :: UCBIT9IE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt enable 0" ] # [ inline ( always ) ] pub fn ucrxie0 ( & self ) -> UCRXIE0_R { UCRXIE0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt enable 0" ] # [ inline ( always ) ] pub fn uctxie0 ( & self ) -> UCTXIE0_R { UCTXIE0_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - START condition interrupt enable" ] # [ inline ( always ) ] pub fn ucsttie ( & self ) -> UCSTTIE_R { UCSTTIE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - STOP condition interrupt enable" ] # [ inline ( always ) ] pub fn ucstpie ( & self ) -> UCSTPIE_R { UCSTPIE_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Arbitration lost interrupt enable" ] # [ inline ( always ) ] pub fn ucalie ( & self ) -> UCALIE_R { UCALIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Not-acknowledge interrupt enable" ] # [ inline ( always ) ] pub fn ucnackie ( & self ) -> UCNACKIE_R { UCNACKIE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Byte counter interrupt enable" ] # [ inline ( always ) ] pub fn ucbcntie ( & self ) -> UCBCNTIE_R { UCBCNTIE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Clock low timeout interrupt enable" ] # [ inline ( always ) ] pub fn uccltoie ( & self ) -> UCCLTOIE_R { UCCLTOIE_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Receive interrupt enable 1" ] # [ inline ( always ) ] pub fn ucrxie1 ( & self ) -> UCRXIE1_R { UCRXIE1_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Transmit interrupt enable 1" ] # [ inline ( always ) ] pub fn uctxie1 ( & self ) -> UCTXIE1_R { UCTXIE1_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Receive interrupt enable 2" ] # [ inline ( always ) ] pub fn ucrxie2 ( & self ) -> UCRXIE2_R { UCRXIE2_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Transmit interrupt enable 2" ] # [ inline ( always ) ] pub fn uctxie2 ( & self ) -> UCTXIE2_R { UCTXIE2_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Receive interrupt enable 3" ] # [ inline ( always ) ] pub fn ucrxie3 ( & self ) -> UCRXIE3_R { UCRXIE3_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Transmit interrupt enable 3" ] # [ inline ( always ) ] pub fn uctxie3 ( & self ) -> UCTXIE3_R { UCTXIE3_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Bit position 9 interrupt enable" ] # [ inline ( always ) ] pub fn ucbit9ie ( & self ) -> UCBIT9IE_R { UCBIT9IE_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt enable 0" ] # [ inline ( always ) ] pub fn ucrxie0 ( & mut self ) -> UCRXIE0_W { UCRXIE0_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt enable 0" ] # [ inline ( always ) ] pub fn uctxie0 ( & mut self ) -> UCTXIE0_W { UCTXIE0_W { w : self } }
# [ doc = "Bit 2 - START condition interrupt enable" ] # [ inline ( always ) ] pub fn ucsttie ( & mut self ) -> UCSTTIE_W { UCSTTIE_W { w : self } }
# [ doc = "Bit 3 - STOP condition interrupt enable" ] # [ inline ( always ) ] pub fn ucstpie ( & mut self ) -> UCSTPIE_W { UCSTPIE_W { w : self } }
# [ doc = "Bit 4 - Arbitration lost interrupt enable" ] # [ inline ( always ) ] pub fn ucalie ( & mut self ) -> UCALIE_W { UCALIE_W { w : self } }
# [ doc = "Bit 5 - Not-acknowledge interrupt enable" ] # [ inline ( always ) ] pub fn ucnackie ( & mut self ) -> UCNACKIE_W { UCNACKIE_W { w : self } }
# [ doc = "Bit 6 - Byte counter interrupt enable" ] # [ inline ( always ) ] pub fn ucbcntie ( & mut self ) -> UCBCNTIE_W { UCBCNTIE_W { w : self } }
# [ doc = "Bit 7 - Clock low timeout interrupt enable" ] # [ inline ( always ) ] pub fn uccltoie ( & mut self ) -> UCCLTOIE_W { UCCLTOIE_W { w : self } }
# [ doc = "Bit 8 - Receive interrupt enable 1" ] # [ inline ( always ) ] pub fn ucrxie1 ( & mut self ) -> UCRXIE1_W { UCRXIE1_W { w : self } }
# [ doc = "Bit 9 - Transmit interrupt enable 1" ] # [ inline ( always ) ] pub fn uctxie1 ( & mut self ) -> UCTXIE1_W { UCTXIE1_W { w : self } }
# [ doc = "Bit 10 - Receive interrupt enable 2" ] # [ inline ( always ) ] pub fn ucrxie2 ( & mut self ) -> UCRXIE2_W { UCRXIE2_W { w : self } }
# [ doc = "Bit 11 - Transmit interrupt enable 2" ] # [ inline ( always ) ] pub fn uctxie2 ( & mut self ) -> UCTXIE2_W { UCTXIE2_W { w : self } }
# [ doc = "Bit 12 - Receive interrupt enable 3" ] # [ inline ( always ) ] pub fn ucrxie3 ( & mut self ) -> UCRXIE3_W { UCRXIE3_W { w : self } }
# [ doc = "Bit 13 - Transmit interrupt enable 3" ] # [ inline ( always ) ] pub fn uctxie3 ( & mut self ) -> UCTXIE3_W { UCTXIE3_W { w : self } }
# [ doc = "Bit 14 - Bit position 9 interrupt enable" ] # [ inline ( always ) ] pub fn ucbit9ie ( & mut self ) -> UCBIT9IE_W { UCBIT9IE_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ie_spi](ucb0ie_spi) module" ] pub type UCB0IE_SPI = crate :: Reg < u16 , _UCB0IE_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0IE_SPI ;
# [ doc = "`read()` method returns [ucb0ie_spi::R](ucb0ie_spi::R) reader structure" ] impl crate :: Readable for UCB0IE_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb0ie_spi::W](ucb0ie_spi::W) writer structure" ] impl crate :: Writable for UCB0IE_SPI { }
# [ doc = "eUSCI_Bx Interrupt Enable Register" ] pub mod ucb0ie_spi {
# [ doc = "Reader of register UCB0IE_SPI" ] pub type R = crate :: R < u16 , super :: UCB0IE_SPI > ;
# [ doc = "Writer for register UCB0IE_SPI" ] pub type W = crate :: W < u16 , super :: UCB0IE_SPI > ;
# [ doc = "Register UCB0IE_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0IE_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE_A { # [ doc = "0: Interrupt disabled" ] UCRXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE_1 = 1 } impl From < UCRXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE`" ] pub type UCRXIE_R = crate :: R < bool , UCRXIE_A > ; impl UCRXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE_A { match self . bits { false => UCRXIE_A :: UCRXIE_0 , true => UCRXIE_A :: UCRXIE_1 } } # [ doc = "Checks if the value of the field is `UCRXIE_0`" ] # [ inline ( always ) ] pub fn is_ucrxie_0 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_0 } # [ doc = "Checks if the value of the field is `UCRXIE_1`" ] # [ inline ( always ) ] pub fn is_ucrxie_1 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_1 } }
# [ doc = "Write proxy for field `UCRXIE`" ] pub struct UCRXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE_A { # [ doc = "0: Interrupt disabled" ] UCTXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE_1 = 1 } impl From < UCTXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE`" ] pub type UCTXIE_R = crate :: R < bool , UCTXIE_A > ; impl UCTXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE_A { match self . bits { false => UCTXIE_A :: UCTXIE_0 , true => UCTXIE_A :: UCTXIE_1 } } # [ doc = "Checks if the value of the field is `UCTXIE_0`" ] # [ inline ( always ) ] pub fn is_uctxie_0 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_0 } # [ doc = "Checks if the value of the field is `UCTXIE_1`" ] # [ inline ( always ) ] pub fn is_uctxie_1 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_1 } }
# [ doc = "Write proxy for field `UCTXIE`" ] pub struct UCTXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & self ) -> UCRXIE_R { UCRXIE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & self ) -> UCTXIE_R { UCTXIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & mut self ) -> UCRXIE_W { UCRXIE_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & mut self ) -> UCTXIE_W { UCTXIE_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ifg](ucb0ifg) module" ] pub type UCB0IFG = crate :: Reg < u16 , _UCB0IFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0IFG ;
# [ doc = "`read()` method returns [ucb0ifg::R](ucb0ifg::R) reader structure" ] impl crate :: Readable for UCB0IFG { }
# [ doc = "`write(|w| ..)` method takes [ucb0ifg::W](ucb0ifg::W) writer structure" ] impl crate :: Writable for UCB0IFG { }
# [ doc = "eUSCI_Bx Interrupt Flag Register" ] pub mod ucb0ifg {
# [ doc = "Reader of register UCB0IFG" ] pub type R = crate :: R < u16 , super :: UCB0IFG > ;
# [ doc = "Writer for register UCB0IFG" ] pub type W = crate :: W < u16 , super :: UCB0IFG > ;
# [ doc = "Register UCB0IFG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0IFG { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "eUSCI_B receive interrupt flag 0\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG0_A { # [ doc = "0: No interrupt pending" ] UCRXIFG0_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG0_1 = 1 } impl From < UCRXIFG0_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG0`" ] pub type UCRXIFG0_R = crate :: R < bool , UCRXIFG0_A > ; impl UCRXIFG0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG0_A { match self . bits { false => UCRXIFG0_A :: UCRXIFG0_0 , true => UCRXIFG0_A :: UCRXIFG0_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG0_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg0_0 ( & self ) -> bool { * self == UCRXIFG0_A :: UCRXIFG0_0 } # [ doc = "Checks if the value of the field is `UCRXIFG0_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg0_1 ( & self ) -> bool { * self == UCRXIFG0_A :: UCRXIFG0_1 } }
# [ doc = "Write proxy for field `UCRXIFG0`" ] pub struct UCRXIFG0_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg0_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG0_A :: UCRXIFG0_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg0_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG0_A :: UCRXIFG0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "eUSCI_B transmit interrupt flag 0\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG0_A { # [ doc = "0: No interrupt pending" ] UCTXIFG0_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG0_1 = 1 } impl From < UCTXIFG0_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG0`" ] pub type UCTXIFG0_R = crate :: R < bool , UCTXIFG0_A > ; impl UCTXIFG0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG0_A { match self . bits { false => UCTXIFG0_A :: UCTXIFG0_0 , true => UCTXIFG0_A :: UCTXIFG0_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG0_0`" ] # [ inline ( always ) ] pub fn is_uctxifg0_0 ( & self ) -> bool { * self == UCTXIFG0_A :: UCTXIFG0_0 } # [ doc = "Checks if the value of the field is `UCTXIFG0_1`" ] # [ inline ( always ) ] pub fn is_uctxifg0_1 ( & self ) -> bool { * self == UCTXIFG0_A :: UCTXIFG0_1 } }
# [ doc = "Write proxy for field `UCTXIFG0`" ] pub struct UCTXIFG0_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg0_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG0_A :: UCTXIFG0_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg0_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG0_A :: UCTXIFG0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "START condition interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTTIFG_A { # [ doc = "0: No interrupt pending" ] UCSTTIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCSTTIFG_1 = 1 } impl From < UCSTTIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTTIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTTIFG`" ] pub type UCSTTIFG_R = crate :: R < bool , UCSTTIFG_A > ; impl UCSTTIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTTIFG_A { match self . bits { false => UCSTTIFG_A :: UCSTTIFG_0 , true => UCSTTIFG_A :: UCSTTIFG_1 } } # [ doc = "Checks if the value of the field is `UCSTTIFG_0`" ] # [ inline ( always ) ] pub fn is_ucsttifg_0 ( & self ) -> bool { * self == UCSTTIFG_A :: UCSTTIFG_0 } # [ doc = "Checks if the value of the field is `UCSTTIFG_1`" ] # [ inline ( always ) ] pub fn is_ucsttifg_1 ( & self ) -> bool { * self == UCSTTIFG_A :: UCSTTIFG_1 } }
# [ doc = "Write proxy for field `UCSTTIFG`" ] pub struct UCSTTIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTTIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTTIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucsttifg_0 ( self ) -> & 'a mut W { self . variant ( UCSTTIFG_A :: UCSTTIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucsttifg_1 ( self ) -> & 'a mut W { self . variant ( UCSTTIFG_A :: UCSTTIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "STOP condition interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTPIFG_A { # [ doc = "0: No interrupt pending" ] UCSTPIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCSTPIFG_1 = 1 } impl From < UCSTPIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTPIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTPIFG`" ] pub type UCSTPIFG_R = crate :: R < bool , UCSTPIFG_A > ; impl UCSTPIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTPIFG_A { match self . bits { false => UCSTPIFG_A :: UCSTPIFG_0 , true => UCSTPIFG_A :: UCSTPIFG_1 } } # [ doc = "Checks if the value of the field is `UCSTPIFG_0`" ] # [ inline ( always ) ] pub fn is_ucstpifg_0 ( & self ) -> bool { * self == UCSTPIFG_A :: UCSTPIFG_0 } # [ doc = "Checks if the value of the field is `UCSTPIFG_1`" ] # [ inline ( always ) ] pub fn is_ucstpifg_1 ( & self ) -> bool { * self == UCSTPIFG_A :: UCSTPIFG_1 } }
# [ doc = "Write proxy for field `UCSTPIFG`" ] pub struct UCSTPIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTPIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTPIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucstpifg_0 ( self ) -> & 'a mut W { self . variant ( UCSTPIFG_A :: UCSTPIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucstpifg_1 ( self ) -> & 'a mut W { self . variant ( UCSTPIFG_A :: UCSTPIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Arbitration lost interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCALIFG_A { # [ doc = "0: No interrupt pending" ] UCALIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCALIFG_1 = 1 } impl From < UCALIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCALIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCALIFG`" ] pub type UCALIFG_R = crate :: R < bool , UCALIFG_A > ; impl UCALIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCALIFG_A { match self . bits { false => UCALIFG_A :: UCALIFG_0 , true => UCALIFG_A :: UCALIFG_1 } } # [ doc = "Checks if the value of the field is `UCALIFG_0`" ] # [ inline ( always ) ] pub fn is_ucalifg_0 ( & self ) -> bool { * self == UCALIFG_A :: UCALIFG_0 } # [ doc = "Checks if the value of the field is `UCALIFG_1`" ] # [ inline ( always ) ] pub fn is_ucalifg_1 ( & self ) -> bool { * self == UCALIFG_A :: UCALIFG_1 } }
# [ doc = "Write proxy for field `UCALIFG`" ] pub struct UCALIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCALIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCALIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucalifg_0 ( self ) -> & 'a mut W { self . variant ( UCALIFG_A :: UCALIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucalifg_1 ( self ) -> & 'a mut W { self . variant ( UCALIFG_A :: UCALIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Not-acknowledge received interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCNACKIFG_A { # [ doc = "0: No interrupt pending" ] UCNACKIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCNACKIFG_1 = 1 } impl From < UCNACKIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCNACKIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCNACKIFG`" ] pub type UCNACKIFG_R = crate :: R < bool , UCNACKIFG_A > ; impl UCNACKIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCNACKIFG_A { match self . bits { false => UCNACKIFG_A :: UCNACKIFG_0 , true => UCNACKIFG_A :: UCNACKIFG_1 } } # [ doc = "Checks if the value of the field is `UCNACKIFG_0`" ] # [ inline ( always ) ] pub fn is_ucnackifg_0 ( & self ) -> bool { * self == UCNACKIFG_A :: UCNACKIFG_0 } # [ doc = "Checks if the value of the field is `UCNACKIFG_1`" ] # [ inline ( always ) ] pub fn is_ucnackifg_1 ( & self ) -> bool { * self == UCNACKIFG_A :: UCNACKIFG_1 } }
# [ doc = "Write proxy for field `UCNACKIFG`" ] pub struct UCNACKIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCNACKIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCNACKIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucnackifg_0 ( self ) -> & 'a mut W { self . variant ( UCNACKIFG_A :: UCNACKIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucnackifg_1 ( self ) -> & 'a mut W { self . variant ( UCNACKIFG_A :: UCNACKIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Byte counter interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBCNTIFG_A { # [ doc = "0: No interrupt pending" ] UCBCNTIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCBCNTIFG_1 = 1 } impl From < UCBCNTIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBCNTIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBCNTIFG`" ] pub type UCBCNTIFG_R = crate :: R < bool , UCBCNTIFG_A > ; impl UCBCNTIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBCNTIFG_A { match self . bits { false => UCBCNTIFG_A :: UCBCNTIFG_0 , true => UCBCNTIFG_A :: UCBCNTIFG_1 } } # [ doc = "Checks if the value of the field is `UCBCNTIFG_0`" ] # [ inline ( always ) ] pub fn is_ucbcntifg_0 ( & self ) -> bool { * self == UCBCNTIFG_A :: UCBCNTIFG_0 } # [ doc = "Checks if the value of the field is `UCBCNTIFG_1`" ] # [ inline ( always ) ] pub fn is_ucbcntifg_1 ( & self ) -> bool { * self == UCBCNTIFG_A :: UCBCNTIFG_1 } }
# [ doc = "Write proxy for field `UCBCNTIFG`" ] pub struct UCBCNTIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCBCNTIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBCNTIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucbcntifg_0 ( self ) -> & 'a mut W { self . variant ( UCBCNTIFG_A :: UCBCNTIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucbcntifg_1 ( self ) -> & 'a mut W { self . variant ( UCBCNTIFG_A :: UCBCNTIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Clock low timeout interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCLTOIFG_A { # [ doc = "0: No interrupt pending" ] UCCLTOIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCCLTOIFG_1 = 1 } impl From < UCCLTOIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCLTOIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCLTOIFG`" ] pub type UCCLTOIFG_R = crate :: R < bool , UCCLTOIFG_A > ; impl UCCLTOIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCLTOIFG_A { match self . bits { false => UCCLTOIFG_A :: UCCLTOIFG_0 , true => UCCLTOIFG_A :: UCCLTOIFG_1 } } # [ doc = "Checks if the value of the field is `UCCLTOIFG_0`" ] # [ inline ( always ) ] pub fn is_uccltoifg_0 ( & self ) -> bool { * self == UCCLTOIFG_A :: UCCLTOIFG_0 } # [ doc = "Checks if the value of the field is `UCCLTOIFG_1`" ] # [ inline ( always ) ] pub fn is_uccltoifg_1 ( & self ) -> bool { * self == UCCLTOIFG_A :: UCCLTOIFG_1 } }
# [ doc = "Write proxy for field `UCCLTOIFG`" ] pub struct UCCLTOIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCCLTOIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCLTOIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uccltoifg_0 ( self ) -> & 'a mut W { self . variant ( UCCLTOIFG_A :: UCCLTOIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uccltoifg_1 ( self ) -> & 'a mut W { self . variant ( UCCLTOIFG_A :: UCCLTOIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "eUSCI_B receive interrupt flag 1\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG1_A { # [ doc = "0: No interrupt pending" ] UCRXIFG1_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG1_1 = 1 } impl From < UCRXIFG1_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG1_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG1`" ] pub type UCRXIFG1_R = crate :: R < bool , UCRXIFG1_A > ; impl UCRXIFG1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG1_A { match self . bits { false => UCRXIFG1_A :: UCRXIFG1_0 , true => UCRXIFG1_A :: UCRXIFG1_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG1_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg1_0 ( & self ) -> bool { * self == UCRXIFG1_A :: UCRXIFG1_0 } # [ doc = "Checks if the value of the field is `UCRXIFG1_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg1_1 ( & self ) -> bool { * self == UCRXIFG1_A :: UCRXIFG1_1 } }
# [ doc = "Write proxy for field `UCRXIFG1`" ] pub struct UCRXIFG1_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG1_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg1_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG1_A :: UCRXIFG1_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg1_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG1_A :: UCRXIFG1_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "eUSCI_B transmit interrupt flag 1\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG1_A { # [ doc = "0: No interrupt pending" ] UCTXIFG1_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG1_1 = 1 } impl From < UCTXIFG1_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG1_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG1`" ] pub type UCTXIFG1_R = crate :: R < bool , UCTXIFG1_A > ; impl UCTXIFG1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG1_A { match self . bits { false => UCTXIFG1_A :: UCTXIFG1_0 , true => UCTXIFG1_A :: UCTXIFG1_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG1_0`" ] # [ inline ( always ) ] pub fn is_uctxifg1_0 ( & self ) -> bool { * self == UCTXIFG1_A :: UCTXIFG1_0 } # [ doc = "Checks if the value of the field is `UCTXIFG1_1`" ] # [ inline ( always ) ] pub fn is_uctxifg1_1 ( & self ) -> bool { * self == UCTXIFG1_A :: UCTXIFG1_1 } }
# [ doc = "Write proxy for field `UCTXIFG1`" ] pub struct UCTXIFG1_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG1_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg1_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG1_A :: UCTXIFG1_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg1_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG1_A :: UCTXIFG1_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "eUSCI_B receive interrupt flag 2\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG2_A { # [ doc = "0: No interrupt pending" ] UCRXIFG2_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG2_1 = 1 } impl From < UCRXIFG2_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG2_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG2`" ] pub type UCRXIFG2_R = crate :: R < bool , UCRXIFG2_A > ; impl UCRXIFG2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG2_A { match self . bits { false => UCRXIFG2_A :: UCRXIFG2_0 , true => UCRXIFG2_A :: UCRXIFG2_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG2_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg2_0 ( & self ) -> bool { * self == UCRXIFG2_A :: UCRXIFG2_0 } # [ doc = "Checks if the value of the field is `UCRXIFG2_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg2_1 ( & self ) -> bool { * self == UCRXIFG2_A :: UCRXIFG2_1 } }
# [ doc = "Write proxy for field `UCRXIFG2`" ] pub struct UCRXIFG2_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG2_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg2_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG2_A :: UCRXIFG2_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg2_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG2_A :: UCRXIFG2_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "eUSCI_B transmit interrupt flag 2\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG2_A { # [ doc = "0: No interrupt pending" ] UCTXIFG2_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG2_1 = 1 } impl From < UCTXIFG2_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG2_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG2`" ] pub type UCTXIFG2_R = crate :: R < bool , UCTXIFG2_A > ; impl UCTXIFG2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG2_A { match self . bits { false => UCTXIFG2_A :: UCTXIFG2_0 , true => UCTXIFG2_A :: UCTXIFG2_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG2_0`" ] # [ inline ( always ) ] pub fn is_uctxifg2_0 ( & self ) -> bool { * self == UCTXIFG2_A :: UCTXIFG2_0 } # [ doc = "Checks if the value of the field is `UCTXIFG2_1`" ] # [ inline ( always ) ] pub fn is_uctxifg2_1 ( & self ) -> bool { * self == UCTXIFG2_A :: UCTXIFG2_1 } }
# [ doc = "Write proxy for field `UCTXIFG2`" ] pub struct UCTXIFG2_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG2_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg2_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG2_A :: UCTXIFG2_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg2_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG2_A :: UCTXIFG2_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "eUSCI_B receive interrupt flag 3\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG3_A { # [ doc = "0: No interrupt pending" ] UCRXIFG3_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG3_1 = 1 } impl From < UCRXIFG3_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG3_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG3`" ] pub type UCRXIFG3_R = crate :: R < bool , UCRXIFG3_A > ; impl UCRXIFG3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG3_A { match self . bits { false => UCRXIFG3_A :: UCRXIFG3_0 , true => UCRXIFG3_A :: UCRXIFG3_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG3_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg3_0 ( & self ) -> bool { * self == UCRXIFG3_A :: UCRXIFG3_0 } # [ doc = "Checks if the value of the field is `UCRXIFG3_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg3_1 ( & self ) -> bool { * self == UCRXIFG3_A :: UCRXIFG3_1 } }
# [ doc = "Write proxy for field `UCRXIFG3`" ] pub struct UCRXIFG3_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG3_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG3_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg3_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG3_A :: UCRXIFG3_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg3_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG3_A :: UCRXIFG3_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "eUSCI_B transmit interrupt flag 3\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG3_A { # [ doc = "0: No interrupt pending" ] UCTXIFG3_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG3_1 = 1 } impl From < UCTXIFG3_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG3_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG3`" ] pub type UCTXIFG3_R = crate :: R < bool , UCTXIFG3_A > ; impl UCTXIFG3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG3_A { match self . bits { false => UCTXIFG3_A :: UCTXIFG3_0 , true => UCTXIFG3_A :: UCTXIFG3_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG3_0`" ] # [ inline ( always ) ] pub fn is_uctxifg3_0 ( & self ) -> bool { * self == UCTXIFG3_A :: UCTXIFG3_0 } # [ doc = "Checks if the value of the field is `UCTXIFG3_1`" ] # [ inline ( always ) ] pub fn is_uctxifg3_1 ( & self ) -> bool { * self == UCTXIFG3_A :: UCTXIFG3_1 } }
# [ doc = "Write proxy for field `UCTXIFG3`" ] pub struct UCTXIFG3_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG3_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG3_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg3_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG3_A :: UCTXIFG3_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg3_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG3_A :: UCTXIFG3_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Bit position 9 interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBIT9IFG_A { # [ doc = "0: No interrupt pending" ] UCBIT9IFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCBIT9IFG_1 = 1 } impl From < UCBIT9IFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBIT9IFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBIT9IFG`" ] pub type UCBIT9IFG_R = crate :: R < bool , UCBIT9IFG_A > ; impl UCBIT9IFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBIT9IFG_A { match self . bits { false => UCBIT9IFG_A :: UCBIT9IFG_0 , true => UCBIT9IFG_A :: UCBIT9IFG_1 } } # [ doc = "Checks if the value of the field is `UCBIT9IFG_0`" ] # [ inline ( always ) ] pub fn is_ucbit9ifg_0 ( & self ) -> bool { * self == UCBIT9IFG_A :: UCBIT9IFG_0 } # [ doc = "Checks if the value of the field is `UCBIT9IFG_1`" ] # [ inline ( always ) ] pub fn is_ucbit9ifg_1 ( & self ) -> bool { * self == UCBIT9IFG_A :: UCBIT9IFG_1 } }
# [ doc = "Write proxy for field `UCBIT9IFG`" ] pub struct UCBIT9IFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCBIT9IFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBIT9IFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucbit9ifg_0 ( self ) -> & 'a mut W { self . variant ( UCBIT9IFG_A :: UCBIT9IFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucbit9ifg_1 ( self ) -> & 'a mut W { self . variant ( UCBIT9IFG_A :: UCBIT9IFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - eUSCI_B receive interrupt flag 0" ] # [ inline ( always ) ] pub fn ucrxifg0 ( & self ) -> UCRXIFG0_R { UCRXIFG0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - eUSCI_B transmit interrupt flag 0" ] # [ inline ( always ) ] pub fn uctxifg0 ( & self ) -> UCTXIFG0_R { UCTXIFG0_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - START condition interrupt flag" ] # [ inline ( always ) ] pub fn ucsttifg ( & self ) -> UCSTTIFG_R { UCSTTIFG_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - STOP condition interrupt flag" ] # [ inline ( always ) ] pub fn ucstpifg ( & self ) -> UCSTPIFG_R { UCSTPIFG_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Arbitration lost interrupt flag" ] # [ inline ( always ) ] pub fn ucalifg ( & self ) -> UCALIFG_R { UCALIFG_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Not-acknowledge received interrupt flag" ] # [ inline ( always ) ] pub fn ucnackifg ( & self ) -> UCNACKIFG_R { UCNACKIFG_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Byte counter interrupt flag" ] # [ inline ( always ) ] pub fn ucbcntifg ( & self ) -> UCBCNTIFG_R { UCBCNTIFG_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Clock low timeout interrupt flag" ] # [ inline ( always ) ] pub fn uccltoifg ( & self ) -> UCCLTOIFG_R { UCCLTOIFG_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - eUSCI_B receive interrupt flag 1" ] # [ inline ( always ) ] pub fn ucrxifg1 ( & self ) -> UCRXIFG1_R { UCRXIFG1_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - eUSCI_B transmit interrupt flag 1" ] # [ inline ( always ) ] pub fn uctxifg1 ( & self ) -> UCTXIFG1_R { UCTXIFG1_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - eUSCI_B receive interrupt flag 2" ] # [ inline ( always ) ] pub fn ucrxifg2 ( & self ) -> UCRXIFG2_R { UCRXIFG2_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - eUSCI_B transmit interrupt flag 2" ] # [ inline ( always ) ] pub fn uctxifg2 ( & self ) -> UCTXIFG2_R { UCTXIFG2_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - eUSCI_B receive interrupt flag 3" ] # [ inline ( always ) ] pub fn ucrxifg3 ( & self ) -> UCRXIFG3_R { UCRXIFG3_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - eUSCI_B transmit interrupt flag 3" ] # [ inline ( always ) ] pub fn uctxifg3 ( & self ) -> UCTXIFG3_R { UCTXIFG3_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Bit position 9 interrupt flag" ] # [ inline ( always ) ] pub fn ucbit9ifg ( & self ) -> UCBIT9IFG_R { UCBIT9IFG_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - eUSCI_B receive interrupt flag 0" ] # [ inline ( always ) ] pub fn ucrxifg0 ( & mut self ) -> UCRXIFG0_W { UCRXIFG0_W { w : self } }
# [ doc = "Bit 1 - eUSCI_B transmit interrupt flag 0" ] # [ inline ( always ) ] pub fn uctxifg0 ( & mut self ) -> UCTXIFG0_W { UCTXIFG0_W { w : self } }
# [ doc = "Bit 2 - START condition interrupt flag" ] # [ inline ( always ) ] pub fn ucsttifg ( & mut self ) -> UCSTTIFG_W { UCSTTIFG_W { w : self } }
# [ doc = "Bit 3 - STOP condition interrupt flag" ] # [ inline ( always ) ] pub fn ucstpifg ( & mut self ) -> UCSTPIFG_W { UCSTPIFG_W { w : self } }
# [ doc = "Bit 4 - Arbitration lost interrupt flag" ] # [ inline ( always ) ] pub fn ucalifg ( & mut self ) -> UCALIFG_W { UCALIFG_W { w : self } }
# [ doc = "Bit 5 - Not-acknowledge received interrupt flag" ] # [ inline ( always ) ] pub fn ucnackifg ( & mut self ) -> UCNACKIFG_W { UCNACKIFG_W { w : self } }
# [ doc = "Bit 6 - Byte counter interrupt flag" ] # [ inline ( always ) ] pub fn ucbcntifg ( & mut self ) -> UCBCNTIFG_W { UCBCNTIFG_W { w : self } }
# [ doc = "Bit 7 - Clock low timeout interrupt flag" ] # [ inline ( always ) ] pub fn uccltoifg ( & mut self ) -> UCCLTOIFG_W { UCCLTOIFG_W { w : self } }
# [ doc = "Bit 8 - eUSCI_B receive interrupt flag 1" ] # [ inline ( always ) ] pub fn ucrxifg1 ( & mut self ) -> UCRXIFG1_W { UCRXIFG1_W { w : self } }
# [ doc = "Bit 9 - eUSCI_B transmit interrupt flag 1" ] # [ inline ( always ) ] pub fn uctxifg1 ( & mut self ) -> UCTXIFG1_W { UCTXIFG1_W { w : self } }
# [ doc = "Bit 10 - eUSCI_B receive interrupt flag 2" ] # [ inline ( always ) ] pub fn ucrxifg2 ( & mut self ) -> UCRXIFG2_W { UCRXIFG2_W { w : self } }
# [ doc = "Bit 11 - eUSCI_B transmit interrupt flag 2" ] # [ inline ( always ) ] pub fn uctxifg2 ( & mut self ) -> UCTXIFG2_W { UCTXIFG2_W { w : self } }
# [ doc = "Bit 12 - eUSCI_B receive interrupt flag 3" ] # [ inline ( always ) ] pub fn ucrxifg3 ( & mut self ) -> UCRXIFG3_W { UCRXIFG3_W { w : self } }
# [ doc = "Bit 13 - eUSCI_B transmit interrupt flag 3" ] # [ inline ( always ) ] pub fn uctxifg3 ( & mut self ) -> UCTXIFG3_W { UCTXIFG3_W { w : self } }
# [ doc = "Bit 14 - Bit position 9 interrupt flag" ] # [ inline ( always ) ] pub fn ucbit9ifg ( & mut self ) -> UCBIT9IFG_W { UCBIT9IFG_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ifg_spi](ucb0ifg_spi) module" ] pub type UCB0IFG_SPI = crate :: Reg < u16 , _UCB0IFG_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0IFG_SPI ;
# [ doc = "`read()` method returns [ucb0ifg_spi::R](ucb0ifg_spi::R) reader structure" ] impl crate :: Readable for UCB0IFG_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb0ifg_spi::W](ucb0ifg_spi::W) writer structure" ] impl crate :: Writable for UCB0IFG_SPI { }
# [ doc = "eUSCI_Bx Interrupt Flag Register" ] pub mod ucb0ifg_spi {
# [ doc = "Reader of register UCB0IFG_SPI" ] pub type R = crate :: R < u16 , super :: UCB0IFG_SPI > ;
# [ doc = "Writer for register UCB0IFG_SPI" ] pub type W = crate :: W < u16 , super :: UCB0IFG_SPI > ;
# [ doc = "Register UCB0IFG_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0IFG_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG_A { # [ doc = "0: No interrupt pending" ] UCRXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG_1 = 1 } impl From < UCRXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG`" ] pub type UCRXIFG_R = crate :: R < bool , UCRXIFG_A > ; impl UCRXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG_A { match self . bits { false => UCRXIFG_A :: UCRXIFG_0 , true => UCRXIFG_A :: UCRXIFG_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg_0 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_0 } # [ doc = "Checks if the value of the field is `UCRXIFG_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg_1 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_1 } }
# [ doc = "Write proxy for field `UCRXIFG`" ] pub struct UCRXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG_A { # [ doc = "0: No interrupt pending" ] UCTXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG_1 = 1 } impl From < UCTXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG`" ] pub type UCTXIFG_R = crate :: R < bool , UCTXIFG_A > ; impl UCTXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG_A { match self . bits { false => UCTXIFG_A :: UCTXIFG_0 , true => UCTXIFG_A :: UCTXIFG_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG_0`" ] # [ inline ( always ) ] pub fn is_uctxifg_0 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_0 } # [ doc = "Checks if the value of the field is `UCTXIFG_1`" ] # [ inline ( always ) ] pub fn is_uctxifg_1 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_1 } }
# [ doc = "Write proxy for field `UCTXIFG`" ] pub struct UCTXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & self ) -> UCRXIFG_R { UCRXIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & self ) -> UCTXIFG_R { UCTXIFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & mut self ) -> UCRXIFG_W { UCRXIFG_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & mut self ) -> UCTXIFG_W { UCTXIFG_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0iv](ucb0iv) module" ] pub type UCB0IV = crate :: Reg < u16 , _UCB0IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0IV ;
# [ doc = "`read()` method returns [ucb0iv::R](ucb0iv::R) reader structure" ] impl crate :: Readable for UCB0IV { }
# [ doc = "eUSCI_Bx Interrupt Vector Register" ] pub mod ucb0iv {
# [ doc = "Reader of register UCB0IV" ] pub type R = crate :: R < u16 , super :: UCB0IV > ;
# [ doc = "eUSCI_B interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum UCIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Arbitration lost; Interrupt Flag: UCALIFG; Interrupt Priority: Highest" ] UCALIFG = 2 , # [ doc = "4: Interrupt Source: Not acknowledgment; Interrupt Flag: UCNACKIFG" ] UCNACKIFG = 4 , # [ doc = "6: Interrupt Source: Start condition received; Interrupt Flag: UCSTTIFG" ] UCSTTIFG = 6 , # [ doc = "8: Interrupt Source: Stop condition received; Interrupt Flag: UCSTPIFG" ] UCSTPIFG = 8 , # [ doc = "10: Interrupt Source: Slave 3 Data received; Interrupt Flag: UCRXIFG3" ] UCRXIFG3 = 10 , # [ doc = "12: Interrupt Source: Slave 3 Transmit buffer empty; Interrupt Flag: UCTXIFG3" ] UCTXIFG3 = 12 , # [ doc = "14: Interrupt Source: Slave 2 Data received; Interrupt Flag: UCRXIFG2" ] UCRXIFG2 = 14 , # [ doc = "16: Interrupt Source: Slave 2 Transmit buffer empty; Interrupt Flag: UCTXIFG2" ] UCTXIFG2 = 16 , # [ doc = "18: Interrupt Source: Slave 1 Data received; Interrupt Flag: UCRXIFG1" ] UCRXIFG1 = 18 , # [ doc = "20: Interrupt Source: Slave 1 Transmit buffer empty; Interrupt Flag: UCTXIFG1" ] UCTXIFG1 = 20 , # [ doc = "22: Interrupt Source: Data received; Interrupt Flag: UCRXIFG0" ] UCRXIFG0 = 22 , # [ doc = "24: Interrupt Source: Transmit buffer empty; Interrupt Flag: UCTXIFG0" ] UCTXIFG0 = 24 , # [ doc = "26: Interrupt Source: Byte counter zero; Interrupt Flag: UCBCNTIFG" ] UCBCNTIFG = 26 , # [ doc = "28: Interrupt Source: Clock low timeout; Interrupt Flag: UCCLTOIFG" ] UCCLTOIFG = 28 , # [ doc = "30: Interrupt Source: Nineth bit position; Interrupt Flag: UCBIT9IFG; Priority: Lowest" ] UCBIT9IFG = 30 } impl From < UCIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : UCIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCIV`" ] pub type UCIV_R = crate :: R < u16 , UCIV_A > ; impl UCIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , UCIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( UCIV_A :: NONE ) , 2 => Val ( UCIV_A :: UCALIFG ) , 4 => Val ( UCIV_A :: UCNACKIFG ) , 6 => Val ( UCIV_A :: UCSTTIFG ) , 8 => Val ( UCIV_A :: UCSTPIFG ) , 10 => Val ( UCIV_A :: UCRXIFG3 ) , 12 => Val ( UCIV_A :: UCTXIFG3 ) , 14 => Val ( UCIV_A :: UCRXIFG2 ) , 16 => Val ( UCIV_A :: UCTXIFG2 ) , 18 => Val ( UCIV_A :: UCRXIFG1 ) , 20 => Val ( UCIV_A :: UCTXIFG1 ) , 22 => Val ( UCIV_A :: UCRXIFG0 ) , 24 => Val ( UCIV_A :: UCTXIFG0 ) , 26 => Val ( UCIV_A :: UCBCNTIFG ) , 28 => Val ( UCIV_A :: UCCLTOIFG ) , 30 => Val ( UCIV_A :: UCBIT9IFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == UCIV_A :: NONE } # [ doc = "Checks if the value of the field is `UCALIFG`" ] # [ inline ( always ) ] pub fn is_ucalifg ( & self ) -> bool { * self == UCIV_A :: UCALIFG } # [ doc = "Checks if the value of the field is `UCNACKIFG`" ] # [ inline ( always ) ] pub fn is_ucnackifg ( & self ) -> bool { * self == UCIV_A :: UCNACKIFG } # [ doc = "Checks if the value of the field is `UCSTTIFG`" ] # [ inline ( always ) ] pub fn is_ucsttifg ( & self ) -> bool { * self == UCIV_A :: UCSTTIFG } # [ doc = "Checks if the value of the field is `UCSTPIFG`" ] # [ inline ( always ) ] pub fn is_ucstpifg ( & self ) -> bool { * self == UCIV_A :: UCSTPIFG } # [ doc = "Checks if the value of the field is `UCRXIFG3`" ] # [ inline ( always ) ] pub fn is_ucrxifg3 ( & self ) -> bool { * self == UCIV_A :: UCRXIFG3 } # [ doc = "Checks if the value of the field is `UCTXIFG3`" ] # [ inline ( always ) ] pub fn is_uctxifg3 ( & self ) -> bool { * self == UCIV_A :: UCTXIFG3 } # [ doc = "Checks if the value of the field is `UCRXIFG2`" ] # [ inline ( always ) ] pub fn is_ucrxifg2 ( & self ) -> bool { * self == UCIV_A :: UCRXIFG2 } # [ doc = "Checks if the value of the field is `UCTXIFG2`" ] # [ inline ( always ) ] pub fn is_uctxifg2 ( & self ) -> bool { * self == UCIV_A :: UCTXIFG2 } # [ doc = "Checks if the value of the field is `UCRXIFG1`" ] # [ inline ( always ) ] pub fn is_ucrxifg1 ( & self ) -> bool { * self == UCIV_A :: UCRXIFG1 } # [ doc = "Checks if the value of the field is `UCTXIFG1`" ] # [ inline ( always ) ] pub fn is_uctxifg1 ( & self ) -> bool { * self == UCIV_A :: UCTXIFG1 } # [ doc = "Checks if the value of the field is `UCRXIFG0`" ] # [ inline ( always ) ] pub fn is_ucrxifg0 ( & self ) -> bool { * self == UCIV_A :: UCRXIFG0 } # [ doc = "Checks if the value of the field is `UCTXIFG0`" ] # [ inline ( always ) ] pub fn is_uctxifg0 ( & self ) -> bool { * self == UCIV_A :: UCTXIFG0 } # [ doc = "Checks if the value of the field is `UCBCNTIFG`" ] # [ inline ( always ) ] pub fn is_ucbcntifg ( & self ) -> bool { * self == UCIV_A :: UCBCNTIFG } # [ doc = "Checks if the value of the field is `UCCLTOIFG`" ] # [ inline ( always ) ] pub fn is_uccltoifg ( & self ) -> bool { * self == UCIV_A :: UCCLTOIFG } # [ doc = "Checks if the value of the field is `UCBIT9IFG`" ] # [ inline ( always ) ] pub fn is_ucbit9ifg ( & self ) -> bool { * self == UCIV_A :: UCBIT9IFG } }
impl R {
# [ doc = "Bits 0:15 - eUSCI_B interrupt vector value" ] # [ inline ( always ) ] pub fn uciv ( & self ) -> UCIV_R { UCIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
# [ doc = "eUSCI_Bx Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0iv_spi](ucb0iv_spi) module" ] pub type UCB0IV_SPI = crate :: Reg < u16 , _UCB0IV_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0IV_SPI ;
# [ doc = "`read()` method returns [ucb0iv_spi::R](ucb0iv_spi::R) reader structure" ] impl crate :: Readable for UCB0IV_SPI { }
# [ doc = "eUSCI_Bx Interrupt Vector Register" ] pub mod ucb0iv_spi {
# [ doc = "Reader of register UCB0IV_SPI" ] pub type R = crate :: R < u16 , super :: UCB0IV_SPI > ;
# [ doc = "eUSCI_B interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum UCIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Data received; Interrupt Flag: UCRXIFG; Interrupt Priority: Highest" ] UCRXIFG = 2 , # [ doc = "4: Interrupt Source: Transmit buffer empty; Interrupt Flag: UCTXIFG; Interrupt Priority: Lowest" ] UCTXIFG = 4 } impl From < UCIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : UCIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCIV`" ] pub type UCIV_R = crate :: R < u16 , UCIV_A > ; impl UCIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , UCIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( UCIV_A :: NONE ) , 2 => Val ( UCIV_A :: UCRXIFG ) , 4 => Val ( UCIV_A :: UCTXIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == UCIV_A :: NONE } # [ doc = "Checks if the value of the field is `UCRXIFG`" ] # [ inline ( always ) ] pub fn is_ucrxifg ( & self ) -> bool { * self == UCIV_A :: UCRXIFG } # [ doc = "Checks if the value of the field is `UCTXIFG`" ] # [ inline ( always ) ] pub fn is_uctxifg ( & self ) -> bool { * self == UCIV_A :: UCTXIFG } }
impl R {
# [ doc = "Bits 0:15 - eUSCI_B interrupt vector value" ] # [ inline ( always ) ] pub fn uciv ( & self ) -> UCIV_R { UCIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "eUSCI_A1" ] pub struct E_USCI_A1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for E_USCI_A1 { } impl E_USCI_A1 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const e_usci_a1 :: RegisterBlock { 0x0580 as * const _ } } impl Deref for E_USCI_A1 { type Target = e_usci_a1 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * E_USCI_A1 :: ptr ( ) } } }
# [ doc = "eUSCI_A1" ] pub mod e_usci_a1 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved_0_uca1ctlw : [ u8 ; 2usize ] , # [ doc = "0x02 - eUSCI_Ax Control Word Register 1" ] pub uca1ctlw1 : UCA1CTLW1 , _reserved2 : [ u8 ; 2usize ] , _reserved_2_uca1 : [ u8 ; 2usize ] , # [ doc = "0x08 - eUSCI_Ax Modulation Control Word Register" ] pub uca1mctlw : UCA1MCTLW , _reserved_4_uca1 : [ u8 ; 2usize ] , _reserved_5_uca1 : [ u8 ; 2usize ] , _reserved_6_uca1 : [ u8 ; 2usize ] , # [ doc = "0x10 - eUSCI_Ax Auto Baud Rate Control Register" ] pub uca1abctl : UCA1ABCTL , # [ doc = "0x12 - eUSCI_Ax IrDA Control Word Register" ] pub uca1irctl : UCA1IRCTL , _reserved9 : [ u8 ; 6usize ] , _reserved_9_uca1 : [ u8 ; 2usize ] , _reserved_10_uca1 : [ u8 ; 2usize ] , _reserved_11_uca1 : [ u8 ; 2usize ] , } impl RegisterBlock { # [ doc = "0x00 - eUSCI_Ax Control Word Register 0" ] # [ inline ( always ) ] pub fn uca1ctlw0_spi ( & self ) -> & UCA1CTLW0_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const UCA1CTLW0_SPI ) } } # [ doc = "0x00 - eUSCI_Ax Control Word Register 0" ] # [ inline ( always ) ] pub fn uca1ctlw0_spi_mut ( & self ) -> & mut UCA1CTLW0_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut UCA1CTLW0_SPI ) } } # [ doc = "0x00 - eUSCI_Ax Control Word Register 0" ] # [ inline ( always ) ] pub fn uca1ctlw0 ( & self ) -> & UCA1CTLW0 { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const UCA1CTLW0 ) } } # [ doc = "0x00 - eUSCI_Ax Control Word Register 0" ] # [ inline ( always ) ] pub fn uca1ctlw0_mut ( & self ) -> & mut UCA1CTLW0 { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut UCA1CTLW0 ) } } # [ doc = "0x06 - eUSCI_Ax Bit Rate Control Register 1" ] # [ inline ( always ) ] pub fn uca1brw_spi ( & self ) -> & UCA1BRW_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 6usize ) as * const UCA1BRW_SPI ) } } # [ doc = "0x06 - eUSCI_Ax Bit Rate Control Register 1" ] # [ inline ( always ) ] pub fn uca1brw_spi_mut ( & self ) -> & mut UCA1BRW_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 6usize ) as * mut UCA1BRW_SPI ) } } # [ doc = "0x06 - eUSCI_Ax Baud Rate Control Word Register" ] # [ inline ( always ) ] pub fn uca1brw ( & self ) -> & UCA1BRW { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 6usize ) as * const UCA1BRW ) } } # [ doc = "0x06 - eUSCI_Ax Baud Rate Control Word Register" ] # [ inline ( always ) ] pub fn uca1brw_mut ( & self ) -> & mut UCA1BRW { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 6usize ) as * mut UCA1BRW ) } } # [ doc = "0x0a - UCA1STATW_SPI" ] # [ inline ( always ) ] pub fn uca1statw_spi ( & self ) -> & UCA1STATW_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 10usize ) as * const UCA1STATW_SPI ) } } # [ doc = "0x0a - UCA1STATW_SPI" ] # [ inline ( always ) ] pub fn uca1statw_spi_mut ( & self ) -> & mut UCA1STATW_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 10usize ) as * mut UCA1STATW_SPI ) } } # [ doc = "0x0a - eUSCI_Ax Status Register" ] # [ inline ( always ) ] pub fn uca1statw ( & self ) -> & UCA1STATW { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 10usize ) as * const UCA1STATW ) } } # [ doc = "0x0a - eUSCI_Ax Status Register" ] # [ inline ( always ) ] pub fn uca1statw_mut ( & self ) -> & mut UCA1STATW { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 10usize ) as * mut UCA1STATW ) } } # [ doc = "0x0c - eUSCI_Ax Receive Buffer Register" ] # [ inline ( always ) ] pub fn uca1rxbuf_spi ( & self ) -> & UCA1RXBUF_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const UCA1RXBUF_SPI ) } } # [ doc = "0x0c - eUSCI_Ax Receive Buffer Register" ] # [ inline ( always ) ] pub fn uca1rxbuf_spi_mut ( & self ) -> & mut UCA1RXBUF_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut UCA1RXBUF_SPI ) } } # [ doc = "0x0c - eUSCI_Ax Receive Buffer Register" ] # [ inline ( always ) ] pub fn uca1rxbuf ( & self ) -> & UCA1RXBUF { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const UCA1RXBUF ) } } # [ doc = "0x0c - eUSCI_Ax Receive Buffer Register" ] # [ inline ( always ) ] pub fn uca1rxbuf_mut ( & self ) -> & mut UCA1RXBUF { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut UCA1RXBUF ) } } # [ doc = "0x0e - eUSCI_Ax Transmit Buffer Register" ] # [ inline ( always ) ] pub fn uca1txbuf_spi ( & self ) -> & UCA1TXBUF_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 14usize ) as * const UCA1TXBUF_SPI ) } } # [ doc = "0x0e - eUSCI_Ax Transmit Buffer Register" ] # [ inline ( always ) ] pub fn uca1txbuf_spi_mut ( & self ) -> & mut UCA1TXBUF_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 14usize ) as * mut UCA1TXBUF_SPI ) } } # [ doc = "0x0e - eUSCI_Ax Transmit Buffer Register" ] # [ inline ( always ) ] pub fn uca1txbuf ( & self ) -> & UCA1TXBUF { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 14usize ) as * const UCA1TXBUF ) } } # [ doc = "0x0e - eUSCI_Ax Transmit Buffer Register" ] # [ inline ( always ) ] pub fn uca1txbuf_mut ( & self ) -> & mut UCA1TXBUF { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 14usize ) as * mut UCA1TXBUF ) } } # [ doc = "0x1a - eUSCI_Ax Interrupt Enable Register" ] # [ inline ( always ) ] pub fn uca1ie_spi ( & self ) -> & UCA1IE_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 26usize ) as * const UCA1IE_SPI ) } } # [ doc = "0x1a - eUSCI_Ax Interrupt Enable Register" ] # [ inline ( always ) ] pub fn uca1ie_spi_mut ( & self ) -> & mut UCA1IE_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 26usize ) as * mut UCA1IE_SPI ) } } # [ doc = "0x1a - eUSCI_Ax Interrupt Enable Register" ] # [ inline ( always ) ] pub fn uca1ie ( & self ) -> & UCA1IE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 26usize ) as * const UCA1IE ) } } # [ doc = "0x1a - eUSCI_Ax Interrupt Enable Register" ] # [ inline ( always ) ] pub fn uca1ie_mut ( & self ) -> & mut UCA1IE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 26usize ) as * mut UCA1IE ) } } # [ doc = "0x1c - eUSCI_Ax Interrupt Flag Register" ] # [ inline ( always ) ] pub fn uca1ifg_spi ( & self ) -> & UCA1IFG_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 28usize ) as * const UCA1IFG_SPI ) } } # [ doc = "0x1c - eUSCI_Ax Interrupt Flag Register" ] # [ inline ( always ) ] pub fn uca1ifg_spi_mut ( & self ) -> & mut UCA1IFG_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 28usize ) as * mut UCA1IFG_SPI ) } } # [ doc = "0x1c - eUSCI_Ax Interrupt Flag Register" ] # [ inline ( always ) ] pub fn uca1ifg ( & self ) -> & UCA1IFG { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 28usize ) as * const UCA1IFG ) } } # [ doc = "0x1c - eUSCI_Ax Interrupt Flag Register" ] # [ inline ( always ) ] pub fn uca1ifg_mut ( & self ) -> & mut UCA1IFG { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 28usize ) as * mut UCA1IFG ) } } # [ doc = "0x1e - eUSCI_Ax Interrupt Vector Register" ] # [ inline ( always ) ] pub fn uca1iv_spi ( & self ) -> & UCA1IV_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 30usize ) as * const UCA1IV_SPI ) } } # [ doc = "0x1e - eUSCI_Ax Interrupt Vector Register" ] # [ inline ( always ) ] pub fn uca1iv_spi_mut ( & self ) -> & mut UCA1IV_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 30usize ) as * mut UCA1IV_SPI ) } } # [ doc = "0x1e - eUSCI_Ax Interrupt Vector Register" ] # [ inline ( always ) ] pub fn uca1iv ( & self ) -> & UCA1IV { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 30usize ) as * const UCA1IV ) } } # [ doc = "0x1e - eUSCI_Ax Interrupt Vector Register" ] # [ inline ( always ) ] pub fn uca1iv_mut ( & self ) -> & mut UCA1IV { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 30usize ) as * mut UCA1IV ) } } }
# [ doc = "eUSCI_Ax Control Word Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ctlw0](uca1ctlw0) module" ] pub type UCA1CTLW0 = crate :: Reg < u16 , _UCA1CTLW0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1CTLW0 ;
# [ doc = "`read()` method returns [uca1ctlw0::R](uca1ctlw0::R) reader structure" ] impl crate :: Readable for UCA1CTLW0 { }
# [ doc = "`write(|w| ..)` method takes [uca1ctlw0::W](uca1ctlw0::W) writer structure" ] impl crate :: Writable for UCA1CTLW0 { }
# [ doc = "eUSCI_Ax Control Word Register 0" ] pub mod uca1ctlw0 {
# [ doc = "Reader of register UCA1CTLW0" ] pub type R = crate :: R < u16 , super :: UCA1CTLW0 > ;
# [ doc = "Writer for register UCA1CTLW0" ] pub type W = crate :: W < u16 , super :: UCA1CTLW0 > ;
# [ doc = "Register UCA1CTLW0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1CTLW0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Software reset enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSWRST_A { # [ doc = "0: Disabled. eUSCI_A reset released for operation" ] DISABLE = 0 , # [ doc = "1: Enabled. eUSCI_A logic held in reset state" ] ENABLE = 1 } impl From < UCSWRST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSWRST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSWRST`" ] pub type UCSWRST_R = crate :: R < bool , UCSWRST_A > ; impl UCSWRST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSWRST_A { match self . bits { false => UCSWRST_A :: DISABLE , true => UCSWRST_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCSWRST_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCSWRST_A :: ENABLE } }
# [ doc = "Write proxy for field `UCSWRST`" ] pub struct UCSWRST_W < 'a > { w : & 'a mut W , } impl < 'a > UCSWRST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSWRST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled. eUSCI_A reset released for operation" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: DISABLE ) } # [ doc = "Enabled. eUSCI_A logic held in reset state" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit break\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXBRK_A { # [ doc = "0: Next frame transmitted is not a break" ] UCTXBRK_0 = 0 , # [ doc = "1: Next frame transmitted is a break or a break/synch" ] UCTXBRK_1 = 1 } impl From < UCTXBRK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXBRK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXBRK`" ] pub type UCTXBRK_R = crate :: R < bool , UCTXBRK_A > ; impl UCTXBRK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXBRK_A { match self . bits { false => UCTXBRK_A :: UCTXBRK_0 , true => UCTXBRK_A :: UCTXBRK_1 } } # [ doc = "Checks if the value of the field is `UCTXBRK_0`" ] # [ inline ( always ) ] pub fn is_uctxbrk_0 ( & self ) -> bool { * self == UCTXBRK_A :: UCTXBRK_0 } # [ doc = "Checks if the value of the field is `UCTXBRK_1`" ] # [ inline ( always ) ] pub fn is_uctxbrk_1 ( & self ) -> bool { * self == UCTXBRK_A :: UCTXBRK_1 } }
# [ doc = "Write proxy for field `UCTXBRK`" ] pub struct UCTXBRK_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXBRK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXBRK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Next frame transmitted is not a break" ] # [ inline ( always ) ] pub fn uctxbrk_0 ( self ) -> & 'a mut W { self . variant ( UCTXBRK_A :: UCTXBRK_0 ) } # [ doc = "Next frame transmitted is a break or a break/synch" ] # [ inline ( always ) ] pub fn uctxbrk_1 ( self ) -> & 'a mut W { self . variant ( UCTXBRK_A :: UCTXBRK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Transmit address\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXADDR_A { # [ doc = "0: Next frame transmitted is data" ] UCTXADDR_0 = 0 , # [ doc = "1: Next frame transmitted is an address" ] UCTXADDR_1 = 1 } impl From < UCTXADDR_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXADDR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXADDR`" ] pub type UCTXADDR_R = crate :: R < bool , UCTXADDR_A > ; impl UCTXADDR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXADDR_A { match self . bits { false => UCTXADDR_A :: UCTXADDR_0 , true => UCTXADDR_A :: UCTXADDR_1 } } # [ doc = "Checks if the value of the field is `UCTXADDR_0`" ] # [ inline ( always ) ] pub fn is_uctxaddr_0 ( & self ) -> bool { * self == UCTXADDR_A :: UCTXADDR_0 } # [ doc = "Checks if the value of the field is `UCTXADDR_1`" ] # [ inline ( always ) ] pub fn is_uctxaddr_1 ( & self ) -> bool { * self == UCTXADDR_A :: UCTXADDR_1 } }
# [ doc = "Write proxy for field `UCTXADDR`" ] pub struct UCTXADDR_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXADDR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXADDR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Next frame transmitted is data" ] # [ inline ( always ) ] pub fn uctxaddr_0 ( self ) -> & 'a mut W { self . variant ( UCTXADDR_A :: UCTXADDR_0 ) } # [ doc = "Next frame transmitted is an address" ] # [ inline ( always ) ] pub fn uctxaddr_1 ( self ) -> & 'a mut W { self . variant ( UCTXADDR_A :: UCTXADDR_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Dormant\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCDORM_A { # [ doc = "0: Not dormant. All received characters set UCRXIFG." ] UCDORM_0 = 0 , # [ doc = "1: Dormant. Only characters that are preceded by an idle-line or with address bit set UCRXIFG. In UART mode with automatic baud-rate detection, only the combination of a break and synch field sets UCRXIFG." ] UCDORM_1 = 1 } impl From < UCDORM_A > for bool { # [ inline ( always ) ] fn from ( variant : UCDORM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCDORM`" ] pub type UCDORM_R = crate :: R < bool , UCDORM_A > ; impl UCDORM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCDORM_A { match self . bits { false => UCDORM_A :: UCDORM_0 , true => UCDORM_A :: UCDORM_1 } } # [ doc = "Checks if the value of the field is `UCDORM_0`" ] # [ inline ( always ) ] pub fn is_ucdorm_0 ( & self ) -> bool { * self == UCDORM_A :: UCDORM_0 } # [ doc = "Checks if the value of the field is `UCDORM_1`" ] # [ inline ( always ) ] pub fn is_ucdorm_1 ( & self ) -> bool { * self == UCDORM_A :: UCDORM_1 } }
# [ doc = "Write proxy for field `UCDORM`" ] pub struct UCDORM_W < 'a > { w : & 'a mut W , } impl < 'a > UCDORM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCDORM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Not dormant. All received characters set UCRXIFG." ] # [ inline ( always ) ] pub fn ucdorm_0 ( self ) -> & 'a mut W { self . variant ( UCDORM_A :: UCDORM_0 ) } # [ doc = "Dormant. Only characters that are preceded by an idle-line or with address bit set UCRXIFG. In UART mode with automatic baud-rate detection, only the combination of a break and synch field sets UCRXIFG." ] # [ inline ( always ) ] pub fn ucdorm_1 ( self ) -> & 'a mut W { self . variant ( UCDORM_A :: UCDORM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Receive break character interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBRKIE_A { # [ doc = "0: Received break characters do not set UCRXIFG" ] UCBRKIE_0 = 0 , # [ doc = "1: Received break characters set UCRXIFG" ] UCBRKIE_1 = 1 } impl From < UCBRKIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBRKIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBRKIE`" ] pub type UCBRKIE_R = crate :: R < bool , UCBRKIE_A > ; impl UCBRKIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBRKIE_A { match self . bits { false => UCBRKIE_A :: UCBRKIE_0 , true => UCBRKIE_A :: UCBRKIE_1 } } # [ doc = "Checks if the value of the field is `UCBRKIE_0`" ] # [ inline ( always ) ] pub fn is_ucbrkie_0 ( & self ) -> bool { * self == UCBRKIE_A :: UCBRKIE_0 } # [ doc = "Checks if the value of the field is `UCBRKIE_1`" ] # [ inline ( always ) ] pub fn is_ucbrkie_1 ( & self ) -> bool { * self == UCBRKIE_A :: UCBRKIE_1 } }
# [ doc = "Write proxy for field `UCBRKIE`" ] pub struct UCBRKIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCBRKIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBRKIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Received break characters do not set UCRXIFG" ] # [ inline ( always ) ] pub fn ucbrkie_0 ( self ) -> & 'a mut W { self . variant ( UCBRKIE_A :: UCBRKIE_0 ) } # [ doc = "Received break characters set UCRXIFG" ] # [ inline ( always ) ] pub fn ucbrkie_1 ( self ) -> & 'a mut W { self . variant ( UCBRKIE_A :: UCBRKIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Receive erroneous-character interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXEIE_A { # [ doc = "0: Erroneous characters rejected and UCRXIFG is not set" ] UCRXEIE_0 = 0 , # [ doc = "1: Erroneous characters received set UCRXIFG" ] UCRXEIE_1 = 1 } impl From < UCRXEIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXEIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXEIE`" ] pub type UCRXEIE_R = crate :: R < bool , UCRXEIE_A > ; impl UCRXEIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXEIE_A { match self . bits { false => UCRXEIE_A :: UCRXEIE_0 , true => UCRXEIE_A :: UCRXEIE_1 } } # [ doc = "Checks if the value of the field is `UCRXEIE_0`" ] # [ inline ( always ) ] pub fn is_ucrxeie_0 ( & self ) -> bool { * self == UCRXEIE_A :: UCRXEIE_0 } # [ doc = "Checks if the value of the field is `UCRXEIE_1`" ] # [ inline ( always ) ] pub fn is_ucrxeie_1 ( & self ) -> bool { * self == UCRXEIE_A :: UCRXEIE_1 } }
# [ doc = "Write proxy for field `UCRXEIE`" ] pub struct UCRXEIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXEIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXEIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Erroneous characters rejected and UCRXIFG is not set" ] # [ inline ( always ) ] pub fn ucrxeie_0 ( self ) -> & 'a mut W { self . variant ( UCRXEIE_A :: UCRXEIE_0 ) } # [ doc = "Erroneous characters received set UCRXIFG" ] # [ inline ( always ) ] pub fn ucrxeie_1 ( self ) -> & 'a mut W { self . variant ( UCRXEIE_A :: UCRXEIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "eUSCI_A clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCSSEL_A { # [ doc = "0: UCLK" ] UCLK = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: SMCLK" ] UCSSEL_3 = 3 } impl From < UCSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCSSEL`" ] pub type UCSSEL_R = crate :: R < u8 , UCSSEL_A > ; impl UCSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSSEL_A { match self . bits { 0 => UCSSEL_A :: UCLK , 1 => UCSSEL_A :: ACLK , 2 => UCSSEL_A :: SMCLK , 3 => UCSSEL_A :: UCSSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCLK`" ] # [ inline ( always ) ] pub fn is_uclk ( & self ) -> bool { * self == UCSSEL_A :: UCLK } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == UCSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == UCSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `UCSSEL_3`" ] # [ inline ( always ) ] pub fn is_ucssel_3 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_3 } }
# [ doc = "Write proxy for field `UCSSEL`" ] pub struct UCSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > UCSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "UCLK" ] # [ inline ( always ) ] pub fn uclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCLK ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: SMCLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn ucssel_3 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Synchronous mode enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSYNC_A { # [ doc = "0: Asynchronous mode" ] ASYNC = 0 , # [ doc = "1: Synchronous mode" ] SYNC = 1 } impl From < UCSYNC_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSYNC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSYNC`" ] pub type UCSYNC_R = crate :: R < bool , UCSYNC_A > ; impl UCSYNC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSYNC_A { match self . bits { false => UCSYNC_A :: ASYNC , true => UCSYNC_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == UCSYNC_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == UCSYNC_A :: SYNC } }
# [ doc = "Write proxy for field `UCSYNC`" ] pub struct UCSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > UCSYNC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSYNC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous mode" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: ASYNC ) } # [ doc = "Synchronous mode" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "eUSCI_A mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCMODE_A { # [ doc = "0: UART mode" ] UCMODE_0 = 0 , # [ doc = "1: Idle-line multiprocessor mode" ] UCMODE_1 = 1 , # [ doc = "2: Address-bit multiprocessor mode" ] UCMODE_2 = 2 , # [ doc = "3: UART mode with automatic baud-rate detection" ] UCMODE_3 = 3 } impl From < UCMODE_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCMODE_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCMODE`" ] pub type UCMODE_R = crate :: R < u8 , UCMODE_A > ; impl UCMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMODE_A { match self . bits { 0 => UCMODE_A :: UCMODE_0 , 1 => UCMODE_A :: UCMODE_1 , 2 => UCMODE_A :: UCMODE_2 , 3 => UCMODE_A :: UCMODE_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCMODE_0`" ] # [ inline ( always ) ] pub fn is_ucmode_0 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_0 } # [ doc = "Checks if the value of the field is `UCMODE_1`" ] # [ inline ( always ) ] pub fn is_ucmode_1 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_1 } # [ doc = "Checks if the value of the field is `UCMODE_2`" ] # [ inline ( always ) ] pub fn is_ucmode_2 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_2 } # [ doc = "Checks if the value of the field is `UCMODE_3`" ] # [ inline ( always ) ] pub fn is_ucmode_3 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_3 } }
# [ doc = "Write proxy for field `UCMODE`" ] pub struct UCMODE_W < 'a > { w : & 'a mut W , } impl < 'a > UCMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMODE_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "UART mode" ] # [ inline ( always ) ] pub fn ucmode_0 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_0 ) } # [ doc = "Idle-line multiprocessor mode" ] # [ inline ( always ) ] pub fn ucmode_1 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_1 ) } # [ doc = "Address-bit multiprocessor mode" ] # [ inline ( always ) ] pub fn ucmode_2 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_2 ) } # [ doc = "UART mode with automatic baud-rate detection" ] # [ inline ( always ) ] pub fn ucmode_3 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Stop bit select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSPB_A { # [ doc = "0: One stop bit" ] UCSPB_0 = 0 , # [ doc = "1: Two stop bits" ] UCSPB_1 = 1 } impl From < UCSPB_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSPB_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSPB`" ] pub type UCSPB_R = crate :: R < bool , UCSPB_A > ; impl UCSPB_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSPB_A { match self . bits { false => UCSPB_A :: UCSPB_0 , true => UCSPB_A :: UCSPB_1 } } # [ doc = "Checks if the value of the field is `UCSPB_0`" ] # [ inline ( always ) ] pub fn is_ucspb_0 ( & self ) -> bool { * self == UCSPB_A :: UCSPB_0 } # [ doc = "Checks if the value of the field is `UCSPB_1`" ] # [ inline ( always ) ] pub fn is_ucspb_1 ( & self ) -> bool { * self == UCSPB_A :: UCSPB_1 } }
# [ doc = "Write proxy for field `UCSPB`" ] pub struct UCSPB_W < 'a > { w : & 'a mut W , } impl < 'a > UCSPB_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSPB_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "One stop bit" ] # [ inline ( always ) ] pub fn ucspb_0 ( self ) -> & 'a mut W { self . variant ( UCSPB_A :: UCSPB_0 ) } # [ doc = "Two stop bits" ] # [ inline ( always ) ] pub fn ucspb_1 ( self ) -> & 'a mut W { self . variant ( UCSPB_A :: UCSPB_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Character length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UC7BIT_A { # [ doc = "0: 8-bit data" ] _8BIT = 0 , # [ doc = "1: 7-bit data" ] _7BIT = 1 } impl From < UC7BIT_A > for bool { # [ inline ( always ) ] fn from ( variant : UC7BIT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UC7BIT`" ] pub type UC7BIT_R = crate :: R < bool , UC7BIT_A > ; impl UC7BIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UC7BIT_A { match self . bits { false => UC7BIT_A :: _8BIT , true => UC7BIT_A :: _7BIT } } # [ doc = "Checks if the value of the field is `_8BIT`" ] # [ inline ( always ) ] pub fn is_8bit ( & self ) -> bool { * self == UC7BIT_A :: _8BIT } # [ doc = "Checks if the value of the field is `_7BIT`" ] # [ inline ( always ) ] pub fn is_7bit ( & self ) -> bool { * self == UC7BIT_A :: _7BIT } }
# [ doc = "Write proxy for field `UC7BIT`" ] pub struct UC7BIT_W < 'a > { w : & 'a mut W , } impl < 'a > UC7BIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UC7BIT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "8-bit data" ] # [ inline ( always ) ] pub fn _8bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _8BIT ) } # [ doc = "7-bit data" ] # [ inline ( always ) ] pub fn _7bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _7BIT ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "MSB first select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMSB_A { # [ doc = "0: LSB first" ] UCMSB_0 = 0 , # [ doc = "1: MSB first" ] UCMSB_1 = 1 } impl From < UCMSB_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMSB_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMSB`" ] pub type UCMSB_R = crate :: R < bool , UCMSB_A > ; impl UCMSB_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMSB_A { match self . bits { false => UCMSB_A :: UCMSB_0 , true => UCMSB_A :: UCMSB_1 } } # [ doc = "Checks if the value of the field is `UCMSB_0`" ] # [ inline ( always ) ] pub fn is_ucmsb_0 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_0 } # [ doc = "Checks if the value of the field is `UCMSB_1`" ] # [ inline ( always ) ] pub fn is_ucmsb_1 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_1 } }
# [ doc = "Write proxy for field `UCMSB`" ] pub struct UCMSB_W < 'a > { w : & 'a mut W , } impl < 'a > UCMSB_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMSB_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "LSB first" ] # [ inline ( always ) ] pub fn ucmsb_0 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_0 ) } # [ doc = "MSB first" ] # [ inline ( always ) ] pub fn ucmsb_1 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Parity select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCPAR_A { # [ doc = "0: Odd parity" ] ODD = 0 , # [ doc = "1: Even parity" ] EVEN = 1 } impl From < UCPAR_A > for bool { # [ inline ( always ) ] fn from ( variant : UCPAR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCPAR`" ] pub type UCPAR_R = crate :: R < bool , UCPAR_A > ; impl UCPAR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCPAR_A { match self . bits { false => UCPAR_A :: ODD , true => UCPAR_A :: EVEN } } # [ doc = "Checks if the value of the field is `ODD`" ] # [ inline ( always ) ] pub fn is_odd ( & self ) -> bool { * self == UCPAR_A :: ODD } # [ doc = "Checks if the value of the field is `EVEN`" ] # [ inline ( always ) ] pub fn is_even ( & self ) -> bool { * self == UCPAR_A :: EVEN } }
# [ doc = "Write proxy for field `UCPAR`" ] pub struct UCPAR_W < 'a > { w : & 'a mut W , } impl < 'a > UCPAR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCPAR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Odd parity" ] # [ inline ( always ) ] pub fn odd ( self ) -> & 'a mut W { self . variant ( UCPAR_A :: ODD ) } # [ doc = "Even parity" ] # [ inline ( always ) ] pub fn even ( self ) -> & 'a mut W { self . variant ( UCPAR_A :: EVEN ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Parity enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCPEN_A { # [ doc = "0: Parity disabled" ] UCPEN_0 = 0 , # [ doc = "1: Parity enabled. Parity bit is generated (UCAxTXD) and expected (UCAxRXD). In address-bit multiprocessor mode, the address bit is included in the parity calculation." ] UCPEN_1 = 1 } impl From < UCPEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCPEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCPEN`" ] pub type UCPEN_R = crate :: R < bool , UCPEN_A > ; impl UCPEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCPEN_A { match self . bits { false => UCPEN_A :: UCPEN_0 , true => UCPEN_A :: UCPEN_1 } } # [ doc = "Checks if the value of the field is `UCPEN_0`" ] # [ inline ( always ) ] pub fn is_ucpen_0 ( & self ) -> bool { * self == UCPEN_A :: UCPEN_0 } # [ doc = "Checks if the value of the field is `UCPEN_1`" ] # [ inline ( always ) ] pub fn is_ucpen_1 ( & self ) -> bool { * self == UCPEN_A :: UCPEN_1 } }
# [ doc = "Write proxy for field `UCPEN`" ] pub struct UCPEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCPEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCPEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Parity disabled" ] # [ inline ( always ) ] pub fn ucpen_0 ( self ) -> & 'a mut W { self . variant ( UCPEN_A :: UCPEN_0 ) } # [ doc = "Parity enabled. Parity bit is generated (UCAxTXD) and expected (UCAxRXD). In address-bit multiprocessor mode, the address bit is included in the parity calculation." ] # [ inline ( always ) ] pub fn ucpen_1 ( self ) -> & 'a mut W { self . variant ( UCPEN_A :: UCPEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & self ) -> UCSWRST_R { UCSWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit break" ] # [ inline ( always ) ] pub fn uctxbrk ( & self ) -> UCTXBRK_R { UCTXBRK_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Transmit address" ] # [ inline ( always ) ] pub fn uctxaddr ( & self ) -> UCTXADDR_R { UCTXADDR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Dormant" ] # [ inline ( always ) ] pub fn ucdorm ( & self ) -> UCDORM_R { UCDORM_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Receive break character interrupt enable" ] # [ inline ( always ) ] pub fn ucbrkie ( & self ) -> UCBRKIE_R { UCBRKIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Receive erroneous-character interrupt enable" ] # [ inline ( always ) ] pub fn ucrxeie ( & self ) -> UCRXEIE_R { UCRXEIE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - eUSCI_A clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & self ) -> UCSSEL_R { UCSSEL_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & self ) -> UCSYNC_R { UCSYNC_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - eUSCI_A mode" ] # [ inline ( always ) ] pub fn ucmode ( & self ) -> UCMODE_R { UCMODE_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Stop bit select" ] # [ inline ( always ) ] pub fn ucspb ( & self ) -> UCSPB_R { UCSPB_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & self ) -> UC7BIT_R { UC7BIT_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & self ) -> UCMSB_R { UCMSB_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Parity select" ] # [ inline ( always ) ] pub fn ucpar ( & self ) -> UCPAR_R { UCPAR_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Parity enable" ] # [ inline ( always ) ] pub fn ucpen ( & self ) -> UCPEN_R { UCPEN_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & mut self ) -> UCSWRST_W { UCSWRST_W { w : self } }
# [ doc = "Bit 1 - Transmit break" ] # [ inline ( always ) ] pub fn uctxbrk ( & mut self ) -> UCTXBRK_W { UCTXBRK_W { w : self } }
# [ doc = "Bit 2 - Transmit address" ] # [ inline ( always ) ] pub fn uctxaddr ( & mut self ) -> UCTXADDR_W { UCTXADDR_W { w : self } }
# [ doc = "Bit 3 - Dormant" ] # [ inline ( always ) ] pub fn ucdorm ( & mut self ) -> UCDORM_W { UCDORM_W { w : self } }
# [ doc = "Bit 4 - Receive break character interrupt enable" ] # [ inline ( always ) ] pub fn ucbrkie ( & mut self ) -> UCBRKIE_W { UCBRKIE_W { w : self } }
# [ doc = "Bit 5 - Receive erroneous-character interrupt enable" ] # [ inline ( always ) ] pub fn ucrxeie ( & mut self ) -> UCRXEIE_W { UCRXEIE_W { w : self } }
# [ doc = "Bits 6:7 - eUSCI_A clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & mut self ) -> UCSSEL_W { UCSSEL_W { w : self } }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & mut self ) -> UCSYNC_W { UCSYNC_W { w : self } }
# [ doc = "Bits 9:10 - eUSCI_A mode" ] # [ inline ( always ) ] pub fn ucmode ( & mut self ) -> UCMODE_W { UCMODE_W { w : self } }
# [ doc = "Bit 11 - Stop bit select" ] # [ inline ( always ) ] pub fn ucspb ( & mut self ) -> UCSPB_W { UCSPB_W { w : self } }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & mut self ) -> UC7BIT_W { UC7BIT_W { w : self } }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & mut self ) -> UCMSB_W { UCMSB_W { w : self } }
# [ doc = "Bit 14 - Parity select" ] # [ inline ( always ) ] pub fn ucpar ( & mut self ) -> UCPAR_W { UCPAR_W { w : self } }
# [ doc = "Bit 15 - Parity enable" ] # [ inline ( always ) ] pub fn ucpen ( & mut self ) -> UCPEN_W { UCPEN_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Control Word Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ctlw0_spi](uca1ctlw0_spi) module" ] pub type UCA1CTLW0_SPI = crate :: Reg < u16 , _UCA1CTLW0_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1CTLW0_SPI ;
# [ doc = "`read()` method returns [uca1ctlw0_spi::R](uca1ctlw0_spi::R) reader structure" ] impl crate :: Readable for UCA1CTLW0_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca1ctlw0_spi::W](uca1ctlw0_spi::W) writer structure" ] impl crate :: Writable for UCA1CTLW0_SPI { }
# [ doc = "eUSCI_Ax Control Word Register 0" ] pub mod uca1ctlw0_spi {
# [ doc = "Reader of register UCA1CTLW0_SPI" ] pub type R = crate :: R < u16 , super :: UCA1CTLW0_SPI > ;
# [ doc = "Writer for register UCA1CTLW0_SPI" ] pub type W = crate :: W < u16 , super :: UCA1CTLW0_SPI > ;
# [ doc = "Register UCA1CTLW0_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1CTLW0_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Software reset enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSWRST_A { # [ doc = "0: Disabled. eUSCI_A reset released for operation" ] DISABLE = 0 , # [ doc = "1: Enabled. eUSCI_A logic held in reset state" ] ENABLE = 1 } impl From < UCSWRST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSWRST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSWRST`" ] pub type UCSWRST_R = crate :: R < bool , UCSWRST_A > ; impl UCSWRST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSWRST_A { match self . bits { false => UCSWRST_A :: DISABLE , true => UCSWRST_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCSWRST_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCSWRST_A :: ENABLE } }
# [ doc = "Write proxy for field `UCSWRST`" ] pub struct UCSWRST_W < 'a > { w : & 'a mut W , } impl < 'a > UCSWRST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSWRST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled. eUSCI_A reset released for operation" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: DISABLE ) } # [ doc = "Enabled. eUSCI_A logic held in reset state" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "STE mode select in master mode.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTEM_A { # [ doc = "0: STE pin is used to prevent conflicts with other masters" ] UCSTEM_0 = 0 , # [ doc = "1: STE pin is used to generate the enable signal for a 4-wire slave" ] UCSTEM_1 = 1 } impl From < UCSTEM_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTEM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTEM`" ] pub type UCSTEM_R = crate :: R < bool , UCSTEM_A > ; impl UCSTEM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTEM_A { match self . bits { false => UCSTEM_A :: UCSTEM_0 , true => UCSTEM_A :: UCSTEM_1 } } # [ doc = "Checks if the value of the field is `UCSTEM_0`" ] # [ inline ( always ) ] pub fn is_ucstem_0 ( & self ) -> bool { * self == UCSTEM_A :: UCSTEM_0 } # [ doc = "Checks if the value of the field is `UCSTEM_1`" ] # [ inline ( always ) ] pub fn is_ucstem_1 ( & self ) -> bool { * self == UCSTEM_A :: UCSTEM_1 } }
# [ doc = "Write proxy for field `UCSTEM`" ] pub struct UCSTEM_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTEM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTEM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "STE pin is used to prevent conflicts with other masters" ] # [ inline ( always ) ] pub fn ucstem_0 ( self ) -> & 'a mut W { self . variant ( UCSTEM_A :: UCSTEM_0 ) } # [ doc = "STE pin is used to generate the enable signal for a 4-wire slave" ] # [ inline ( always ) ] pub fn ucstem_1 ( self ) -> & 'a mut W { self . variant ( UCSTEM_A :: UCSTEM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "eUSCI_A clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCSSEL_A { # [ doc = "0: Reserved" ] UCSSEL_0 = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: SMCLK" ] UCSSEL_3 = 3 } impl From < UCSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCSSEL`" ] pub type UCSSEL_R = crate :: R < u8 , UCSSEL_A > ; impl UCSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSSEL_A { match self . bits { 0 => UCSSEL_A :: UCSSEL_0 , 1 => UCSSEL_A :: ACLK , 2 => UCSSEL_A :: SMCLK , 3 => UCSSEL_A :: UCSSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCSSEL_0`" ] # [ inline ( always ) ] pub fn is_ucssel_0 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_0 } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == UCSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == UCSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `UCSSEL_3`" ] # [ inline ( always ) ] pub fn is_ucssel_3 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_3 } }
# [ doc = "Write proxy for field `UCSSEL`" ] pub struct UCSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > UCSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn ucssel_0 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_0 ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: SMCLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn ucssel_3 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Synchronous mode enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSYNC_A { # [ doc = "0: Asynchronous mode" ] ASYNC = 0 , # [ doc = "1: Synchronous mode" ] SYNC = 1 } impl From < UCSYNC_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSYNC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSYNC`" ] pub type UCSYNC_R = crate :: R < bool , UCSYNC_A > ; impl UCSYNC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSYNC_A { match self . bits { false => UCSYNC_A :: ASYNC , true => UCSYNC_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == UCSYNC_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == UCSYNC_A :: SYNC } }
# [ doc = "Write proxy for field `UCSYNC`" ] pub struct UCSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > UCSYNC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSYNC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous mode" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: ASYNC ) } # [ doc = "Synchronous mode" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "eUSCI mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCMODE_A { # [ doc = "0: 3-pin SPI" ] UCMODE_0 = 0 , # [ doc = "1: 4-pin SPI with UCxSTE active high: Slave enabled when UCxSTE = 1" ] UCMODE_1 = 1 , # [ doc = "2: 4-pin SPI with UCxSTE active low: Slave enabled when UCxSTE = 0" ] UCMODE_2 = 2 , # [ doc = "3: I2C mode" ] UCMODE_3 = 3 } impl From < UCMODE_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCMODE_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCMODE`" ] pub type UCMODE_R = crate :: R < u8 , UCMODE_A > ; impl UCMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMODE_A { match self . bits { 0 => UCMODE_A :: UCMODE_0 , 1 => UCMODE_A :: UCMODE_1 , 2 => UCMODE_A :: UCMODE_2 , 3 => UCMODE_A :: UCMODE_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCMODE_0`" ] # [ inline ( always ) ] pub fn is_ucmode_0 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_0 } # [ doc = "Checks if the value of the field is `UCMODE_1`" ] # [ inline ( always ) ] pub fn is_ucmode_1 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_1 } # [ doc = "Checks if the value of the field is `UCMODE_2`" ] # [ inline ( always ) ] pub fn is_ucmode_2 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_2 } # [ doc = "Checks if the value of the field is `UCMODE_3`" ] # [ inline ( always ) ] pub fn is_ucmode_3 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_3 } }
# [ doc = "Write proxy for field `UCMODE`" ] pub struct UCMODE_W < 'a > { w : & 'a mut W , } impl < 'a > UCMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMODE_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "3-pin SPI" ] # [ inline ( always ) ] pub fn ucmode_0 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_0 ) } # [ doc = "4-pin SPI with UCxSTE active high: Slave enabled when UCxSTE = 1" ] # [ inline ( always ) ] pub fn ucmode_1 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_1 ) } # [ doc = "4-pin SPI with UCxSTE active low: Slave enabled when UCxSTE = 0" ] # [ inline ( always ) ] pub fn ucmode_2 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_2 ) } # [ doc = "I2C mode" ] # [ inline ( always ) ] pub fn ucmode_3 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Master mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMST_A { # [ doc = "0: Slave mode" ] SLAVE = 0 , # [ doc = "1: Master mode" ] MASTER = 1 } impl From < UCMST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMST`" ] pub type UCMST_R = crate :: R < bool , UCMST_A > ; impl UCMST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMST_A { match self . bits { false => UCMST_A :: SLAVE , true => UCMST_A :: MASTER } } # [ doc = "Checks if the value of the field is `SLAVE`" ] # [ inline ( always ) ] pub fn is_slave ( & self ) -> bool { * self == UCMST_A :: SLAVE } # [ doc = "Checks if the value of the field is `MASTER`" ] # [ inline ( always ) ] pub fn is_master ( & self ) -> bool { * self == UCMST_A :: MASTER } }
# [ doc = "Write proxy for field `UCMST`" ] pub struct UCMST_W < 'a > { w : & 'a mut W , } impl < 'a > UCMST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Slave mode" ] # [ inline ( always ) ] pub fn slave ( self ) -> & 'a mut W { self . variant ( UCMST_A :: SLAVE ) } # [ doc = "Master mode" ] # [ inline ( always ) ] pub fn master ( self ) -> & 'a mut W { self . variant ( UCMST_A :: MASTER ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Character length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UC7BIT_A { # [ doc = "0: 8-bit data" ] _8BIT = 0 , # [ doc = "1: 7-bit data" ] _7BIT = 1 } impl From < UC7BIT_A > for bool { # [ inline ( always ) ] fn from ( variant : UC7BIT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UC7BIT`" ] pub type UC7BIT_R = crate :: R < bool , UC7BIT_A > ; impl UC7BIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UC7BIT_A { match self . bits { false => UC7BIT_A :: _8BIT , true => UC7BIT_A :: _7BIT } } # [ doc = "Checks if the value of the field is `_8BIT`" ] # [ inline ( always ) ] pub fn is_8bit ( & self ) -> bool { * self == UC7BIT_A :: _8BIT } # [ doc = "Checks if the value of the field is `_7BIT`" ] # [ inline ( always ) ] pub fn is_7bit ( & self ) -> bool { * self == UC7BIT_A :: _7BIT } }
# [ doc = "Write proxy for field `UC7BIT`" ] pub struct UC7BIT_W < 'a > { w : & 'a mut W , } impl < 'a > UC7BIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UC7BIT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "8-bit data" ] # [ inline ( always ) ] pub fn _8bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _8BIT ) } # [ doc = "7-bit data" ] # [ inline ( always ) ] pub fn _7bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _7BIT ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "MSB first select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMSB_A { # [ doc = "0: LSB first" ] UCMSB_0 = 0 , # [ doc = "1: MSB first" ] UCMSB_1 = 1 } impl From < UCMSB_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMSB_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMSB`" ] pub type UCMSB_R = crate :: R < bool , UCMSB_A > ; impl UCMSB_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMSB_A { match self . bits { false => UCMSB_A :: UCMSB_0 , true => UCMSB_A :: UCMSB_1 } } # [ doc = "Checks if the value of the field is `UCMSB_0`" ] # [ inline ( always ) ] pub fn is_ucmsb_0 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_0 } # [ doc = "Checks if the value of the field is `UCMSB_1`" ] # [ inline ( always ) ] pub fn is_ucmsb_1 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_1 } }
# [ doc = "Write proxy for field `UCMSB`" ] pub struct UCMSB_W < 'a > { w : & 'a mut W , } impl < 'a > UCMSB_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMSB_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "LSB first" ] # [ inline ( always ) ] pub fn ucmsb_0 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_0 ) } # [ doc = "MSB first" ] # [ inline ( always ) ] pub fn ucmsb_1 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Clock polarity select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCKPL_A { # [ doc = "0: The inactive state is low" ] LOW = 0 , # [ doc = "1: The inactive state is high" ] HIGH = 1 } impl From < UCCKPL_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCKPL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCKPL`" ] pub type UCCKPL_R = crate :: R < bool , UCCKPL_A > ; impl UCCKPL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCKPL_A { match self . bits { false => UCCKPL_A :: LOW , true => UCCKPL_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == UCCKPL_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == UCCKPL_A :: HIGH } }
# [ doc = "Write proxy for field `UCCKPL`" ] pub struct UCCKPL_W < 'a > { w : & 'a mut W , } impl < 'a > UCCKPL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCKPL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The inactive state is low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( UCCKPL_A :: LOW ) } # [ doc = "The inactive state is high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( UCCKPL_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Clock phase select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCKPH_A { # [ doc = "0: Data is changed on the first UCLK edge and captured on the following edge." ] UCCKPH_0 = 0 , # [ doc = "1: Data is captured on the first UCLK edge and changed on the following edge." ] UCCKPH_1 = 1 } impl From < UCCKPH_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCKPH_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCKPH`" ] pub type UCCKPH_R = crate :: R < bool , UCCKPH_A > ; impl UCCKPH_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCKPH_A { match self . bits { false => UCCKPH_A :: UCCKPH_0 , true => UCCKPH_A :: UCCKPH_1 } } # [ doc = "Checks if the value of the field is `UCCKPH_0`" ] # [ inline ( always ) ] pub fn is_ucckph_0 ( & self ) -> bool { * self == UCCKPH_A :: UCCKPH_0 } # [ doc = "Checks if the value of the field is `UCCKPH_1`" ] # [ inline ( always ) ] pub fn is_ucckph_1 ( & self ) -> bool { * self == UCCKPH_A :: UCCKPH_1 } }
# [ doc = "Write proxy for field `UCCKPH`" ] pub struct UCCKPH_W < 'a > { w : & 'a mut W , } impl < 'a > UCCKPH_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCKPH_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Data is changed on the first UCLK edge and captured on the following edge." ] # [ inline ( always ) ] pub fn ucckph_0 ( self ) -> & 'a mut W { self . variant ( UCCKPH_A :: UCCKPH_0 ) } # [ doc = "Data is captured on the first UCLK edge and changed on the following edge." ] # [ inline ( always ) ] pub fn ucckph_1 ( self ) -> & 'a mut W { self . variant ( UCCKPH_A :: UCCKPH_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & self ) -> UCSWRST_R { UCSWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - STE mode select in master mode." ] # [ inline ( always ) ] pub fn ucstem ( & self ) -> UCSTEM_R { UCSTEM_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - eUSCI_A clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & self ) -> UCSSEL_R { UCSSEL_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & self ) -> UCSYNC_R { UCSYNC_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - eUSCI mode" ] # [ inline ( always ) ] pub fn ucmode ( & self ) -> UCMODE_R { UCMODE_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & self ) -> UCMST_R { UCMST_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & self ) -> UC7BIT_R { UC7BIT_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & self ) -> UCMSB_R { UCMSB_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Clock polarity select" ] # [ inline ( always ) ] pub fn ucckpl ( & self ) -> UCCKPL_R { UCCKPL_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Clock phase select" ] # [ inline ( always ) ] pub fn ucckph ( & self ) -> UCCKPH_R { UCCKPH_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & mut self ) -> UCSWRST_W { UCSWRST_W { w : self } }
# [ doc = "Bit 1 - STE mode select in master mode." ] # [ inline ( always ) ] pub fn ucstem ( & mut self ) -> UCSTEM_W { UCSTEM_W { w : self } }
# [ doc = "Bits 6:7 - eUSCI_A clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & mut self ) -> UCSSEL_W { UCSSEL_W { w : self } }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & mut self ) -> UCSYNC_W { UCSYNC_W { w : self } }
# [ doc = "Bits 9:10 - eUSCI mode" ] # [ inline ( always ) ] pub fn ucmode ( & mut self ) -> UCMODE_W { UCMODE_W { w : self } }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & mut self ) -> UCMST_W { UCMST_W { w : self } }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & mut self ) -> UC7BIT_W { UC7BIT_W { w : self } }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & mut self ) -> UCMSB_W { UCMSB_W { w : self } }
# [ doc = "Bit 14 - Clock polarity select" ] # [ inline ( always ) ] pub fn ucckpl ( & mut self ) -> UCCKPL_W { UCCKPL_W { w : self } }
# [ doc = "Bit 15 - Clock phase select" ] # [ inline ( always ) ] pub fn ucckph ( & mut self ) -> UCCKPH_W { UCCKPH_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Control Word Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ctlw1](uca1ctlw1) module" ] pub type UCA1CTLW1 = crate :: Reg < u16 , _UCA1CTLW1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1CTLW1 ;
# [ doc = "`read()` method returns [uca1ctlw1::R](uca1ctlw1::R) reader structure" ] impl crate :: Readable for UCA1CTLW1 { }
# [ doc = "`write(|w| ..)` method takes [uca1ctlw1::W](uca1ctlw1::W) writer structure" ] impl crate :: Writable for UCA1CTLW1 { }
# [ doc = "eUSCI_Ax Control Word Register 1" ] pub mod uca1ctlw1 {
# [ doc = "Reader of register UCA1CTLW1" ] pub type R = crate :: R < u16 , super :: UCA1CTLW1 > ;
# [ doc = "Writer for register UCA1CTLW1" ] pub type W = crate :: W < u16 , super :: UCA1CTLW1 > ;
# [ doc = "Register UCA1CTLW1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1CTLW1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Deglitch time\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCGLIT_A { # [ doc = "0: Approximately 2 ns (equivalent of 1 delay element)" ] UCGLIT_0 = 0 , # [ doc = "1: Approximately 50 ns" ] UCGLIT_1 = 1 , # [ doc = "2: Approximately 100 ns" ] UCGLIT_2 = 2 , # [ doc = "3: Approximately 200 ns" ] UCGLIT_3 = 3 } impl From < UCGLIT_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCGLIT_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCGLIT`" ] pub type UCGLIT_R = crate :: R < u8 , UCGLIT_A > ; impl UCGLIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCGLIT_A { match self . bits { 0 => UCGLIT_A :: UCGLIT_0 , 1 => UCGLIT_A :: UCGLIT_1 , 2 => UCGLIT_A :: UCGLIT_2 , 3 => UCGLIT_A :: UCGLIT_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCGLIT_0`" ] # [ inline ( always ) ] pub fn is_ucglit_0 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_0 } # [ doc = "Checks if the value of the field is `UCGLIT_1`" ] # [ inline ( always ) ] pub fn is_ucglit_1 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_1 } # [ doc = "Checks if the value of the field is `UCGLIT_2`" ] # [ inline ( always ) ] pub fn is_ucglit_2 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_2 } # [ doc = "Checks if the value of the field is `UCGLIT_3`" ] # [ inline ( always ) ] pub fn is_ucglit_3 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_3 } }
# [ doc = "Write proxy for field `UCGLIT`" ] pub struct UCGLIT_W < 'a > { w : & 'a mut W , } impl < 'a > UCGLIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCGLIT_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Approximately 2 ns (equivalent of 1 delay element)" ] # [ inline ( always ) ] pub fn ucglit_0 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_0 ) } # [ doc = "Approximately 50 ns" ] # [ inline ( always ) ] pub fn ucglit_1 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_1 ) } # [ doc = "Approximately 100 ns" ] # [ inline ( always ) ] pub fn ucglit_2 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_2 ) } # [ doc = "Approximately 200 ns" ] # [ inline ( always ) ] pub fn ucglit_3 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Deglitch time" ] # [ inline ( always ) ] pub fn ucglit ( & self ) -> UCGLIT_R { UCGLIT_R :: new ( ( self . bits & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - Deglitch time" ] # [ inline ( always ) ] pub fn ucglit ( & mut self ) -> UCGLIT_W { UCGLIT_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Baud Rate Control Word Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1brw](uca1brw) module" ] pub type UCA1BRW = crate :: Reg < u16 , _UCA1BRW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1BRW ;
# [ doc = "`read()` method returns [uca1brw::R](uca1brw::R) reader structure" ] impl crate :: Readable for UCA1BRW { }
# [ doc = "`write(|w| ..)` method takes [uca1brw::W](uca1brw::W) writer structure" ] impl crate :: Writable for UCA1BRW { }
# [ doc = "eUSCI_Ax Baud Rate Control Word Register" ] pub mod uca1brw {
# [ doc = "Reader of register UCA1BRW" ] pub type R = crate :: R < u16 , super :: UCA1BRW > ;
# [ doc = "Writer for register UCA1BRW" ] pub type W = crate :: W < u16 , super :: UCA1BRW > ;
# [ doc = "Register UCA1BRW `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1BRW { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "eUSCI_Ax Bit Rate Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1brw_spi](uca1brw_spi) module" ] pub type UCA1BRW_SPI = crate :: Reg < u16 , _UCA1BRW_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1BRW_SPI ;
# [ doc = "`read()` method returns [uca1brw_spi::R](uca1brw_spi::R) reader structure" ] impl crate :: Readable for UCA1BRW_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca1brw_spi::W](uca1brw_spi::W) writer structure" ] impl crate :: Writable for UCA1BRW_SPI { }
# [ doc = "eUSCI_Ax Bit Rate Control Register 1" ] pub mod uca1brw_spi {
# [ doc = "Reader of register UCA1BRW_SPI" ] pub type R = crate :: R < u16 , super :: UCA1BRW_SPI > ;
# [ doc = "Writer for register UCA1BRW_SPI" ] pub type W = crate :: W < u16 , super :: UCA1BRW_SPI > ;
# [ doc = "Register UCA1BRW_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1BRW_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "eUSCI_Ax Modulation Control Word Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1mctlw](uca1mctlw) module" ] pub type UCA1MCTLW = crate :: Reg < u16 , _UCA1MCTLW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1MCTLW ;
# [ doc = "`read()` method returns [uca1mctlw::R](uca1mctlw::R) reader structure" ] impl crate :: Readable for UCA1MCTLW { }
# [ doc = "`write(|w| ..)` method takes [uca1mctlw::W](uca1mctlw::W) writer structure" ] impl crate :: Writable for UCA1MCTLW { }
# [ doc = "eUSCI_Ax Modulation Control Word Register" ] pub mod uca1mctlw {
# [ doc = "Reader of register UCA1MCTLW" ] pub type R = crate :: R < u16 , super :: UCA1MCTLW > ;
# [ doc = "Writer for register UCA1MCTLW" ] pub type W = crate :: W < u16 , super :: UCA1MCTLW > ;
# [ doc = "Register UCA1MCTLW `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1MCTLW { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Oversampling mode enabled\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOS16_A { # [ doc = "0: Disabled" ] UCOS16_0 = 0 , # [ doc = "1: Enabled" ] UCOS16_1 = 1 } impl From < UCOS16_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOS16_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOS16`" ] pub type UCOS16_R = crate :: R < bool , UCOS16_A > ; impl UCOS16_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOS16_A { match self . bits { false => UCOS16_A :: UCOS16_0 , true => UCOS16_A :: UCOS16_1 } } # [ doc = "Checks if the value of the field is `UCOS16_0`" ] # [ inline ( always ) ] pub fn is_ucos16_0 ( & self ) -> bool { * self == UCOS16_A :: UCOS16_0 } # [ doc = "Checks if the value of the field is `UCOS16_1`" ] # [ inline ( always ) ] pub fn is_ucos16_1 ( & self ) -> bool { * self == UCOS16_A :: UCOS16_1 } }
# [ doc = "Write proxy for field `UCOS16`" ] pub struct UCOS16_W < 'a > { w : & 'a mut W , } impl < 'a > UCOS16_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOS16_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn ucos16_0 ( self ) -> & 'a mut W { self . variant ( UCOS16_A :: UCOS16_0 ) } # [ doc = "Enabled" ] # [ inline ( always ) ] pub fn ucos16_1 ( self ) -> & 'a mut W { self . variant ( UCOS16_A :: UCOS16_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `UCBRF`" ] pub type UCBRF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCBRF`" ] pub struct UCBRF_W < 'a > { w : & 'a mut W , } impl < 'a > UCBRF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 4 ) ) | ( ( ( value as u16 ) & 0x0f ) << 4 ) ; self . w } }
# [ doc = "Reader of field `UCBRS`" ] pub type UCBRS_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCBRS`" ] pub struct UCBRS_W < 'a > { w : & 'a mut W , } impl < 'a > UCBRS_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 8 ) ) | ( ( ( value as u16 ) & 0xff ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Oversampling mode enabled" ] # [ inline ( always ) ] pub fn ucos16 ( & self ) -> UCOS16_R { UCOS16_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bits 4:7 - First modulation stage select" ] # [ inline ( always ) ] pub fn ucbrf ( & self ) -> UCBRF_R { UCBRF_R :: new ( ( ( self . bits >> 4 ) & 0x0f ) as u8 ) }
# [ doc = "Bits 8:15 - Second modulation stage select" ] # [ inline ( always ) ] pub fn ucbrs ( & self ) -> UCBRS_R { UCBRS_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Oversampling mode enabled" ] # [ inline ( always ) ] pub fn ucos16 ( & mut self ) -> UCOS16_W { UCOS16_W { w : self } }
# [ doc = "Bits 4:7 - First modulation stage select" ] # [ inline ( always ) ] pub fn ucbrf ( & mut self ) -> UCBRF_W { UCBRF_W { w : self } }
# [ doc = "Bits 8:15 - Second modulation stage select" ] # [ inline ( always ) ] pub fn ucbrs ( & mut self ) -> UCBRS_W { UCBRS_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1statw](uca1statw) module" ] pub type UCA1STATW = crate :: Reg < u16 , _UCA1STATW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1STATW ;
# [ doc = "`read()` method returns [uca1statw::R](uca1statw::R) reader structure" ] impl crate :: Readable for UCA1STATW { }
# [ doc = "`write(|w| ..)` method takes [uca1statw::W](uca1statw::W) writer structure" ] impl crate :: Writable for UCA1STATW { }
# [ doc = "eUSCI_Ax Status Register" ] pub mod uca1statw {
# [ doc = "Reader of register UCA1STATW" ] pub type R = crate :: R < u16 , super :: UCA1STATW > ;
# [ doc = "Writer for register UCA1STATW" ] pub type W = crate :: W < u16 , super :: UCA1STATW > ;
# [ doc = "Register UCA1STATW `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1STATW { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "eUSCI_A busy\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBUSY_A { # [ doc = "0: eUSCI_A inactive" ] IDLE = 0 , # [ doc = "1: eUSCI_A transmitting or receiving" ] BUSY = 1 } impl From < UCBUSY_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBUSY_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBUSY`" ] pub type UCBUSY_R = crate :: R < bool , UCBUSY_A > ; impl UCBUSY_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBUSY_A { match self . bits { false => UCBUSY_A :: IDLE , true => UCBUSY_A :: BUSY } } # [ doc = "Checks if the value of the field is `IDLE`" ] # [ inline ( always ) ] pub fn is_idle ( & self ) -> bool { * self == UCBUSY_A :: IDLE } # [ doc = "Checks if the value of the field is `BUSY`" ] # [ inline ( always ) ] pub fn is_busy ( & self ) -> bool { * self == UCBUSY_A :: BUSY } }
# [ doc = "Address received / Idle line detected\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCADDR_UCIDLE_A { # [ doc = "0: UCADDR: Received character is data. UCIDLE: No idle line detected" ] UCADDR_UCIDLE_0 = 0 , # [ doc = "1: UCADDR: Received character is an address. UCIDLE: Idle line detected" ] UCADDR_UCIDLE_1 = 1 } impl From < UCADDR_UCIDLE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCADDR_UCIDLE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCADDR_UCIDLE`" ] pub type UCADDR_UCIDLE_R = crate :: R < bool , UCADDR_UCIDLE_A > ; impl UCADDR_UCIDLE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCADDR_UCIDLE_A { match self . bits { false => UCADDR_UCIDLE_A :: UCADDR_UCIDLE_0 , true => UCADDR_UCIDLE_A :: UCADDR_UCIDLE_1 } } # [ doc = "Checks if the value of the field is `UCADDR_UCIDLE_0`" ] # [ inline ( always ) ] pub fn is_ucaddr_ucidle_0 ( & self ) -> bool { * self == UCADDR_UCIDLE_A :: UCADDR_UCIDLE_0 } # [ doc = "Checks if the value of the field is `UCADDR_UCIDLE_1`" ] # [ inline ( always ) ] pub fn is_ucaddr_ucidle_1 ( & self ) -> bool { * self == UCADDR_UCIDLE_A :: UCADDR_UCIDLE_1 } }
# [ doc = "Write proxy for field `UCADDR_UCIDLE`" ] pub struct UCADDR_UCIDLE_W < 'a > { w : & 'a mut W , } impl < 'a > UCADDR_UCIDLE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCADDR_UCIDLE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "UCADDR: Received character is data. UCIDLE: No idle line detected" ] # [ inline ( always ) ] pub fn ucaddr_ucidle_0 ( self ) -> & 'a mut W { self . variant ( UCADDR_UCIDLE_A :: UCADDR_UCIDLE_0 ) } # [ doc = "UCADDR: Received character is an address. UCIDLE: Idle line detected" ] # [ inline ( always ) ] pub fn ucaddr_ucidle_1 ( self ) -> & 'a mut W { self . variant ( UCADDR_UCIDLE_A :: UCADDR_UCIDLE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Receive error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXERR_A { # [ doc = "0: No receive errors detected" ] UCRXERR_0 = 0 , # [ doc = "1: Receive error detected" ] UCRXERR_1 = 1 } impl From < UCRXERR_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXERR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXERR`" ] pub type UCRXERR_R = crate :: R < bool , UCRXERR_A > ; impl UCRXERR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXERR_A { match self . bits { false => UCRXERR_A :: UCRXERR_0 , true => UCRXERR_A :: UCRXERR_1 } } # [ doc = "Checks if the value of the field is `UCRXERR_0`" ] # [ inline ( always ) ] pub fn is_ucrxerr_0 ( & self ) -> bool { * self == UCRXERR_A :: UCRXERR_0 } # [ doc = "Checks if the value of the field is `UCRXERR_1`" ] # [ inline ( always ) ] pub fn is_ucrxerr_1 ( & self ) -> bool { * self == UCRXERR_A :: UCRXERR_1 } }
# [ doc = "Write proxy for field `UCRXERR`" ] pub struct UCRXERR_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXERR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXERR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No receive errors detected" ] # [ inline ( always ) ] pub fn ucrxerr_0 ( self ) -> & 'a mut W { self . variant ( UCRXERR_A :: UCRXERR_0 ) } # [ doc = "Receive error detected" ] # [ inline ( always ) ] pub fn ucrxerr_1 ( self ) -> & 'a mut W { self . variant ( UCRXERR_A :: UCRXERR_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Break detect flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBRK_A { # [ doc = "0: No break condition" ] UCBRK_0 = 0 , # [ doc = "1: Break condition occurred" ] UCBRK_1 = 1 } impl From < UCBRK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBRK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBRK`" ] pub type UCBRK_R = crate :: R < bool , UCBRK_A > ; impl UCBRK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBRK_A { match self . bits { false => UCBRK_A :: UCBRK_0 , true => UCBRK_A :: UCBRK_1 } } # [ doc = "Checks if the value of the field is `UCBRK_0`" ] # [ inline ( always ) ] pub fn is_ucbrk_0 ( & self ) -> bool { * self == UCBRK_A :: UCBRK_0 } # [ doc = "Checks if the value of the field is `UCBRK_1`" ] # [ inline ( always ) ] pub fn is_ucbrk_1 ( & self ) -> bool { * self == UCBRK_A :: UCBRK_1 } }
# [ doc = "Write proxy for field `UCBRK`" ] pub struct UCBRK_W < 'a > { w : & 'a mut W , } impl < 'a > UCBRK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBRK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No break condition" ] # [ inline ( always ) ] pub fn ucbrk_0 ( self ) -> & 'a mut W { self . variant ( UCBRK_A :: UCBRK_0 ) } # [ doc = "Break condition occurred" ] # [ inline ( always ) ] pub fn ucbrk_1 ( self ) -> & 'a mut W { self . variant ( UCBRK_A :: UCBRK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Parity error flag. When UCPEN = 0, UCPE is read as 0. UCPE is cleared when UCAxRXBUF is read.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCPE_A { # [ doc = "0: No error" ] UCPE_0 = 0 , # [ doc = "1: Character received with parity error" ] UCPE_1 = 1 } impl From < UCPE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCPE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCPE`" ] pub type UCPE_R = crate :: R < bool , UCPE_A > ; impl UCPE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCPE_A { match self . bits { false => UCPE_A :: UCPE_0 , true => UCPE_A :: UCPE_1 } } # [ doc = "Checks if the value of the field is `UCPE_0`" ] # [ inline ( always ) ] pub fn is_ucpe_0 ( & self ) -> bool { * self == UCPE_A :: UCPE_0 } # [ doc = "Checks if the value of the field is `UCPE_1`" ] # [ inline ( always ) ] pub fn is_ucpe_1 ( & self ) -> bool { * self == UCPE_A :: UCPE_1 } }
# [ doc = "Write proxy for field `UCPE`" ] pub struct UCPE_W < 'a > { w : & 'a mut W , } impl < 'a > UCPE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCPE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucpe_0 ( self ) -> & 'a mut W { self . variant ( UCPE_A :: UCPE_0 ) } # [ doc = "Character received with parity error" ] # [ inline ( always ) ] pub fn ucpe_1 ( self ) -> & 'a mut W { self . variant ( UCPE_A :: UCPE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Overrun error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOE_A { # [ doc = "0: No error" ] UCOE_0 = 0 , # [ doc = "1: Overrun error occurred" ] UCOE_1 = 1 } impl From < UCOE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOE`" ] pub type UCOE_R = crate :: R < bool , UCOE_A > ; impl UCOE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOE_A { match self . bits { false => UCOE_A :: UCOE_0 , true => UCOE_A :: UCOE_1 } } # [ doc = "Checks if the value of the field is `UCOE_0`" ] # [ inline ( always ) ] pub fn is_ucoe_0 ( & self ) -> bool { * self == UCOE_A :: UCOE_0 } # [ doc = "Checks if the value of the field is `UCOE_1`" ] # [ inline ( always ) ] pub fn is_ucoe_1 ( & self ) -> bool { * self == UCOE_A :: UCOE_1 } }
# [ doc = "Write proxy for field `UCOE`" ] pub struct UCOE_W < 'a > { w : & 'a mut W , } impl < 'a > UCOE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucoe_0 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_0 ) } # [ doc = "Overrun error occurred" ] # [ inline ( always ) ] pub fn ucoe_1 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Framing error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCFE_A { # [ doc = "0: No error" ] UCFE_0 = 0 , # [ doc = "1: Character received with low stop bit" ] UCFE_1 = 1 } impl From < UCFE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCFE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCFE`" ] pub type UCFE_R = crate :: R < bool , UCFE_A > ; impl UCFE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCFE_A { match self . bits { false => UCFE_A :: UCFE_0 , true => UCFE_A :: UCFE_1 } } # [ doc = "Checks if the value of the field is `UCFE_0`" ] # [ inline ( always ) ] pub fn is_ucfe_0 ( & self ) -> bool { * self == UCFE_A :: UCFE_0 } # [ doc = "Checks if the value of the field is `UCFE_1`" ] # [ inline ( always ) ] pub fn is_ucfe_1 ( & self ) -> bool { * self == UCFE_A :: UCFE_1 } }
# [ doc = "Write proxy for field `UCFE`" ] pub struct UCFE_W < 'a > { w : & 'a mut W , } impl < 'a > UCFE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCFE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucfe_0 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_0 ) } # [ doc = "Character received with low stop bit" ] # [ inline ( always ) ] pub fn ucfe_1 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Listen enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCLISTEN_A { # [ doc = "0: Disabled" ] UCLISTEN_0 = 0 , # [ doc = "1: Enabled. UCAxTXD is internally fed back to the receiver" ] UCLISTEN_1 = 1 } impl From < UCLISTEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCLISTEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCLISTEN`" ] pub type UCLISTEN_R = crate :: R < bool , UCLISTEN_A > ; impl UCLISTEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCLISTEN_A { match self . bits { false => UCLISTEN_A :: UCLISTEN_0 , true => UCLISTEN_A :: UCLISTEN_1 } } # [ doc = "Checks if the value of the field is `UCLISTEN_0`" ] # [ inline ( always ) ] pub fn is_uclisten_0 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_0 } # [ doc = "Checks if the value of the field is `UCLISTEN_1`" ] # [ inline ( always ) ] pub fn is_uclisten_1 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_1 } }
# [ doc = "Write proxy for field `UCLISTEN`" ] pub struct UCLISTEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCLISTEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCLISTEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn uclisten_0 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_0 ) } # [ doc = "Enabled. UCAxTXD is internally fed back to the receiver" ] # [ inline ( always ) ] pub fn uclisten_1 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - eUSCI_A busy" ] # [ inline ( always ) ] pub fn ucbusy ( & self ) -> UCBUSY_R { UCBUSY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Address received / Idle line detected" ] # [ inline ( always ) ] pub fn ucaddr_ucidle ( & self ) -> UCADDR_UCIDLE_R { UCADDR_UCIDLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Receive error flag" ] # [ inline ( always ) ] pub fn ucrxerr ( & self ) -> UCRXERR_R { UCRXERR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Break detect flag" ] # [ inline ( always ) ] pub fn ucbrk ( & self ) -> UCBRK_R { UCBRK_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Parity error flag. When UCPEN = 0, UCPE is read as 0. UCPE is cleared when UCAxRXBUF is read." ] # [ inline ( always ) ] pub fn ucpe ( & self ) -> UCPE_R { UCPE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & self ) -> UCOE_R { UCOE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & self ) -> UCFE_R { UCFE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & self ) -> UCLISTEN_R { UCLISTEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 1 - Address received / Idle line detected" ] # [ inline ( always ) ] pub fn ucaddr_ucidle ( & mut self ) -> UCADDR_UCIDLE_W { UCADDR_UCIDLE_W { w : self } }
# [ doc = "Bit 2 - Receive error flag" ] # [ inline ( always ) ] pub fn ucrxerr ( & mut self ) -> UCRXERR_W { UCRXERR_W { w : self } }
# [ doc = "Bit 3 - Break detect flag" ] # [ inline ( always ) ] pub fn ucbrk ( & mut self ) -> UCBRK_W { UCBRK_W { w : self } }
# [ doc = "Bit 4 - Parity error flag. When UCPEN = 0, UCPE is read as 0. UCPE is cleared when UCAxRXBUF is read." ] # [ inline ( always ) ] pub fn ucpe ( & mut self ) -> UCPE_W { UCPE_W { w : self } }
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & mut self ) -> UCOE_W { UCOE_W { w : self } }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & mut self ) -> UCFE_W { UCFE_W { w : self } }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & mut self ) -> UCLISTEN_W { UCLISTEN_W { w : self } }
}
}
# [ doc = "UCA1STATW_SPI\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1statw_spi](uca1statw_spi) module" ] pub type UCA1STATW_SPI = crate :: Reg < u16 , _UCA1STATW_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1STATW_SPI ;
# [ doc = "`read()` method returns [uca1statw_spi::R](uca1statw_spi::R) reader structure" ] impl crate :: Readable for UCA1STATW_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca1statw_spi::W](uca1statw_spi::W) writer structure" ] impl crate :: Writable for UCA1STATW_SPI { }
# [ doc = "UCA1STATW_SPI" ] pub mod uca1statw_spi {
# [ doc = "Reader of register UCA1STATW_SPI" ] pub type R = crate :: R < u16 , super :: UCA1STATW_SPI > ;
# [ doc = "Writer for register UCA1STATW_SPI" ] pub type W = crate :: W < u16 , super :: UCA1STATW_SPI > ;
# [ doc = "Register UCA1STATW_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1STATW_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Overrun error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOE_A { # [ doc = "0: No error" ] UCOE_0 = 0 , # [ doc = "1: Overrun error occurred" ] UCOE_1 = 1 } impl From < UCOE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOE`" ] pub type UCOE_R = crate :: R < bool , UCOE_A > ; impl UCOE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOE_A { match self . bits { false => UCOE_A :: UCOE_0 , true => UCOE_A :: UCOE_1 } } # [ doc = "Checks if the value of the field is `UCOE_0`" ] # [ inline ( always ) ] pub fn is_ucoe_0 ( & self ) -> bool { * self == UCOE_A :: UCOE_0 } # [ doc = "Checks if the value of the field is `UCOE_1`" ] # [ inline ( always ) ] pub fn is_ucoe_1 ( & self ) -> bool { * self == UCOE_A :: UCOE_1 } }
# [ doc = "Write proxy for field `UCOE`" ] pub struct UCOE_W < 'a > { w : & 'a mut W , } impl < 'a > UCOE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucoe_0 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_0 ) } # [ doc = "Overrun error occurred" ] # [ inline ( always ) ] pub fn ucoe_1 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Framing error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCFE_A { # [ doc = "0: No error" ] UCFE_0 = 0 , # [ doc = "1: Bus conflict occurred" ] UCFE_1 = 1 } impl From < UCFE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCFE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCFE`" ] pub type UCFE_R = crate :: R < bool , UCFE_A > ; impl UCFE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCFE_A { match self . bits { false => UCFE_A :: UCFE_0 , true => UCFE_A :: UCFE_1 } } # [ doc = "Checks if the value of the field is `UCFE_0`" ] # [ inline ( always ) ] pub fn is_ucfe_0 ( & self ) -> bool { * self == UCFE_A :: UCFE_0 } # [ doc = "Checks if the value of the field is `UCFE_1`" ] # [ inline ( always ) ] pub fn is_ucfe_1 ( & self ) -> bool { * self == UCFE_A :: UCFE_1 } }
# [ doc = "Write proxy for field `UCFE`" ] pub struct UCFE_W < 'a > { w : & 'a mut W , } impl < 'a > UCFE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCFE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucfe_0 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_0 ) } # [ doc = "Bus conflict occurred" ] # [ inline ( always ) ] pub fn ucfe_1 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Listen enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCLISTEN_A { # [ doc = "0: Disabled" ] UCLISTEN_0 = 0 , # [ doc = "1: Enabled. UCAxTXD is internally fed back to the receiver" ] UCLISTEN_1 = 1 } impl From < UCLISTEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCLISTEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCLISTEN`" ] pub type UCLISTEN_R = crate :: R < bool , UCLISTEN_A > ; impl UCLISTEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCLISTEN_A { match self . bits { false => UCLISTEN_A :: UCLISTEN_0 , true => UCLISTEN_A :: UCLISTEN_1 } } # [ doc = "Checks if the value of the field is `UCLISTEN_0`" ] # [ inline ( always ) ] pub fn is_uclisten_0 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_0 } # [ doc = "Checks if the value of the field is `UCLISTEN_1`" ] # [ inline ( always ) ] pub fn is_uclisten_1 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_1 } }
# [ doc = "Write proxy for field `UCLISTEN`" ] pub struct UCLISTEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCLISTEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCLISTEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn uclisten_0 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_0 ) } # [ doc = "Enabled. UCAxTXD is internally fed back to the receiver" ] # [ inline ( always ) ] pub fn uclisten_1 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & self ) -> UCOE_R { UCOE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & self ) -> UCFE_R { UCFE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & self ) -> UCLISTEN_R { UCLISTEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & mut self ) -> UCOE_W { UCOE_W { w : self } }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & mut self ) -> UCFE_W { UCFE_W { w : self } }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & mut self ) -> UCLISTEN_W { UCLISTEN_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Receive Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1rxbuf](uca1rxbuf) module" ] pub type UCA1RXBUF = crate :: Reg < u16 , _UCA1RXBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1RXBUF ;
# [ doc = "`read()` method returns [uca1rxbuf::R](uca1rxbuf::R) reader structure" ] impl crate :: Readable for UCA1RXBUF { }
# [ doc = "eUSCI_Ax Receive Buffer Register" ] pub mod uca1rxbuf {
# [ doc = "Reader of register UCA1RXBUF" ] pub type R = crate :: R < u16 , super :: UCA1RXBUF > ;
# [ doc = "Reader of field `UCRXBUF`" ] pub type UCRXBUF_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Receive data buffer" ] # [ inline ( always ) ] pub fn ucrxbuf ( & self ) -> UCRXBUF_R { UCRXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
}
# [ doc = "eUSCI_Ax Receive Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1rxbuf_spi](uca1rxbuf_spi) module" ] pub type UCA1RXBUF_SPI = crate :: Reg < u16 , _UCA1RXBUF_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1RXBUF_SPI ;
# [ doc = "`read()` method returns [uca1rxbuf_spi::R](uca1rxbuf_spi::R) reader structure" ] impl crate :: Readable for UCA1RXBUF_SPI { }
# [ doc = "eUSCI_Ax Receive Buffer Register" ] pub mod uca1rxbuf_spi {
# [ doc = "Reader of register UCA1RXBUF_SPI" ] pub type R = crate :: R < u16 , super :: UCA1RXBUF_SPI > ;
# [ doc = "Reader of field `UCRXBUF`" ] pub type UCRXBUF_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Receive data buffer" ] # [ inline ( always ) ] pub fn ucrxbuf ( & self ) -> UCRXBUF_R { UCRXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
}
# [ doc = "eUSCI_Ax Transmit Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1txbuf](uca1txbuf) module" ] pub type UCA1TXBUF = crate :: Reg < u16 , _UCA1TXBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1TXBUF ;
# [ doc = "`read()` method returns [uca1txbuf::R](uca1txbuf::R) reader structure" ] impl crate :: Readable for UCA1TXBUF { }
# [ doc = "`write(|w| ..)` method takes [uca1txbuf::W](uca1txbuf::W) writer structure" ] impl crate :: Writable for UCA1TXBUF { }
# [ doc = "eUSCI_Ax Transmit Buffer Register" ] pub mod uca1txbuf {
# [ doc = "Reader of register UCA1TXBUF" ] pub type R = crate :: R < u16 , super :: UCA1TXBUF > ;
# [ doc = "Writer for register UCA1TXBUF" ] pub type W = crate :: W < u16 , super :: UCA1TXBUF > ;
# [ doc = "Register UCA1TXBUF `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1TXBUF { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UCTXBUF`" ] pub type UCTXBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCTXBUF`" ] pub struct UCTXBUF_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & self ) -> UCTXBUF_R { UCTXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & mut self ) -> UCTXBUF_W { UCTXBUF_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Transmit Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1txbuf_spi](uca1txbuf_spi) module" ] pub type UCA1TXBUF_SPI = crate :: Reg < u16 , _UCA1TXBUF_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1TXBUF_SPI ;
# [ doc = "`read()` method returns [uca1txbuf_spi::R](uca1txbuf_spi::R) reader structure" ] impl crate :: Readable for UCA1TXBUF_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca1txbuf_spi::W](uca1txbuf_spi::W) writer structure" ] impl crate :: Writable for UCA1TXBUF_SPI { }
# [ doc = "eUSCI_Ax Transmit Buffer Register" ] pub mod uca1txbuf_spi {
# [ doc = "Reader of register UCA1TXBUF_SPI" ] pub type R = crate :: R < u16 , super :: UCA1TXBUF_SPI > ;
# [ doc = "Writer for register UCA1TXBUF_SPI" ] pub type W = crate :: W < u16 , super :: UCA1TXBUF_SPI > ;
# [ doc = "Register UCA1TXBUF_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1TXBUF_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UCTXBUF`" ] pub type UCTXBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCTXBUF`" ] pub struct UCTXBUF_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & self ) -> UCTXBUF_R { UCTXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & mut self ) -> UCTXBUF_W { UCTXBUF_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Auto Baud Rate Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1abctl](uca1abctl) module" ] pub type UCA1ABCTL = crate :: Reg < u16 , _UCA1ABCTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1ABCTL ;
# [ doc = "`read()` method returns [uca1abctl::R](uca1abctl::R) reader structure" ] impl crate :: Readable for UCA1ABCTL { }
# [ doc = "`write(|w| ..)` method takes [uca1abctl::W](uca1abctl::W) writer structure" ] impl crate :: Writable for UCA1ABCTL { }
# [ doc = "eUSCI_Ax Auto Baud Rate Control Register" ] pub mod uca1abctl {
# [ doc = "Reader of register UCA1ABCTL" ] pub type R = crate :: R < u16 , super :: UCA1ABCTL > ;
# [ doc = "Writer for register UCA1ABCTL" ] pub type W = crate :: W < u16 , super :: UCA1ABCTL > ;
# [ doc = "Register UCA1ABCTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1ABCTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Automatic baud-rate detect enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCABDEN_A { # [ doc = "0: Baud-rate detection disabled. Length of break and synch field is not measured." ] UCABDEN_0 = 0 , # [ doc = "1: Baud-rate detection enabled. Length of break and synch field is measured and baud-rate settings are changed accordingly." ] UCABDEN_1 = 1 } impl From < UCABDEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCABDEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCABDEN`" ] pub type UCABDEN_R = crate :: R < bool , UCABDEN_A > ; impl UCABDEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCABDEN_A { match self . bits { false => UCABDEN_A :: UCABDEN_0 , true => UCABDEN_A :: UCABDEN_1 } } # [ doc = "Checks if the value of the field is `UCABDEN_0`" ] # [ inline ( always ) ] pub fn is_ucabden_0 ( & self ) -> bool { * self == UCABDEN_A :: UCABDEN_0 } # [ doc = "Checks if the value of the field is `UCABDEN_1`" ] # [ inline ( always ) ] pub fn is_ucabden_1 ( & self ) -> bool { * self == UCABDEN_A :: UCABDEN_1 } }
# [ doc = "Write proxy for field `UCABDEN`" ] pub struct UCABDEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCABDEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCABDEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Baud-rate detection disabled. Length of break and synch field is not measured." ] # [ inline ( always ) ] pub fn ucabden_0 ( self ) -> & 'a mut W { self . variant ( UCABDEN_A :: UCABDEN_0 ) } # [ doc = "Baud-rate detection enabled. Length of break and synch field is measured and baud-rate settings are changed accordingly." ] # [ inline ( always ) ] pub fn ucabden_1 ( self ) -> & 'a mut W { self . variant ( UCABDEN_A :: UCABDEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Break time out error\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBTOE_A { # [ doc = "0: No error" ] UCBTOE_0 = 0 , # [ doc = "1: Length of break field exceeded 22 bit times" ] UCBTOE_1 = 1 } impl From < UCBTOE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBTOE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBTOE`" ] pub type UCBTOE_R = crate :: R < bool , UCBTOE_A > ; impl UCBTOE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBTOE_A { match self . bits { false => UCBTOE_A :: UCBTOE_0 , true => UCBTOE_A :: UCBTOE_1 } } # [ doc = "Checks if the value of the field is `UCBTOE_0`" ] # [ inline ( always ) ] pub fn is_ucbtoe_0 ( & self ) -> bool { * self == UCBTOE_A :: UCBTOE_0 } # [ doc = "Checks if the value of the field is `UCBTOE_1`" ] # [ inline ( always ) ] pub fn is_ucbtoe_1 ( & self ) -> bool { * self == UCBTOE_A :: UCBTOE_1 } }
# [ doc = "Write proxy for field `UCBTOE`" ] pub struct UCBTOE_W < 'a > { w : & 'a mut W , } impl < 'a > UCBTOE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBTOE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucbtoe_0 ( self ) -> & 'a mut W { self . variant ( UCBTOE_A :: UCBTOE_0 ) } # [ doc = "Length of break field exceeded 22 bit times" ] # [ inline ( always ) ] pub fn ucbtoe_1 ( self ) -> & 'a mut W { self . variant ( UCBTOE_A :: UCBTOE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Synch field time out error\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTOE_A { # [ doc = "0: No error" ] UCSTOE_0 = 0 , # [ doc = "1: Length of synch field exceeded measurable time" ] UCSTOE_1 = 1 } impl From < UCSTOE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTOE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTOE`" ] pub type UCSTOE_R = crate :: R < bool , UCSTOE_A > ; impl UCSTOE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTOE_A { match self . bits { false => UCSTOE_A :: UCSTOE_0 , true => UCSTOE_A :: UCSTOE_1 } } # [ doc = "Checks if the value of the field is `UCSTOE_0`" ] # [ inline ( always ) ] pub fn is_ucstoe_0 ( & self ) -> bool { * self == UCSTOE_A :: UCSTOE_0 } # [ doc = "Checks if the value of the field is `UCSTOE_1`" ] # [ inline ( always ) ] pub fn is_ucstoe_1 ( & self ) -> bool { * self == UCSTOE_A :: UCSTOE_1 } }
# [ doc = "Write proxy for field `UCSTOE`" ] pub struct UCSTOE_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTOE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTOE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucstoe_0 ( self ) -> & 'a mut W { self . variant ( UCSTOE_A :: UCSTOE_0 ) } # [ doc = "Length of synch field exceeded measurable time" ] # [ inline ( always ) ] pub fn ucstoe_1 ( self ) -> & 'a mut W { self . variant ( UCSTOE_A :: UCSTOE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Break/synch delimiter length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCDELIM_A { # [ doc = "0: 1 bit time" ] UCDELIM_0 = 0 , # [ doc = "1: 2 bit times" ] UCDELIM_1 = 1 , # [ doc = "2: 3 bit times" ] UCDELIM_2 = 2 , # [ doc = "3: 4 bit times" ] UCDELIM_3 = 3 } impl From < UCDELIM_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCDELIM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCDELIM`" ] pub type UCDELIM_R = crate :: R < u8 , UCDELIM_A > ; impl UCDELIM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCDELIM_A { match self . bits { 0 => UCDELIM_A :: UCDELIM_0 , 1 => UCDELIM_A :: UCDELIM_1 , 2 => UCDELIM_A :: UCDELIM_2 , 3 => UCDELIM_A :: UCDELIM_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCDELIM_0`" ] # [ inline ( always ) ] pub fn is_ucdelim_0 ( & self ) -> bool { * self == UCDELIM_A :: UCDELIM_0 } # [ doc = "Checks if the value of the field is `UCDELIM_1`" ] # [ inline ( always ) ] pub fn is_ucdelim_1 ( & self ) -> bool { * self == UCDELIM_A :: UCDELIM_1 } # [ doc = "Checks if the value of the field is `UCDELIM_2`" ] # [ inline ( always ) ] pub fn is_ucdelim_2 ( & self ) -> bool { * self == UCDELIM_A :: UCDELIM_2 } # [ doc = "Checks if the value of the field is `UCDELIM_3`" ] # [ inline ( always ) ] pub fn is_ucdelim_3 ( & self ) -> bool { * self == UCDELIM_A :: UCDELIM_3 } }
# [ doc = "Write proxy for field `UCDELIM`" ] pub struct UCDELIM_W < 'a > { w : & 'a mut W , } impl < 'a > UCDELIM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCDELIM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "1 bit time" ] # [ inline ( always ) ] pub fn ucdelim_0 ( self ) -> & 'a mut W { self . variant ( UCDELIM_A :: UCDELIM_0 ) } # [ doc = "2 bit times" ] # [ inline ( always ) ] pub fn ucdelim_1 ( self ) -> & 'a mut W { self . variant ( UCDELIM_A :: UCDELIM_1 ) } # [ doc = "3 bit times" ] # [ inline ( always ) ] pub fn ucdelim_2 ( self ) -> & 'a mut W { self . variant ( UCDELIM_A :: UCDELIM_2 ) } # [ doc = "4 bit times" ] # [ inline ( always ) ] pub fn ucdelim_3 ( self ) -> & 'a mut W { self . variant ( UCDELIM_A :: UCDELIM_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Automatic baud-rate detect enable" ] # [ inline ( always ) ] pub fn ucabden ( & self ) -> UCABDEN_R { UCABDEN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Break time out error" ] # [ inline ( always ) ] pub fn ucbtoe ( & self ) -> UCBTOE_R { UCBTOE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Synch field time out error" ] # [ inline ( always ) ] pub fn ucstoe ( & self ) -> UCSTOE_R { UCSTOE_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - Break/synch delimiter length" ] # [ inline ( always ) ] pub fn ucdelim ( & self ) -> UCDELIM_R { UCDELIM_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Automatic baud-rate detect enable" ] # [ inline ( always ) ] pub fn ucabden ( & mut self ) -> UCABDEN_W { UCABDEN_W { w : self } }
# [ doc = "Bit 2 - Break time out error" ] # [ inline ( always ) ] pub fn ucbtoe ( & mut self ) -> UCBTOE_W { UCBTOE_W { w : self } }
# [ doc = "Bit 3 - Synch field time out error" ] # [ inline ( always ) ] pub fn ucstoe ( & mut self ) -> UCSTOE_W { UCSTOE_W { w : self } }
# [ doc = "Bits 4:5 - Break/synch delimiter length" ] # [ inline ( always ) ] pub fn ucdelim ( & mut self ) -> UCDELIM_W { UCDELIM_W { w : self } }
}
}
# [ doc = "eUSCI_Ax IrDA Control Word Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1irctl](uca1irctl) module" ] pub type UCA1IRCTL = crate :: Reg < u16 , _UCA1IRCTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1IRCTL ;
# [ doc = "`read()` method returns [uca1irctl::R](uca1irctl::R) reader structure" ] impl crate :: Readable for UCA1IRCTL { }
# [ doc = "`write(|w| ..)` method takes [uca1irctl::W](uca1irctl::W) writer structure" ] impl crate :: Writable for UCA1IRCTL { }
# [ doc = "eUSCI_Ax IrDA Control Word Register" ] pub mod uca1irctl {
# [ doc = "Reader of register UCA1IRCTL" ] pub type R = crate :: R < u16 , super :: UCA1IRCTL > ;
# [ doc = "Writer for register UCA1IRCTL" ] pub type W = crate :: W < u16 , super :: UCA1IRCTL > ;
# [ doc = "Register UCA1IRCTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1IRCTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "IrDA encoder/decoder enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCIREN_A { # [ doc = "0: IrDA encoder/decoder disabled" ] UCIREN_0 = 0 , # [ doc = "1: IrDA encoder/decoder enabled" ] UCIREN_1 = 1 } impl From < UCIREN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCIREN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCIREN`" ] pub type UCIREN_R = crate :: R < bool , UCIREN_A > ; impl UCIREN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCIREN_A { match self . bits { false => UCIREN_A :: UCIREN_0 , true => UCIREN_A :: UCIREN_1 } } # [ doc = "Checks if the value of the field is `UCIREN_0`" ] # [ inline ( always ) ] pub fn is_uciren_0 ( & self ) -> bool { * self == UCIREN_A :: UCIREN_0 } # [ doc = "Checks if the value of the field is `UCIREN_1`" ] # [ inline ( always ) ] pub fn is_uciren_1 ( & self ) -> bool { * self == UCIREN_A :: UCIREN_1 } }
# [ doc = "Write proxy for field `UCIREN`" ] pub struct UCIREN_W < 'a > { w : & 'a mut W , } impl < 'a > UCIREN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCIREN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "IrDA encoder/decoder disabled" ] # [ inline ( always ) ] pub fn uciren_0 ( self ) -> & 'a mut W { self . variant ( UCIREN_A :: UCIREN_0 ) } # [ doc = "IrDA encoder/decoder enabled" ] # [ inline ( always ) ] pub fn uciren_1 ( self ) -> & 'a mut W { self . variant ( UCIREN_A :: UCIREN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "IrDA transmit pulse clock select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCIRTXCLK_A { # [ doc = "0: BRCLK" ] UCIRTXCLK_0 = 0 , # [ doc = "1: BITCLK16 when UCOS16 = 1. Otherwise, BRCLK." ] UCIRTXCLK_1 = 1 } impl From < UCIRTXCLK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCIRTXCLK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCIRTXCLK`" ] pub type UCIRTXCLK_R = crate :: R < bool , UCIRTXCLK_A > ; impl UCIRTXCLK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCIRTXCLK_A { match self . bits { false => UCIRTXCLK_A :: UCIRTXCLK_0 , true => UCIRTXCLK_A :: UCIRTXCLK_1 } } # [ doc = "Checks if the value of the field is `UCIRTXCLK_0`" ] # [ inline ( always ) ] pub fn is_ucirtxclk_0 ( & self ) -> bool { * self == UCIRTXCLK_A :: UCIRTXCLK_0 } # [ doc = "Checks if the value of the field is `UCIRTXCLK_1`" ] # [ inline ( always ) ] pub fn is_ucirtxclk_1 ( & self ) -> bool { * self == UCIRTXCLK_A :: UCIRTXCLK_1 } }
# [ doc = "Write proxy for field `UCIRTXCLK`" ] pub struct UCIRTXCLK_W < 'a > { w : & 'a mut W , } impl < 'a > UCIRTXCLK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCIRTXCLK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "BRCLK" ] # [ inline ( always ) ] pub fn ucirtxclk_0 ( self ) -> & 'a mut W { self . variant ( UCIRTXCLK_A :: UCIRTXCLK_0 ) } # [ doc = "BITCLK16 when UCOS16 = 1. Otherwise, BRCLK." ] # [ inline ( always ) ] pub fn ucirtxclk_1 ( self ) -> & 'a mut W { self . variant ( UCIRTXCLK_A :: UCIRTXCLK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `UCIRTXPL`" ] pub type UCIRTXPL_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCIRTXPL`" ] pub struct UCIRTXPL_W < 'a > { w : & 'a mut W , } impl < 'a > UCIRTXPL_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 2 ) ) | ( ( ( value as u16 ) & 0x3f ) << 2 ) ; self . w } }
# [ doc = "IrDA receive filter enabled\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCIRRXFE_A { # [ doc = "0: Receive filter disabled" ] UCIRRXFE_0 = 0 , # [ doc = "1: Receive filter enabled" ] UCIRRXFE_1 = 1 } impl From < UCIRRXFE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCIRRXFE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCIRRXFE`" ] pub type UCIRRXFE_R = crate :: R < bool , UCIRRXFE_A > ; impl UCIRRXFE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCIRRXFE_A { match self . bits { false => UCIRRXFE_A :: UCIRRXFE_0 , true => UCIRRXFE_A :: UCIRRXFE_1 } } # [ doc = "Checks if the value of the field is `UCIRRXFE_0`" ] # [ inline ( always ) ] pub fn is_ucirrxfe_0 ( & self ) -> bool { * self == UCIRRXFE_A :: UCIRRXFE_0 } # [ doc = "Checks if the value of the field is `UCIRRXFE_1`" ] # [ inline ( always ) ] pub fn is_ucirrxfe_1 ( & self ) -> bool { * self == UCIRRXFE_A :: UCIRRXFE_1 } }
# [ doc = "Write proxy for field `UCIRRXFE`" ] pub struct UCIRRXFE_W < 'a > { w : & 'a mut W , } impl < 'a > UCIRRXFE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCIRRXFE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Receive filter disabled" ] # [ inline ( always ) ] pub fn ucirrxfe_0 ( self ) -> & 'a mut W { self . variant ( UCIRRXFE_A :: UCIRRXFE_0 ) } # [ doc = "Receive filter enabled" ] # [ inline ( always ) ] pub fn ucirrxfe_1 ( self ) -> & 'a mut W { self . variant ( UCIRRXFE_A :: UCIRRXFE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "IrDA receive input UCAxRXD polarity\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCIRRXPL_A { # [ doc = "0: IrDA transceiver delivers a high pulse when a light pulse is seen" ] HIGH = 0 , # [ doc = "1: IrDA transceiver delivers a low pulse when a light pulse is seen" ] LOW = 1 } impl From < UCIRRXPL_A > for bool { # [ inline ( always ) ] fn from ( variant : UCIRRXPL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCIRRXPL`" ] pub type UCIRRXPL_R = crate :: R < bool , UCIRRXPL_A > ; impl UCIRRXPL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCIRRXPL_A { match self . bits { false => UCIRRXPL_A :: HIGH , true => UCIRRXPL_A :: LOW } } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == UCIRRXPL_A :: HIGH } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == UCIRRXPL_A :: LOW } }
# [ doc = "Write proxy for field `UCIRRXPL`" ] pub struct UCIRRXPL_W < 'a > { w : & 'a mut W , } impl < 'a > UCIRRXPL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCIRRXPL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "IrDA transceiver delivers a high pulse when a light pulse is seen" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( UCIRRXPL_A :: HIGH ) } # [ doc = "IrDA transceiver delivers a low pulse when a light pulse is seen" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( UCIRRXPL_A :: LOW ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `UCIRRXFL`" ] pub type UCIRRXFL_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCIRRXFL`" ] pub struct UCIRRXFL_W < 'a > { w : & 'a mut W , } impl < 'a > UCIRRXFL_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 10 ) ) | ( ( ( value as u16 ) & 0x3f ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - IrDA encoder/decoder enable" ] # [ inline ( always ) ] pub fn uciren ( & self ) -> UCIREN_R { UCIREN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - IrDA transmit pulse clock select" ] # [ inline ( always ) ] pub fn ucirtxclk ( & self ) -> UCIRTXCLK_R { UCIRTXCLK_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 2:7 - Transmit pulse length" ] # [ inline ( always ) ] pub fn ucirtxpl ( & self ) -> UCIRTXPL_R { UCIRTXPL_R :: new ( ( ( self . bits >> 2 ) & 0x3f ) as u8 ) }
# [ doc = "Bit 8 - IrDA receive filter enabled" ] # [ inline ( always ) ] pub fn ucirrxfe ( & self ) -> UCIRRXFE_R { UCIRRXFE_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - IrDA receive input UCAxRXD polarity" ] # [ inline ( always ) ] pub fn ucirrxpl ( & self ) -> UCIRRXPL_R { UCIRRXPL_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 10:15 - Receive filter length" ] # [ inline ( always ) ] pub fn ucirrxfl ( & self ) -> UCIRRXFL_R { UCIRRXFL_R :: new ( ( ( self . bits >> 10 ) & 0x3f ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - IrDA encoder/decoder enable" ] # [ inline ( always ) ] pub fn uciren ( & mut self ) -> UCIREN_W { UCIREN_W { w : self } }
# [ doc = "Bit 1 - IrDA transmit pulse clock select" ] # [ inline ( always ) ] pub fn ucirtxclk ( & mut self ) -> UCIRTXCLK_W { UCIRTXCLK_W { w : self } }
# [ doc = "Bits 2:7 - Transmit pulse length" ] # [ inline ( always ) ] pub fn ucirtxpl ( & mut self ) -> UCIRTXPL_W { UCIRTXPL_W { w : self } }
# [ doc = "Bit 8 - IrDA receive filter enabled" ] # [ inline ( always ) ] pub fn ucirrxfe ( & mut self ) -> UCIRRXFE_W { UCIRRXFE_W { w : self } }
# [ doc = "Bit 9 - IrDA receive input UCAxRXD polarity" ] # [ inline ( always ) ] pub fn ucirrxpl ( & mut self ) -> UCIRRXPL_W { UCIRRXPL_W { w : self } }
# [ doc = "Bits 10:15 - Receive filter length" ] # [ inline ( always ) ] pub fn ucirrxfl ( & mut self ) -> UCIRRXFL_W { UCIRRXFL_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ie](uca1ie) module" ] pub type UCA1IE = crate :: Reg < u16 , _UCA1IE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1IE ;
# [ doc = "`read()` method returns [uca1ie::R](uca1ie::R) reader structure" ] impl crate :: Readable for UCA1IE { }
# [ doc = "`write(|w| ..)` method takes [uca1ie::W](uca1ie::W) writer structure" ] impl crate :: Writable for UCA1IE { }
# [ doc = "eUSCI_Ax Interrupt Enable Register" ] pub mod uca1ie {
# [ doc = "Reader of register UCA1IE" ] pub type R = crate :: R < u16 , super :: UCA1IE > ;
# [ doc = "Writer for register UCA1IE" ] pub type W = crate :: W < u16 , super :: UCA1IE > ;
# [ doc = "Register UCA1IE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1IE { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE_A { # [ doc = "0: Interrupt disabled" ] UCRXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE_1 = 1 } impl From < UCRXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE`" ] pub type UCRXIE_R = crate :: R < bool , UCRXIE_A > ; impl UCRXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE_A { match self . bits { false => UCRXIE_A :: UCRXIE_0 , true => UCRXIE_A :: UCRXIE_1 } } # [ doc = "Checks if the value of the field is `UCRXIE_0`" ] # [ inline ( always ) ] pub fn is_ucrxie_0 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_0 } # [ doc = "Checks if the value of the field is `UCRXIE_1`" ] # [ inline ( always ) ] pub fn is_ucrxie_1 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_1 } }
# [ doc = "Write proxy for field `UCRXIE`" ] pub struct UCRXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE_A { # [ doc = "0: Interrupt disabled" ] UCTXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE_1 = 1 } impl From < UCTXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE`" ] pub type UCTXIE_R = crate :: R < bool , UCTXIE_A > ; impl UCTXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE_A { match self . bits { false => UCTXIE_A :: UCTXIE_0 , true => UCTXIE_A :: UCTXIE_1 } } # [ doc = "Checks if the value of the field is `UCTXIE_0`" ] # [ inline ( always ) ] pub fn is_uctxie_0 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_0 } # [ doc = "Checks if the value of the field is `UCTXIE_1`" ] # [ inline ( always ) ] pub fn is_uctxie_1 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_1 } }
# [ doc = "Write proxy for field `UCTXIE`" ] pub struct UCTXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Start bit interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTTIE_A { # [ doc = "0: Interrupt disabled" ] UCSTTIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCSTTIE_1 = 1 } impl From < UCSTTIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTTIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTTIE`" ] pub type UCSTTIE_R = crate :: R < bool , UCSTTIE_A > ; impl UCSTTIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTTIE_A { match self . bits { false => UCSTTIE_A :: UCSTTIE_0 , true => UCSTTIE_A :: UCSTTIE_1 } } # [ doc = "Checks if the value of the field is `UCSTTIE_0`" ] # [ inline ( always ) ] pub fn is_ucsttie_0 ( & self ) -> bool { * self == UCSTTIE_A :: UCSTTIE_0 } # [ doc = "Checks if the value of the field is `UCSTTIE_1`" ] # [ inline ( always ) ] pub fn is_ucsttie_1 ( & self ) -> bool { * self == UCSTTIE_A :: UCSTTIE_1 } }
# [ doc = "Write proxy for field `UCSTTIE`" ] pub struct UCSTTIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTTIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTTIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucsttie_0 ( self ) -> & 'a mut W { self . variant ( UCSTTIE_A :: UCSTTIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucsttie_1 ( self ) -> & 'a mut W { self . variant ( UCSTTIE_A :: UCSTTIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Transmit complete interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXCPTIE_A { # [ doc = "0: Interrupt disabled" ] UCTXCPTIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXCPTIE_1 = 1 } impl From < UCTXCPTIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXCPTIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXCPTIE`" ] pub type UCTXCPTIE_R = crate :: R < bool , UCTXCPTIE_A > ; impl UCTXCPTIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXCPTIE_A { match self . bits { false => UCTXCPTIE_A :: UCTXCPTIE_0 , true => UCTXCPTIE_A :: UCTXCPTIE_1 } } # [ doc = "Checks if the value of the field is `UCTXCPTIE_0`" ] # [ inline ( always ) ] pub fn is_uctxcptie_0 ( & self ) -> bool { * self == UCTXCPTIE_A :: UCTXCPTIE_0 } # [ doc = "Checks if the value of the field is `UCTXCPTIE_1`" ] # [ inline ( always ) ] pub fn is_uctxcptie_1 ( & self ) -> bool { * self == UCTXCPTIE_A :: UCTXCPTIE_1 } }
# [ doc = "Write proxy for field `UCTXCPTIE`" ] pub struct UCTXCPTIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXCPTIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXCPTIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxcptie_0 ( self ) -> & 'a mut W { self . variant ( UCTXCPTIE_A :: UCTXCPTIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxcptie_1 ( self ) -> & 'a mut W { self . variant ( UCTXCPTIE_A :: UCTXCPTIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & self ) -> UCRXIE_R { UCRXIE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & self ) -> UCTXIE_R { UCTXIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Start bit interrupt enable" ] # [ inline ( always ) ] pub fn ucsttie ( & self ) -> UCSTTIE_R { UCSTTIE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Transmit complete interrupt enable" ] # [ inline ( always ) ] pub fn uctxcptie ( & self ) -> UCTXCPTIE_R { UCTXCPTIE_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & mut self ) -> UCRXIE_W { UCRXIE_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & mut self ) -> UCTXIE_W { UCTXIE_W { w : self } }
# [ doc = "Bit 2 - Start bit interrupt enable" ] # [ inline ( always ) ] pub fn ucsttie ( & mut self ) -> UCSTTIE_W { UCSTTIE_W { w : self } }
# [ doc = "Bit 3 - Transmit complete interrupt enable" ] # [ inline ( always ) ] pub fn uctxcptie ( & mut self ) -> UCTXCPTIE_W { UCTXCPTIE_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ie_spi](uca1ie_spi) module" ] pub type UCA1IE_SPI = crate :: Reg < u16 , _UCA1IE_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1IE_SPI ;
# [ doc = "`read()` method returns [uca1ie_spi::R](uca1ie_spi::R) reader structure" ] impl crate :: Readable for UCA1IE_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca1ie_spi::W](uca1ie_spi::W) writer structure" ] impl crate :: Writable for UCA1IE_SPI { }
# [ doc = "eUSCI_Ax Interrupt Enable Register" ] pub mod uca1ie_spi {
# [ doc = "Reader of register UCA1IE_SPI" ] pub type R = crate :: R < u16 , super :: UCA1IE_SPI > ;
# [ doc = "Writer for register UCA1IE_SPI" ] pub type W = crate :: W < u16 , super :: UCA1IE_SPI > ;
# [ doc = "Register UCA1IE_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1IE_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE_A { # [ doc = "0: Interrupt disabled" ] UCRXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE_1 = 1 } impl From < UCRXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE`" ] pub type UCRXIE_R = crate :: R < bool , UCRXIE_A > ; impl UCRXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE_A { match self . bits { false => UCRXIE_A :: UCRXIE_0 , true => UCRXIE_A :: UCRXIE_1 } } # [ doc = "Checks if the value of the field is `UCRXIE_0`" ] # [ inline ( always ) ] pub fn is_ucrxie_0 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_0 } # [ doc = "Checks if the value of the field is `UCRXIE_1`" ] # [ inline ( always ) ] pub fn is_ucrxie_1 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_1 } }
# [ doc = "Write proxy for field `UCRXIE`" ] pub struct UCRXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE_A { # [ doc = "0: Interrupt disabled" ] UCTXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE_1 = 1 } impl From < UCTXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE`" ] pub type UCTXIE_R = crate :: R < bool , UCTXIE_A > ; impl UCTXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE_A { match self . bits { false => UCTXIE_A :: UCTXIE_0 , true => UCTXIE_A :: UCTXIE_1 } } # [ doc = "Checks if the value of the field is `UCTXIE_0`" ] # [ inline ( always ) ] pub fn is_uctxie_0 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_0 } # [ doc = "Checks if the value of the field is `UCTXIE_1`" ] # [ inline ( always ) ] pub fn is_uctxie_1 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_1 } }
# [ doc = "Write proxy for field `UCTXIE`" ] pub struct UCTXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & self ) -> UCRXIE_R { UCRXIE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & self ) -> UCTXIE_R { UCTXIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & mut self ) -> UCRXIE_W { UCRXIE_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & mut self ) -> UCTXIE_W { UCTXIE_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ifg](uca1ifg) module" ] pub type UCA1IFG = crate :: Reg < u16 , _UCA1IFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1IFG ;
# [ doc = "`read()` method returns [uca1ifg::R](uca1ifg::R) reader structure" ] impl crate :: Readable for UCA1IFG { }
# [ doc = "`write(|w| ..)` method takes [uca1ifg::W](uca1ifg::W) writer structure" ] impl crate :: Writable for UCA1IFG { }
# [ doc = "eUSCI_Ax Interrupt Flag Register" ] pub mod uca1ifg {
# [ doc = "Reader of register UCA1IFG" ] pub type R = crate :: R < u16 , super :: UCA1IFG > ;
# [ doc = "Writer for register UCA1IFG" ] pub type W = crate :: W < u16 , super :: UCA1IFG > ;
# [ doc = "Register UCA1IFG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1IFG { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG_A { # [ doc = "0: No interrupt pending" ] UCRXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG_1 = 1 } impl From < UCRXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG`" ] pub type UCRXIFG_R = crate :: R < bool , UCRXIFG_A > ; impl UCRXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG_A { match self . bits { false => UCRXIFG_A :: UCRXIFG_0 , true => UCRXIFG_A :: UCRXIFG_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg_0 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_0 } # [ doc = "Checks if the value of the field is `UCRXIFG_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg_1 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_1 } }
# [ doc = "Write proxy for field `UCRXIFG`" ] pub struct UCRXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG_A { # [ doc = "0: No interrupt pending" ] UCTXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG_1 = 1 } impl From < UCTXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG`" ] pub type UCTXIFG_R = crate :: R < bool , UCTXIFG_A > ; impl UCTXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG_A { match self . bits { false => UCTXIFG_A :: UCTXIFG_0 , true => UCTXIFG_A :: UCTXIFG_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG_0`" ] # [ inline ( always ) ] pub fn is_uctxifg_0 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_0 } # [ doc = "Checks if the value of the field is `UCTXIFG_1`" ] # [ inline ( always ) ] pub fn is_uctxifg_1 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_1 } }
# [ doc = "Write proxy for field `UCTXIFG`" ] pub struct UCTXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Start bit interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTTIFG_A { # [ doc = "0: No interrupt pending" ] UCSTTIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCSTTIFG_1 = 1 } impl From < UCSTTIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTTIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTTIFG`" ] pub type UCSTTIFG_R = crate :: R < bool , UCSTTIFG_A > ; impl UCSTTIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTTIFG_A { match self . bits { false => UCSTTIFG_A :: UCSTTIFG_0 , true => UCSTTIFG_A :: UCSTTIFG_1 } } # [ doc = "Checks if the value of the field is `UCSTTIFG_0`" ] # [ inline ( always ) ] pub fn is_ucsttifg_0 ( & self ) -> bool { * self == UCSTTIFG_A :: UCSTTIFG_0 } # [ doc = "Checks if the value of the field is `UCSTTIFG_1`" ] # [ inline ( always ) ] pub fn is_ucsttifg_1 ( & self ) -> bool { * self == UCSTTIFG_A :: UCSTTIFG_1 } }
# [ doc = "Write proxy for field `UCSTTIFG`" ] pub struct UCSTTIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTTIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTTIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucsttifg_0 ( self ) -> & 'a mut W { self . variant ( UCSTTIFG_A :: UCSTTIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucsttifg_1 ( self ) -> & 'a mut W { self . variant ( UCSTTIFG_A :: UCSTTIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Transmit ready interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXCPTIFG_A { # [ doc = "0: No interrupt pending" ] UCTXCPTIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXCPTIFG_1 = 1 } impl From < UCTXCPTIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXCPTIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXCPTIFG`" ] pub type UCTXCPTIFG_R = crate :: R < bool , UCTXCPTIFG_A > ; impl UCTXCPTIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXCPTIFG_A { match self . bits { false => UCTXCPTIFG_A :: UCTXCPTIFG_0 , true => UCTXCPTIFG_A :: UCTXCPTIFG_1 } } # [ doc = "Checks if the value of the field is `UCTXCPTIFG_0`" ] # [ inline ( always ) ] pub fn is_uctxcptifg_0 ( & self ) -> bool { * self == UCTXCPTIFG_A :: UCTXCPTIFG_0 } # [ doc = "Checks if the value of the field is `UCTXCPTIFG_1`" ] # [ inline ( always ) ] pub fn is_uctxcptifg_1 ( & self ) -> bool { * self == UCTXCPTIFG_A :: UCTXCPTIFG_1 } }
# [ doc = "Write proxy for field `UCTXCPTIFG`" ] pub struct UCTXCPTIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXCPTIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXCPTIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxcptifg_0 ( self ) -> & 'a mut W { self . variant ( UCTXCPTIFG_A :: UCTXCPTIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxcptifg_1 ( self ) -> & 'a mut W { self . variant ( UCTXCPTIFG_A :: UCTXCPTIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & self ) -> UCRXIFG_R { UCRXIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & self ) -> UCTXIFG_R { UCTXIFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Start bit interrupt flag" ] # [ inline ( always ) ] pub fn ucsttifg ( & self ) -> UCSTTIFG_R { UCSTTIFG_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Transmit ready interrupt enable" ] # [ inline ( always ) ] pub fn uctxcptifg ( & self ) -> UCTXCPTIFG_R { UCTXCPTIFG_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & mut self ) -> UCRXIFG_W { UCRXIFG_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & mut self ) -> UCTXIFG_W { UCTXIFG_W { w : self } }
# [ doc = "Bit 2 - Start bit interrupt flag" ] # [ inline ( always ) ] pub fn ucsttifg ( & mut self ) -> UCSTTIFG_W { UCSTTIFG_W { w : self } }
# [ doc = "Bit 3 - Transmit ready interrupt enable" ] # [ inline ( always ) ] pub fn uctxcptifg ( & mut self ) -> UCTXCPTIFG_W { UCTXCPTIFG_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ifg_spi](uca1ifg_spi) module" ] pub type UCA1IFG_SPI = crate :: Reg < u16 , _UCA1IFG_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1IFG_SPI ;
# [ doc = "`read()` method returns [uca1ifg_spi::R](uca1ifg_spi::R) reader structure" ] impl crate :: Readable for UCA1IFG_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca1ifg_spi::W](uca1ifg_spi::W) writer structure" ] impl crate :: Writable for UCA1IFG_SPI { }
# [ doc = "eUSCI_Ax Interrupt Flag Register" ] pub mod uca1ifg_spi {
# [ doc = "Reader of register UCA1IFG_SPI" ] pub type R = crate :: R < u16 , super :: UCA1IFG_SPI > ;
# [ doc = "Writer for register UCA1IFG_SPI" ] pub type W = crate :: W < u16 , super :: UCA1IFG_SPI > ;
# [ doc = "Register UCA1IFG_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1IFG_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG_A { # [ doc = "0: No interrupt pending" ] UCRXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG_1 = 1 } impl From < UCRXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG`" ] pub type UCRXIFG_R = crate :: R < bool , UCRXIFG_A > ; impl UCRXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG_A { match self . bits { false => UCRXIFG_A :: UCRXIFG_0 , true => UCRXIFG_A :: UCRXIFG_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg_0 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_0 } # [ doc = "Checks if the value of the field is `UCRXIFG_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg_1 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_1 } }
# [ doc = "Write proxy for field `UCRXIFG`" ] pub struct UCRXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG_A { # [ doc = "0: No interrupt pending" ] UCTXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG_1 = 1 } impl From < UCTXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG`" ] pub type UCTXIFG_R = crate :: R < bool , UCTXIFG_A > ; impl UCTXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG_A { match self . bits { false => UCTXIFG_A :: UCTXIFG_0 , true => UCTXIFG_A :: UCTXIFG_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG_0`" ] # [ inline ( always ) ] pub fn is_uctxifg_0 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_0 } # [ doc = "Checks if the value of the field is `UCTXIFG_1`" ] # [ inline ( always ) ] pub fn is_uctxifg_1 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_1 } }
# [ doc = "Write proxy for field `UCTXIFG`" ] pub struct UCTXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & self ) -> UCRXIFG_R { UCRXIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & self ) -> UCTXIFG_R { UCTXIFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & mut self ) -> UCRXIFG_W { UCRXIFG_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & mut self ) -> UCTXIFG_W { UCTXIFG_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1iv](uca1iv) module" ] pub type UCA1IV = crate :: Reg < u16 , _UCA1IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1IV ;
# [ doc = "`read()` method returns [uca1iv::R](uca1iv::R) reader structure" ] impl crate :: Readable for UCA1IV { }
# [ doc = "eUSCI_Ax Interrupt Vector Register" ] pub mod uca1iv {
# [ doc = "Reader of register UCA1IV" ] pub type R = crate :: R < u16 , super :: UCA1IV > ;
# [ doc = "eUSCI_A interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum UCIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Receive buffer full; Interrupt Flag: UCRXIFG; Interrupt Priority: Highest" ] UCRXIFG = 2 , # [ doc = "4: Interrupt Source: Transmit buffer empty; Interrupt Flag: UCTXIFG" ] UCTXIFG = 4 , # [ doc = "6: Interrupt Source: Start bit received; Interrupt Flag: UCSTTIFG" ] UCSTTIFG = 6 , # [ doc = "8: Interrupt Source: Transmit complete; Interrupt Flag: UCTXCPTIFG; Interrupt Priority: Lowest" ] UCTXCPTIFG = 8 } impl From < UCIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : UCIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCIV`" ] pub type UCIV_R = crate :: R < u16 , UCIV_A > ; impl UCIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , UCIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( UCIV_A :: NONE ) , 2 => Val ( UCIV_A :: UCRXIFG ) , 4 => Val ( UCIV_A :: UCTXIFG ) , 6 => Val ( UCIV_A :: UCSTTIFG ) , 8 => Val ( UCIV_A :: UCTXCPTIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == UCIV_A :: NONE } # [ doc = "Checks if the value of the field is `UCRXIFG`" ] # [ inline ( always ) ] pub fn is_ucrxifg ( & self ) -> bool { * self == UCIV_A :: UCRXIFG } # [ doc = "Checks if the value of the field is `UCTXIFG`" ] # [ inline ( always ) ] pub fn is_uctxifg ( & self ) -> bool { * self == UCIV_A :: UCTXIFG } # [ doc = "Checks if the value of the field is `UCSTTIFG`" ] # [ inline ( always ) ] pub fn is_ucsttifg ( & self ) -> bool { * self == UCIV_A :: UCSTTIFG } # [ doc = "Checks if the value of the field is `UCTXCPTIFG`" ] # [ inline ( always ) ] pub fn is_uctxcptifg ( & self ) -> bool { * self == UCIV_A :: UCTXCPTIFG } }
impl R {
# [ doc = "Bits 0:15 - eUSCI_A interrupt vector value" ] # [ inline ( always ) ] pub fn uciv ( & self ) -> UCIV_R { UCIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
# [ doc = "eUSCI_Ax Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1iv_spi](uca1iv_spi) module" ] pub type UCA1IV_SPI = crate :: Reg < u16 , _UCA1IV_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1IV_SPI ;
# [ doc = "`read()` method returns [uca1iv_spi::R](uca1iv_spi::R) reader structure" ] impl crate :: Readable for UCA1IV_SPI { }
# [ doc = "eUSCI_Ax Interrupt Vector Register" ] pub mod uca1iv_spi {
# [ doc = "Reader of register UCA1IV_SPI" ] pub type R = crate :: R < u16 , super :: UCA1IV_SPI > ;
# [ doc = "eUSCI_A interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum UCIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Data received; Interrupt Flag: UCRXIFG; Interrupt Priority: Highest" ] UCRXIFG = 2 , # [ doc = "4: Interrupt Source: Transmit buffer empty; Interrupt Flag: UCTXIFG; Interrupt Priority: Lowest" ] UCTXIFG = 4 } impl From < UCIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : UCIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCIV`" ] pub type UCIV_R = crate :: R < u16 , UCIV_A > ; impl UCIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , UCIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( UCIV_A :: NONE ) , 2 => Val ( UCIV_A :: UCRXIFG ) , 4 => Val ( UCIV_A :: UCTXIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == UCIV_A :: NONE } # [ doc = "Checks if the value of the field is `UCRXIFG`" ] # [ inline ( always ) ] pub fn is_ucrxifg ( & self ) -> bool { * self == UCIV_A :: UCRXIFG } # [ doc = "Checks if the value of the field is `UCTXIFG`" ] # [ inline ( always ) ] pub fn is_uctxifg ( & self ) -> bool { * self == UCIV_A :: UCTXIFG } }
impl R {
# [ doc = "Bits 0:15 - eUSCI_A interrupt vector value" ] # [ inline ( always ) ] pub fn uciv ( & self ) -> UCIV_R { UCIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "eUSCI_B1" ] pub struct E_USCI_B1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for E_USCI_B1 { } impl E_USCI_B1 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const e_usci_b1 :: RegisterBlock { 0x05c0 as * const _ } } impl Deref for E_USCI_B1 { type Target = e_usci_b1 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * E_USCI_B1 :: ptr ( ) } } }
# [ doc = "eUSCI_B1" ] pub mod e_usci_b1 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved_0_ucb1ctlw : [ u8 ; 2usize ] , # [ doc = "0x02 - eUSCI_Bx Control Word Register 1" ] pub ucb1ctlw1 : UCB1CTLW1 , _reserved2 : [ u8 ; 2usize ] , _reserved_2_ucb1 : [ u8 ; 2usize ] , _reserved_3_ucb1 : [ u8 ; 2usize ] , # [ doc = "0x0a - eUSCI_Bx Byte Counter Threshold Register" ] pub ucb1tbcnt : UCB1TBCNT , _reserved_5_ucb1 : [ u8 ; 2usize ] , _reserved_6_ucb1 : [ u8 ; 2usize ] , _reserved7 : [ u8 ; 4usize ] , # [ doc = "0x14 - eUSCI_Bx I2C Own Address 0 Register" ] pub ucb1i2coa0 : UCB1I2COA0 , # [ doc = "0x16 - eUSCI_Bx I2C Own Address 1 Register" ] pub ucb1i2coa1 : UCB1I2COA1 , # [ doc = "0x18 - eUSCI_Bx I2C Own Address 2 Register" ] pub ucb1i2coa2 : UCB1I2COA2 , # [ doc = "0x1a - eUSCI_Bx I2C Own Address 3 Register" ] pub ucb1i2coa3 : UCB1I2COA3 , # [ doc = "0x1c - eUSCI_Bx I2C Received Address Register" ] pub ucb1addrx : UCB1ADDRX , # [ doc = "0x1e - eUSCI_Bx I2C Address Mask Register" ] pub ucb1addmask : UCB1ADDMASK , # [ doc = "0x20 - eUSCI_Bx I2C Slave Address Register" ] pub ucb1i2csa : UCB1I2CSA , _reserved14 : [ u8 ; 8usize ] , _reserved_14_ucb1 : [ u8 ; 2usize ] , _reserved_15_ucb1 : [ u8 ; 2usize ] , _reserved_16_ucb1 : [ u8 ; 2usize ] , } impl RegisterBlock { # [ doc = "0x00 - eUSCI_Bx Control Word Register 0" ] # [ inline ( always ) ] pub fn ucb1ctlw0_spi ( & self ) -> & UCB1CTLW0_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const UCB1CTLW0_SPI ) } } # [ doc = "0x00 - eUSCI_Bx Control Word Register 0" ] # [ inline ( always ) ] pub fn ucb1ctlw0_spi_mut ( & self ) -> & mut UCB1CTLW0_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut UCB1CTLW0_SPI ) } } # [ doc = "0x00 - eUSCI_Bx Control Word Register 0" ] # [ inline ( always ) ] pub fn ucb1ctlw0 ( & self ) -> & UCB1CTLW0 { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const UCB1CTLW0 ) } } # [ doc = "0x00 - eUSCI_Bx Control Word Register 0" ] # [ inline ( always ) ] pub fn ucb1ctlw0_mut ( & self ) -> & mut UCB1CTLW0 { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut UCB1CTLW0 ) } } # [ doc = "0x06 - eUSCI_Bx Bit Rate Control Register 1" ] # [ inline ( always ) ] pub fn ucb1brw_spi ( & self ) -> & UCB1BRW_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 6usize ) as * const UCB1BRW_SPI ) } } # [ doc = "0x06 - eUSCI_Bx Bit Rate Control Register 1" ] # [ inline ( always ) ] pub fn ucb1brw_spi_mut ( & self ) -> & mut UCB1BRW_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 6usize ) as * mut UCB1BRW_SPI ) } } # [ doc = "0x06 - eUSCI_Bx Baud Rate Control Word Register" ] # [ inline ( always ) ] pub fn ucb1brw ( & self ) -> & UCB1BRW { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 6usize ) as * const UCB1BRW ) } } # [ doc = "0x06 - eUSCI_Bx Baud Rate Control Word Register" ] # [ inline ( always ) ] pub fn ucb1brw_mut ( & self ) -> & mut UCB1BRW { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 6usize ) as * mut UCB1BRW ) } } # [ doc = "0x08 - UCB1STATW_SPI" ] # [ inline ( always ) ] pub fn ucb1statw_spi ( & self ) -> & UCB1STATW_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 8usize ) as * const UCB1STATW_SPI ) } } # [ doc = "0x08 - UCB1STATW_SPI" ] # [ inline ( always ) ] pub fn ucb1statw_spi_mut ( & self ) -> & mut UCB1STATW_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 8usize ) as * mut UCB1STATW_SPI ) } } # [ doc = "0x08 - eUSCI_Bx Status Register" ] # [ inline ( always ) ] pub fn ucb1statw ( & self ) -> & UCB1STATW { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 8usize ) as * const UCB1STATW ) } } # [ doc = "0x08 - eUSCI_Bx Status Register" ] # [ inline ( always ) ] pub fn ucb1statw_mut ( & self ) -> & mut UCB1STATW { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 8usize ) as * mut UCB1STATW ) } } # [ doc = "0x0c - eUSCI_Bx Receive Buffer Register" ] # [ inline ( always ) ] pub fn ucb1rxbuf_spi ( & self ) -> & UCB1RXBUF_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const UCB1RXBUF_SPI ) } } # [ doc = "0x0c - eUSCI_Bx Receive Buffer Register" ] # [ inline ( always ) ] pub fn ucb1rxbuf_spi_mut ( & self ) -> & mut UCB1RXBUF_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut UCB1RXBUF_SPI ) } } # [ doc = "0x0c - eUSCI_Bx Receive Buffer Register" ] # [ inline ( always ) ] pub fn ucb1rxbuf ( & self ) -> & UCB1RXBUF { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const UCB1RXBUF ) } } # [ doc = "0x0c - eUSCI_Bx Receive Buffer Register" ] # [ inline ( always ) ] pub fn ucb1rxbuf_mut ( & self ) -> & mut UCB1RXBUF { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut UCB1RXBUF ) } } # [ doc = "0x0e - eUSCI_Bx Transmit Buffer Register" ] # [ inline ( always ) ] pub fn ucb1txbuf_spi ( & self ) -> & UCB1TXBUF_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 14usize ) as * const UCB1TXBUF_SPI ) } } # [ doc = "0x0e - eUSCI_Bx Transmit Buffer Register" ] # [ inline ( always ) ] pub fn ucb1txbuf_spi_mut ( & self ) -> & mut UCB1TXBUF_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 14usize ) as * mut UCB1TXBUF_SPI ) } } # [ doc = "0x0e - eUSCI_Bx Transmit Buffer Register" ] # [ inline ( always ) ] pub fn ucb1txbuf ( & self ) -> & UCB1TXBUF { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 14usize ) as * const UCB1TXBUF ) } } # [ doc = "0x0e - eUSCI_Bx Transmit Buffer Register" ] # [ inline ( always ) ] pub fn ucb1txbuf_mut ( & self ) -> & mut UCB1TXBUF { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 14usize ) as * mut UCB1TXBUF ) } } # [ doc = "0x2a - eUSCI_Bx Interrupt Enable Register" ] # [ inline ( always ) ] pub fn ucb1ie_spi ( & self ) -> & UCB1IE_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 42usize ) as * const UCB1IE_SPI ) } } # [ doc = "0x2a - eUSCI_Bx Interrupt Enable Register" ] # [ inline ( always ) ] pub fn ucb1ie_spi_mut ( & self ) -> & mut UCB1IE_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 42usize ) as * mut UCB1IE_SPI ) } } # [ doc = "0x2a - eUSCI_Bx Interrupt Enable Register" ] # [ inline ( always ) ] pub fn ucb1ie ( & self ) -> & UCB1IE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 42usize ) as * const UCB1IE ) } } # [ doc = "0x2a - eUSCI_Bx Interrupt Enable Register" ] # [ inline ( always ) ] pub fn ucb1ie_mut ( & self ) -> & mut UCB1IE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 42usize ) as * mut UCB1IE ) } } # [ doc = "0x2c - eUSCI_Bx Interrupt Flag Register" ] # [ inline ( always ) ] pub fn ucb1ifg_spi ( & self ) -> & UCB1IFG_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 44usize ) as * const UCB1IFG_SPI ) } } # [ doc = "0x2c - eUSCI_Bx Interrupt Flag Register" ] # [ inline ( always ) ] pub fn ucb1ifg_spi_mut ( & self ) -> & mut UCB1IFG_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 44usize ) as * mut UCB1IFG_SPI ) } } # [ doc = "0x2c - eUSCI_Bx Interrupt Flag Register" ] # [ inline ( always ) ] pub fn ucb1ifg ( & self ) -> & UCB1IFG { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 44usize ) as * const UCB1IFG ) } } # [ doc = "0x2c - eUSCI_Bx Interrupt Flag Register" ] # [ inline ( always ) ] pub fn ucb1ifg_mut ( & self ) -> & mut UCB1IFG { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 44usize ) as * mut UCB1IFG ) } } # [ doc = "0x2e - eUSCI_Bx Interrupt Vector Register" ] # [ inline ( always ) ] pub fn ucb1iv_spi ( & self ) -> & UCB1IV_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 46usize ) as * const UCB1IV_SPI ) } } # [ doc = "0x2e - eUSCI_Bx Interrupt Vector Register" ] # [ inline ( always ) ] pub fn ucb1iv_spi_mut ( & self ) -> & mut UCB1IV_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 46usize ) as * mut UCB1IV_SPI ) } } # [ doc = "0x2e - eUSCI_Bx Interrupt Vector Register" ] # [ inline ( always ) ] pub fn ucb1iv ( & self ) -> & UCB1IV { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 46usize ) as * const UCB1IV ) } } # [ doc = "0x2e - eUSCI_Bx Interrupt Vector Register" ] # [ inline ( always ) ] pub fn ucb1iv_mut ( & self ) -> & mut UCB1IV { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 46usize ) as * mut UCB1IV ) } } }
# [ doc = "eUSCI_Bx Control Word Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1ctlw0](ucb1ctlw0) module" ] pub type UCB1CTLW0 = crate :: Reg < u16 , _UCB1CTLW0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1CTLW0 ;
# [ doc = "`read()` method returns [ucb1ctlw0::R](ucb1ctlw0::R) reader structure" ] impl crate :: Readable for UCB1CTLW0 { }
# [ doc = "`write(|w| ..)` method takes [ucb1ctlw0::W](ucb1ctlw0::W) writer structure" ] impl crate :: Writable for UCB1CTLW0 { }
# [ doc = "eUSCI_Bx Control Word Register 0" ] pub mod ucb1ctlw0 {
# [ doc = "Reader of register UCB1CTLW0" ] pub type R = crate :: R < u16 , super :: UCB1CTLW0 > ;
# [ doc = "Writer for register UCB1CTLW0" ] pub type W = crate :: W < u16 , super :: UCB1CTLW0 > ;
# [ doc = "Register UCB1CTLW0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1CTLW0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Software reset enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSWRST_A { # [ doc = "0: Disabled. eUSCI_B reset released for operation" ] DISABLE = 0 , # [ doc = "1: Enabled. eUSCI_B logic held in reset state" ] ENABLE = 1 } impl From < UCSWRST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSWRST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSWRST`" ] pub type UCSWRST_R = crate :: R < bool , UCSWRST_A > ; impl UCSWRST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSWRST_A { match self . bits { false => UCSWRST_A :: DISABLE , true => UCSWRST_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCSWRST_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCSWRST_A :: ENABLE } }
# [ doc = "Write proxy for field `UCSWRST`" ] pub struct UCSWRST_W < 'a > { w : & 'a mut W , } impl < 'a > UCSWRST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSWRST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled. eUSCI_B reset released for operation" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: DISABLE ) } # [ doc = "Enabled. eUSCI_B logic held in reset state" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit START condition in master mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXSTT_A { # [ doc = "0: Do not generate START condition" ] UCTXSTT_0 = 0 , # [ doc = "1: Generate START condition" ] UCTXSTT_1 = 1 } impl From < UCTXSTT_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXSTT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXSTT`" ] pub type UCTXSTT_R = crate :: R < bool , UCTXSTT_A > ; impl UCTXSTT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXSTT_A { match self . bits { false => UCTXSTT_A :: UCTXSTT_0 , true => UCTXSTT_A :: UCTXSTT_1 } } # [ doc = "Checks if the value of the field is `UCTXSTT_0`" ] # [ inline ( always ) ] pub fn is_uctxstt_0 ( & self ) -> bool { * self == UCTXSTT_A :: UCTXSTT_0 } # [ doc = "Checks if the value of the field is `UCTXSTT_1`" ] # [ inline ( always ) ] pub fn is_uctxstt_1 ( & self ) -> bool { * self == UCTXSTT_A :: UCTXSTT_1 } }
# [ doc = "Write proxy for field `UCTXSTT`" ] pub struct UCTXSTT_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXSTT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXSTT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Do not generate START condition" ] # [ inline ( always ) ] pub fn uctxstt_0 ( self ) -> & 'a mut W { self . variant ( UCTXSTT_A :: UCTXSTT_0 ) } # [ doc = "Generate START condition" ] # [ inline ( always ) ] pub fn uctxstt_1 ( self ) -> & 'a mut W { self . variant ( UCTXSTT_A :: UCTXSTT_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Transmit STOP condition in master mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXSTP_A { # [ doc = "0: No STOP generated" ] UCTXSTP_0 = 0 , # [ doc = "1: Generate STOP" ] UCTXSTP_1 = 1 } impl From < UCTXSTP_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXSTP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXSTP`" ] pub type UCTXSTP_R = crate :: R < bool , UCTXSTP_A > ; impl UCTXSTP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXSTP_A { match self . bits { false => UCTXSTP_A :: UCTXSTP_0 , true => UCTXSTP_A :: UCTXSTP_1 } } # [ doc = "Checks if the value of the field is `UCTXSTP_0`" ] # [ inline ( always ) ] pub fn is_uctxstp_0 ( & self ) -> bool { * self == UCTXSTP_A :: UCTXSTP_0 } # [ doc = "Checks if the value of the field is `UCTXSTP_1`" ] # [ inline ( always ) ] pub fn is_uctxstp_1 ( & self ) -> bool { * self == UCTXSTP_A :: UCTXSTP_1 } }
# [ doc = "Write proxy for field `UCTXSTP`" ] pub struct UCTXSTP_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXSTP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXSTP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No STOP generated" ] # [ inline ( always ) ] pub fn uctxstp_0 ( self ) -> & 'a mut W { self . variant ( UCTXSTP_A :: UCTXSTP_0 ) } # [ doc = "Generate STOP" ] # [ inline ( always ) ] pub fn uctxstp_1 ( self ) -> & 'a mut W { self . variant ( UCTXSTP_A :: UCTXSTP_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Transmit a NACK\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXNACK_A { # [ doc = "0: Acknowledge normally" ] UCTXNACK_0 = 0 , # [ doc = "1: Generate NACK" ] UCTXNACK_1 = 1 } impl From < UCTXNACK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXNACK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXNACK`" ] pub type UCTXNACK_R = crate :: R < bool , UCTXNACK_A > ; impl UCTXNACK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXNACK_A { match self . bits { false => UCTXNACK_A :: UCTXNACK_0 , true => UCTXNACK_A :: UCTXNACK_1 } } # [ doc = "Checks if the value of the field is `UCTXNACK_0`" ] # [ inline ( always ) ] pub fn is_uctxnack_0 ( & self ) -> bool { * self == UCTXNACK_A :: UCTXNACK_0 } # [ doc = "Checks if the value of the field is `UCTXNACK_1`" ] # [ inline ( always ) ] pub fn is_uctxnack_1 ( & self ) -> bool { * self == UCTXNACK_A :: UCTXNACK_1 } }
# [ doc = "Write proxy for field `UCTXNACK`" ] pub struct UCTXNACK_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXNACK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXNACK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Acknowledge normally" ] # [ inline ( always ) ] pub fn uctxnack_0 ( self ) -> & 'a mut W { self . variant ( UCTXNACK_A :: UCTXNACK_0 ) } # [ doc = "Generate NACK" ] # [ inline ( always ) ] pub fn uctxnack_1 ( self ) -> & 'a mut W { self . variant ( UCTXNACK_A :: UCTXNACK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Transmitter/receiver\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTR_A { # [ doc = "0: Receiver" ] RX = 0 , # [ doc = "1: Transmitter" ] TX = 1 } impl From < UCTR_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTR`" ] pub type UCTR_R = crate :: R < bool , UCTR_A > ; impl UCTR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTR_A { match self . bits { false => UCTR_A :: RX , true => UCTR_A :: TX } } # [ doc = "Checks if the value of the field is `RX`" ] # [ inline ( always ) ] pub fn is_rx ( & self ) -> bool { * self == UCTR_A :: RX } # [ doc = "Checks if the value of the field is `TX`" ] # [ inline ( always ) ] pub fn is_tx ( & self ) -> bool { * self == UCTR_A :: TX } }
# [ doc = "Write proxy for field `UCTR`" ] pub struct UCTR_W < 'a > { w : & 'a mut W , } impl < 'a > UCTR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Receiver" ] # [ inline ( always ) ] pub fn rx ( self ) -> & 'a mut W { self . variant ( UCTR_A :: RX ) } # [ doc = "Transmitter" ] # [ inline ( always ) ] pub fn tx ( self ) -> & 'a mut W { self . variant ( UCTR_A :: TX ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Transmit ACK condition in slave mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXACK_A { # [ doc = "0: Do not acknowledge the slave address" ] UCTXACK_0 = 0 , # [ doc = "1: Acknowledge the slave address" ] UCTXACK_1 = 1 } impl From < UCTXACK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXACK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXACK`" ] pub type UCTXACK_R = crate :: R < bool , UCTXACK_A > ; impl UCTXACK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXACK_A { match self . bits { false => UCTXACK_A :: UCTXACK_0 , true => UCTXACK_A :: UCTXACK_1 } } # [ doc = "Checks if the value of the field is `UCTXACK_0`" ] # [ inline ( always ) ] pub fn is_uctxack_0 ( & self ) -> bool { * self == UCTXACK_A :: UCTXACK_0 } # [ doc = "Checks if the value of the field is `UCTXACK_1`" ] # [ inline ( always ) ] pub fn is_uctxack_1 ( & self ) -> bool { * self == UCTXACK_A :: UCTXACK_1 } }
# [ doc = "Write proxy for field `UCTXACK`" ] pub struct UCTXACK_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXACK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXACK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Do not acknowledge the slave address" ] # [ inline ( always ) ] pub fn uctxack_0 ( self ) -> & 'a mut W { self . variant ( UCTXACK_A :: UCTXACK_0 ) } # [ doc = "Acknowledge the slave address" ] # [ inline ( always ) ] pub fn uctxack_1 ( self ) -> & 'a mut W { self . variant ( UCTXACK_A :: UCTXACK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "eUSCI_B clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCSSEL_A { # [ doc = "0: UCLKI" ] UCLKI = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: SMCLK" ] UCSSEL_3 = 3 } impl From < UCSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCSSEL`" ] pub type UCSSEL_R = crate :: R < u8 , UCSSEL_A > ; impl UCSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSSEL_A { match self . bits { 0 => UCSSEL_A :: UCLKI , 1 => UCSSEL_A :: ACLK , 2 => UCSSEL_A :: SMCLK , 3 => UCSSEL_A :: UCSSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCLKI`" ] # [ inline ( always ) ] pub fn is_uclki ( & self ) -> bool { * self == UCSSEL_A :: UCLKI } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == UCSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == UCSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `UCSSEL_3`" ] # [ inline ( always ) ] pub fn is_ucssel_3 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_3 } }
# [ doc = "Write proxy for field `UCSSEL`" ] pub struct UCSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > UCSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "UCLKI" ] # [ inline ( always ) ] pub fn uclki ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCLKI ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: SMCLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn ucssel_3 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Synchronous mode enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSYNC_A { # [ doc = "0: Asynchronous mode" ] ASYNC = 0 , # [ doc = "1: Synchronous mode" ] SYNC = 1 } impl From < UCSYNC_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSYNC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSYNC`" ] pub type UCSYNC_R = crate :: R < bool , UCSYNC_A > ; impl UCSYNC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSYNC_A { match self . bits { false => UCSYNC_A :: ASYNC , true => UCSYNC_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == UCSYNC_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == UCSYNC_A :: SYNC } }
# [ doc = "Write proxy for field `UCSYNC`" ] pub struct UCSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > UCSYNC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSYNC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous mode" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: ASYNC ) } # [ doc = "Synchronous mode" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "eUSCI_B mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCMODE_A { # [ doc = "0: 3-pin SPI" ] UCMODE_0 = 0 , # [ doc = "1: 4-pin SPI (master or slave enabled if STE = 1)" ] UCMODE_1 = 1 , # [ doc = "2: 4-pin SPI (master or slave enabled if STE = 0)" ] UCMODE_2 = 2 , # [ doc = "3: I2C mode" ] UCMODE_3 = 3 } impl From < UCMODE_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCMODE_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCMODE`" ] pub type UCMODE_R = crate :: R < u8 , UCMODE_A > ; impl UCMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMODE_A { match self . bits { 0 => UCMODE_A :: UCMODE_0 , 1 => UCMODE_A :: UCMODE_1 , 2 => UCMODE_A :: UCMODE_2 , 3 => UCMODE_A :: UCMODE_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCMODE_0`" ] # [ inline ( always ) ] pub fn is_ucmode_0 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_0 } # [ doc = "Checks if the value of the field is `UCMODE_1`" ] # [ inline ( always ) ] pub fn is_ucmode_1 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_1 } # [ doc = "Checks if the value of the field is `UCMODE_2`" ] # [ inline ( always ) ] pub fn is_ucmode_2 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_2 } # [ doc = "Checks if the value of the field is `UCMODE_3`" ] # [ inline ( always ) ] pub fn is_ucmode_3 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_3 } }
# [ doc = "Write proxy for field `UCMODE`" ] pub struct UCMODE_W < 'a > { w : & 'a mut W , } impl < 'a > UCMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMODE_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "3-pin SPI" ] # [ inline ( always ) ] pub fn ucmode_0 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_0 ) } # [ doc = "4-pin SPI (master or slave enabled if STE = 1)" ] # [ inline ( always ) ] pub fn ucmode_1 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_1 ) } # [ doc = "4-pin SPI (master or slave enabled if STE = 0)" ] # [ inline ( always ) ] pub fn ucmode_2 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_2 ) } # [ doc = "I2C mode" ] # [ inline ( always ) ] pub fn ucmode_3 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Master mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMST_A { # [ doc = "0: Slave mode" ] SLAVE = 0 , # [ doc = "1: Master mode" ] MASTER = 1 } impl From < UCMST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMST`" ] pub type UCMST_R = crate :: R < bool , UCMST_A > ; impl UCMST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMST_A { match self . bits { false => UCMST_A :: SLAVE , true => UCMST_A :: MASTER } } # [ doc = "Checks if the value of the field is `SLAVE`" ] # [ inline ( always ) ] pub fn is_slave ( & self ) -> bool { * self == UCMST_A :: SLAVE } # [ doc = "Checks if the value of the field is `MASTER`" ] # [ inline ( always ) ] pub fn is_master ( & self ) -> bool { * self == UCMST_A :: MASTER } }
# [ doc = "Write proxy for field `UCMST`" ] pub struct UCMST_W < 'a > { w : & 'a mut W , } impl < 'a > UCMST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Slave mode" ] # [ inline ( always ) ] pub fn slave ( self ) -> & 'a mut W { self . variant ( UCMST_A :: SLAVE ) } # [ doc = "Master mode" ] # [ inline ( always ) ] pub fn master ( self ) -> & 'a mut W { self . variant ( UCMST_A :: MASTER ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Multi-master environment select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMM_A { # [ doc = "0: Single master environment. There is no other master in the system. The address compare unit is disabled." ] SINGLE = 0 , # [ doc = "1: Multi-master environment" ] MULTI = 1 } impl From < UCMM_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMM`" ] pub type UCMM_R = crate :: R < bool , UCMM_A > ; impl UCMM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMM_A { match self . bits { false => UCMM_A :: SINGLE , true => UCMM_A :: MULTI } } # [ doc = "Checks if the value of the field is `SINGLE`" ] # [ inline ( always ) ] pub fn is_single ( & self ) -> bool { * self == UCMM_A :: SINGLE } # [ doc = "Checks if the value of the field is `MULTI`" ] # [ inline ( always ) ] pub fn is_multi ( & self ) -> bool { * self == UCMM_A :: MULTI } }
# [ doc = "Write proxy for field `UCMM`" ] pub struct UCMM_W < 'a > { w : & 'a mut W , } impl < 'a > UCMM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Single master environment. There is no other master in the system. The address compare unit is disabled." ] # [ inline ( always ) ] pub fn single ( self ) -> & 'a mut W { self . variant ( UCMM_A :: SINGLE ) } # [ doc = "Multi-master environment" ] # [ inline ( always ) ] pub fn multi ( self ) -> & 'a mut W { self . variant ( UCMM_A :: MULTI ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Slave addressing mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSLA10_A { # [ doc = "0: Address slave with 7-bit address" ] _7BIT = 0 , # [ doc = "1: Address slave with 10-bit address" ] _10BIT = 1 } impl From < UCSLA10_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSLA10_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSLA10`" ] pub type UCSLA10_R = crate :: R < bool , UCSLA10_A > ; impl UCSLA10_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSLA10_A { match self . bits { false => UCSLA10_A :: _7BIT , true => UCSLA10_A :: _10BIT } } # [ doc = "Checks if the value of the field is `_7BIT`" ] # [ inline ( always ) ] pub fn is_7bit ( & self ) -> bool { * self == UCSLA10_A :: _7BIT } # [ doc = "Checks if the value of the field is `_10BIT`" ] # [ inline ( always ) ] pub fn is_10bit ( & self ) -> bool { * self == UCSLA10_A :: _10BIT } }
# [ doc = "Write proxy for field `UCSLA10`" ] pub struct UCSLA10_W < 'a > { w : & 'a mut W , } impl < 'a > UCSLA10_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSLA10_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Address slave with 7-bit address" ] # [ inline ( always ) ] pub fn _7bit ( self ) -> & 'a mut W { self . variant ( UCSLA10_A :: _7BIT ) } # [ doc = "Address slave with 10-bit address" ] # [ inline ( always ) ] pub fn _10bit ( self ) -> & 'a mut W { self . variant ( UCSLA10_A :: _10BIT ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Own addressing mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCA10_A { # [ doc = "0: Own address is a 7-bit address" ] UCA10_0 = 0 , # [ doc = "1: Own address is a 10-bit address" ] UCA10_1 = 1 } impl From < UCA10_A > for bool { # [ inline ( always ) ] fn from ( variant : UCA10_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCA10`" ] pub type UCA10_R = crate :: R < bool , UCA10_A > ; impl UCA10_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCA10_A { match self . bits { false => UCA10_A :: UCA10_0 , true => UCA10_A :: UCA10_1 } } # [ doc = "Checks if the value of the field is `UCA10_0`" ] # [ inline ( always ) ] pub fn is_uca10_0 ( & self ) -> bool { * self == UCA10_A :: UCA10_0 } # [ doc = "Checks if the value of the field is `UCA10_1`" ] # [ inline ( always ) ] pub fn is_uca10_1 ( & self ) -> bool { * self == UCA10_A :: UCA10_1 } }
# [ doc = "Write proxy for field `UCA10`" ] pub struct UCA10_W < 'a > { w : & 'a mut W , } impl < 'a > UCA10_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCA10_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Own address is a 7-bit address" ] # [ inline ( always ) ] pub fn uca10_0 ( self ) -> & 'a mut W { self . variant ( UCA10_A :: UCA10_0 ) } # [ doc = "Own address is a 10-bit address" ] # [ inline ( always ) ] pub fn uca10_1 ( self ) -> & 'a mut W { self . variant ( UCA10_A :: UCA10_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & self ) -> UCSWRST_R { UCSWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit START condition in master mode" ] # [ inline ( always ) ] pub fn uctxstt ( & self ) -> UCTXSTT_R { UCTXSTT_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Transmit STOP condition in master mode" ] # [ inline ( always ) ] pub fn uctxstp ( & self ) -> UCTXSTP_R { UCTXSTP_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Transmit a NACK" ] # [ inline ( always ) ] pub fn uctxnack ( & self ) -> UCTXNACK_R { UCTXNACK_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Transmitter/receiver" ] # [ inline ( always ) ] pub fn uctr ( & self ) -> UCTR_R { UCTR_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Transmit ACK condition in slave mode" ] # [ inline ( always ) ] pub fn uctxack ( & self ) -> UCTXACK_R { UCTXACK_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - eUSCI_B clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & self ) -> UCSSEL_R { UCSSEL_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & self ) -> UCSYNC_R { UCSYNC_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - eUSCI_B mode" ] # [ inline ( always ) ] pub fn ucmode ( & self ) -> UCMODE_R { UCMODE_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & self ) -> UCMST_R { UCMST_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Multi-master environment select" ] # [ inline ( always ) ] pub fn ucmm ( & self ) -> UCMM_R { UCMM_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Slave addressing mode select" ] # [ inline ( always ) ] pub fn ucsla10 ( & self ) -> UCSLA10_R { UCSLA10_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Own addressing mode select" ] # [ inline ( always ) ] pub fn uca10 ( & self ) -> UCA10_R { UCA10_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & mut self ) -> UCSWRST_W { UCSWRST_W { w : self } }
# [ doc = "Bit 1 - Transmit START condition in master mode" ] # [ inline ( always ) ] pub fn uctxstt ( & mut self ) -> UCTXSTT_W { UCTXSTT_W { w : self } }
# [ doc = "Bit 2 - Transmit STOP condition in master mode" ] # [ inline ( always ) ] pub fn uctxstp ( & mut self ) -> UCTXSTP_W { UCTXSTP_W { w : self } }
# [ doc = "Bit 3 - Transmit a NACK" ] # [ inline ( always ) ] pub fn uctxnack ( & mut self ) -> UCTXNACK_W { UCTXNACK_W { w : self } }
# [ doc = "Bit 4 - Transmitter/receiver" ] # [ inline ( always ) ] pub fn uctr ( & mut self ) -> UCTR_W { UCTR_W { w : self } }
# [ doc = "Bit 5 - Transmit ACK condition in slave mode" ] # [ inline ( always ) ] pub fn uctxack ( & mut self ) -> UCTXACK_W { UCTXACK_W { w : self } }
# [ doc = "Bits 6:7 - eUSCI_B clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & mut self ) -> UCSSEL_W { UCSSEL_W { w : self } }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & mut self ) -> UCSYNC_W { UCSYNC_W { w : self } }
# [ doc = "Bits 9:10 - eUSCI_B mode" ] # [ inline ( always ) ] pub fn ucmode ( & mut self ) -> UCMODE_W { UCMODE_W { w : self } }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & mut self ) -> UCMST_W { UCMST_W { w : self } }
# [ doc = "Bit 13 - Multi-master environment select" ] # [ inline ( always ) ] pub fn ucmm ( & mut self ) -> UCMM_W { UCMM_W { w : self } }
# [ doc = "Bit 14 - Slave addressing mode select" ] # [ inline ( always ) ] pub fn ucsla10 ( & mut self ) -> UCSLA10_W { UCSLA10_W { w : self } }
# [ doc = "Bit 15 - Own addressing mode select" ] # [ inline ( always ) ] pub fn uca10 ( & mut self ) -> UCA10_W { UCA10_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Control Word Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1ctlw0_spi](ucb1ctlw0_spi) module" ] pub type UCB1CTLW0_SPI = crate :: Reg < u16 , _UCB1CTLW0_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1CTLW0_SPI ;
# [ doc = "`read()` method returns [ucb1ctlw0_spi::R](ucb1ctlw0_spi::R) reader structure" ] impl crate :: Readable for UCB1CTLW0_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb1ctlw0_spi::W](ucb1ctlw0_spi::W) writer structure" ] impl crate :: Writable for UCB1CTLW0_SPI { }
# [ doc = "eUSCI_Bx Control Word Register 0" ] pub mod ucb1ctlw0_spi {
# [ doc = "Reader of register UCB1CTLW0_SPI" ] pub type R = crate :: R < u16 , super :: UCB1CTLW0_SPI > ;
# [ doc = "Writer for register UCB1CTLW0_SPI" ] pub type W = crate :: W < u16 , super :: UCB1CTLW0_SPI > ;
# [ doc = "Register UCB1CTLW0_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1CTLW0_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Software reset enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSWRST_A { # [ doc = "0: Disabled. eUSCI_B reset released for operation" ] DISABLE = 0 , # [ doc = "1: Enabled. eUSCI_B logic held in reset state" ] ENABLE = 1 } impl From < UCSWRST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSWRST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSWRST`" ] pub type UCSWRST_R = crate :: R < bool , UCSWRST_A > ; impl UCSWRST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSWRST_A { match self . bits { false => UCSWRST_A :: DISABLE , true => UCSWRST_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCSWRST_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCSWRST_A :: ENABLE } }
# [ doc = "Write proxy for field `UCSWRST`" ] pub struct UCSWRST_W < 'a > { w : & 'a mut W , } impl < 'a > UCSWRST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSWRST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled. eUSCI_B reset released for operation" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: DISABLE ) } # [ doc = "Enabled. eUSCI_B logic held in reset state" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "STE mode select in master mode.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTEM_A { # [ doc = "0: STE pin is used to prevent conflicts with other masters" ] UCSTEM_0 = 0 , # [ doc = "1: STE pin is used to generate the enable signal for a 4-wire slave" ] UCSTEM_1 = 1 } impl From < UCSTEM_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTEM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTEM`" ] pub type UCSTEM_R = crate :: R < bool , UCSTEM_A > ; impl UCSTEM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTEM_A { match self . bits { false => UCSTEM_A :: UCSTEM_0 , true => UCSTEM_A :: UCSTEM_1 } } # [ doc = "Checks if the value of the field is `UCSTEM_0`" ] # [ inline ( always ) ] pub fn is_ucstem_0 ( & self ) -> bool { * self == UCSTEM_A :: UCSTEM_0 } # [ doc = "Checks if the value of the field is `UCSTEM_1`" ] # [ inline ( always ) ] pub fn is_ucstem_1 ( & self ) -> bool { * self == UCSTEM_A :: UCSTEM_1 } }
# [ doc = "Write proxy for field `UCSTEM`" ] pub struct UCSTEM_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTEM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTEM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "STE pin is used to prevent conflicts with other masters" ] # [ inline ( always ) ] pub fn ucstem_0 ( self ) -> & 'a mut W { self . variant ( UCSTEM_A :: UCSTEM_0 ) } # [ doc = "STE pin is used to generate the enable signal for a 4-wire slave" ] # [ inline ( always ) ] pub fn ucstem_1 ( self ) -> & 'a mut W { self . variant ( UCSTEM_A :: UCSTEM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "eUSCI_B clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCSSEL_A { # [ doc = "0: Reserved" ] UCSSEL_0 = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: SMCLK" ] UCSSEL_3 = 3 } impl From < UCSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCSSEL`" ] pub type UCSSEL_R = crate :: R < u8 , UCSSEL_A > ; impl UCSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSSEL_A { match self . bits { 0 => UCSSEL_A :: UCSSEL_0 , 1 => UCSSEL_A :: ACLK , 2 => UCSSEL_A :: SMCLK , 3 => UCSSEL_A :: UCSSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCSSEL_0`" ] # [ inline ( always ) ] pub fn is_ucssel_0 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_0 } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == UCSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == UCSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `UCSSEL_3`" ] # [ inline ( always ) ] pub fn is_ucssel_3 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_3 } }
# [ doc = "Write proxy for field `UCSSEL`" ] pub struct UCSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > UCSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn ucssel_0 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_0 ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: SMCLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn ucssel_3 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Synchronous mode enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSYNC_A { # [ doc = "0: Asynchronous mode" ] ASYNC = 0 , # [ doc = "1: Synchronous mode" ] SYNC = 1 } impl From < UCSYNC_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSYNC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSYNC`" ] pub type UCSYNC_R = crate :: R < bool , UCSYNC_A > ; impl UCSYNC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSYNC_A { match self . bits { false => UCSYNC_A :: ASYNC , true => UCSYNC_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == UCSYNC_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == UCSYNC_A :: SYNC } }
# [ doc = "Write proxy for field `UCSYNC`" ] pub struct UCSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > UCSYNC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSYNC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous mode" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: ASYNC ) } # [ doc = "Synchronous mode" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "eUSCI mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCMODE_A { # [ doc = "0: 3-pin SPI" ] UCMODE_0 = 0 , # [ doc = "1: 4-pin SPI with UCxSTE active high: Slave enabled when UCxSTE = 1" ] UCMODE_1 = 1 , # [ doc = "2: 4-pin SPI with UCxSTE active low: Slave enabled when UCxSTE = 0" ] UCMODE_2 = 2 , # [ doc = "3: I2C mode" ] UCMODE_3 = 3 } impl From < UCMODE_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCMODE_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCMODE`" ] pub type UCMODE_R = crate :: R < u8 , UCMODE_A > ; impl UCMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMODE_A { match self . bits { 0 => UCMODE_A :: UCMODE_0 , 1 => UCMODE_A :: UCMODE_1 , 2 => UCMODE_A :: UCMODE_2 , 3 => UCMODE_A :: UCMODE_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCMODE_0`" ] # [ inline ( always ) ] pub fn is_ucmode_0 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_0 } # [ doc = "Checks if the value of the field is `UCMODE_1`" ] # [ inline ( always ) ] pub fn is_ucmode_1 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_1 } # [ doc = "Checks if the value of the field is `UCMODE_2`" ] # [ inline ( always ) ] pub fn is_ucmode_2 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_2 } # [ doc = "Checks if the value of the field is `UCMODE_3`" ] # [ inline ( always ) ] pub fn is_ucmode_3 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_3 } }
# [ doc = "Write proxy for field `UCMODE`" ] pub struct UCMODE_W < 'a > { w : & 'a mut W , } impl < 'a > UCMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMODE_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "3-pin SPI" ] # [ inline ( always ) ] pub fn ucmode_0 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_0 ) } # [ doc = "4-pin SPI with UCxSTE active high: Slave enabled when UCxSTE = 1" ] # [ inline ( always ) ] pub fn ucmode_1 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_1 ) } # [ doc = "4-pin SPI with UCxSTE active low: Slave enabled when UCxSTE = 0" ] # [ inline ( always ) ] pub fn ucmode_2 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_2 ) } # [ doc = "I2C mode" ] # [ inline ( always ) ] pub fn ucmode_3 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Master mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMST_A { # [ doc = "0: Slave mode" ] SLAVE = 0 , # [ doc = "1: Master mode" ] MASTER = 1 } impl From < UCMST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMST`" ] pub type UCMST_R = crate :: R < bool , UCMST_A > ; impl UCMST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMST_A { match self . bits { false => UCMST_A :: SLAVE , true => UCMST_A :: MASTER } } # [ doc = "Checks if the value of the field is `SLAVE`" ] # [ inline ( always ) ] pub fn is_slave ( & self ) -> bool { * self == UCMST_A :: SLAVE } # [ doc = "Checks if the value of the field is `MASTER`" ] # [ inline ( always ) ] pub fn is_master ( & self ) -> bool { * self == UCMST_A :: MASTER } }
# [ doc = "Write proxy for field `UCMST`" ] pub struct UCMST_W < 'a > { w : & 'a mut W , } impl < 'a > UCMST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Slave mode" ] # [ inline ( always ) ] pub fn slave ( self ) -> & 'a mut W { self . variant ( UCMST_A :: SLAVE ) } # [ doc = "Master mode" ] # [ inline ( always ) ] pub fn master ( self ) -> & 'a mut W { self . variant ( UCMST_A :: MASTER ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Character length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UC7BIT_A { # [ doc = "0: 8-bit data" ] _8BIT = 0 , # [ doc = "1: 7-bit data" ] _7BIT = 1 } impl From < UC7BIT_A > for bool { # [ inline ( always ) ] fn from ( variant : UC7BIT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UC7BIT`" ] pub type UC7BIT_R = crate :: R < bool , UC7BIT_A > ; impl UC7BIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UC7BIT_A { match self . bits { false => UC7BIT_A :: _8BIT , true => UC7BIT_A :: _7BIT } } # [ doc = "Checks if the value of the field is `_8BIT`" ] # [ inline ( always ) ] pub fn is_8bit ( & self ) -> bool { * self == UC7BIT_A :: _8BIT } # [ doc = "Checks if the value of the field is `_7BIT`" ] # [ inline ( always ) ] pub fn is_7bit ( & self ) -> bool { * self == UC7BIT_A :: _7BIT } }
# [ doc = "Write proxy for field `UC7BIT`" ] pub struct UC7BIT_W < 'a > { w : & 'a mut W , } impl < 'a > UC7BIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UC7BIT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "8-bit data" ] # [ inline ( always ) ] pub fn _8bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _8BIT ) } # [ doc = "7-bit data" ] # [ inline ( always ) ] pub fn _7bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _7BIT ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "MSB first select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMSB_A { # [ doc = "0: LSB first" ] UCMSB_0 = 0 , # [ doc = "1: MSB first" ] UCMSB_1 = 1 } impl From < UCMSB_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMSB_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMSB`" ] pub type UCMSB_R = crate :: R < bool , UCMSB_A > ; impl UCMSB_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMSB_A { match self . bits { false => UCMSB_A :: UCMSB_0 , true => UCMSB_A :: UCMSB_1 } } # [ doc = "Checks if the value of the field is `UCMSB_0`" ] # [ inline ( always ) ] pub fn is_ucmsb_0 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_0 } # [ doc = "Checks if the value of the field is `UCMSB_1`" ] # [ inline ( always ) ] pub fn is_ucmsb_1 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_1 } }
# [ doc = "Write proxy for field `UCMSB`" ] pub struct UCMSB_W < 'a > { w : & 'a mut W , } impl < 'a > UCMSB_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMSB_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "LSB first" ] # [ inline ( always ) ] pub fn ucmsb_0 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_0 ) } # [ doc = "MSB first" ] # [ inline ( always ) ] pub fn ucmsb_1 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Clock polarity select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCKPL_A { # [ doc = "0: The inactive state is low" ] LOW = 0 , # [ doc = "1: The inactive state is high" ] HIGH = 1 } impl From < UCCKPL_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCKPL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCKPL`" ] pub type UCCKPL_R = crate :: R < bool , UCCKPL_A > ; impl UCCKPL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCKPL_A { match self . bits { false => UCCKPL_A :: LOW , true => UCCKPL_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == UCCKPL_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == UCCKPL_A :: HIGH } }
# [ doc = "Write proxy for field `UCCKPL`" ] pub struct UCCKPL_W < 'a > { w : & 'a mut W , } impl < 'a > UCCKPL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCKPL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The inactive state is low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( UCCKPL_A :: LOW ) } # [ doc = "The inactive state is high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( UCCKPL_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Clock phase select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCKPH_A { # [ doc = "0: Data is changed on the first UCLK edge and captured on the following edge." ] UCCKPH_0 = 0 , # [ doc = "1: Data is captured on the first UCLK edge and changed on the following edge." ] UCCKPH_1 = 1 } impl From < UCCKPH_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCKPH_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCKPH`" ] pub type UCCKPH_R = crate :: R < bool , UCCKPH_A > ; impl UCCKPH_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCKPH_A { match self . bits { false => UCCKPH_A :: UCCKPH_0 , true => UCCKPH_A :: UCCKPH_1 } } # [ doc = "Checks if the value of the field is `UCCKPH_0`" ] # [ inline ( always ) ] pub fn is_ucckph_0 ( & self ) -> bool { * self == UCCKPH_A :: UCCKPH_0 } # [ doc = "Checks if the value of the field is `UCCKPH_1`" ] # [ inline ( always ) ] pub fn is_ucckph_1 ( & self ) -> bool { * self == UCCKPH_A :: UCCKPH_1 } }
# [ doc = "Write proxy for field `UCCKPH`" ] pub struct UCCKPH_W < 'a > { w : & 'a mut W , } impl < 'a > UCCKPH_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCKPH_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Data is changed on the first UCLK edge and captured on the following edge." ] # [ inline ( always ) ] pub fn ucckph_0 ( self ) -> & 'a mut W { self . variant ( UCCKPH_A :: UCCKPH_0 ) } # [ doc = "Data is captured on the first UCLK edge and changed on the following edge." ] # [ inline ( always ) ] pub fn ucckph_1 ( self ) -> & 'a mut W { self . variant ( UCCKPH_A :: UCCKPH_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & self ) -> UCSWRST_R { UCSWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - STE mode select in master mode." ] # [ inline ( always ) ] pub fn ucstem ( & self ) -> UCSTEM_R { UCSTEM_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - eUSCI_B clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & self ) -> UCSSEL_R { UCSSEL_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & self ) -> UCSYNC_R { UCSYNC_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - eUSCI mode" ] # [ inline ( always ) ] pub fn ucmode ( & self ) -> UCMODE_R { UCMODE_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & self ) -> UCMST_R { UCMST_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & self ) -> UC7BIT_R { UC7BIT_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & self ) -> UCMSB_R { UCMSB_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Clock polarity select" ] # [ inline ( always ) ] pub fn ucckpl ( & self ) -> UCCKPL_R { UCCKPL_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Clock phase select" ] # [ inline ( always ) ] pub fn ucckph ( & self ) -> UCCKPH_R { UCCKPH_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & mut self ) -> UCSWRST_W { UCSWRST_W { w : self } }
# [ doc = "Bit 1 - STE mode select in master mode." ] # [ inline ( always ) ] pub fn ucstem ( & mut self ) -> UCSTEM_W { UCSTEM_W { w : self } }
# [ doc = "Bits 6:7 - eUSCI_B clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & mut self ) -> UCSSEL_W { UCSSEL_W { w : self } }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & mut self ) -> UCSYNC_W { UCSYNC_W { w : self } }
# [ doc = "Bits 9:10 - eUSCI mode" ] # [ inline ( always ) ] pub fn ucmode ( & mut self ) -> UCMODE_W { UCMODE_W { w : self } }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & mut self ) -> UCMST_W { UCMST_W { w : self } }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & mut self ) -> UC7BIT_W { UC7BIT_W { w : self } }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & mut self ) -> UCMSB_W { UCMSB_W { w : self } }
# [ doc = "Bit 14 - Clock polarity select" ] # [ inline ( always ) ] pub fn ucckpl ( & mut self ) -> UCCKPL_W { UCCKPL_W { w : self } }
# [ doc = "Bit 15 - Clock phase select" ] # [ inline ( always ) ] pub fn ucckph ( & mut self ) -> UCCKPH_W { UCCKPH_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Control Word Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1ctlw1](ucb1ctlw1) module" ] pub type UCB1CTLW1 = crate :: Reg < u16 , _UCB1CTLW1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1CTLW1 ;
# [ doc = "`read()` method returns [ucb1ctlw1::R](ucb1ctlw1::R) reader structure" ] impl crate :: Readable for UCB1CTLW1 { }
# [ doc = "`write(|w| ..)` method takes [ucb1ctlw1::W](ucb1ctlw1::W) writer structure" ] impl crate :: Writable for UCB1CTLW1 { }
# [ doc = "eUSCI_Bx Control Word Register 1" ] pub mod ucb1ctlw1 {
# [ doc = "Reader of register UCB1CTLW1" ] pub type R = crate :: R < u16 , super :: UCB1CTLW1 > ;
# [ doc = "Writer for register UCB1CTLW1" ] pub type W = crate :: W < u16 , super :: UCB1CTLW1 > ;
# [ doc = "Register UCB1CTLW1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1CTLW1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Deglitch time\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCGLIT_A { # [ doc = "0: 50 ns" ] UCGLIT_0 = 0 , # [ doc = "1: 25 ns" ] UCGLIT_1 = 1 , # [ doc = "2: 12.5 ns" ] UCGLIT_2 = 2 , # [ doc = "3: 6.25 ns" ] UCGLIT_3 = 3 } impl From < UCGLIT_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCGLIT_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCGLIT`" ] pub type UCGLIT_R = crate :: R < u8 , UCGLIT_A > ; impl UCGLIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCGLIT_A { match self . bits { 0 => UCGLIT_A :: UCGLIT_0 , 1 => UCGLIT_A :: UCGLIT_1 , 2 => UCGLIT_A :: UCGLIT_2 , 3 => UCGLIT_A :: UCGLIT_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCGLIT_0`" ] # [ inline ( always ) ] pub fn is_ucglit_0 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_0 } # [ doc = "Checks if the value of the field is `UCGLIT_1`" ] # [ inline ( always ) ] pub fn is_ucglit_1 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_1 } # [ doc = "Checks if the value of the field is `UCGLIT_2`" ] # [ inline ( always ) ] pub fn is_ucglit_2 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_2 } # [ doc = "Checks if the value of the field is `UCGLIT_3`" ] # [ inline ( always ) ] pub fn is_ucglit_3 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_3 } }
# [ doc = "Write proxy for field `UCGLIT`" ] pub struct UCGLIT_W < 'a > { w : & 'a mut W , } impl < 'a > UCGLIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCGLIT_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "50 ns" ] # [ inline ( always ) ] pub fn ucglit_0 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_0 ) } # [ doc = "25 ns" ] # [ inline ( always ) ] pub fn ucglit_1 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_1 ) } # [ doc = "12.5 ns" ] # [ inline ( always ) ] pub fn ucglit_2 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_2 ) } # [ doc = "6.25 ns" ] # [ inline ( always ) ] pub fn ucglit_3 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Automatic STOP condition generation\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCASTP_A { # [ doc = "0: No automatic STOP generation. The STOP condition is generated after the user sets the UCTXSTP bit. The value in UCBxTBCNT is a don't care." ] UCASTP_0 = 0 , # [ doc = "1: UCBCNTIFG is set with the byte counter reaches the threshold defined in UCBxTBCNT" ] UCASTP_1 = 1 , # [ doc = "2: A STOP condition is generated automatically after the byte counter value reached UCBxTBCNT. UCBCNTIFG is set with the byte counter reaching the threshold" ] UCASTP_2 = 2 , # [ doc = "3: Reserved" ] UCASTP_3 = 3 } impl From < UCASTP_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCASTP_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCASTP`" ] pub type UCASTP_R = crate :: R < u8 , UCASTP_A > ; impl UCASTP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCASTP_A { match self . bits { 0 => UCASTP_A :: UCASTP_0 , 1 => UCASTP_A :: UCASTP_1 , 2 => UCASTP_A :: UCASTP_2 , 3 => UCASTP_A :: UCASTP_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCASTP_0`" ] # [ inline ( always ) ] pub fn is_ucastp_0 ( & self ) -> bool { * self == UCASTP_A :: UCASTP_0 } # [ doc = "Checks if the value of the field is `UCASTP_1`" ] # [ inline ( always ) ] pub fn is_ucastp_1 ( & self ) -> bool { * self == UCASTP_A :: UCASTP_1 } # [ doc = "Checks if the value of the field is `UCASTP_2`" ] # [ inline ( always ) ] pub fn is_ucastp_2 ( & self ) -> bool { * self == UCASTP_A :: UCASTP_2 } # [ doc = "Checks if the value of the field is `UCASTP_3`" ] # [ inline ( always ) ] pub fn is_ucastp_3 ( & self ) -> bool { * self == UCASTP_A :: UCASTP_3 } }
# [ doc = "Write proxy for field `UCASTP`" ] pub struct UCASTP_W < 'a > { w : & 'a mut W , } impl < 'a > UCASTP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCASTP_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No automatic STOP generation. The STOP condition is generated after the user sets the UCTXSTP bit. The value in UCBxTBCNT is a don't care." ] # [ inline ( always ) ] pub fn ucastp_0 ( self ) -> & 'a mut W { self . variant ( UCASTP_A :: UCASTP_0 ) } # [ doc = "UCBCNTIFG is set with the byte counter reaches the threshold defined in UCBxTBCNT" ] # [ inline ( always ) ] pub fn ucastp_1 ( self ) -> & 'a mut W { self . variant ( UCASTP_A :: UCASTP_1 ) } # [ doc = "A STOP condition is generated automatically after the byte counter value reached UCBxTBCNT. UCBCNTIFG is set with the byte counter reaching the threshold" ] # [ inline ( always ) ] pub fn ucastp_2 ( self ) -> & 'a mut W { self . variant ( UCASTP_A :: UCASTP_2 ) } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn ucastp_3 ( self ) -> & 'a mut W { self . variant ( UCASTP_A :: UCASTP_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u16 ) & 0x03 ) << 2 ) ; self . w } }
# [ doc = "SW or HW ACK control\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSWACK_A { # [ doc = "0: The address acknowledge of the slave is controlled by the eUSCI_B module" ] UCSWACK_0 = 0 , # [ doc = "1: The user needs to trigger the sending of the address ACK by issuing UCTXACK" ] UCSWACK_1 = 1 } impl From < UCSWACK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSWACK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSWACK`" ] pub type UCSWACK_R = crate :: R < bool , UCSWACK_A > ; impl UCSWACK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSWACK_A { match self . bits { false => UCSWACK_A :: UCSWACK_0 , true => UCSWACK_A :: UCSWACK_1 } } # [ doc = "Checks if the value of the field is `UCSWACK_0`" ] # [ inline ( always ) ] pub fn is_ucswack_0 ( & self ) -> bool { * self == UCSWACK_A :: UCSWACK_0 } # [ doc = "Checks if the value of the field is `UCSWACK_1`" ] # [ inline ( always ) ] pub fn is_ucswack_1 ( & self ) -> bool { * self == UCSWACK_A :: UCSWACK_1 } }
# [ doc = "Write proxy for field `UCSWACK`" ] pub struct UCSWACK_W < 'a > { w : & 'a mut W , } impl < 'a > UCSWACK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSWACK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The address acknowledge of the slave is controlled by the eUSCI_B module" ] # [ inline ( always ) ] pub fn ucswack_0 ( self ) -> & 'a mut W { self . variant ( UCSWACK_A :: UCSWACK_0 ) } # [ doc = "The user needs to trigger the sending of the address ACK by issuing UCTXACK" ] # [ inline ( always ) ] pub fn ucswack_1 ( self ) -> & 'a mut W { self . variant ( UCSWACK_A :: UCSWACK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "ACK all master bytes\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTPNACK_A { # [ doc = "0: Send a non-acknowledge before the STOP condition as a master receiver (conform to I2C standard)" ] UCSTPNACK_0 = 0 , # [ doc = "1: All bytes are acknowledged by the eUSCI_B when configured as master receiver" ] UCSTPNACK_1 = 1 } impl From < UCSTPNACK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTPNACK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTPNACK`" ] pub type UCSTPNACK_R = crate :: R < bool , UCSTPNACK_A > ; impl UCSTPNACK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTPNACK_A { match self . bits { false => UCSTPNACK_A :: UCSTPNACK_0 , true => UCSTPNACK_A :: UCSTPNACK_1 } } # [ doc = "Checks if the value of the field is `UCSTPNACK_0`" ] # [ inline ( always ) ] pub fn is_ucstpnack_0 ( & self ) -> bool { * self == UCSTPNACK_A :: UCSTPNACK_0 } # [ doc = "Checks if the value of the field is `UCSTPNACK_1`" ] # [ inline ( always ) ] pub fn is_ucstpnack_1 ( & self ) -> bool { * self == UCSTPNACK_A :: UCSTPNACK_1 } }
# [ doc = "Write proxy for field `UCSTPNACK`" ] pub struct UCSTPNACK_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTPNACK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTPNACK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Send a non-acknowledge before the STOP condition as a master receiver (conform to I2C standard)" ] # [ inline ( always ) ] pub fn ucstpnack_0 ( self ) -> & 'a mut W { self . variant ( UCSTPNACK_A :: UCSTPNACK_0 ) } # [ doc = "All bytes are acknowledged by the eUSCI_B when configured as master receiver" ] # [ inline ( always ) ] pub fn ucstpnack_1 ( self ) -> & 'a mut W { self . variant ( UCSTPNACK_A :: UCSTPNACK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Clock low timeout select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCCLTO_A { # [ doc = "0: Disable clock low timeout counter" ] UCCLTO_0 = 0 , # [ doc = "1: 135 000 SYSCLK cycles (approximately 28 ms)" ] UCCLTO_1 = 1 , # [ doc = "2: 150 000 SYSCLK cycles (approximately 31 ms)" ] UCCLTO_2 = 2 , # [ doc = "3: 165 000 SYSCLK cycles (approximately 34 ms)" ] UCCLTO_3 = 3 } impl From < UCCLTO_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCCLTO_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCCLTO`" ] pub type UCCLTO_R = crate :: R < u8 , UCCLTO_A > ; impl UCCLTO_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCLTO_A { match self . bits { 0 => UCCLTO_A :: UCCLTO_0 , 1 => UCCLTO_A :: UCCLTO_1 , 2 => UCCLTO_A :: UCCLTO_2 , 3 => UCCLTO_A :: UCCLTO_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCCLTO_0`" ] # [ inline ( always ) ] pub fn is_ucclto_0 ( & self ) -> bool { * self == UCCLTO_A :: UCCLTO_0 } # [ doc = "Checks if the value of the field is `UCCLTO_1`" ] # [ inline ( always ) ] pub fn is_ucclto_1 ( & self ) -> bool { * self == UCCLTO_A :: UCCLTO_1 } # [ doc = "Checks if the value of the field is `UCCLTO_2`" ] # [ inline ( always ) ] pub fn is_ucclto_2 ( & self ) -> bool { * self == UCCLTO_A :: UCCLTO_2 } # [ doc = "Checks if the value of the field is `UCCLTO_3`" ] # [ inline ( always ) ] pub fn is_ucclto_3 ( & self ) -> bool { * self == UCCLTO_A :: UCCLTO_3 } }
# [ doc = "Write proxy for field `UCCLTO`" ] pub struct UCCLTO_W < 'a > { w : & 'a mut W , } impl < 'a > UCCLTO_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCLTO_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Disable clock low timeout counter" ] # [ inline ( always ) ] pub fn ucclto_0 ( self ) -> & 'a mut W { self . variant ( UCCLTO_A :: UCCLTO_0 ) } # [ doc = "135 000 SYSCLK cycles (approximately 28 ms)" ] # [ inline ( always ) ] pub fn ucclto_1 ( self ) -> & 'a mut W { self . variant ( UCCLTO_A :: UCCLTO_1 ) } # [ doc = "150 000 SYSCLK cycles (approximately 31 ms)" ] # [ inline ( always ) ] pub fn ucclto_2 ( self ) -> & 'a mut W { self . variant ( UCCLTO_A :: UCCLTO_2 ) } # [ doc = "165 000 SYSCLK cycles (approximately 34 ms)" ] # [ inline ( always ) ] pub fn ucclto_3 ( self ) -> & 'a mut W { self . variant ( UCCLTO_A :: UCCLTO_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Early UCTXIFG0\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCETXINT_A { # [ doc = "0: UCTXIFGx is set after an address match with UCxI2COAx and the direction bit indicating slave transmit" ] UCETXINT_0 = 0 , # [ doc = "1: UCTXIFG0 is set for each START condition" ] UCETXINT_1 = 1 } impl From < UCETXINT_A > for bool { # [ inline ( always ) ] fn from ( variant : UCETXINT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCETXINT`" ] pub type UCETXINT_R = crate :: R < bool , UCETXINT_A > ; impl UCETXINT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCETXINT_A { match self . bits { false => UCETXINT_A :: UCETXINT_0 , true => UCETXINT_A :: UCETXINT_1 } } # [ doc = "Checks if the value of the field is `UCETXINT_0`" ] # [ inline ( always ) ] pub fn is_ucetxint_0 ( & self ) -> bool { * self == UCETXINT_A :: UCETXINT_0 } # [ doc = "Checks if the value of the field is `UCETXINT_1`" ] # [ inline ( always ) ] pub fn is_ucetxint_1 ( & self ) -> bool { * self == UCETXINT_A :: UCETXINT_1 } }
# [ doc = "Write proxy for field `UCETXINT`" ] pub struct UCETXINT_W < 'a > { w : & 'a mut W , } impl < 'a > UCETXINT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCETXINT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "UCTXIFGx is set after an address match with UCxI2COAx and the direction bit indicating slave transmit" ] # [ inline ( always ) ] pub fn ucetxint_0 ( self ) -> & 'a mut W { self . variant ( UCETXINT_A :: UCETXINT_0 ) } # [ doc = "UCTXIFG0 is set for each START condition" ] # [ inline ( always ) ] pub fn ucetxint_1 ( self ) -> & 'a mut W { self . variant ( UCETXINT_A :: UCETXINT_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Deglitch time" ] # [ inline ( always ) ] pub fn ucglit ( & self ) -> UCGLIT_R { UCGLIT_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 2:3 - Automatic STOP condition generation" ] # [ inline ( always ) ] pub fn ucastp ( & self ) -> UCASTP_R { UCASTP_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 4 - SW or HW ACK control" ] # [ inline ( always ) ] pub fn ucswack ( & self ) -> UCSWACK_R { UCSWACK_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - ACK all master bytes" ] # [ inline ( always ) ] pub fn ucstpnack ( & self ) -> UCSTPNACK_R { UCSTPNACK_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - Clock low timeout select" ] # [ inline ( always ) ] pub fn ucclto ( & self ) -> UCCLTO_R { UCCLTO_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Early UCTXIFG0" ] # [ inline ( always ) ] pub fn ucetxint ( & self ) -> UCETXINT_R { UCETXINT_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:1 - Deglitch time" ] # [ inline ( always ) ] pub fn ucglit ( & mut self ) -> UCGLIT_W { UCGLIT_W { w : self } }
# [ doc = "Bits 2:3 - Automatic STOP condition generation" ] # [ inline ( always ) ] pub fn ucastp ( & mut self ) -> UCASTP_W { UCASTP_W { w : self } }
# [ doc = "Bit 4 - SW or HW ACK control" ] # [ inline ( always ) ] pub fn ucswack ( & mut self ) -> UCSWACK_W { UCSWACK_W { w : self } }
# [ doc = "Bit 5 - ACK all master bytes" ] # [ inline ( always ) ] pub fn ucstpnack ( & mut self ) -> UCSTPNACK_W { UCSTPNACK_W { w : self } }
# [ doc = "Bits 6:7 - Clock low timeout select" ] # [ inline ( always ) ] pub fn ucclto ( & mut self ) -> UCCLTO_W { UCCLTO_W { w : self } }
# [ doc = "Bit 8 - Early UCTXIFG0" ] # [ inline ( always ) ] pub fn ucetxint ( & mut self ) -> UCETXINT_W { UCETXINT_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Baud Rate Control Word Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1brw](ucb1brw) module" ] pub type UCB1BRW = crate :: Reg < u16 , _UCB1BRW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1BRW ;
# [ doc = "`read()` method returns [ucb1brw::R](ucb1brw::R) reader structure" ] impl crate :: Readable for UCB1BRW { }
# [ doc = "`write(|w| ..)` method takes [ucb1brw::W](ucb1brw::W) writer structure" ] impl crate :: Writable for UCB1BRW { }
# [ doc = "eUSCI_Bx Baud Rate Control Word Register" ] pub mod ucb1brw {
# [ doc = "Reader of register UCB1BRW" ] pub type R = crate :: R < u16 , super :: UCB1BRW > ;
# [ doc = "Writer for register UCB1BRW" ] pub type W = crate :: W < u16 , super :: UCB1BRW > ;
# [ doc = "Register UCB1BRW `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1BRW { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "eUSCI_Bx Bit Rate Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1brw_spi](ucb1brw_spi) module" ] pub type UCB1BRW_SPI = crate :: Reg < u16 , _UCB1BRW_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1BRW_SPI ;
# [ doc = "`read()` method returns [ucb1brw_spi::R](ucb1brw_spi::R) reader structure" ] impl crate :: Readable for UCB1BRW_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb1brw_spi::W](ucb1brw_spi::W) writer structure" ] impl crate :: Writable for UCB1BRW_SPI { }
# [ doc = "eUSCI_Bx Bit Rate Control Register 1" ] pub mod ucb1brw_spi {
# [ doc = "Reader of register UCB1BRW_SPI" ] pub type R = crate :: R < u16 , super :: UCB1BRW_SPI > ;
# [ doc = "Writer for register UCB1BRW_SPI" ] pub type W = crate :: W < u16 , super :: UCB1BRW_SPI > ;
# [ doc = "Register UCB1BRW_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1BRW_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "eUSCI_Bx Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1statw](ucb1statw) module" ] pub type UCB1STATW = crate :: Reg < u16 , _UCB1STATW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1STATW ;
# [ doc = "`read()` method returns [ucb1statw::R](ucb1statw::R) reader structure" ] impl crate :: Readable for UCB1STATW { }
# [ doc = "eUSCI_Bx Status Register" ] pub mod ucb1statw {
# [ doc = "Reader of register UCB1STATW" ] pub type R = crate :: R < u16 , super :: UCB1STATW > ;
# [ doc = "Bus busy\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBBUSY_A { # [ doc = "0: Bus inactive" ] IDLE = 0 , # [ doc = "1: Bus busy" ] BUSY = 1 } impl From < UCBBUSY_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBBUSY_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBBUSY`" ] pub type UCBBUSY_R = crate :: R < bool , UCBBUSY_A > ; impl UCBBUSY_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBBUSY_A { match self . bits { false => UCBBUSY_A :: IDLE , true => UCBBUSY_A :: BUSY } } # [ doc = "Checks if the value of the field is `IDLE`" ] # [ inline ( always ) ] pub fn is_idle ( & self ) -> bool { * self == UCBBUSY_A :: IDLE } # [ doc = "Checks if the value of the field is `BUSY`" ] # [ inline ( always ) ] pub fn is_busy ( & self ) -> bool { * self == UCBBUSY_A :: BUSY } }
# [ doc = "General call address received\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCGC_A { # [ doc = "0: No general call address received" ] UCGC_0 = 0 , # [ doc = "1: General call address received" ] UCGC_1 = 1 } impl From < UCGC_A > for bool { # [ inline ( always ) ] fn from ( variant : UCGC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCGC`" ] pub type UCGC_R = crate :: R < bool , UCGC_A > ; impl UCGC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCGC_A { match self . bits { false => UCGC_A :: UCGC_0 , true => UCGC_A :: UCGC_1 } } # [ doc = "Checks if the value of the field is `UCGC_0`" ] # [ inline ( always ) ] pub fn is_ucgc_0 ( & self ) -> bool { * self == UCGC_A :: UCGC_0 } # [ doc = "Checks if the value of the field is `UCGC_1`" ] # [ inline ( always ) ] pub fn is_ucgc_1 ( & self ) -> bool { * self == UCGC_A :: UCGC_1 } }
# [ doc = "SCL low\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSCLLOW_A { # [ doc = "0: SCL is not held low" ] UCSCLLOW_0 = 0 , # [ doc = "1: SCL is held low" ] UCSCLLOW_1 = 1 } impl From < UCSCLLOW_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSCLLOW_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSCLLOW`" ] pub type UCSCLLOW_R = crate :: R < bool , UCSCLLOW_A > ; impl UCSCLLOW_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSCLLOW_A { match self . bits { false => UCSCLLOW_A :: UCSCLLOW_0 , true => UCSCLLOW_A :: UCSCLLOW_1 } } # [ doc = "Checks if the value of the field is `UCSCLLOW_0`" ] # [ inline ( always ) ] pub fn is_ucscllow_0 ( & self ) -> bool { * self == UCSCLLOW_A :: UCSCLLOW_0 } # [ doc = "Checks if the value of the field is `UCSCLLOW_1`" ] # [ inline ( always ) ] pub fn is_ucscllow_1 ( & self ) -> bool { * self == UCSCLLOW_A :: UCSCLLOW_1 } }
# [ doc = "Reader of field `UCBCNT`" ] pub type UCBCNT_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bit 4 - Bus busy" ] # [ inline ( always ) ] pub fn ucbbusy ( & self ) -> UCBBUSY_R { UCBBUSY_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - General call address received" ] # [ inline ( always ) ] pub fn ucgc ( & self ) -> UCGC_R { UCGC_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - SCL low" ] # [ inline ( always ) ] pub fn ucscllow ( & self ) -> UCSCLLOW_R { UCSCLLOW_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:15 - Hardware byte counter value" ] # [ inline ( always ) ] pub fn ucbcnt ( & self ) -> UCBCNT_R { UCBCNT_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
}
}
# [ doc = "UCB1STATW_SPI\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1statw_spi](ucb1statw_spi) module" ] pub type UCB1STATW_SPI = crate :: Reg < u16 , _UCB1STATW_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1STATW_SPI ;
# [ doc = "`read()` method returns [ucb1statw_spi::R](ucb1statw_spi::R) reader structure" ] impl crate :: Readable for UCB1STATW_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb1statw_spi::W](ucb1statw_spi::W) writer structure" ] impl crate :: Writable for UCB1STATW_SPI { }
# [ doc = "UCB1STATW_SPI" ] pub mod ucb1statw_spi {
# [ doc = "Reader of register UCB1STATW_SPI" ] pub type R = crate :: R < u16 , super :: UCB1STATW_SPI > ;
# [ doc = "Writer for register UCB1STATW_SPI" ] pub type W = crate :: W < u16 , super :: UCB1STATW_SPI > ;
# [ doc = "Register UCB1STATW_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1STATW_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Overrun error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOE_A { # [ doc = "0: No error" ] UCOE_0 = 0 , # [ doc = "1: Overrun error occurred" ] UCOE_1 = 1 } impl From < UCOE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOE`" ] pub type UCOE_R = crate :: R < bool , UCOE_A > ; impl UCOE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOE_A { match self . bits { false => UCOE_A :: UCOE_0 , true => UCOE_A :: UCOE_1 } } # [ doc = "Checks if the value of the field is `UCOE_0`" ] # [ inline ( always ) ] pub fn is_ucoe_0 ( & self ) -> bool { * self == UCOE_A :: UCOE_0 } # [ doc = "Checks if the value of the field is `UCOE_1`" ] # [ inline ( always ) ] pub fn is_ucoe_1 ( & self ) -> bool { * self == UCOE_A :: UCOE_1 } }
# [ doc = "Write proxy for field `UCOE`" ] pub struct UCOE_W < 'a > { w : & 'a mut W , } impl < 'a > UCOE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucoe_0 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_0 ) } # [ doc = "Overrun error occurred" ] # [ inline ( always ) ] pub fn ucoe_1 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Framing error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCFE_A { # [ doc = "0: No error" ] UCFE_0 = 0 , # [ doc = "1: Bus conflict occurred" ] UCFE_1 = 1 } impl From < UCFE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCFE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCFE`" ] pub type UCFE_R = crate :: R < bool , UCFE_A > ; impl UCFE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCFE_A { match self . bits { false => UCFE_A :: UCFE_0 , true => UCFE_A :: UCFE_1 } } # [ doc = "Checks if the value of the field is `UCFE_0`" ] # [ inline ( always ) ] pub fn is_ucfe_0 ( & self ) -> bool { * self == UCFE_A :: UCFE_0 } # [ doc = "Checks if the value of the field is `UCFE_1`" ] # [ inline ( always ) ] pub fn is_ucfe_1 ( & self ) -> bool { * self == UCFE_A :: UCFE_1 } }
# [ doc = "Write proxy for field `UCFE`" ] pub struct UCFE_W < 'a > { w : & 'a mut W , } impl < 'a > UCFE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCFE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucfe_0 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_0 ) } # [ doc = "Bus conflict occurred" ] # [ inline ( always ) ] pub fn ucfe_1 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Listen enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCLISTEN_A { # [ doc = "0: Disabled" ] UCLISTEN_0 = 0 , # [ doc = "1: Enabled. UCBxTXD is internally fed back to the receiver" ] UCLISTEN_1 = 1 } impl From < UCLISTEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCLISTEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCLISTEN`" ] pub type UCLISTEN_R = crate :: R < bool , UCLISTEN_A > ; impl UCLISTEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCLISTEN_A { match self . bits { false => UCLISTEN_A :: UCLISTEN_0 , true => UCLISTEN_A :: UCLISTEN_1 } } # [ doc = "Checks if the value of the field is `UCLISTEN_0`" ] # [ inline ( always ) ] pub fn is_uclisten_0 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_0 } # [ doc = "Checks if the value of the field is `UCLISTEN_1`" ] # [ inline ( always ) ] pub fn is_uclisten_1 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_1 } }
# [ doc = "Write proxy for field `UCLISTEN`" ] pub struct UCLISTEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCLISTEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCLISTEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn uclisten_0 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_0 ) } # [ doc = "Enabled. UCBxTXD is internally fed back to the receiver" ] # [ inline ( always ) ] pub fn uclisten_1 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & self ) -> UCOE_R { UCOE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & self ) -> UCFE_R { UCFE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & self ) -> UCLISTEN_R { UCLISTEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & mut self ) -> UCOE_W { UCOE_W { w : self } }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & mut self ) -> UCFE_W { UCFE_W { w : self } }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & mut self ) -> UCLISTEN_W { UCLISTEN_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Byte Counter Threshold Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1tbcnt](ucb1tbcnt) module" ] pub type UCB1TBCNT = crate :: Reg < u16 , _UCB1TBCNT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1TBCNT ;
# [ doc = "`read()` method returns [ucb1tbcnt::R](ucb1tbcnt::R) reader structure" ] impl crate :: Readable for UCB1TBCNT { }
# [ doc = "`write(|w| ..)` method takes [ucb1tbcnt::W](ucb1tbcnt::W) writer structure" ] impl crate :: Writable for UCB1TBCNT { }
# [ doc = "eUSCI_Bx Byte Counter Threshold Register" ] pub mod ucb1tbcnt {
# [ doc = "Reader of register UCB1TBCNT" ] pub type R = crate :: R < u16 , super :: UCB1TBCNT > ;
# [ doc = "Writer for register UCB1TBCNT" ] pub type W = crate :: W < u16 , super :: UCB1TBCNT > ;
# [ doc = "Register UCB1TBCNT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1TBCNT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UCTBCNT`" ] pub type UCTBCNT_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCTBCNT`" ] pub struct UCTBCNT_W < 'a > { w : & 'a mut W , } impl < 'a > UCTBCNT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Byte counter threshold value" ] # [ inline ( always ) ] pub fn uctbcnt ( & self ) -> UCTBCNT_R { UCTBCNT_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Byte counter threshold value" ] # [ inline ( always ) ] pub fn uctbcnt ( & mut self ) -> UCTBCNT_W { UCTBCNT_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Receive Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1rxbuf](ucb1rxbuf) module" ] pub type UCB1RXBUF = crate :: Reg < u16 , _UCB1RXBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1RXBUF ;
# [ doc = "`read()` method returns [ucb1rxbuf::R](ucb1rxbuf::R) reader structure" ] impl crate :: Readable for UCB1RXBUF { }
# [ doc = "eUSCI_Bx Receive Buffer Register" ] pub mod ucb1rxbuf {
# [ doc = "Reader of register UCB1RXBUF" ] pub type R = crate :: R < u16 , super :: UCB1RXBUF > ;
# [ doc = "Reader of field `UCRXBUF`" ] pub type UCRXBUF_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Receive data buffer" ] # [ inline ( always ) ] pub fn ucrxbuf ( & self ) -> UCRXBUF_R { UCRXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
}
# [ doc = "eUSCI_Bx Receive Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1rxbuf_spi](ucb1rxbuf_spi) module" ] pub type UCB1RXBUF_SPI = crate :: Reg < u16 , _UCB1RXBUF_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1RXBUF_SPI ;
# [ doc = "`read()` method returns [ucb1rxbuf_spi::R](ucb1rxbuf_spi::R) reader structure" ] impl crate :: Readable for UCB1RXBUF_SPI { }
# [ doc = "eUSCI_Bx Receive Buffer Register" ] pub mod ucb1rxbuf_spi {
# [ doc = "Reader of register UCB1RXBUF_SPI" ] pub type R = crate :: R < u16 , super :: UCB1RXBUF_SPI > ;
# [ doc = "Reader of field `UCRXBUF`" ] pub type UCRXBUF_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Receive data buffer" ] # [ inline ( always ) ] pub fn ucrxbuf ( & self ) -> UCRXBUF_R { UCRXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
}
# [ doc = "eUSCI_Bx Transmit Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1txbuf](ucb1txbuf) module" ] pub type UCB1TXBUF = crate :: Reg < u16 , _UCB1TXBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1TXBUF ;
# [ doc = "`read()` method returns [ucb1txbuf::R](ucb1txbuf::R) reader structure" ] impl crate :: Readable for UCB1TXBUF { }
# [ doc = "`write(|w| ..)` method takes [ucb1txbuf::W](ucb1txbuf::W) writer structure" ] impl crate :: Writable for UCB1TXBUF { }
# [ doc = "eUSCI_Bx Transmit Buffer Register" ] pub mod ucb1txbuf {
# [ doc = "Reader of register UCB1TXBUF" ] pub type R = crate :: R < u16 , super :: UCB1TXBUF > ;
# [ doc = "Writer for register UCB1TXBUF" ] pub type W = crate :: W < u16 , super :: UCB1TXBUF > ;
# [ doc = "Register UCB1TXBUF `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1TXBUF { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UCTXBUF`" ] pub type UCTXBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCTXBUF`" ] pub struct UCTXBUF_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & self ) -> UCTXBUF_R { UCTXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & mut self ) -> UCTXBUF_W { UCTXBUF_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Transmit Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1txbuf_spi](ucb1txbuf_spi) module" ] pub type UCB1TXBUF_SPI = crate :: Reg < u16 , _UCB1TXBUF_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1TXBUF_SPI ;
# [ doc = "`read()` method returns [ucb1txbuf_spi::R](ucb1txbuf_spi::R) reader structure" ] impl crate :: Readable for UCB1TXBUF_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb1txbuf_spi::W](ucb1txbuf_spi::W) writer structure" ] impl crate :: Writable for UCB1TXBUF_SPI { }
# [ doc = "eUSCI_Bx Transmit Buffer Register" ] pub mod ucb1txbuf_spi {
# [ doc = "Reader of register UCB1TXBUF_SPI" ] pub type R = crate :: R < u16 , super :: UCB1TXBUF_SPI > ;
# [ doc = "Writer for register UCB1TXBUF_SPI" ] pub type W = crate :: W < u16 , super :: UCB1TXBUF_SPI > ;
# [ doc = "Register UCB1TXBUF_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1TXBUF_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UCTXBUF`" ] pub type UCTXBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCTXBUF`" ] pub struct UCTXBUF_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & self ) -> UCTXBUF_R { UCTXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & mut self ) -> UCTXBUF_W { UCTXBUF_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Own Address 0 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1i2coa0](ucb1i2coa0) module" ] pub type UCB1I2COA0 = crate :: Reg < u16 , _UCB1I2COA0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1I2COA0 ;
# [ doc = "`read()` method returns [ucb1i2coa0::R](ucb1i2coa0::R) reader structure" ] impl crate :: Readable for UCB1I2COA0 { }
# [ doc = "`write(|w| ..)` method takes [ucb1i2coa0::W](ucb1i2coa0::W) writer structure" ] impl crate :: Writable for UCB1I2COA0 { }
# [ doc = "eUSCI_Bx I2C Own Address 0 Register" ] pub mod ucb1i2coa0 {
# [ doc = "Reader of register UCB1I2COA0" ] pub type R = crate :: R < u16 , super :: UCB1I2COA0 > ;
# [ doc = "Writer for register UCB1I2COA0" ] pub type W = crate :: W < u16 , super :: UCB1I2COA0 > ;
# [ doc = "Register UCB1I2COA0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1I2COA0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `I2COA0`" ] pub type I2COA0_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `I2COA0`" ] pub struct I2COA0_W < 'a > { w : & 'a mut W , } impl < 'a > I2COA0_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
# [ doc = "Own Address enable register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOAEN_A { # [ doc = "0: The slave address defined in I2COA0 is disabled" ] DISABLE = 0 , # [ doc = "1: The slave address defined in I2COA0 is enabled" ] ENABLE = 1 } impl From < UCOAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOAEN`" ] pub type UCOAEN_R = crate :: R < bool , UCOAEN_A > ; impl UCOAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOAEN_A { match self . bits { false => UCOAEN_A :: DISABLE , true => UCOAEN_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCOAEN_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCOAEN_A :: ENABLE } }
# [ doc = "Write proxy for field `UCOAEN`" ] pub struct UCOAEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCOAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The slave address defined in I2COA0 is disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: DISABLE ) } # [ doc = "The slave address defined in I2COA0 is enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "General call response enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCGCEN_A { # [ doc = "0: Do not respond to a general call" ] UCGCEN_0 = 0 , # [ doc = "1: Respond to a general call" ] UCGCEN_1 = 1 } impl From < UCGCEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCGCEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCGCEN`" ] pub type UCGCEN_R = crate :: R < bool , UCGCEN_A > ; impl UCGCEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCGCEN_A { match self . bits { false => UCGCEN_A :: UCGCEN_0 , true => UCGCEN_A :: UCGCEN_1 } } # [ doc = "Checks if the value of the field is `UCGCEN_0`" ] # [ inline ( always ) ] pub fn is_ucgcen_0 ( & self ) -> bool { * self == UCGCEN_A :: UCGCEN_0 } # [ doc = "Checks if the value of the field is `UCGCEN_1`" ] # [ inline ( always ) ] pub fn is_ucgcen_1 ( & self ) -> bool { * self == UCGCEN_A :: UCGCEN_1 } }
# [ doc = "Write proxy for field `UCGCEN`" ] pub struct UCGCEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCGCEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCGCEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Do not respond to a general call" ] # [ inline ( always ) ] pub fn ucgcen_0 ( self ) -> & 'a mut W { self . variant ( UCGCEN_A :: UCGCEN_0 ) } # [ doc = "Respond to a general call" ] # [ inline ( always ) ] pub fn ucgcen_1 ( self ) -> & 'a mut W { self . variant ( UCGCEN_A :: UCGCEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa0 ( & self ) -> I2COA0_R { I2COA0_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & self ) -> UCOAEN_R { UCOAEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - General call response enable" ] # [ inline ( always ) ] pub fn ucgcen ( & self ) -> UCGCEN_R { UCGCEN_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa0 ( & mut self ) -> I2COA0_W { I2COA0_W { w : self } }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & mut self ) -> UCOAEN_W { UCOAEN_W { w : self } }
# [ doc = "Bit 15 - General call response enable" ] # [ inline ( always ) ] pub fn ucgcen ( & mut self ) -> UCGCEN_W { UCGCEN_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Own Address 1 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1i2coa1](ucb1i2coa1) module" ] pub type UCB1I2COA1 = crate :: Reg < u16 , _UCB1I2COA1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1I2COA1 ;
# [ doc = "`read()` method returns [ucb1i2coa1::R](ucb1i2coa1::R) reader structure" ] impl crate :: Readable for UCB1I2COA1 { }
# [ doc = "`write(|w| ..)` method takes [ucb1i2coa1::W](ucb1i2coa1::W) writer structure" ] impl crate :: Writable for UCB1I2COA1 { }
# [ doc = "eUSCI_Bx I2C Own Address 1 Register" ] pub mod ucb1i2coa1 {
# [ doc = "Reader of register UCB1I2COA1" ] pub type R = crate :: R < u16 , super :: UCB1I2COA1 > ;
# [ doc = "Writer for register UCB1I2COA1" ] pub type W = crate :: W < u16 , super :: UCB1I2COA1 > ;
# [ doc = "Register UCB1I2COA1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1I2COA1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `I2COA1`" ] pub type I2COA1_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `I2COA1`" ] pub struct I2COA1_W < 'a > { w : & 'a mut W , } impl < 'a > I2COA1_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
# [ doc = "Own Address enable register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOAEN_A { # [ doc = "0: The slave address defined in I2COA1 is disabled" ] DISABLE = 0 , # [ doc = "1: The slave address defined in I2COA1 is enabled" ] ENABLE = 1 } impl From < UCOAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOAEN`" ] pub type UCOAEN_R = crate :: R < bool , UCOAEN_A > ; impl UCOAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOAEN_A { match self . bits { false => UCOAEN_A :: DISABLE , true => UCOAEN_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCOAEN_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCOAEN_A :: ENABLE } }
# [ doc = "Write proxy for field `UCOAEN`" ] pub struct UCOAEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCOAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The slave address defined in I2COA1 is disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: DISABLE ) } # [ doc = "The slave address defined in I2COA1 is enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa1 ( & self ) -> I2COA1_R { I2COA1_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & self ) -> UCOAEN_R { UCOAEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa1 ( & mut self ) -> I2COA1_W { I2COA1_W { w : self } }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & mut self ) -> UCOAEN_W { UCOAEN_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Own Address 2 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1i2coa2](ucb1i2coa2) module" ] pub type UCB1I2COA2 = crate :: Reg < u16 , _UCB1I2COA2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1I2COA2 ;
# [ doc = "`read()` method returns [ucb1i2coa2::R](ucb1i2coa2::R) reader structure" ] impl crate :: Readable for UCB1I2COA2 { }
# [ doc = "`write(|w| ..)` method takes [ucb1i2coa2::W](ucb1i2coa2::W) writer structure" ] impl crate :: Writable for UCB1I2COA2 { }
# [ doc = "eUSCI_Bx I2C Own Address 2 Register" ] pub mod ucb1i2coa2 {
# [ doc = "Reader of register UCB1I2COA2" ] pub type R = crate :: R < u16 , super :: UCB1I2COA2 > ;
# [ doc = "Writer for register UCB1I2COA2" ] pub type W = crate :: W < u16 , super :: UCB1I2COA2 > ;
# [ doc = "Register UCB1I2COA2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1I2COA2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `I2COA2`" ] pub type I2COA2_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `I2COA2`" ] pub struct I2COA2_W < 'a > { w : & 'a mut W , } impl < 'a > I2COA2_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
# [ doc = "Own Address enable register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOAEN_A { # [ doc = "0: The slave address defined in I2COA2 is disabled" ] DISABLE = 0 , # [ doc = "1: The slave address defined in I2COA2 is enabled" ] ENABLE = 1 } impl From < UCOAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOAEN`" ] pub type UCOAEN_R = crate :: R < bool , UCOAEN_A > ; impl UCOAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOAEN_A { match self . bits { false => UCOAEN_A :: DISABLE , true => UCOAEN_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCOAEN_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCOAEN_A :: ENABLE } }
# [ doc = "Write proxy for field `UCOAEN`" ] pub struct UCOAEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCOAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The slave address defined in I2COA2 is disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: DISABLE ) } # [ doc = "The slave address defined in I2COA2 is enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa2 ( & self ) -> I2COA2_R { I2COA2_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & self ) -> UCOAEN_R { UCOAEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa2 ( & mut self ) -> I2COA2_W { I2COA2_W { w : self } }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & mut self ) -> UCOAEN_W { UCOAEN_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Own Address 3 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1i2coa3](ucb1i2coa3) module" ] pub type UCB1I2COA3 = crate :: Reg < u16 , _UCB1I2COA3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1I2COA3 ;
# [ doc = "`read()` method returns [ucb1i2coa3::R](ucb1i2coa3::R) reader structure" ] impl crate :: Readable for UCB1I2COA3 { }
# [ doc = "`write(|w| ..)` method takes [ucb1i2coa3::W](ucb1i2coa3::W) writer structure" ] impl crate :: Writable for UCB1I2COA3 { }
# [ doc = "eUSCI_Bx I2C Own Address 3 Register" ] pub mod ucb1i2coa3 {
# [ doc = "Reader of register UCB1I2COA3" ] pub type R = crate :: R < u16 , super :: UCB1I2COA3 > ;
# [ doc = "Writer for register UCB1I2COA3" ] pub type W = crate :: W < u16 , super :: UCB1I2COA3 > ;
# [ doc = "Register UCB1I2COA3 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1I2COA3 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `I2COA3`" ] pub type I2COA3_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `I2COA3`" ] pub struct I2COA3_W < 'a > { w : & 'a mut W , } impl < 'a > I2COA3_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
# [ doc = "Own Address enable register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOAEN_A { # [ doc = "0: The slave address defined in I2COA3 is disabled" ] DISABLE = 0 , # [ doc = "1: The slave address defined in I2COA3 is enabled" ] ENABLE = 1 } impl From < UCOAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOAEN`" ] pub type UCOAEN_R = crate :: R < bool , UCOAEN_A > ; impl UCOAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOAEN_A { match self . bits { false => UCOAEN_A :: DISABLE , true => UCOAEN_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCOAEN_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCOAEN_A :: ENABLE } }
# [ doc = "Write proxy for field `UCOAEN`" ] pub struct UCOAEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCOAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The slave address defined in I2COA3 is disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: DISABLE ) } # [ doc = "The slave address defined in I2COA3 is enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa3 ( & self ) -> I2COA3_R { I2COA3_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & self ) -> UCOAEN_R { UCOAEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa3 ( & mut self ) -> I2COA3_W { I2COA3_W { w : self } }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & mut self ) -> UCOAEN_W { UCOAEN_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Received Address Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1addrx](ucb1addrx) module" ] pub type UCB1ADDRX = crate :: Reg < u16 , _UCB1ADDRX > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1ADDRX ;
# [ doc = "`read()` method returns [ucb1addrx::R](ucb1addrx::R) reader structure" ] impl crate :: Readable for UCB1ADDRX { }
# [ doc = "eUSCI_Bx I2C Received Address Register" ] pub mod ucb1addrx {
# [ doc = "Reader of register UCB1ADDRX" ] pub type R = crate :: R < u16 , super :: UCB1ADDRX > ;
# [ doc = "Reader of field `ADDRX`" ] pub type ADDRX_R = crate :: R < u16 , u16 > ;
impl R {
# [ doc = "Bits 0:9 - Received Address Register" ] # [ inline ( always ) ] pub fn addrx ( & self ) -> ADDRX_R { ADDRX_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
}
}
# [ doc = "eUSCI_Bx I2C Address Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1addmask](ucb1addmask) module" ] pub type UCB1ADDMASK = crate :: Reg < u16 , _UCB1ADDMASK > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1ADDMASK ;
# [ doc = "`read()` method returns [ucb1addmask::R](ucb1addmask::R) reader structure" ] impl crate :: Readable for UCB1ADDMASK { }
# [ doc = "`write(|w| ..)` method takes [ucb1addmask::W](ucb1addmask::W) writer structure" ] impl crate :: Writable for UCB1ADDMASK { }
# [ doc = "eUSCI_Bx I2C Address Mask Register" ] pub mod ucb1addmask {
# [ doc = "Reader of register UCB1ADDMASK" ] pub type R = crate :: R < u16 , super :: UCB1ADDMASK > ;
# [ doc = "Writer for register UCB1ADDMASK" ] pub type W = crate :: W < u16 , super :: UCB1ADDMASK > ;
# [ doc = "Register UCB1ADDMASK `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1ADDMASK { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ADDMASK`" ] pub type ADDMASK_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `ADDMASK`" ] pub struct ADDMASK_W < 'a > { w : & 'a mut W , } impl < 'a > ADDMASK_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - Address Mask Register. By clearing the corresponding bit of the own address, this bit is a don't care when comparing the address on the bus to the own address. Using this method, it is possible to react on more than one slave address. When all bits of ADDMASKx are set, the address mask feature is deactivated. Modify only when UCSWRST = 1." ] # [ inline ( always ) ] pub fn addmask ( & self ) -> ADDMASK_R { ADDMASK_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:9 - Address Mask Register. By clearing the corresponding bit of the own address, this bit is a don't care when comparing the address on the bus to the own address. Using this method, it is possible to react on more than one slave address. When all bits of ADDMASKx are set, the address mask feature is deactivated. Modify only when UCSWRST = 1." ] # [ inline ( always ) ] pub fn addmask ( & mut self ) -> ADDMASK_W { ADDMASK_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Slave Address Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1i2csa](ucb1i2csa) module" ] pub type UCB1I2CSA = crate :: Reg < u16 , _UCB1I2CSA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1I2CSA ;
# [ doc = "`read()` method returns [ucb1i2csa::R](ucb1i2csa::R) reader structure" ] impl crate :: Readable for UCB1I2CSA { }
# [ doc = "`write(|w| ..)` method takes [ucb1i2csa::W](ucb1i2csa::W) writer structure" ] impl crate :: Writable for UCB1I2CSA { }
# [ doc = "eUSCI_Bx I2C Slave Address Register" ] pub mod ucb1i2csa {
# [ doc = "Reader of register UCB1I2CSA" ] pub type R = crate :: R < u16 , super :: UCB1I2CSA > ;
# [ doc = "Writer for register UCB1I2CSA" ] pub type W = crate :: W < u16 , super :: UCB1I2CSA > ;
# [ doc = "Register UCB1I2CSA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1I2CSA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `I2CSA`" ] pub type I2CSA_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `I2CSA`" ] pub struct I2CSA_W < 'a > { w : & 'a mut W , } impl < 'a > I2CSA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - I2C slave address" ] # [ inline ( always ) ] pub fn i2csa ( & self ) -> I2CSA_R { I2CSA_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:9 - I2C slave address" ] # [ inline ( always ) ] pub fn i2csa ( & mut self ) -> I2CSA_W { I2CSA_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1ie](ucb1ie) module" ] pub type UCB1IE = crate :: Reg < u16 , _UCB1IE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1IE ;
# [ doc = "`read()` method returns [ucb1ie::R](ucb1ie::R) reader structure" ] impl crate :: Readable for UCB1IE { }
# [ doc = "`write(|w| ..)` method takes [ucb1ie::W](ucb1ie::W) writer structure" ] impl crate :: Writable for UCB1IE { }
# [ doc = "eUSCI_Bx Interrupt Enable Register" ] pub mod ucb1ie {
# [ doc = "Reader of register UCB1IE" ] pub type R = crate :: R < u16 , super :: UCB1IE > ;
# [ doc = "Writer for register UCB1IE" ] pub type W = crate :: W < u16 , super :: UCB1IE > ;
# [ doc = "Register UCB1IE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1IE { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt enable 0\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE0_A { # [ doc = "0: Interrupt disabled" ] UCRXIE0_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE0_1 = 1 } impl From < UCRXIE0_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE0`" ] pub type UCRXIE0_R = crate :: R < bool , UCRXIE0_A > ; impl UCRXIE0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE0_A { match self . bits { false => UCRXIE0_A :: UCRXIE0_0 , true => UCRXIE0_A :: UCRXIE0_1 } } # [ doc = "Checks if the value of the field is `UCRXIE0_0`" ] # [ inline ( always ) ] pub fn is_ucrxie0_0 ( & self ) -> bool { * self == UCRXIE0_A :: UCRXIE0_0 } # [ doc = "Checks if the value of the field is `UCRXIE0_1`" ] # [ inline ( always ) ] pub fn is_ucrxie0_1 ( & self ) -> bool { * self == UCRXIE0_A :: UCRXIE0_1 } }
# [ doc = "Write proxy for field `UCRXIE0`" ] pub struct UCRXIE0_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie0_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE0_A :: UCRXIE0_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie0_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE0_A :: UCRXIE0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt enable 0\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE0_A { # [ doc = "0: Interrupt disabled" ] UCTXIE0_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE0_1 = 1 } impl From < UCTXIE0_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE0`" ] pub type UCTXIE0_R = crate :: R < bool , UCTXIE0_A > ; impl UCTXIE0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE0_A { match self . bits { false => UCTXIE0_A :: UCTXIE0_0 , true => UCTXIE0_A :: UCTXIE0_1 } } # [ doc = "Checks if the value of the field is `UCTXIE0_0`" ] # [ inline ( always ) ] pub fn is_uctxie0_0 ( & self ) -> bool { * self == UCTXIE0_A :: UCTXIE0_0 } # [ doc = "Checks if the value of the field is `UCTXIE0_1`" ] # [ inline ( always ) ] pub fn is_uctxie0_1 ( & self ) -> bool { * self == UCTXIE0_A :: UCTXIE0_1 } }
# [ doc = "Write proxy for field `UCTXIE0`" ] pub struct UCTXIE0_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie0_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE0_A :: UCTXIE0_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie0_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE0_A :: UCTXIE0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "START condition interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTTIE_A { # [ doc = "0: Interrupt disabled" ] UCSTTIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCSTTIE_1 = 1 } impl From < UCSTTIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTTIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTTIE`" ] pub type UCSTTIE_R = crate :: R < bool , UCSTTIE_A > ; impl UCSTTIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTTIE_A { match self . bits { false => UCSTTIE_A :: UCSTTIE_0 , true => UCSTTIE_A :: UCSTTIE_1 } } # [ doc = "Checks if the value of the field is `UCSTTIE_0`" ] # [ inline ( always ) ] pub fn is_ucsttie_0 ( & self ) -> bool { * self == UCSTTIE_A :: UCSTTIE_0 } # [ doc = "Checks if the value of the field is `UCSTTIE_1`" ] # [ inline ( always ) ] pub fn is_ucsttie_1 ( & self ) -> bool { * self == UCSTTIE_A :: UCSTTIE_1 } }
# [ doc = "Write proxy for field `UCSTTIE`" ] pub struct UCSTTIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTTIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTTIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucsttie_0 ( self ) -> & 'a mut W { self . variant ( UCSTTIE_A :: UCSTTIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucsttie_1 ( self ) -> & 'a mut W { self . variant ( UCSTTIE_A :: UCSTTIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "STOP condition interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTPIE_A { # [ doc = "0: Interrupt disabled" ] UCSTPIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCSTPIE_1 = 1 } impl From < UCSTPIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTPIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTPIE`" ] pub type UCSTPIE_R = crate :: R < bool , UCSTPIE_A > ; impl UCSTPIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTPIE_A { match self . bits { false => UCSTPIE_A :: UCSTPIE_0 , true => UCSTPIE_A :: UCSTPIE_1 } } # [ doc = "Checks if the value of the field is `UCSTPIE_0`" ] # [ inline ( always ) ] pub fn is_ucstpie_0 ( & self ) -> bool { * self == UCSTPIE_A :: UCSTPIE_0 } # [ doc = "Checks if the value of the field is `UCSTPIE_1`" ] # [ inline ( always ) ] pub fn is_ucstpie_1 ( & self ) -> bool { * self == UCSTPIE_A :: UCSTPIE_1 } }
# [ doc = "Write proxy for field `UCSTPIE`" ] pub struct UCSTPIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTPIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTPIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucstpie_0 ( self ) -> & 'a mut W { self . variant ( UCSTPIE_A :: UCSTPIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucstpie_1 ( self ) -> & 'a mut W { self . variant ( UCSTPIE_A :: UCSTPIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Arbitration lost interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCALIE_A { # [ doc = "0: Interrupt disabled" ] UCALIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCALIE_1 = 1 } impl From < UCALIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCALIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCALIE`" ] pub type UCALIE_R = crate :: R < bool , UCALIE_A > ; impl UCALIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCALIE_A { match self . bits { false => UCALIE_A :: UCALIE_0 , true => UCALIE_A :: UCALIE_1 } } # [ doc = "Checks if the value of the field is `UCALIE_0`" ] # [ inline ( always ) ] pub fn is_ucalie_0 ( & self ) -> bool { * self == UCALIE_A :: UCALIE_0 } # [ doc = "Checks if the value of the field is `UCALIE_1`" ] # [ inline ( always ) ] pub fn is_ucalie_1 ( & self ) -> bool { * self == UCALIE_A :: UCALIE_1 } }
# [ doc = "Write proxy for field `UCALIE`" ] pub struct UCALIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCALIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCALIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucalie_0 ( self ) -> & 'a mut W { self . variant ( UCALIE_A :: UCALIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucalie_1 ( self ) -> & 'a mut W { self . variant ( UCALIE_A :: UCALIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Not-acknowledge interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCNACKIE_A { # [ doc = "0: Interrupt disabled" ] UCNACKIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCNACKIE_1 = 1 } impl From < UCNACKIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCNACKIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCNACKIE`" ] pub type UCNACKIE_R = crate :: R < bool , UCNACKIE_A > ; impl UCNACKIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCNACKIE_A { match self . bits { false => UCNACKIE_A :: UCNACKIE_0 , true => UCNACKIE_A :: UCNACKIE_1 } } # [ doc = "Checks if the value of the field is `UCNACKIE_0`" ] # [ inline ( always ) ] pub fn is_ucnackie_0 ( & self ) -> bool { * self == UCNACKIE_A :: UCNACKIE_0 } # [ doc = "Checks if the value of the field is `UCNACKIE_1`" ] # [ inline ( always ) ] pub fn is_ucnackie_1 ( & self ) -> bool { * self == UCNACKIE_A :: UCNACKIE_1 } }
# [ doc = "Write proxy for field `UCNACKIE`" ] pub struct UCNACKIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCNACKIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCNACKIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucnackie_0 ( self ) -> & 'a mut W { self . variant ( UCNACKIE_A :: UCNACKIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucnackie_1 ( self ) -> & 'a mut W { self . variant ( UCNACKIE_A :: UCNACKIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Byte counter interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBCNTIE_A { # [ doc = "0: Interrupt disabled" ] UCBCNTIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCBCNTIE_1 = 1 } impl From < UCBCNTIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBCNTIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBCNTIE`" ] pub type UCBCNTIE_R = crate :: R < bool , UCBCNTIE_A > ; impl UCBCNTIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBCNTIE_A { match self . bits { false => UCBCNTIE_A :: UCBCNTIE_0 , true => UCBCNTIE_A :: UCBCNTIE_1 } } # [ doc = "Checks if the value of the field is `UCBCNTIE_0`" ] # [ inline ( always ) ] pub fn is_ucbcntie_0 ( & self ) -> bool { * self == UCBCNTIE_A :: UCBCNTIE_0 } # [ doc = "Checks if the value of the field is `UCBCNTIE_1`" ] # [ inline ( always ) ] pub fn is_ucbcntie_1 ( & self ) -> bool { * self == UCBCNTIE_A :: UCBCNTIE_1 } }
# [ doc = "Write proxy for field `UCBCNTIE`" ] pub struct UCBCNTIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCBCNTIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBCNTIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucbcntie_0 ( self ) -> & 'a mut W { self . variant ( UCBCNTIE_A :: UCBCNTIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucbcntie_1 ( self ) -> & 'a mut W { self . variant ( UCBCNTIE_A :: UCBCNTIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Clock low timeout interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCLTOIE_A { # [ doc = "0: Interrupt disabled" ] UCCLTOIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCCLTOIE_1 = 1 } impl From < UCCLTOIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCLTOIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCLTOIE`" ] pub type UCCLTOIE_R = crate :: R < bool , UCCLTOIE_A > ; impl UCCLTOIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCLTOIE_A { match self . bits { false => UCCLTOIE_A :: UCCLTOIE_0 , true => UCCLTOIE_A :: UCCLTOIE_1 } } # [ doc = "Checks if the value of the field is `UCCLTOIE_0`" ] # [ inline ( always ) ] pub fn is_uccltoie_0 ( & self ) -> bool { * self == UCCLTOIE_A :: UCCLTOIE_0 } # [ doc = "Checks if the value of the field is `UCCLTOIE_1`" ] # [ inline ( always ) ] pub fn is_uccltoie_1 ( & self ) -> bool { * self == UCCLTOIE_A :: UCCLTOIE_1 } }
# [ doc = "Write proxy for field `UCCLTOIE`" ] pub struct UCCLTOIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCCLTOIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCLTOIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uccltoie_0 ( self ) -> & 'a mut W { self . variant ( UCCLTOIE_A :: UCCLTOIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uccltoie_1 ( self ) -> & 'a mut W { self . variant ( UCCLTOIE_A :: UCCLTOIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Receive interrupt enable 1\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE1_A { # [ doc = "0: Interrupt disabled" ] UCRXIE1_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE1_1 = 1 } impl From < UCRXIE1_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE1_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE1`" ] pub type UCRXIE1_R = crate :: R < bool , UCRXIE1_A > ; impl UCRXIE1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE1_A { match self . bits { false => UCRXIE1_A :: UCRXIE1_0 , true => UCRXIE1_A :: UCRXIE1_1 } } # [ doc = "Checks if the value of the field is `UCRXIE1_0`" ] # [ inline ( always ) ] pub fn is_ucrxie1_0 ( & self ) -> bool { * self == UCRXIE1_A :: UCRXIE1_0 } # [ doc = "Checks if the value of the field is `UCRXIE1_1`" ] # [ inline ( always ) ] pub fn is_ucrxie1_1 ( & self ) -> bool { * self == UCRXIE1_A :: UCRXIE1_1 } }
# [ doc = "Write proxy for field `UCRXIE1`" ] pub struct UCRXIE1_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE1_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie1_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE1_A :: UCRXIE1_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie1_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE1_A :: UCRXIE1_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Transmit interrupt enable 1\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE1_A { # [ doc = "0: Interrupt disabled" ] UCTXIE1_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE1_1 = 1 } impl From < UCTXIE1_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE1_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE1`" ] pub type UCTXIE1_R = crate :: R < bool , UCTXIE1_A > ; impl UCTXIE1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE1_A { match self . bits { false => UCTXIE1_A :: UCTXIE1_0 , true => UCTXIE1_A :: UCTXIE1_1 } } # [ doc = "Checks if the value of the field is `UCTXIE1_0`" ] # [ inline ( always ) ] pub fn is_uctxie1_0 ( & self ) -> bool { * self == UCTXIE1_A :: UCTXIE1_0 } # [ doc = "Checks if the value of the field is `UCTXIE1_1`" ] # [ inline ( always ) ] pub fn is_uctxie1_1 ( & self ) -> bool { * self == UCTXIE1_A :: UCTXIE1_1 } }
# [ doc = "Write proxy for field `UCTXIE1`" ] pub struct UCTXIE1_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE1_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie1_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE1_A :: UCTXIE1_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie1_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE1_A :: UCTXIE1_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Receive interrupt enable 2\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE2_A { # [ doc = "0: Interrupt disabled" ] UCRXIE2_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE2_1 = 1 } impl From < UCRXIE2_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE2_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE2`" ] pub type UCRXIE2_R = crate :: R < bool , UCRXIE2_A > ; impl UCRXIE2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE2_A { match self . bits { false => UCRXIE2_A :: UCRXIE2_0 , true => UCRXIE2_A :: UCRXIE2_1 } } # [ doc = "Checks if the value of the field is `UCRXIE2_0`" ] # [ inline ( always ) ] pub fn is_ucrxie2_0 ( & self ) -> bool { * self == UCRXIE2_A :: UCRXIE2_0 } # [ doc = "Checks if the value of the field is `UCRXIE2_1`" ] # [ inline ( always ) ] pub fn is_ucrxie2_1 ( & self ) -> bool { * self == UCRXIE2_A :: UCRXIE2_1 } }
# [ doc = "Write proxy for field `UCRXIE2`" ] pub struct UCRXIE2_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE2_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie2_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE2_A :: UCRXIE2_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie2_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE2_A :: UCRXIE2_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Transmit interrupt enable 2\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE2_A { # [ doc = "0: Interrupt disabled" ] UCTXIE2_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE2_1 = 1 } impl From < UCTXIE2_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE2_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE2`" ] pub type UCTXIE2_R = crate :: R < bool , UCTXIE2_A > ; impl UCTXIE2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE2_A { match self . bits { false => UCTXIE2_A :: UCTXIE2_0 , true => UCTXIE2_A :: UCTXIE2_1 } } # [ doc = "Checks if the value of the field is `UCTXIE2_0`" ] # [ inline ( always ) ] pub fn is_uctxie2_0 ( & self ) -> bool { * self == UCTXIE2_A :: UCTXIE2_0 } # [ doc = "Checks if the value of the field is `UCTXIE2_1`" ] # [ inline ( always ) ] pub fn is_uctxie2_1 ( & self ) -> bool { * self == UCTXIE2_A :: UCTXIE2_1 } }
# [ doc = "Write proxy for field `UCTXIE2`" ] pub struct UCTXIE2_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE2_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie2_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE2_A :: UCTXIE2_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie2_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE2_A :: UCTXIE2_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Receive interrupt enable 3\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE3_A { # [ doc = "0: Interrupt disabled" ] UCRXIE3_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE3_1 = 1 } impl From < UCRXIE3_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE3_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE3`" ] pub type UCRXIE3_R = crate :: R < bool , UCRXIE3_A > ; impl UCRXIE3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE3_A { match self . bits { false => UCRXIE3_A :: UCRXIE3_0 , true => UCRXIE3_A :: UCRXIE3_1 } } # [ doc = "Checks if the value of the field is `UCRXIE3_0`" ] # [ inline ( always ) ] pub fn is_ucrxie3_0 ( & self ) -> bool { * self == UCRXIE3_A :: UCRXIE3_0 } # [ doc = "Checks if the value of the field is `UCRXIE3_1`" ] # [ inline ( always ) ] pub fn is_ucrxie3_1 ( & self ) -> bool { * self == UCRXIE3_A :: UCRXIE3_1 } }
# [ doc = "Write proxy for field `UCRXIE3`" ] pub struct UCRXIE3_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE3_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE3_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie3_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE3_A :: UCRXIE3_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie3_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE3_A :: UCRXIE3_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Transmit interrupt enable 3\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE3_A { # [ doc = "0: Interrupt disabled" ] UCTXIE3_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE3_1 = 1 } impl From < UCTXIE3_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE3_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE3`" ] pub type UCTXIE3_R = crate :: R < bool , UCTXIE3_A > ; impl UCTXIE3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE3_A { match self . bits { false => UCTXIE3_A :: UCTXIE3_0 , true => UCTXIE3_A :: UCTXIE3_1 } } # [ doc = "Checks if the value of the field is `UCTXIE3_0`" ] # [ inline ( always ) ] pub fn is_uctxie3_0 ( & self ) -> bool { * self == UCTXIE3_A :: UCTXIE3_0 } # [ doc = "Checks if the value of the field is `UCTXIE3_1`" ] # [ inline ( always ) ] pub fn is_uctxie3_1 ( & self ) -> bool { * self == UCTXIE3_A :: UCTXIE3_1 } }
# [ doc = "Write proxy for field `UCTXIE3`" ] pub struct UCTXIE3_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE3_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE3_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie3_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE3_A :: UCTXIE3_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie3_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE3_A :: UCTXIE3_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Bit position 9 interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBIT9IE_A { # [ doc = "0: Interrupt disabled" ] UCBIT9IE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCBIT9IE_1 = 1 } impl From < UCBIT9IE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBIT9IE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBIT9IE`" ] pub type UCBIT9IE_R = crate :: R < bool , UCBIT9IE_A > ; impl UCBIT9IE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBIT9IE_A { match self . bits { false => UCBIT9IE_A :: UCBIT9IE_0 , true => UCBIT9IE_A :: UCBIT9IE_1 } } # [ doc = "Checks if the value of the field is `UCBIT9IE_0`" ] # [ inline ( always ) ] pub fn is_ucbit9ie_0 ( & self ) -> bool { * self == UCBIT9IE_A :: UCBIT9IE_0 } # [ doc = "Checks if the value of the field is `UCBIT9IE_1`" ] # [ inline ( always ) ] pub fn is_ucbit9ie_1 ( & self ) -> bool { * self == UCBIT9IE_A :: UCBIT9IE_1 } }
# [ doc = "Write proxy for field `UCBIT9IE`" ] pub struct UCBIT9IE_W < 'a > { w : & 'a mut W , } impl < 'a > UCBIT9IE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBIT9IE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucbit9ie_0 ( self ) -> & 'a mut W { self . variant ( UCBIT9IE_A :: UCBIT9IE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucbit9ie_1 ( self ) -> & 'a mut W { self . variant ( UCBIT9IE_A :: UCBIT9IE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt enable 0" ] # [ inline ( always ) ] pub fn ucrxie0 ( & self ) -> UCRXIE0_R { UCRXIE0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt enable 0" ] # [ inline ( always ) ] pub fn uctxie0 ( & self ) -> UCTXIE0_R { UCTXIE0_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - START condition interrupt enable" ] # [ inline ( always ) ] pub fn ucsttie ( & self ) -> UCSTTIE_R { UCSTTIE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - STOP condition interrupt enable" ] # [ inline ( always ) ] pub fn ucstpie ( & self ) -> UCSTPIE_R { UCSTPIE_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Arbitration lost interrupt enable" ] # [ inline ( always ) ] pub fn ucalie ( & self ) -> UCALIE_R { UCALIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Not-acknowledge interrupt enable" ] # [ inline ( always ) ] pub fn ucnackie ( & self ) -> UCNACKIE_R { UCNACKIE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Byte counter interrupt enable" ] # [ inline ( always ) ] pub fn ucbcntie ( & self ) -> UCBCNTIE_R { UCBCNTIE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Clock low timeout interrupt enable" ] # [ inline ( always ) ] pub fn uccltoie ( & self ) -> UCCLTOIE_R { UCCLTOIE_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Receive interrupt enable 1" ] # [ inline ( always ) ] pub fn ucrxie1 ( & self ) -> UCRXIE1_R { UCRXIE1_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Transmit interrupt enable 1" ] # [ inline ( always ) ] pub fn uctxie1 ( & self ) -> UCTXIE1_R { UCTXIE1_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Receive interrupt enable 2" ] # [ inline ( always ) ] pub fn ucrxie2 ( & self ) -> UCRXIE2_R { UCRXIE2_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Transmit interrupt enable 2" ] # [ inline ( always ) ] pub fn uctxie2 ( & self ) -> UCTXIE2_R { UCTXIE2_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Receive interrupt enable 3" ] # [ inline ( always ) ] pub fn ucrxie3 ( & self ) -> UCRXIE3_R { UCRXIE3_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Transmit interrupt enable 3" ] # [ inline ( always ) ] pub fn uctxie3 ( & self ) -> UCTXIE3_R { UCTXIE3_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Bit position 9 interrupt enable" ] # [ inline ( always ) ] pub fn ucbit9ie ( & self ) -> UCBIT9IE_R { UCBIT9IE_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt enable 0" ] # [ inline ( always ) ] pub fn ucrxie0 ( & mut self ) -> UCRXIE0_W { UCRXIE0_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt enable 0" ] # [ inline ( always ) ] pub fn uctxie0 ( & mut self ) -> UCTXIE0_W { UCTXIE0_W { w : self } }
# [ doc = "Bit 2 - START condition interrupt enable" ] # [ inline ( always ) ] pub fn ucsttie ( & mut self ) -> UCSTTIE_W { UCSTTIE_W { w : self } }
# [ doc = "Bit 3 - STOP condition interrupt enable" ] # [ inline ( always ) ] pub fn ucstpie ( & mut self ) -> UCSTPIE_W { UCSTPIE_W { w : self } }
# [ doc = "Bit 4 - Arbitration lost interrupt enable" ] # [ inline ( always ) ] pub fn ucalie ( & mut self ) -> UCALIE_W { UCALIE_W { w : self } }
# [ doc = "Bit 5 - Not-acknowledge interrupt enable" ] # [ inline ( always ) ] pub fn ucnackie ( & mut self ) -> UCNACKIE_W { UCNACKIE_W { w : self } }
# [ doc = "Bit 6 - Byte counter interrupt enable" ] # [ inline ( always ) ] pub fn ucbcntie ( & mut self ) -> UCBCNTIE_W { UCBCNTIE_W { w : self } }
# [ doc = "Bit 7 - Clock low timeout interrupt enable" ] # [ inline ( always ) ] pub fn uccltoie ( & mut self ) -> UCCLTOIE_W { UCCLTOIE_W { w : self } }
# [ doc = "Bit 8 - Receive interrupt enable 1" ] # [ inline ( always ) ] pub fn ucrxie1 ( & mut self ) -> UCRXIE1_W { UCRXIE1_W { w : self } }
# [ doc = "Bit 9 - Transmit interrupt enable 1" ] # [ inline ( always ) ] pub fn uctxie1 ( & mut self ) -> UCTXIE1_W { UCTXIE1_W { w : self } }
# [ doc = "Bit 10 - Receive interrupt enable 2" ] # [ inline ( always ) ] pub fn ucrxie2 ( & mut self ) -> UCRXIE2_W { UCRXIE2_W { w : self } }
# [ doc = "Bit 11 - Transmit interrupt enable 2" ] # [ inline ( always ) ] pub fn uctxie2 ( & mut self ) -> UCTXIE2_W { UCTXIE2_W { w : self } }
# [ doc = "Bit 12 - Receive interrupt enable 3" ] # [ inline ( always ) ] pub fn ucrxie3 ( & mut self ) -> UCRXIE3_W { UCRXIE3_W { w : self } }
# [ doc = "Bit 13 - Transmit interrupt enable 3" ] # [ inline ( always ) ] pub fn uctxie3 ( & mut self ) -> UCTXIE3_W { UCTXIE3_W { w : self } }
# [ doc = "Bit 14 - Bit position 9 interrupt enable" ] # [ inline ( always ) ] pub fn ucbit9ie ( & mut self ) -> UCBIT9IE_W { UCBIT9IE_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1ie_spi](ucb1ie_spi) module" ] pub type UCB1IE_SPI = crate :: Reg < u16 , _UCB1IE_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1IE_SPI ;
# [ doc = "`read()` method returns [ucb1ie_spi::R](ucb1ie_spi::R) reader structure" ] impl crate :: Readable for UCB1IE_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb1ie_spi::W](ucb1ie_spi::W) writer structure" ] impl crate :: Writable for UCB1IE_SPI { }
# [ doc = "eUSCI_Bx Interrupt Enable Register" ] pub mod ucb1ie_spi {
# [ doc = "Reader of register UCB1IE_SPI" ] pub type R = crate :: R < u16 , super :: UCB1IE_SPI > ;
# [ doc = "Writer for register UCB1IE_SPI" ] pub type W = crate :: W < u16 , super :: UCB1IE_SPI > ;
# [ doc = "Register UCB1IE_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1IE_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE_A { # [ doc = "0: Interrupt disabled" ] UCRXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE_1 = 1 } impl From < UCRXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE`" ] pub type UCRXIE_R = crate :: R < bool , UCRXIE_A > ; impl UCRXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE_A { match self . bits { false => UCRXIE_A :: UCRXIE_0 , true => UCRXIE_A :: UCRXIE_1 } } # [ doc = "Checks if the value of the field is `UCRXIE_0`" ] # [ inline ( always ) ] pub fn is_ucrxie_0 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_0 } # [ doc = "Checks if the value of the field is `UCRXIE_1`" ] # [ inline ( always ) ] pub fn is_ucrxie_1 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_1 } }
# [ doc = "Write proxy for field `UCRXIE`" ] pub struct UCRXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE_A { # [ doc = "0: Interrupt disabled" ] UCTXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE_1 = 1 } impl From < UCTXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE`" ] pub type UCTXIE_R = crate :: R < bool , UCTXIE_A > ; impl UCTXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE_A { match self . bits { false => UCTXIE_A :: UCTXIE_0 , true => UCTXIE_A :: UCTXIE_1 } } # [ doc = "Checks if the value of the field is `UCTXIE_0`" ] # [ inline ( always ) ] pub fn is_uctxie_0 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_0 } # [ doc = "Checks if the value of the field is `UCTXIE_1`" ] # [ inline ( always ) ] pub fn is_uctxie_1 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_1 } }
# [ doc = "Write proxy for field `UCTXIE`" ] pub struct UCTXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & self ) -> UCRXIE_R { UCRXIE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & self ) -> UCTXIE_R { UCTXIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & mut self ) -> UCRXIE_W { UCRXIE_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & mut self ) -> UCTXIE_W { UCTXIE_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1ifg](ucb1ifg) module" ] pub type UCB1IFG = crate :: Reg < u16 , _UCB1IFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1IFG ;
# [ doc = "`read()` method returns [ucb1ifg::R](ucb1ifg::R) reader structure" ] impl crate :: Readable for UCB1IFG { }
# [ doc = "`write(|w| ..)` method takes [ucb1ifg::W](ucb1ifg::W) writer structure" ] impl crate :: Writable for UCB1IFG { }
# [ doc = "eUSCI_Bx Interrupt Flag Register" ] pub mod ucb1ifg {
# [ doc = "Reader of register UCB1IFG" ] pub type R = crate :: R < u16 , super :: UCB1IFG > ;
# [ doc = "Writer for register UCB1IFG" ] pub type W = crate :: W < u16 , super :: UCB1IFG > ;
# [ doc = "Register UCB1IFG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1IFG { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "eUSCI_B receive interrupt flag 0\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG0_A { # [ doc = "0: No interrupt pending" ] UCRXIFG0_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG0_1 = 1 } impl From < UCRXIFG0_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG0`" ] pub type UCRXIFG0_R = crate :: R < bool , UCRXIFG0_A > ; impl UCRXIFG0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG0_A { match self . bits { false => UCRXIFG0_A :: UCRXIFG0_0 , true => UCRXIFG0_A :: UCRXIFG0_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG0_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg0_0 ( & self ) -> bool { * self == UCRXIFG0_A :: UCRXIFG0_0 } # [ doc = "Checks if the value of the field is `UCRXIFG0_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg0_1 ( & self ) -> bool { * self == UCRXIFG0_A :: UCRXIFG0_1 } }
# [ doc = "Write proxy for field `UCRXIFG0`" ] pub struct UCRXIFG0_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg0_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG0_A :: UCRXIFG0_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg0_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG0_A :: UCRXIFG0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "eUSCI_B transmit interrupt flag 0\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG0_A { # [ doc = "0: No interrupt pending" ] UCTXIFG0_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG0_1 = 1 } impl From < UCTXIFG0_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG0`" ] pub type UCTXIFG0_R = crate :: R < bool , UCTXIFG0_A > ; impl UCTXIFG0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG0_A { match self . bits { false => UCTXIFG0_A :: UCTXIFG0_0 , true => UCTXIFG0_A :: UCTXIFG0_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG0_0`" ] # [ inline ( always ) ] pub fn is_uctxifg0_0 ( & self ) -> bool { * self == UCTXIFG0_A :: UCTXIFG0_0 } # [ doc = "Checks if the value of the field is `UCTXIFG0_1`" ] # [ inline ( always ) ] pub fn is_uctxifg0_1 ( & self ) -> bool { * self == UCTXIFG0_A :: UCTXIFG0_1 } }
# [ doc = "Write proxy for field `UCTXIFG0`" ] pub struct UCTXIFG0_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg0_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG0_A :: UCTXIFG0_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg0_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG0_A :: UCTXIFG0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "START condition interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTTIFG_A { # [ doc = "0: No interrupt pending" ] UCSTTIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCSTTIFG_1 = 1 } impl From < UCSTTIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTTIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTTIFG`" ] pub type UCSTTIFG_R = crate :: R < bool , UCSTTIFG_A > ; impl UCSTTIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTTIFG_A { match self . bits { false => UCSTTIFG_A :: UCSTTIFG_0 , true => UCSTTIFG_A :: UCSTTIFG_1 } } # [ doc = "Checks if the value of the field is `UCSTTIFG_0`" ] # [ inline ( always ) ] pub fn is_ucsttifg_0 ( & self ) -> bool { * self == UCSTTIFG_A :: UCSTTIFG_0 } # [ doc = "Checks if the value of the field is `UCSTTIFG_1`" ] # [ inline ( always ) ] pub fn is_ucsttifg_1 ( & self ) -> bool { * self == UCSTTIFG_A :: UCSTTIFG_1 } }
# [ doc = "Write proxy for field `UCSTTIFG`" ] pub struct UCSTTIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTTIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTTIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucsttifg_0 ( self ) -> & 'a mut W { self . variant ( UCSTTIFG_A :: UCSTTIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucsttifg_1 ( self ) -> & 'a mut W { self . variant ( UCSTTIFG_A :: UCSTTIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "STOP condition interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTPIFG_A { # [ doc = "0: No interrupt pending" ] UCSTPIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCSTPIFG_1 = 1 } impl From < UCSTPIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTPIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTPIFG`" ] pub type UCSTPIFG_R = crate :: R < bool , UCSTPIFG_A > ; impl UCSTPIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTPIFG_A { match self . bits { false => UCSTPIFG_A :: UCSTPIFG_0 , true => UCSTPIFG_A :: UCSTPIFG_1 } } # [ doc = "Checks if the value of the field is `UCSTPIFG_0`" ] # [ inline ( always ) ] pub fn is_ucstpifg_0 ( & self ) -> bool { * self == UCSTPIFG_A :: UCSTPIFG_0 } # [ doc = "Checks if the value of the field is `UCSTPIFG_1`" ] # [ inline ( always ) ] pub fn is_ucstpifg_1 ( & self ) -> bool { * self == UCSTPIFG_A :: UCSTPIFG_1 } }
# [ doc = "Write proxy for field `UCSTPIFG`" ] pub struct UCSTPIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTPIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTPIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucstpifg_0 ( self ) -> & 'a mut W { self . variant ( UCSTPIFG_A :: UCSTPIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucstpifg_1 ( self ) -> & 'a mut W { self . variant ( UCSTPIFG_A :: UCSTPIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Arbitration lost interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCALIFG_A { # [ doc = "0: No interrupt pending" ] UCALIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCALIFG_1 = 1 } impl From < UCALIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCALIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCALIFG`" ] pub type UCALIFG_R = crate :: R < bool , UCALIFG_A > ; impl UCALIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCALIFG_A { match self . bits { false => UCALIFG_A :: UCALIFG_0 , true => UCALIFG_A :: UCALIFG_1 } } # [ doc = "Checks if the value of the field is `UCALIFG_0`" ] # [ inline ( always ) ] pub fn is_ucalifg_0 ( & self ) -> bool { * self == UCALIFG_A :: UCALIFG_0 } # [ doc = "Checks if the value of the field is `UCALIFG_1`" ] # [ inline ( always ) ] pub fn is_ucalifg_1 ( & self ) -> bool { * self == UCALIFG_A :: UCALIFG_1 } }
# [ doc = "Write proxy for field `UCALIFG`" ] pub struct UCALIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCALIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCALIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucalifg_0 ( self ) -> & 'a mut W { self . variant ( UCALIFG_A :: UCALIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucalifg_1 ( self ) -> & 'a mut W { self . variant ( UCALIFG_A :: UCALIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Not-acknowledge received interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCNACKIFG_A { # [ doc = "0: No interrupt pending" ] UCNACKIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCNACKIFG_1 = 1 } impl From < UCNACKIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCNACKIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCNACKIFG`" ] pub type UCNACKIFG_R = crate :: R < bool , UCNACKIFG_A > ; impl UCNACKIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCNACKIFG_A { match self . bits { false => UCNACKIFG_A :: UCNACKIFG_0 , true => UCNACKIFG_A :: UCNACKIFG_1 } } # [ doc = "Checks if the value of the field is `UCNACKIFG_0`" ] # [ inline ( always ) ] pub fn is_ucnackifg_0 ( & self ) -> bool { * self == UCNACKIFG_A :: UCNACKIFG_0 } # [ doc = "Checks if the value of the field is `UCNACKIFG_1`" ] # [ inline ( always ) ] pub fn is_ucnackifg_1 ( & self ) -> bool { * self == UCNACKIFG_A :: UCNACKIFG_1 } }
# [ doc = "Write proxy for field `UCNACKIFG`" ] pub struct UCNACKIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCNACKIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCNACKIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucnackifg_0 ( self ) -> & 'a mut W { self . variant ( UCNACKIFG_A :: UCNACKIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucnackifg_1 ( self ) -> & 'a mut W { self . variant ( UCNACKIFG_A :: UCNACKIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Byte counter interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBCNTIFG_A { # [ doc = "0: No interrupt pending" ] UCBCNTIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCBCNTIFG_1 = 1 } impl From < UCBCNTIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBCNTIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBCNTIFG`" ] pub type UCBCNTIFG_R = crate :: R < bool , UCBCNTIFG_A > ; impl UCBCNTIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBCNTIFG_A { match self . bits { false => UCBCNTIFG_A :: UCBCNTIFG_0 , true => UCBCNTIFG_A :: UCBCNTIFG_1 } } # [ doc = "Checks if the value of the field is `UCBCNTIFG_0`" ] # [ inline ( always ) ] pub fn is_ucbcntifg_0 ( & self ) -> bool { * self == UCBCNTIFG_A :: UCBCNTIFG_0 } # [ doc = "Checks if the value of the field is `UCBCNTIFG_1`" ] # [ inline ( always ) ] pub fn is_ucbcntifg_1 ( & self ) -> bool { * self == UCBCNTIFG_A :: UCBCNTIFG_1 } }
# [ doc = "Write proxy for field `UCBCNTIFG`" ] pub struct UCBCNTIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCBCNTIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBCNTIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucbcntifg_0 ( self ) -> & 'a mut W { self . variant ( UCBCNTIFG_A :: UCBCNTIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucbcntifg_1 ( self ) -> & 'a mut W { self . variant ( UCBCNTIFG_A :: UCBCNTIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Clock low timeout interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCLTOIFG_A { # [ doc = "0: No interrupt pending" ] UCCLTOIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCCLTOIFG_1 = 1 } impl From < UCCLTOIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCLTOIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCLTOIFG`" ] pub type UCCLTOIFG_R = crate :: R < bool , UCCLTOIFG_A > ; impl UCCLTOIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCLTOIFG_A { match self . bits { false => UCCLTOIFG_A :: UCCLTOIFG_0 , true => UCCLTOIFG_A :: UCCLTOIFG_1 } } # [ doc = "Checks if the value of the field is `UCCLTOIFG_0`" ] # [ inline ( always ) ] pub fn is_uccltoifg_0 ( & self ) -> bool { * self == UCCLTOIFG_A :: UCCLTOIFG_0 } # [ doc = "Checks if the value of the field is `UCCLTOIFG_1`" ] # [ inline ( always ) ] pub fn is_uccltoifg_1 ( & self ) -> bool { * self == UCCLTOIFG_A :: UCCLTOIFG_1 } }
# [ doc = "Write proxy for field `UCCLTOIFG`" ] pub struct UCCLTOIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCCLTOIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCLTOIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uccltoifg_0 ( self ) -> & 'a mut W { self . variant ( UCCLTOIFG_A :: UCCLTOIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uccltoifg_1 ( self ) -> & 'a mut W { self . variant ( UCCLTOIFG_A :: UCCLTOIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "eUSCI_B receive interrupt flag 1\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG1_A { # [ doc = "0: No interrupt pending" ] UCRXIFG1_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG1_1 = 1 } impl From < UCRXIFG1_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG1_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG1`" ] pub type UCRXIFG1_R = crate :: R < bool , UCRXIFG1_A > ; impl UCRXIFG1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG1_A { match self . bits { false => UCRXIFG1_A :: UCRXIFG1_0 , true => UCRXIFG1_A :: UCRXIFG1_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG1_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg1_0 ( & self ) -> bool { * self == UCRXIFG1_A :: UCRXIFG1_0 } # [ doc = "Checks if the value of the field is `UCRXIFG1_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg1_1 ( & self ) -> bool { * self == UCRXIFG1_A :: UCRXIFG1_1 } }
# [ doc = "Write proxy for field `UCRXIFG1`" ] pub struct UCRXIFG1_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG1_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg1_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG1_A :: UCRXIFG1_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg1_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG1_A :: UCRXIFG1_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "eUSCI_B transmit interrupt flag 1\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG1_A { # [ doc = "0: No interrupt pending" ] UCTXIFG1_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG1_1 = 1 } impl From < UCTXIFG1_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG1_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG1`" ] pub type UCTXIFG1_R = crate :: R < bool , UCTXIFG1_A > ; impl UCTXIFG1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG1_A { match self . bits { false => UCTXIFG1_A :: UCTXIFG1_0 , true => UCTXIFG1_A :: UCTXIFG1_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG1_0`" ] # [ inline ( always ) ] pub fn is_uctxifg1_0 ( & self ) -> bool { * self == UCTXIFG1_A :: UCTXIFG1_0 } # [ doc = "Checks if the value of the field is `UCTXIFG1_1`" ] # [ inline ( always ) ] pub fn is_uctxifg1_1 ( & self ) -> bool { * self == UCTXIFG1_A :: UCTXIFG1_1 } }
# [ doc = "Write proxy for field `UCTXIFG1`" ] pub struct UCTXIFG1_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG1_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg1_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG1_A :: UCTXIFG1_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg1_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG1_A :: UCTXIFG1_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "eUSCI_B receive interrupt flag 2\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG2_A { # [ doc = "0: No interrupt pending" ] UCRXIFG2_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG2_1 = 1 } impl From < UCRXIFG2_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG2_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG2`" ] pub type UCRXIFG2_R = crate :: R < bool , UCRXIFG2_A > ; impl UCRXIFG2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG2_A { match self . bits { false => UCRXIFG2_A :: UCRXIFG2_0 , true => UCRXIFG2_A :: UCRXIFG2_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG2_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg2_0 ( & self ) -> bool { * self == UCRXIFG2_A :: UCRXIFG2_0 } # [ doc = "Checks if the value of the field is `UCRXIFG2_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg2_1 ( & self ) -> bool { * self == UCRXIFG2_A :: UCRXIFG2_1 } }
# [ doc = "Write proxy for field `UCRXIFG2`" ] pub struct UCRXIFG2_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG2_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg2_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG2_A :: UCRXIFG2_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg2_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG2_A :: UCRXIFG2_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "eUSCI_B transmit interrupt flag 2\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG2_A { # [ doc = "0: No interrupt pending" ] UCTXIFG2_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG2_1 = 1 } impl From < UCTXIFG2_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG2_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG2`" ] pub type UCTXIFG2_R = crate :: R < bool , UCTXIFG2_A > ; impl UCTXIFG2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG2_A { match self . bits { false => UCTXIFG2_A :: UCTXIFG2_0 , true => UCTXIFG2_A :: UCTXIFG2_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG2_0`" ] # [ inline ( always ) ] pub fn is_uctxifg2_0 ( & self ) -> bool { * self == UCTXIFG2_A :: UCTXIFG2_0 } # [ doc = "Checks if the value of the field is `UCTXIFG2_1`" ] # [ inline ( always ) ] pub fn is_uctxifg2_1 ( & self ) -> bool { * self == UCTXIFG2_A :: UCTXIFG2_1 } }
# [ doc = "Write proxy for field `UCTXIFG2`" ] pub struct UCTXIFG2_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG2_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg2_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG2_A :: UCTXIFG2_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg2_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG2_A :: UCTXIFG2_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "eUSCI_B receive interrupt flag 3\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG3_A { # [ doc = "0: No interrupt pending" ] UCRXIFG3_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG3_1 = 1 } impl From < UCRXIFG3_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG3_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG3`" ] pub type UCRXIFG3_R = crate :: R < bool , UCRXIFG3_A > ; impl UCRXIFG3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG3_A { match self . bits { false => UCRXIFG3_A :: UCRXIFG3_0 , true => UCRXIFG3_A :: UCRXIFG3_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG3_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg3_0 ( & self ) -> bool { * self == UCRXIFG3_A :: UCRXIFG3_0 } # [ doc = "Checks if the value of the field is `UCRXIFG3_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg3_1 ( & self ) -> bool { * self == UCRXIFG3_A :: UCRXIFG3_1 } }
# [ doc = "Write proxy for field `UCRXIFG3`" ] pub struct UCRXIFG3_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG3_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG3_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg3_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG3_A :: UCRXIFG3_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg3_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG3_A :: UCRXIFG3_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "eUSCI_B transmit interrupt flag 3\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG3_A { # [ doc = "0: No interrupt pending" ] UCTXIFG3_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG3_1 = 1 } impl From < UCTXIFG3_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG3_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG3`" ] pub type UCTXIFG3_R = crate :: R < bool , UCTXIFG3_A > ; impl UCTXIFG3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG3_A { match self . bits { false => UCTXIFG3_A :: UCTXIFG3_0 , true => UCTXIFG3_A :: UCTXIFG3_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG3_0`" ] # [ inline ( always ) ] pub fn is_uctxifg3_0 ( & self ) -> bool { * self == UCTXIFG3_A :: UCTXIFG3_0 } # [ doc = "Checks if the value of the field is `UCTXIFG3_1`" ] # [ inline ( always ) ] pub fn is_uctxifg3_1 ( & self ) -> bool { * self == UCTXIFG3_A :: UCTXIFG3_1 } }
# [ doc = "Write proxy for field `UCTXIFG3`" ] pub struct UCTXIFG3_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG3_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG3_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg3_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG3_A :: UCTXIFG3_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg3_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG3_A :: UCTXIFG3_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Bit position 9 interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBIT9IFG_A { # [ doc = "0: No interrupt pending" ] UCBIT9IFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCBIT9IFG_1 = 1 } impl From < UCBIT9IFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBIT9IFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBIT9IFG`" ] pub type UCBIT9IFG_R = crate :: R < bool , UCBIT9IFG_A > ; impl UCBIT9IFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBIT9IFG_A { match self . bits { false => UCBIT9IFG_A :: UCBIT9IFG_0 , true => UCBIT9IFG_A :: UCBIT9IFG_1 } } # [ doc = "Checks if the value of the field is `UCBIT9IFG_0`" ] # [ inline ( always ) ] pub fn is_ucbit9ifg_0 ( & self ) -> bool { * self == UCBIT9IFG_A :: UCBIT9IFG_0 } # [ doc = "Checks if the value of the field is `UCBIT9IFG_1`" ] # [ inline ( always ) ] pub fn is_ucbit9ifg_1 ( & self ) -> bool { * self == UCBIT9IFG_A :: UCBIT9IFG_1 } }
# [ doc = "Write proxy for field `UCBIT9IFG`" ] pub struct UCBIT9IFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCBIT9IFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBIT9IFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucbit9ifg_0 ( self ) -> & 'a mut W { self . variant ( UCBIT9IFG_A :: UCBIT9IFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucbit9ifg_1 ( self ) -> & 'a mut W { self . variant ( UCBIT9IFG_A :: UCBIT9IFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - eUSCI_B receive interrupt flag 0" ] # [ inline ( always ) ] pub fn ucrxifg0 ( & self ) -> UCRXIFG0_R { UCRXIFG0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - eUSCI_B transmit interrupt flag 0" ] # [ inline ( always ) ] pub fn uctxifg0 ( & self ) -> UCTXIFG0_R { UCTXIFG0_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - START condition interrupt flag" ] # [ inline ( always ) ] pub fn ucsttifg ( & self ) -> UCSTTIFG_R { UCSTTIFG_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - STOP condition interrupt flag" ] # [ inline ( always ) ] pub fn ucstpifg ( & self ) -> UCSTPIFG_R { UCSTPIFG_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Arbitration lost interrupt flag" ] # [ inline ( always ) ] pub fn ucalifg ( & self ) -> UCALIFG_R { UCALIFG_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Not-acknowledge received interrupt flag" ] # [ inline ( always ) ] pub fn ucnackifg ( & self ) -> UCNACKIFG_R { UCNACKIFG_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Byte counter interrupt flag" ] # [ inline ( always ) ] pub fn ucbcntifg ( & self ) -> UCBCNTIFG_R { UCBCNTIFG_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Clock low timeout interrupt flag" ] # [ inline ( always ) ] pub fn uccltoifg ( & self ) -> UCCLTOIFG_R { UCCLTOIFG_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - eUSCI_B receive interrupt flag 1" ] # [ inline ( always ) ] pub fn ucrxifg1 ( & self ) -> UCRXIFG1_R { UCRXIFG1_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - eUSCI_B transmit interrupt flag 1" ] # [ inline ( always ) ] pub fn uctxifg1 ( & self ) -> UCTXIFG1_R { UCTXIFG1_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - eUSCI_B receive interrupt flag 2" ] # [ inline ( always ) ] pub fn ucrxifg2 ( & self ) -> UCRXIFG2_R { UCRXIFG2_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - eUSCI_B transmit interrupt flag 2" ] # [ inline ( always ) ] pub fn uctxifg2 ( & self ) -> UCTXIFG2_R { UCTXIFG2_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - eUSCI_B receive interrupt flag 3" ] # [ inline ( always ) ] pub fn ucrxifg3 ( & self ) -> UCRXIFG3_R { UCRXIFG3_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - eUSCI_B transmit interrupt flag 3" ] # [ inline ( always ) ] pub fn uctxifg3 ( & self ) -> UCTXIFG3_R { UCTXIFG3_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Bit position 9 interrupt flag" ] # [ inline ( always ) ] pub fn ucbit9ifg ( & self ) -> UCBIT9IFG_R { UCBIT9IFG_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - eUSCI_B receive interrupt flag 0" ] # [ inline ( always ) ] pub fn ucrxifg0 ( & mut self ) -> UCRXIFG0_W { UCRXIFG0_W { w : self } }
# [ doc = "Bit 1 - eUSCI_B transmit interrupt flag 0" ] # [ inline ( always ) ] pub fn uctxifg0 ( & mut self ) -> UCTXIFG0_W { UCTXIFG0_W { w : self } }
# [ doc = "Bit 2 - START condition interrupt flag" ] # [ inline ( always ) ] pub fn ucsttifg ( & mut self ) -> UCSTTIFG_W { UCSTTIFG_W { w : self } }
# [ doc = "Bit 3 - STOP condition interrupt flag" ] # [ inline ( always ) ] pub fn ucstpifg ( & mut self ) -> UCSTPIFG_W { UCSTPIFG_W { w : self } }
# [ doc = "Bit 4 - Arbitration lost interrupt flag" ] # [ inline ( always ) ] pub fn ucalifg ( & mut self ) -> UCALIFG_W { UCALIFG_W { w : self } }
# [ doc = "Bit 5 - Not-acknowledge received interrupt flag" ] # [ inline ( always ) ] pub fn ucnackifg ( & mut self ) -> UCNACKIFG_W { UCNACKIFG_W { w : self } }
# [ doc = "Bit 6 - Byte counter interrupt flag" ] # [ inline ( always ) ] pub fn ucbcntifg ( & mut self ) -> UCBCNTIFG_W { UCBCNTIFG_W { w : self } }
# [ doc = "Bit 7 - Clock low timeout interrupt flag" ] # [ inline ( always ) ] pub fn uccltoifg ( & mut self ) -> UCCLTOIFG_W { UCCLTOIFG_W { w : self } }
# [ doc = "Bit 8 - eUSCI_B receive interrupt flag 1" ] # [ inline ( always ) ] pub fn ucrxifg1 ( & mut self ) -> UCRXIFG1_W { UCRXIFG1_W { w : self } }
# [ doc = "Bit 9 - eUSCI_B transmit interrupt flag 1" ] # [ inline ( always ) ] pub fn uctxifg1 ( & mut self ) -> UCTXIFG1_W { UCTXIFG1_W { w : self } }
# [ doc = "Bit 10 - eUSCI_B receive interrupt flag 2" ] # [ inline ( always ) ] pub fn ucrxifg2 ( & mut self ) -> UCRXIFG2_W { UCRXIFG2_W { w : self } }
# [ doc = "Bit 11 - eUSCI_B transmit interrupt flag 2" ] # [ inline ( always ) ] pub fn uctxifg2 ( & mut self ) -> UCTXIFG2_W { UCTXIFG2_W { w : self } }
# [ doc = "Bit 12 - eUSCI_B receive interrupt flag 3" ] # [ inline ( always ) ] pub fn ucrxifg3 ( & mut self ) -> UCRXIFG3_W { UCRXIFG3_W { w : self } }
# [ doc = "Bit 13 - eUSCI_B transmit interrupt flag 3" ] # [ inline ( always ) ] pub fn uctxifg3 ( & mut self ) -> UCTXIFG3_W { UCTXIFG3_W { w : self } }
# [ doc = "Bit 14 - Bit position 9 interrupt flag" ] # [ inline ( always ) ] pub fn ucbit9ifg ( & mut self ) -> UCBIT9IFG_W { UCBIT9IFG_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1ifg_spi](ucb1ifg_spi) module" ] pub type UCB1IFG_SPI = crate :: Reg < u16 , _UCB1IFG_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1IFG_SPI ;
# [ doc = "`read()` method returns [ucb1ifg_spi::R](ucb1ifg_spi::R) reader structure" ] impl crate :: Readable for UCB1IFG_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb1ifg_spi::W](ucb1ifg_spi::W) writer structure" ] impl crate :: Writable for UCB1IFG_SPI { }
# [ doc = "eUSCI_Bx Interrupt Flag Register" ] pub mod ucb1ifg_spi {
# [ doc = "Reader of register UCB1IFG_SPI" ] pub type R = crate :: R < u16 , super :: UCB1IFG_SPI > ;
# [ doc = "Writer for register UCB1IFG_SPI" ] pub type W = crate :: W < u16 , super :: UCB1IFG_SPI > ;
# [ doc = "Register UCB1IFG_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1IFG_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG_A { # [ doc = "0: No interrupt pending" ] UCRXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG_1 = 1 } impl From < UCRXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG`" ] pub type UCRXIFG_R = crate :: R < bool , UCRXIFG_A > ; impl UCRXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG_A { match self . bits { false => UCRXIFG_A :: UCRXIFG_0 , true => UCRXIFG_A :: UCRXIFG_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg_0 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_0 } # [ doc = "Checks if the value of the field is `UCRXIFG_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg_1 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_1 } }
# [ doc = "Write proxy for field `UCRXIFG`" ] pub struct UCRXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG_A { # [ doc = "0: No interrupt pending" ] UCTXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG_1 = 1 } impl From < UCTXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG`" ] pub type UCTXIFG_R = crate :: R < bool , UCTXIFG_A > ; impl UCTXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG_A { match self . bits { false => UCTXIFG_A :: UCTXIFG_0 , true => UCTXIFG_A :: UCTXIFG_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG_0`" ] # [ inline ( always ) ] pub fn is_uctxifg_0 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_0 } # [ doc = "Checks if the value of the field is `UCTXIFG_1`" ] # [ inline ( always ) ] pub fn is_uctxifg_1 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_1 } }
# [ doc = "Write proxy for field `UCTXIFG`" ] pub struct UCTXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & self ) -> UCRXIFG_R { UCRXIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & self ) -> UCTXIFG_R { UCTXIFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & mut self ) -> UCRXIFG_W { UCRXIFG_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & mut self ) -> UCTXIFG_W { UCTXIFG_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1iv](ucb1iv) module" ] pub type UCB1IV = crate :: Reg < u16 , _UCB1IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1IV ;
# [ doc = "`read()` method returns [ucb1iv::R](ucb1iv::R) reader structure" ] impl crate :: Readable for UCB1IV { }
# [ doc = "eUSCI_Bx Interrupt Vector Register" ] pub mod ucb1iv {
# [ doc = "Reader of register UCB1IV" ] pub type R = crate :: R < u16 , super :: UCB1IV > ;
# [ doc = "eUSCI_B interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum UCIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Arbitration lost; Interrupt Flag: UCALIFG; Interrupt Priority: Highest" ] UCALIFG = 2 , # [ doc = "4: Interrupt Source: Not acknowledgment; Interrupt Flag: UCNACKIFG" ] UCNACKIFG = 4 , # [ doc = "6: Interrupt Source: Start condition received; Interrupt Flag: UCSTTIFG" ] UCSTTIFG = 6 , # [ doc = "8: Interrupt Source: Stop condition received; Interrupt Flag: UCSTPIFG" ] UCSTPIFG = 8 , # [ doc = "10: Interrupt Source: Slave 3 Data received; Interrupt Flag: UCRXIFG3" ] UCRXIFG3 = 10 , # [ doc = "12: Interrupt Source: Slave 3 Transmit buffer empty; Interrupt Flag: UCTXIFG3" ] UCTXIFG3 = 12 , # [ doc = "14: Interrupt Source: Slave 2 Data received; Interrupt Flag: UCRXIFG2" ] UCRXIFG2 = 14 , # [ doc = "16: Interrupt Source: Slave 2 Transmit buffer empty; Interrupt Flag: UCTXIFG2" ] UCTXIFG2 = 16 , # [ doc = "18: Interrupt Source: Slave 1 Data received; Interrupt Flag: UCRXIFG1" ] UCRXIFG1 = 18 , # [ doc = "20: Interrupt Source: Slave 1 Transmit buffer empty; Interrupt Flag: UCTXIFG1" ] UCTXIFG1 = 20 , # [ doc = "22: Interrupt Source: Data received; Interrupt Flag: UCRXIFG0" ] UCRXIFG0 = 22 , # [ doc = "24: Interrupt Source: Transmit buffer empty; Interrupt Flag: UCTXIFG0" ] UCTXIFG0 = 24 , # [ doc = "26: Interrupt Source: Byte counter zero; Interrupt Flag: UCBCNTIFG" ] UCBCNTIFG = 26 , # [ doc = "28: Interrupt Source: Clock low timeout; Interrupt Flag: UCCLTOIFG" ] UCCLTOIFG = 28 , # [ doc = "30: Interrupt Source: Nineth bit position; Interrupt Flag: UCBIT9IFG; Priority: Lowest" ] UCBIT9IFG = 30 } impl From < UCIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : UCIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCIV`" ] pub type UCIV_R = crate :: R < u16 , UCIV_A > ; impl UCIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , UCIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( UCIV_A :: NONE ) , 2 => Val ( UCIV_A :: UCALIFG ) , 4 => Val ( UCIV_A :: UCNACKIFG ) , 6 => Val ( UCIV_A :: UCSTTIFG ) , 8 => Val ( UCIV_A :: UCSTPIFG ) , 10 => Val ( UCIV_A :: UCRXIFG3 ) , 12 => Val ( UCIV_A :: UCTXIFG3 ) , 14 => Val ( UCIV_A :: UCRXIFG2 ) , 16 => Val ( UCIV_A :: UCTXIFG2 ) , 18 => Val ( UCIV_A :: UCRXIFG1 ) , 20 => Val ( UCIV_A :: UCTXIFG1 ) , 22 => Val ( UCIV_A :: UCRXIFG0 ) , 24 => Val ( UCIV_A :: UCTXIFG0 ) , 26 => Val ( UCIV_A :: UCBCNTIFG ) , 28 => Val ( UCIV_A :: UCCLTOIFG ) , 30 => Val ( UCIV_A :: UCBIT9IFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == UCIV_A :: NONE } # [ doc = "Checks if the value of the field is `UCALIFG`" ] # [ inline ( always ) ] pub fn is_ucalifg ( & self ) -> bool { * self == UCIV_A :: UCALIFG } # [ doc = "Checks if the value of the field is `UCNACKIFG`" ] # [ inline ( always ) ] pub fn is_ucnackifg ( & self ) -> bool { * self == UCIV_A :: UCNACKIFG } # [ doc = "Checks if the value of the field is `UCSTTIFG`" ] # [ inline ( always ) ] pub fn is_ucsttifg ( & self ) -> bool { * self == UCIV_A :: UCSTTIFG } # [ doc = "Checks if the value of the field is `UCSTPIFG`" ] # [ inline ( always ) ] pub fn is_ucstpifg ( & self ) -> bool { * self == UCIV_A :: UCSTPIFG } # [ doc = "Checks if the value of the field is `UCRXIFG3`" ] # [ inline ( always ) ] pub fn is_ucrxifg3 ( & self ) -> bool { * self == UCIV_A :: UCRXIFG3 } # [ doc = "Checks if the value of the field is `UCTXIFG3`" ] # [ inline ( always ) ] pub fn is_uctxifg3 ( & self ) -> bool { * self == UCIV_A :: UCTXIFG3 } # [ doc = "Checks if the value of the field is `UCRXIFG2`" ] # [ inline ( always ) ] pub fn is_ucrxifg2 ( & self ) -> bool { * self == UCIV_A :: UCRXIFG2 } # [ doc = "Checks if the value of the field is `UCTXIFG2`" ] # [ inline ( always ) ] pub fn is_uctxifg2 ( & self ) -> bool { * self == UCIV_A :: UCTXIFG2 } # [ doc = "Checks if the value of the field is `UCRXIFG1`" ] # [ inline ( always ) ] pub fn is_ucrxifg1 ( & self ) -> bool { * self == UCIV_A :: UCRXIFG1 } # [ doc = "Checks if the value of the field is `UCTXIFG1`" ] # [ inline ( always ) ] pub fn is_uctxifg1 ( & self ) -> bool { * self == UCIV_A :: UCTXIFG1 } # [ doc = "Checks if the value of the field is `UCRXIFG0`" ] # [ inline ( always ) ] pub fn is_ucrxifg0 ( & self ) -> bool { * self == UCIV_A :: UCRXIFG0 } # [ doc = "Checks if the value of the field is `UCTXIFG0`" ] # [ inline ( always ) ] pub fn is_uctxifg0 ( & self ) -> bool { * self == UCIV_A :: UCTXIFG0 } # [ doc = "Checks if the value of the field is `UCBCNTIFG`" ] # [ inline ( always ) ] pub fn is_ucbcntifg ( & self ) -> bool { * self == UCIV_A :: UCBCNTIFG } # [ doc = "Checks if the value of the field is `UCCLTOIFG`" ] # [ inline ( always ) ] pub fn is_uccltoifg ( & self ) -> bool { * self == UCIV_A :: UCCLTOIFG } # [ doc = "Checks if the value of the field is `UCBIT9IFG`" ] # [ inline ( always ) ] pub fn is_ucbit9ifg ( & self ) -> bool { * self == UCIV_A :: UCBIT9IFG } }
impl R {
# [ doc = "Bits 0:15 - eUSCI_B interrupt vector value" ] # [ inline ( always ) ] pub fn uciv ( & self ) -> UCIV_R { UCIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
# [ doc = "eUSCI_Bx Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1iv_spi](ucb1iv_spi) module" ] pub type UCB1IV_SPI = crate :: Reg < u16 , _UCB1IV_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1IV_SPI ;
# [ doc = "`read()` method returns [ucb1iv_spi::R](ucb1iv_spi::R) reader structure" ] impl crate :: Readable for UCB1IV_SPI { }
# [ doc = "eUSCI_Bx Interrupt Vector Register" ] pub mod ucb1iv_spi {
# [ doc = "Reader of register UCB1IV_SPI" ] pub type R = crate :: R < u16 , super :: UCB1IV_SPI > ;
# [ doc = "eUSCI_B interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum UCIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Data received; Interrupt Flag: UCRXIFG; Interrupt Priority: Highest" ] UCRXIFG = 2 , # [ doc = "4: Interrupt Source: Transmit buffer empty; Interrupt Flag: UCTXIFG; Interrupt Priority: Lowest" ] UCTXIFG = 4 } impl From < UCIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : UCIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCIV`" ] pub type UCIV_R = crate :: R < u16 , UCIV_A > ; impl UCIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , UCIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( UCIV_A :: NONE ) , 2 => Val ( UCIV_A :: UCRXIFG ) , 4 => Val ( UCIV_A :: UCTXIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == UCIV_A :: NONE } # [ doc = "Checks if the value of the field is `UCRXIFG`" ] # [ inline ( always ) ] pub fn is_ucrxifg ( & self ) -> bool { * self == UCIV_A :: UCRXIFG } # [ doc = "Checks if the value of the field is `UCTXIFG`" ] # [ inline ( always ) ] pub fn is_uctxifg ( & self ) -> bool { * self == UCIV_A :: UCTXIFG } }
impl R {
# [ doc = "Bits 0:15 - eUSCI_B interrupt vector value" ] # [ inline ( always ) ] pub fn uciv ( & self ) -> UCIV_R { UCIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "BKMEM" ] pub struct BKMEM { _marker : PhantomData < * const ( ) > } unsafe impl Send for BKMEM { } impl BKMEM { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const bkmem :: RegisterBlock { 0x0660 as * const _ } } impl Deref for BKMEM { type Target = bkmem :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * BKMEM :: ptr ( ) } } }
# [ doc = "BKMEM" ] pub mod bkmem {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Backup Memory registers. Backup Memory 0." ] pub bakmem0 : BAKMEM0 , # [ doc = "0x02 - Backup Memory 1." ] pub bakmem1 : BAKMEM1 , # [ doc = "0x04 - Backup Memory 2." ] pub bakmem2 : BAKMEM2 , # [ doc = "0x06 - Backup Memory 3." ] pub bakmem3 : BAKMEM3 , # [ doc = "0x08 - Backup Memory 4." ] pub bakmem4 : BAKMEM4 , # [ doc = "0x0a - Backup Memory 5." ] pub bakmem5 : BAKMEM5 , # [ doc = "0x0c - Backup Memory 6." ] pub bakmem6 : BAKMEM6 , # [ doc = "0x0e - Backup Memory 7." ] pub bakmem7 : BAKMEM7 , # [ doc = "0x10 - Backup Memory 8." ] pub bakmem8 : BAKMEM8 , # [ doc = "0x12 - Backup Memory 9." ] pub bakmem9 : BAKMEM9 , # [ doc = "0x14 - Backup Memory registers. Backup Memory 10." ] pub bakmem10 : BAKMEM10 , # [ doc = "0x16 - Backup Memory 11." ] pub bakmem11 : BAKMEM11 , # [ doc = "0x18 - Backup Memory 12." ] pub bakmem12 : BAKMEM12 , # [ doc = "0x1a - Backup Memory 13." ] pub bakmem13 : BAKMEM13 , # [ doc = "0x1c - Backup Memory 14." ] pub bakmem14 : BAKMEM14 , # [ doc = "0x1e - Backup Memory 15." ] pub bakmem15 : BAKMEM15 , }
# [ doc = "Backup Memory registers. Backup Memory 0.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem0](bakmem0) module" ] pub type BAKMEM0 = crate :: Reg < u16 , _BAKMEM0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM0 ;
# [ doc = "`read()` method returns [bakmem0::R](bakmem0::R) reader structure" ] impl crate :: Readable for BAKMEM0 { }
# [ doc = "`write(|w| ..)` method takes [bakmem0::W](bakmem0::W) writer structure" ] impl crate :: Writable for BAKMEM0 { }
# [ doc = "Backup Memory registers. Backup Memory 0." ] pub mod bakmem0 {
# [ doc = "Reader of register BAKMEM0" ] pub type R = crate :: R < u16 , super :: BAKMEM0 > ;
# [ doc = "Writer for register BAKMEM0" ] pub type W = crate :: W < u16 , super :: BAKMEM0 > ;
# [ doc = "Register BAKMEM0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 1.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem1](bakmem1) module" ] pub type BAKMEM1 = crate :: Reg < u16 , _BAKMEM1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM1 ;
# [ doc = "`read()` method returns [bakmem1::R](bakmem1::R) reader structure" ] impl crate :: Readable for BAKMEM1 { }
# [ doc = "`write(|w| ..)` method takes [bakmem1::W](bakmem1::W) writer structure" ] impl crate :: Writable for BAKMEM1 { }
# [ doc = "Backup Memory 1." ] pub mod bakmem1 {
# [ doc = "Reader of register BAKMEM1" ] pub type R = crate :: R < u16 , super :: BAKMEM1 > ;
# [ doc = "Writer for register BAKMEM1" ] pub type W = crate :: W < u16 , super :: BAKMEM1 > ;
# [ doc = "Register BAKMEM1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 2.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem2](bakmem2) module" ] pub type BAKMEM2 = crate :: Reg < u16 , _BAKMEM2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM2 ;
# [ doc = "`read()` method returns [bakmem2::R](bakmem2::R) reader structure" ] impl crate :: Readable for BAKMEM2 { }
# [ doc = "`write(|w| ..)` method takes [bakmem2::W](bakmem2::W) writer structure" ] impl crate :: Writable for BAKMEM2 { }
# [ doc = "Backup Memory 2." ] pub mod bakmem2 {
# [ doc = "Reader of register BAKMEM2" ] pub type R = crate :: R < u16 , super :: BAKMEM2 > ;
# [ doc = "Writer for register BAKMEM2" ] pub type W = crate :: W < u16 , super :: BAKMEM2 > ;
# [ doc = "Register BAKMEM2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 3.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem3](bakmem3) module" ] pub type BAKMEM3 = crate :: Reg < u16 , _BAKMEM3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM3 ;
# [ doc = "`read()` method returns [bakmem3::R](bakmem3::R) reader structure" ] impl crate :: Readable for BAKMEM3 { }
# [ doc = "`write(|w| ..)` method takes [bakmem3::W](bakmem3::W) writer structure" ] impl crate :: Writable for BAKMEM3 { }
# [ doc = "Backup Memory 3." ] pub mod bakmem3 {
# [ doc = "Reader of register BAKMEM3" ] pub type R = crate :: R < u16 , super :: BAKMEM3 > ;
# [ doc = "Writer for register BAKMEM3" ] pub type W = crate :: W < u16 , super :: BAKMEM3 > ;
# [ doc = "Register BAKMEM3 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM3 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 4.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem4](bakmem4) module" ] pub type BAKMEM4 = crate :: Reg < u16 , _BAKMEM4 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM4 ;
# [ doc = "`read()` method returns [bakmem4::R](bakmem4::R) reader structure" ] impl crate :: Readable for BAKMEM4 { }
# [ doc = "`write(|w| ..)` method takes [bakmem4::W](bakmem4::W) writer structure" ] impl crate :: Writable for BAKMEM4 { }
# [ doc = "Backup Memory 4." ] pub mod bakmem4 {
# [ doc = "Reader of register BAKMEM4" ] pub type R = crate :: R < u16 , super :: BAKMEM4 > ;
# [ doc = "Writer for register BAKMEM4" ] pub type W = crate :: W < u16 , super :: BAKMEM4 > ;
# [ doc = "Register BAKMEM4 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM4 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 5.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem5](bakmem5) module" ] pub type BAKMEM5 = crate :: Reg < u16 , _BAKMEM5 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM5 ;
# [ doc = "`read()` method returns [bakmem5::R](bakmem5::R) reader structure" ] impl crate :: Readable for BAKMEM5 { }
# [ doc = "`write(|w| ..)` method takes [bakmem5::W](bakmem5::W) writer structure" ] impl crate :: Writable for BAKMEM5 { }
# [ doc = "Backup Memory 5." ] pub mod bakmem5 {
# [ doc = "Reader of register BAKMEM5" ] pub type R = crate :: R < u16 , super :: BAKMEM5 > ;
# [ doc = "Writer for register BAKMEM5" ] pub type W = crate :: W < u16 , super :: BAKMEM5 > ;
# [ doc = "Register BAKMEM5 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM5 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 6.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem6](bakmem6) module" ] pub type BAKMEM6 = crate :: Reg < u16 , _BAKMEM6 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM6 ;
# [ doc = "`read()` method returns [bakmem6::R](bakmem6::R) reader structure" ] impl crate :: Readable for BAKMEM6 { }
# [ doc = "`write(|w| ..)` method takes [bakmem6::W](bakmem6::W) writer structure" ] impl crate :: Writable for BAKMEM6 { }
# [ doc = "Backup Memory 6." ] pub mod bakmem6 {
# [ doc = "Reader of register BAKMEM6" ] pub type R = crate :: R < u16 , super :: BAKMEM6 > ;
# [ doc = "Writer for register BAKMEM6" ] pub type W = crate :: W < u16 , super :: BAKMEM6 > ;
# [ doc = "Register BAKMEM6 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM6 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 7.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem7](bakmem7) module" ] pub type BAKMEM7 = crate :: Reg < u16 , _BAKMEM7 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM7 ;
# [ doc = "`read()` method returns [bakmem7::R](bakmem7::R) reader structure" ] impl crate :: Readable for BAKMEM7 { }
# [ doc = "`write(|w| ..)` method takes [bakmem7::W](bakmem7::W) writer structure" ] impl crate :: Writable for BAKMEM7 { }
# [ doc = "Backup Memory 7." ] pub mod bakmem7 {
# [ doc = "Reader of register BAKMEM7" ] pub type R = crate :: R < u16 , super :: BAKMEM7 > ;
# [ doc = "Writer for register BAKMEM7" ] pub type W = crate :: W < u16 , super :: BAKMEM7 > ;
# [ doc = "Register BAKMEM7 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM7 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 8.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem8](bakmem8) module" ] pub type BAKMEM8 = crate :: Reg < u16 , _BAKMEM8 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM8 ;
# [ doc = "`read()` method returns [bakmem8::R](bakmem8::R) reader structure" ] impl crate :: Readable for BAKMEM8 { }
# [ doc = "`write(|w| ..)` method takes [bakmem8::W](bakmem8::W) writer structure" ] impl crate :: Writable for BAKMEM8 { }
# [ doc = "Backup Memory 8." ] pub mod bakmem8 {
# [ doc = "Reader of register BAKMEM8" ] pub type R = crate :: R < u16 , super :: BAKMEM8 > ;
# [ doc = "Writer for register BAKMEM8" ] pub type W = crate :: W < u16 , super :: BAKMEM8 > ;
# [ doc = "Register BAKMEM8 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM8 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 9.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem9](bakmem9) module" ] pub type BAKMEM9 = crate :: Reg < u16 , _BAKMEM9 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM9 ;
# [ doc = "`read()` method returns [bakmem9::R](bakmem9::R) reader structure" ] impl crate :: Readable for BAKMEM9 { }
# [ doc = "`write(|w| ..)` method takes [bakmem9::W](bakmem9::W) writer structure" ] impl crate :: Writable for BAKMEM9 { }
# [ doc = "Backup Memory 9." ] pub mod bakmem9 {
# [ doc = "Reader of register BAKMEM9" ] pub type R = crate :: R < u16 , super :: BAKMEM9 > ;
# [ doc = "Writer for register BAKMEM9" ] pub type W = crate :: W < u16 , super :: BAKMEM9 > ;
# [ doc = "Register BAKMEM9 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM9 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory registers. Backup Memory 10.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem10](bakmem10) module" ] pub type BAKMEM10 = crate :: Reg < u16 , _BAKMEM10 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM10 ;
# [ doc = "`read()` method returns [bakmem10::R](bakmem10::R) reader structure" ] impl crate :: Readable for BAKMEM10 { }
# [ doc = "`write(|w| ..)` method takes [bakmem10::W](bakmem10::W) writer structure" ] impl crate :: Writable for BAKMEM10 { }
# [ doc = "Backup Memory registers. Backup Memory 10." ] pub mod bakmem10 {
# [ doc = "Reader of register BAKMEM10" ] pub type R = crate :: R < u16 , super :: BAKMEM10 > ;
# [ doc = "Writer for register BAKMEM10" ] pub type W = crate :: W < u16 , super :: BAKMEM10 > ;
# [ doc = "Register BAKMEM10 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM10 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 11.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem11](bakmem11) module" ] pub type BAKMEM11 = crate :: Reg < u16 , _BAKMEM11 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM11 ;
# [ doc = "`read()` method returns [bakmem11::R](bakmem11::R) reader structure" ] impl crate :: Readable for BAKMEM11 { }
# [ doc = "`write(|w| ..)` method takes [bakmem11::W](bakmem11::W) writer structure" ] impl crate :: Writable for BAKMEM11 { }
# [ doc = "Backup Memory 11." ] pub mod bakmem11 {
# [ doc = "Reader of register BAKMEM11" ] pub type R = crate :: R < u16 , super :: BAKMEM11 > ;
# [ doc = "Writer for register BAKMEM11" ] pub type W = crate :: W < u16 , super :: BAKMEM11 > ;
# [ doc = "Register BAKMEM11 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM11 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 12.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem12](bakmem12) module" ] pub type BAKMEM12 = crate :: Reg < u16 , _BAKMEM12 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM12 ;
# [ doc = "`read()` method returns [bakmem12::R](bakmem12::R) reader structure" ] impl crate :: Readable for BAKMEM12 { }
# [ doc = "`write(|w| ..)` method takes [bakmem12::W](bakmem12::W) writer structure" ] impl crate :: Writable for BAKMEM12 { }
# [ doc = "Backup Memory 12." ] pub mod bakmem12 {
# [ doc = "Reader of register BAKMEM12" ] pub type R = crate :: R < u16 , super :: BAKMEM12 > ;
# [ doc = "Writer for register BAKMEM12" ] pub type W = crate :: W < u16 , super :: BAKMEM12 > ;
# [ doc = "Register BAKMEM12 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM12 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 13.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem13](bakmem13) module" ] pub type BAKMEM13 = crate :: Reg < u16 , _BAKMEM13 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM13 ;
# [ doc = "`read()` method returns [bakmem13::R](bakmem13::R) reader structure" ] impl crate :: Readable for BAKMEM13 { }
# [ doc = "`write(|w| ..)` method takes [bakmem13::W](bakmem13::W) writer structure" ] impl crate :: Writable for BAKMEM13 { }
# [ doc = "Backup Memory 13." ] pub mod bakmem13 {
# [ doc = "Reader of register BAKMEM13" ] pub type R = crate :: R < u16 , super :: BAKMEM13 > ;
# [ doc = "Writer for register BAKMEM13" ] pub type W = crate :: W < u16 , super :: BAKMEM13 > ;
# [ doc = "Register BAKMEM13 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM13 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 14.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem14](bakmem14) module" ] pub type BAKMEM14 = crate :: Reg < u16 , _BAKMEM14 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM14 ;
# [ doc = "`read()` method returns [bakmem14::R](bakmem14::R) reader structure" ] impl crate :: Readable for BAKMEM14 { }
# [ doc = "`write(|w| ..)` method takes [bakmem14::W](bakmem14::W) writer structure" ] impl crate :: Writable for BAKMEM14 { }
# [ doc = "Backup Memory 14." ] pub mod bakmem14 {
# [ doc = "Reader of register BAKMEM14" ] pub type R = crate :: R < u16 , super :: BAKMEM14 > ;
# [ doc = "Writer for register BAKMEM14" ] pub type W = crate :: W < u16 , super :: BAKMEM14 > ;
# [ doc = "Register BAKMEM14 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM14 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 15.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem15](bakmem15) module" ] pub type BAKMEM15 = crate :: Reg < u16 , _BAKMEM15 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM15 ;
# [ doc = "`read()` method returns [bakmem15::R](bakmem15::R) reader structure" ] impl crate :: Readable for BAKMEM15 { }
# [ doc = "`write(|w| ..)` method takes [bakmem15::W](bakmem15::W) writer structure" ] impl crate :: Writable for BAKMEM15 { }
# [ doc = "Backup Memory 15." ] pub mod bakmem15 {
# [ doc = "Reader of register BAKMEM15" ] pub type R = crate :: R < u16 , super :: BAKMEM15 > ;
# [ doc = "Writer for register BAKMEM15" ] pub type W = crate :: W < u16 , super :: BAKMEM15 > ;
# [ doc = "Register BAKMEM15 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM15 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
}
# [ doc = "ICC" ] pub struct ICC { _marker : PhantomData < * const ( ) > } unsafe impl Send for ICC { } impl ICC { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const icc :: RegisterBlock { 0x06c0 as * const _ } } impl Deref for ICC { type Target = icc :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * ICC :: ptr ( ) } } }
# [ doc = "ICC" ] pub mod icc {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - ICCSC" ] pub iccsc : ICCSC , # [ doc = "0x02 - ICCMVS" ] pub iccmvs : ICCMVS , # [ doc = "0x04 - ICCILSR0" ] pub iccilsr0 : ICCILSR0 , # [ doc = "0x06 - ICCILSR1" ] pub iccilsr1 : ICCILSR1 , # [ doc = "0x08 - ICCILSR2" ] pub iccilsr2 : ICCILSR2 , # [ doc = "0x0a - ICCILSR3" ] pub iccilsr3 : ICCILSR3 , }
# [ doc = "ICCSC\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [iccsc](iccsc) module" ] pub type ICCSC = crate :: Reg < u16 , _ICCSC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ICCSC ;
# [ doc = "`read()` method returns [iccsc::R](iccsc::R) reader structure" ] impl crate :: Readable for ICCSC { }
# [ doc = "`write(|w| ..)` method takes [iccsc::W](iccsc::W) writer structure" ] impl crate :: Writable for ICCSC { }
# [ doc = "ICCSC" ] pub mod iccsc {
# [ doc = "Reader of register ICCSC" ] pub type R = crate :: R < u16 , super :: ICCSC > ;
# [ doc = "Writer for register ICCSC" ] pub type W = crate :: W < u16 , super :: ICCSC > ;
# [ doc = "Register ICCSC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ICCSC { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ICMC`" ] pub type ICMC_R = crate :: R < u8 , u8 > ;
# [ doc = "Virtual stack full flag This bit indicates whether or not the virtual stack is full. It is automatically updated when the stack is pushed or popped.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum VSFFLG_A { # [ doc = "0: ICCMVS register is not full" ] VSFFLG_0 = 0 , # [ doc = "1: ICCMVS register is full" ] VSFFLG_1 = 1 } impl From < VSFFLG_A > for bool { # [ inline ( always ) ] fn from ( variant : VSFFLG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `VSFFLG`" ] pub type VSFFLG_R = crate :: R < bool , VSFFLG_A > ; impl VSFFLG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> VSFFLG_A { match self . bits { false => VSFFLG_A :: VSFFLG_0 , true => VSFFLG_A :: VSFFLG_1 } } # [ doc = "Checks if the value of the field is `VSFFLG_0`" ] # [ inline ( always ) ] pub fn is_vsfflg_0 ( & self ) -> bool { * self == VSFFLG_A :: VSFFLG_0 } # [ doc = "Checks if the value of the field is `VSFFLG_1`" ] # [ inline ( always ) ] pub fn is_vsfflg_1 ( & self ) -> bool { * self == VSFFLG_A :: VSFFLG_1 } }
# [ doc = "Virtual stack empty flag.This bit indicates whether or not the virtual stack is empty. It is automatically updated when the stack is pushed or popped.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum VSEFLG_A { # [ doc = "0: Stack has valid data" ] VSEFLG_0 = 0 , # [ doc = "1: Stack has no valid data" ] VSEFLG_1 = 1 } impl From < VSEFLG_A > for bool { # [ inline ( always ) ] fn from ( variant : VSEFLG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `VSEFLG`" ] pub type VSEFLG_R = crate :: R < bool , VSEFLG_A > ; impl VSEFLG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> VSEFLG_A { match self . bits { false => VSEFLG_A :: VSEFLG_0 , true => VSEFLG_A :: VSEFLG_1 } } # [ doc = "Checks if the value of the field is `VSEFLG_0`" ] # [ inline ( always ) ] pub fn is_vseflg_0 ( & self ) -> bool { * self == VSEFLG_A :: VSEFLG_0 } # [ doc = "Checks if the value of the field is `VSEFLG_1`" ] # [ inline ( always ) ] pub fn is_vseflg_1 ( & self ) -> bool { * self == VSEFLG_A :: VSEFLG_1 } }
# [ doc = "ICC enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ICCEN_A { # [ doc = "0: ICC module disabled" ] ICCEN_0 = 0 , # [ doc = "1: ICC module enabled" ] ICCEN_1 = 1 } impl From < ICCEN_A > for bool { # [ inline ( always ) ] fn from ( variant : ICCEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ICCEN`" ] pub type ICCEN_R = crate :: R < bool , ICCEN_A > ; impl ICCEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ICCEN_A { match self . bits { false => ICCEN_A :: ICCEN_0 , true => ICCEN_A :: ICCEN_1 } } # [ doc = "Checks if the value of the field is `ICCEN_0`" ] # [ inline ( always ) ] pub fn is_iccen_0 ( & self ) -> bool { * self == ICCEN_A :: ICCEN_0 } # [ doc = "Checks if the value of the field is `ICCEN_1`" ] # [ inline ( always ) ] pub fn is_iccen_1 ( & self ) -> bool { * self == ICCEN_A :: ICCEN_1 } }
# [ doc = "Write proxy for field `ICCEN`" ] pub struct ICCEN_W < 'a > { w : & 'a mut W , } impl < 'a > ICCEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ICCEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "ICC module disabled" ] # [ inline ( always ) ] pub fn iccen_0 ( self ) -> & 'a mut W { self . variant ( ICCEN_A :: ICCEN_0 ) } # [ doc = "ICC module enabled" ] # [ inline ( always ) ] pub fn iccen_1 ( self ) -> & 'a mut W { self . variant ( ICCEN_A :: ICCEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Current Interrupt Compare Mask of virtual stack specifies the current ICM at the top of virtual stack If ICM\\[1:0\\] is less than the priority level (ILSRx\\[1:0\\]) of the new interrupt, the corresponding source is sent to the CPU. Note that the ICMC is the element stack that the stack pointer is pointing to." ] # [ inline ( always ) ] pub fn icmc ( & self ) -> ICMC_R { ICMC_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bit 4 - Virtual stack full flag This bit indicates whether or not the virtual stack is full. It is automatically updated when the stack is pushed or popped." ] # [ inline ( always ) ] pub fn vsfflg ( & self ) -> VSFFLG_R { VSFFLG_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Virtual stack empty flag.This bit indicates whether or not the virtual stack is empty. It is automatically updated when the stack is pushed or popped." ] # [ inline ( always ) ] pub fn vseflg ( & self ) -> VSEFLG_R { VSEFLG_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - ICC enable" ] # [ inline ( always ) ] pub fn iccen ( & self ) -> ICCEN_R { ICCEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 7 - ICC enable" ] # [ inline ( always ) ] pub fn iccen ( & mut self ) -> ICCEN_W { ICCEN_W { w : self } }
}
}
# [ doc = "ICCMVS\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [iccmvs](iccmvs) module" ] pub type ICCMVS = crate :: Reg < u16 , _ICCMVS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ICCMVS ;
# [ doc = "`read()` method returns [iccmvs::R](iccmvs::R) reader structure" ] impl crate :: Readable for ICCMVS { }
# [ doc = "ICCMVS" ] pub mod iccmvs {
# [ doc = "Reader of register ICCMVS" ] pub type R = crate :: R < u16 , super :: ICCMVS > ;
# [ doc = "Reader of field `ICM0`" ] pub type ICM0_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `ICM1`" ] pub type ICM1_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `ICM3`" ] pub type ICM3_R = crate :: R < u8 , u8 > ;
# [ doc = "MVS stack pointer indicate register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum MVSSP_A { # [ doc = "0: 000b = Stack empty" ] MVSSP_0 = 0 , # [ doc = "1: 001b = ICM0 affected" ] MVSSP_1 = 1 , # [ doc = "2: 010b = ICM0 and ICM1 affected" ] MVSSP_2 = 2 , # [ doc = "3: 011b = ICM0, ICM1, and ICM2 affected" ] MVSSP_3 = 3 , # [ doc = "4: 100b = ICM0, ICM1, ICM2, and ICM3 affected. Also means the stack is full." ] MVSSP_4 = 4 } impl From < MVSSP_A > for u8 { # [ inline ( always ) ] fn from ( variant : MVSSP_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `MVSSP`" ] pub type MVSSP_R = crate :: R < u8 , MVSSP_A > ; impl MVSSP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , MVSSP_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( MVSSP_A :: MVSSP_0 ) , 1 => Val ( MVSSP_A :: MVSSP_1 ) , 2 => Val ( MVSSP_A :: MVSSP_2 ) , 3 => Val ( MVSSP_A :: MVSSP_3 ) , 4 => Val ( MVSSP_A :: MVSSP_4 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `MVSSP_0`" ] # [ inline ( always ) ] pub fn is_mvssp_0 ( & self ) -> bool { * self == MVSSP_A :: MVSSP_0 } # [ doc = "Checks if the value of the field is `MVSSP_1`" ] # [ inline ( always ) ] pub fn is_mvssp_1 ( & self ) -> bool { * self == MVSSP_A :: MVSSP_1 } # [ doc = "Checks if the value of the field is `MVSSP_2`" ] # [ inline ( always ) ] pub fn is_mvssp_2 ( & self ) -> bool { * self == MVSSP_A :: MVSSP_2 } # [ doc = "Checks if the value of the field is `MVSSP_3`" ] # [ inline ( always ) ] pub fn is_mvssp_3 ( & self ) -> bool { * self == MVSSP_A :: MVSSP_3 } # [ doc = "Checks if the value of the field is `MVSSP_4`" ] # [ inline ( always ) ] pub fn is_mvssp_4 ( & self ) -> bool { * self == MVSSP_A :: MVSSP_4 } }
# [ doc = "Reader of field `ICM2`" ] pub type ICM2_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:1 - Interrupt compare mask virtual stack position 0 This field is the virtual stack register for ICM0." ] # [ inline ( always ) ] pub fn icm0 ( & self ) -> ICM0_R { ICM0_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 2:3 - Interrupt compare mask virtual stack position 1 This field is the virtual stack register for ICM1." ] # [ inline ( always ) ] pub fn icm1 ( & self ) -> ICM1_R { ICM1_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 6:7 - Interrupt compare mask virtual stack position 3 This field is the virtual stack register for ICM3." ] # [ inline ( always ) ] pub fn icm3 ( & self ) -> ICM3_R { ICM3_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:10 - MVS stack pointer indicate register" ] # [ inline ( always ) ] pub fn mvssp ( & self ) -> MVSSP_R { MVSSP_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) }
# [ doc = "Bits 4:5 - Interrupt compare mask virtual stack position 2 This field is the virtual stack register for ICM2." ] # [ inline ( always ) ] pub fn icm2 ( & self ) -> ICM2_R { ICM2_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
}
}
# [ doc = "ICCILSR0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [iccilsr0](iccilsr0) module" ] pub type ICCILSR0 = crate :: Reg < u16 , _ICCILSR0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ICCILSR0 ;
# [ doc = "`read()` method returns [iccilsr0::R](iccilsr0::R) reader structure" ] impl crate :: Readable for ICCILSR0 { }
# [ doc = "`write(|w| ..)` method takes [iccilsr0::W](iccilsr0::W) writer structure" ] impl crate :: Writable for ICCILSR0 { }
# [ doc = "ICCILSR0" ] pub mod iccilsr0 {
# [ doc = "Reader of register ICCILSR0" ] pub type R = crate :: R < u16 , super :: ICCILSR0 > ;
# [ doc = "Writer for register ICCILSR0" ] pub type W = crate :: W < u16 , super :: ICCILSR0 > ;
# [ doc = "Register ICCILSR0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ICCILSR0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ILSR0`" ] pub type ILSR0_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR0`" ] pub struct ILSR0_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR0_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `ILSR1`" ] pub type ILSR1_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR1`" ] pub struct ILSR1_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR1_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u16 ) & 0x03 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `ILSR2`" ] pub type ILSR2_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR2`" ] pub struct ILSR2_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR2_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `ILSR3`" ] pub type ILSR3_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR3`" ] pub struct ILSR3_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR3_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `ILSR4`" ] pub type ILSR4_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR4`" ] pub struct ILSR4_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR4_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `ILSR5`" ] pub type ILSR5_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR5`" ] pub struct ILSR5_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR5_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u16 ) & 0x03 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `ILSR6`" ] pub type ILSR6_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR6`" ] pub struct ILSR6_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR6_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `ILSR7`" ] pub type ILSR7_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR7`" ] pub struct ILSR7_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR7_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr0 ( & self ) -> ILSR0_R { ILSR0_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 2:3 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr1 ( & self ) -> ILSR1_R { ILSR1_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 4:5 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr2 ( & self ) -> ILSR2_R { ILSR2_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 6:7 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr3 ( & self ) -> ILSR3_R { ILSR3_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:9 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr4 ( & self ) -> ILSR4_R { ILSR4_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 10:11 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr5 ( & self ) -> ILSR5_R { ILSR5_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 12:13 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr6 ( & self ) -> ILSR6_R { ILSR6_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr7 ( & self ) -> ILSR7_R { ILSR7_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr0 ( & mut self ) -> ILSR0_W { ILSR0_W { w : self } }
# [ doc = "Bits 2:3 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr1 ( & mut self ) -> ILSR1_W { ILSR1_W { w : self } }
# [ doc = "Bits 4:5 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr2 ( & mut self ) -> ILSR2_W { ILSR2_W { w : self } }
# [ doc = "Bits 6:7 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr3 ( & mut self ) -> ILSR3_W { ILSR3_W { w : self } }
# [ doc = "Bits 8:9 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr4 ( & mut self ) -> ILSR4_W { ILSR4_W { w : self } }
# [ doc = "Bits 10:11 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr5 ( & mut self ) -> ILSR5_W { ILSR5_W { w : self } }
# [ doc = "Bits 12:13 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr6 ( & mut self ) -> ILSR6_W { ILSR6_W { w : self } }
# [ doc = "Bits 14:15 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr7 ( & mut self ) -> ILSR7_W { ILSR7_W { w : self } }
}
}
# [ doc = "ICCILSR1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [iccilsr1](iccilsr1) module" ] pub type ICCILSR1 = crate :: Reg < u16 , _ICCILSR1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ICCILSR1 ;
# [ doc = "`read()` method returns [iccilsr1::R](iccilsr1::R) reader structure" ] impl crate :: Readable for ICCILSR1 { }
# [ doc = "`write(|w| ..)` method takes [iccilsr1::W](iccilsr1::W) writer structure" ] impl crate :: Writable for ICCILSR1 { }
# [ doc = "ICCILSR1" ] pub mod iccilsr1 {
# [ doc = "Reader of register ICCILSR1" ] pub type R = crate :: R < u16 , super :: ICCILSR1 > ;
# [ doc = "Writer for register ICCILSR1" ] pub type W = crate :: W < u16 , super :: ICCILSR1 > ;
# [ doc = "Register ICCILSR1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ICCILSR1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ILSR8`" ] pub type ILSR8_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR8`" ] pub struct ILSR8_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR8_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `ILSR9`" ] pub type ILSR9_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR9`" ] pub struct ILSR9_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR9_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u16 ) & 0x03 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `ILSR10`" ] pub type ILSR10_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR10`" ] pub struct ILSR10_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR10_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `ILSR11`" ] pub type ILSR11_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR11`" ] pub struct ILSR11_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR11_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `ILSR12`" ] pub type ILSR12_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR12`" ] pub struct ILSR12_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR12_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `ILSR13`" ] pub type ILSR13_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR13`" ] pub struct ILSR13_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR13_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u16 ) & 0x03 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `ILSR14`" ] pub type ILSR14_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR14`" ] pub struct ILSR14_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR14_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `ILSR15`" ] pub type ILSR15_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR15`" ] pub struct ILSR15_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR15_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr8 ( & self ) -> ILSR8_R { ILSR8_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 2:3 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr9 ( & self ) -> ILSR9_R { ILSR9_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 4:5 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr10 ( & self ) -> ILSR10_R { ILSR10_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 6:7 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit" ] # [ inline ( always ) ] pub fn ilsr11 ( & self ) -> ILSR11_R { ILSR11_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:9 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr12 ( & self ) -> ILSR12_R { ILSR12_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 10:11 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr13 ( & self ) -> ILSR13_R { ILSR13_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 12:13 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr14 ( & self ) -> ILSR14_R { ILSR14_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr15 ( & self ) -> ILSR15_R { ILSR15_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr8 ( & mut self ) -> ILSR8_W { ILSR8_W { w : self } }
# [ doc = "Bits 2:3 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr9 ( & mut self ) -> ILSR9_W { ILSR9_W { w : self } }
# [ doc = "Bits 4:5 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr10 ( & mut self ) -> ILSR10_W { ILSR10_W { w : self } }
# [ doc = "Bits 6:7 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit" ] # [ inline ( always ) ] pub fn ilsr11 ( & mut self ) -> ILSR11_W { ILSR11_W { w : self } }
# [ doc = "Bits 8:9 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr12 ( & mut self ) -> ILSR12_W { ILSR12_W { w : self } }
# [ doc = "Bits 10:11 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr13 ( & mut self ) -> ILSR13_W { ILSR13_W { w : self } }
# [ doc = "Bits 12:13 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr14 ( & mut self ) -> ILSR14_W { ILSR14_W { w : self } }
# [ doc = "Bits 14:15 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr15 ( & mut self ) -> ILSR15_W { ILSR15_W { w : self } }
}
}
# [ doc = "ICCILSR2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [iccilsr2](iccilsr2) module" ] pub type ICCILSR2 = crate :: Reg < u16 , _ICCILSR2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ICCILSR2 ;
# [ doc = "`read()` method returns [iccilsr2::R](iccilsr2::R) reader structure" ] impl crate :: Readable for ICCILSR2 { }
# [ doc = "`write(|w| ..)` method takes [iccilsr2::W](iccilsr2::W) writer structure" ] impl crate :: Writable for ICCILSR2 { }
# [ doc = "ICCILSR2" ] pub mod iccilsr2 {
# [ doc = "Reader of register ICCILSR2" ] pub type R = crate :: R < u16 , super :: ICCILSR2 > ;
# [ doc = "Writer for register ICCILSR2" ] pub type W = crate :: W < u16 , super :: ICCILSR2 > ;
# [ doc = "Register ICCILSR2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ICCILSR2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ILSR16`" ] pub type ILSR16_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR16`" ] pub struct ILSR16_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR16_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `ILSR17`" ] pub type ILSR17_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR17`" ] pub struct ILSR17_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR17_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u16 ) & 0x03 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `ILSR18`" ] pub type ILSR18_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR18`" ] pub struct ILSR18_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR18_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `ILSR19`" ] pub type ILSR19_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR19`" ] pub struct ILSR19_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR19_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `ILSR20`" ] pub type ILSR20_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR20`" ] pub struct ILSR20_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR20_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `ILSR21`" ] pub type ILSR21_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR21`" ] pub struct ILSR21_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR21_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u16 ) & 0x03 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `ILSR22`" ] pub type ILSR22_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR22`" ] pub struct ILSR22_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR22_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `ILSR23`" ] pub type ILSR23_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR23`" ] pub struct ILSR23_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR23_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr16 ( & self ) -> ILSR16_R { ILSR16_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 2:3 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit" ] # [ inline ( always ) ] pub fn ilsr17 ( & self ) -> ILSR17_R { ILSR17_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 4:5 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr18 ( & self ) -> ILSR18_R { ILSR18_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 6:7 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr19 ( & self ) -> ILSR19_R { ILSR19_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:9 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr20 ( & self ) -> ILSR20_R { ILSR20_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 10:11 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr21 ( & self ) -> ILSR21_R { ILSR21_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 12:13 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each" ] # [ inline ( always ) ] pub fn ilsr22 ( & self ) -> ILSR22_R { ILSR22_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each" ] # [ inline ( always ) ] pub fn ilsr23 ( & self ) -> ILSR23_R { ILSR23_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr16 ( & mut self ) -> ILSR16_W { ILSR16_W { w : self } }
# [ doc = "Bits 2:3 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit" ] # [ inline ( always ) ] pub fn ilsr17 ( & mut self ) -> ILSR17_W { ILSR17_W { w : self } }
# [ doc = "Bits 4:5 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr18 ( & mut self ) -> ILSR18_W { ILSR18_W { w : self } }
# [ doc = "Bits 6:7 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr19 ( & mut self ) -> ILSR19_W { ILSR19_W { w : self } }
# [ doc = "Bits 8:9 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr20 ( & mut self ) -> ILSR20_W { ILSR20_W { w : self } }
# [ doc = "Bits 10:11 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr21 ( & mut self ) -> ILSR21_W { ILSR21_W { w : self } }
# [ doc = "Bits 12:13 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each" ] # [ inline ( always ) ] pub fn ilsr22 ( & mut self ) -> ILSR22_W { ILSR22_W { w : self } }
# [ doc = "Bits 14:15 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each" ] # [ inline ( always ) ] pub fn ilsr23 ( & mut self ) -> ILSR23_W { ILSR23_W { w : self } }
}
}
# [ doc = "ICCILSR3\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [iccilsr3](iccilsr3) module" ] pub type ICCILSR3 = crate :: Reg < u16 , _ICCILSR3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ICCILSR3 ;
# [ doc = "`read()` method returns [iccilsr3::R](iccilsr3::R) reader structure" ] impl crate :: Readable for ICCILSR3 { }
# [ doc = "`write(|w| ..)` method takes [iccilsr3::W](iccilsr3::W) writer structure" ] impl crate :: Writable for ICCILSR3 { }
# [ doc = "ICCILSR3" ] pub mod iccilsr3 {
# [ doc = "Reader of register ICCILSR3" ] pub type R = crate :: R < u16 , super :: ICCILSR3 > ;
# [ doc = "Writer for register ICCILSR3" ] pub type W = crate :: W < u16 , super :: ICCILSR3 > ;
# [ doc = "Register ICCILSR3 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ICCILSR3 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ILSR24`" ] pub type ILSR24_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR24`" ] pub struct ILSR24_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR24_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `ILSR25`" ] pub type ILSR25_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR25`" ] pub struct ILSR25_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR25_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u16 ) & 0x03 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `ILSR26`" ] pub type ILSR26_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR26`" ] pub struct ILSR26_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR26_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `ILSR27`" ] pub type ILSR27_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR27`" ] pub struct ILSR27_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR27_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `ILSR28`" ] pub type ILSR28_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR28`" ] pub struct ILSR28_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR28_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `ILSR29`" ] pub type ILSR29_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR29`" ] pub struct ILSR29_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR29_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u16 ) & 0x03 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `ILSR30`" ] pub type ILSR30_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR30`" ] pub struct ILSR30_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR30_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `ILSR31`" ] pub type ILSR31_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR31`" ] pub struct ILSR31_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR31_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr24 ( & self ) -> ILSR24_R { ILSR24_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 2:3 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr25 ( & self ) -> ILSR25_R { ILSR25_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 4:5 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr26 ( & self ) -> ILSR26_R { ILSR26_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 6:7 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr27 ( & self ) -> ILSR27_R { ILSR27_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:9 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr28 ( & self ) -> ILSR28_R { ILSR28_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 10:11 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr29 ( & self ) -> ILSR29_R { ILSR29_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 12:13 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr30 ( & self ) -> ILSR30_R { ILSR30_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr31 ( & self ) -> ILSR31_R { ILSR31_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr24 ( & mut self ) -> ILSR24_W { ILSR24_W { w : self } }
# [ doc = "Bits 2:3 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr25 ( & mut self ) -> ILSR25_W { ILSR25_W { w : self } }
# [ doc = "Bits 4:5 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr26 ( & mut self ) -> ILSR26_W { ILSR26_W { w : self } }
# [ doc = "Bits 6:7 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr27 ( & mut self ) -> ILSR27_W { ILSR27_W { w : self } }
# [ doc = "Bits 8:9 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr28 ( & mut self ) -> ILSR28_W { ILSR28_W { w : self } }
# [ doc = "Bits 10:11 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr29 ( & mut self ) -> ILSR29_W { ILSR29_W { w : self } }
# [ doc = "Bits 12:13 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr30 ( & mut self ) -> ILSR30_W { ILSR30_W { w : self } }
# [ doc = "Bits 14:15 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr31 ( & mut self ) -> ILSR31_W { ILSR31_W { w : self } }
}
}
}
# [ doc = "ADC" ] pub struct ADC { _marker : PhantomData < * const ( ) > } unsafe impl Send for ADC { } impl ADC { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const adc :: RegisterBlock { 0x0700 as * const _ } } impl Deref for ADC { type Target = adc :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * ADC :: ptr ( ) } } }
# [ doc = "ADC" ] pub mod adc {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - ADC Control 0" ] pub adcctl0 : ADCCTL0 , # [ doc = "0x02 - ADC Control 1" ] pub adcctl1 : ADCCTL1 , # [ doc = "0x04 - ADC Control 2" ] pub adcctl2 : ADCCTL2 , # [ doc = "0x06 - ADC Window Comparator Low Threshold Register" ] pub adclo : ADCLO , # [ doc = "0x08 - ADC Window Comparator High Threshold Register" ] pub adchi : ADCHI , # [ doc = "0x0a - ADC Conversion Memory Control Register" ] pub adcmctl0 : ADCMCTL0 , _reserved6 : [ u8 ; 6usize ] , # [ doc = "0x12 - ADC Conversion Memory Register" ] pub adcmem0 : ADCMEM0 , _reserved7 : [ u8 ; 6usize ] , # [ doc = "0x1a - ADC Interrupt Enable 0" ] pub adcie : ADCIE , # [ doc = "0x1c - ADC Interrupt Flag" ] pub adcifg : ADCIFG , # [ doc = "0x1e - ADC Interrupt Vector" ] pub adciv : ADCIV , }
# [ doc = "ADC Control 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcctl0](adcctl0) module" ] pub type ADCCTL0 = crate :: Reg < u16 , _ADCCTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADCCTL0 ;
# [ doc = "`read()` method returns [adcctl0::R](adcctl0::R) reader structure" ] impl crate :: Readable for ADCCTL0 { }
# [ doc = "`write(|w| ..)` method takes [adcctl0::W](adcctl0::W) writer structure" ] impl crate :: Writable for ADCCTL0 { }
# [ doc = "ADC Control 0" ] pub mod adcctl0 {
# [ doc = "Reader of register ADCCTL0" ] pub type R = crate :: R < u16 , super :: ADCCTL0 > ;
# [ doc = "Writer for register ADCCTL0" ] pub type W = crate :: W < u16 , super :: ADCCTL0 > ;
# [ doc = "Register ADCCTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADCCTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "start conversion\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCSC_A { # [ doc = "0: No sample-and-conversion-start" ] ADCSC_0 = 0 , # [ doc = "1: Start sample-and-conversion" ] ADCSC_1 = 1 } impl From < ADCSC_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCSC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCSC`" ] pub type ADCSC_R = crate :: R < bool , ADCSC_A > ; impl ADCSC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCSC_A { match self . bits { false => ADCSC_A :: ADCSC_0 , true => ADCSC_A :: ADCSC_1 } } # [ doc = "Checks if the value of the field is `ADCSC_0`" ] # [ inline ( always ) ] pub fn is_adcsc_0 ( & self ) -> bool { * self == ADCSC_A :: ADCSC_0 } # [ doc = "Checks if the value of the field is `ADCSC_1`" ] # [ inline ( always ) ] pub fn is_adcsc_1 ( & self ) -> bool { * self == ADCSC_A :: ADCSC_1 } }
# [ doc = "Write proxy for field `ADCSC`" ] pub struct ADCSC_W < 'a > { w : & 'a mut W , } impl < 'a > ADCSC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCSC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No sample-and-conversion-start" ] # [ inline ( always ) ] pub fn adcsc_0 ( self ) -> & 'a mut W { self . variant ( ADCSC_A :: ADCSC_0 ) } # [ doc = "Start sample-and-conversion" ] # [ inline ( always ) ] pub fn adcsc_1 ( self ) -> & 'a mut W { self . variant ( ADCSC_A :: ADCSC_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "enable conversion\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCENC_A { # [ doc = "0: ADC disabled" ] ADCENC_0 = 0 , # [ doc = "1: ADC enabled" ] ADCENC_1 = 1 } impl From < ADCENC_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCENC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCENC`" ] pub type ADCENC_R = crate :: R < bool , ADCENC_A > ; impl ADCENC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCENC_A { match self . bits { false => ADCENC_A :: ADCENC_0 , true => ADCENC_A :: ADCENC_1 } } # [ doc = "Checks if the value of the field is `ADCENC_0`" ] # [ inline ( always ) ] pub fn is_adcenc_0 ( & self ) -> bool { * self == ADCENC_A :: ADCENC_0 } # [ doc = "Checks if the value of the field is `ADCENC_1`" ] # [ inline ( always ) ] pub fn is_adcenc_1 ( & self ) -> bool { * self == ADCENC_A :: ADCENC_1 } }
# [ doc = "Write proxy for field `ADCENC`" ] pub struct ADCENC_W < 'a > { w : & 'a mut W , } impl < 'a > ADCENC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCENC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "ADC disabled" ] # [ inline ( always ) ] pub fn adcenc_0 ( self ) -> & 'a mut W { self . variant ( ADCENC_A :: ADCENC_0 ) } # [ doc = "ADC enabled" ] # [ inline ( always ) ] pub fn adcenc_1 ( self ) -> & 'a mut W { self . variant ( ADCENC_A :: ADCENC_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "ADC on\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCON_A { # [ doc = "0: ADC off" ] ADCON_0 = 0 , # [ doc = "1: ADC on" ] ADCON_1 = 1 } impl From < ADCON_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCON_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCON`" ] pub type ADCON_R = crate :: R < bool , ADCON_A > ; impl ADCON_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCON_A { match self . bits { false => ADCON_A :: ADCON_0 , true => ADCON_A :: ADCON_1 } } # [ doc = "Checks if the value of the field is `ADCON_0`" ] # [ inline ( always ) ] pub fn is_adcon_0 ( & self ) -> bool { * self == ADCON_A :: ADCON_0 } # [ doc = "Checks if the value of the field is `ADCON_1`" ] # [ inline ( always ) ] pub fn is_adcon_1 ( & self ) -> bool { * self == ADCON_A :: ADCON_1 } }
# [ doc = "Write proxy for field `ADCON`" ] pub struct ADCON_W < 'a > { w : & 'a mut W , } impl < 'a > ADCON_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCON_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "ADC off" ] # [ inline ( always ) ] pub fn adcon_0 ( self ) -> & 'a mut W { self . variant ( ADCON_A :: ADCON_0 ) } # [ doc = "ADC on" ] # [ inline ( always ) ] pub fn adcon_1 ( self ) -> & 'a mut W { self . variant ( ADCON_A :: ADCON_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "sample-and-hold time.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCMSC_A { # [ doc = "0: The sampling timer requires a rising edge of the SHI signal to trigger each sample-and-convert." ] ADCMSC_0 = 0 , # [ doc = "1: The incidence of a positive(or for devices first rising edge of the) SHI signal triggers the sampling timer, but further sample-and-conversions are performed automatically as soon as the prior conversion is completed." ] ADCMSC_1 = 1 } impl From < ADCMSC_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCMSC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCMSC`" ] pub type ADCMSC_R = crate :: R < bool , ADCMSC_A > ; impl ADCMSC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCMSC_A { match self . bits { false => ADCMSC_A :: ADCMSC_0 , true => ADCMSC_A :: ADCMSC_1 } } # [ doc = "Checks if the value of the field is `ADCMSC_0`" ] # [ inline ( always ) ] pub fn is_adcmsc_0 ( & self ) -> bool { * self == ADCMSC_A :: ADCMSC_0 } # [ doc = "Checks if the value of the field is `ADCMSC_1`" ] # [ inline ( always ) ] pub fn is_adcmsc_1 ( & self ) -> bool { * self == ADCMSC_A :: ADCMSC_1 } }
# [ doc = "Write proxy for field `ADCMSC`" ] pub struct ADCMSC_W < 'a > { w : & 'a mut W , } impl < 'a > ADCMSC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCMSC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The sampling timer requires a rising edge of the SHI signal to trigger each sample-and-convert." ] # [ inline ( always ) ] pub fn adcmsc_0 ( self ) -> & 'a mut W { self . variant ( ADCMSC_A :: ADCMSC_0 ) } # [ doc = "The incidence of a positive(or for devices first rising edge of the) SHI signal triggers the sampling timer, but further sample-and-conversions are performed automatically as soon as the prior conversion is completed." ] # [ inline ( always ) ] pub fn adcmsc_1 ( self ) -> & 'a mut W { self . variant ( ADCMSC_A :: ADCMSC_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "sample-and-hold time.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ADCSHT_A { # [ doc = "0: 4 ADCCLK cycles" ] ADCSHT_0 = 0 , # [ doc = "1: 8 ADCCLK cycles" ] ADCSHT_1 = 1 , # [ doc = "2: 16 ADCCLK cycles" ] ADCSHT_2 = 2 , # [ doc = "3: 32 ADCCLK cycles" ] ADCSHT_3 = 3 , # [ doc = "4: 64 ADCCLK cycles" ] ADCSHT_4 = 4 , # [ doc = "5: 96 ADCCLK cycles" ] ADCSHT_5 = 5 , # [ doc = "6: 128 ADCCLK cycles" ] ADCSHT_6 = 6 , # [ doc = "7: 192 ADCCLK cycles" ] ADCSHT_7 = 7 , # [ doc = "8: 256 ADCCLK cycles" ] ADCSHT_8 = 8 , # [ doc = "9: 384 ADCCLK cycles" ] ADCSHT_9 = 9 , # [ doc = "10: 512 ADCCLK cycles" ] ADCSHT_10 = 10 , # [ doc = "11: 768 ADCCLK cycles" ] ADCSHT_11 = 11 , # [ doc = "12: 1024 ADCCLK cycles" ] ADCSHT_12 = 12 , # [ doc = "13: 1024 ADCCLK cycles" ] ADCSHT_13 = 13 , # [ doc = "14: 1024 ADCCLK cycles" ] ADCSHT_14 = 14 , # [ doc = "15: 1024 ADCCLK cycles" ] ADCSHT_15 = 15 } impl From < ADCSHT_A > for u8 { # [ inline ( always ) ] fn from ( variant : ADCSHT_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ADCSHT`" ] pub type ADCSHT_R = crate :: R < u8 , ADCSHT_A > ; impl ADCSHT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCSHT_A { match self . bits { 0 => ADCSHT_A :: ADCSHT_0 , 1 => ADCSHT_A :: ADCSHT_1 , 2 => ADCSHT_A :: ADCSHT_2 , 3 => ADCSHT_A :: ADCSHT_3 , 4 => ADCSHT_A :: ADCSHT_4 , 5 => ADCSHT_A :: ADCSHT_5 , 6 => ADCSHT_A :: ADCSHT_6 , 7 => ADCSHT_A :: ADCSHT_7 , 8 => ADCSHT_A :: ADCSHT_8 , 9 => ADCSHT_A :: ADCSHT_9 , 10 => ADCSHT_A :: ADCSHT_10 , 11 => ADCSHT_A :: ADCSHT_11 , 12 => ADCSHT_A :: ADCSHT_12 , 13 => ADCSHT_A :: ADCSHT_13 , 14 => ADCSHT_A :: ADCSHT_14 , 15 => ADCSHT_A :: ADCSHT_15 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `ADCSHT_0`" ] # [ inline ( always ) ] pub fn is_adcsht_0 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_0 } # [ doc = "Checks if the value of the field is `ADCSHT_1`" ] # [ inline ( always ) ] pub fn is_adcsht_1 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_1 } # [ doc = "Checks if the value of the field is `ADCSHT_2`" ] # [ inline ( always ) ] pub fn is_adcsht_2 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_2 } # [ doc = "Checks if the value of the field is `ADCSHT_3`" ] # [ inline ( always ) ] pub fn is_adcsht_3 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_3 } # [ doc = "Checks if the value of the field is `ADCSHT_4`" ] # [ inline ( always ) ] pub fn is_adcsht_4 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_4 } # [ doc = "Checks if the value of the field is `ADCSHT_5`" ] # [ inline ( always ) ] pub fn is_adcsht_5 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_5 } # [ doc = "Checks if the value of the field is `ADCSHT_6`" ] # [ inline ( always ) ] pub fn is_adcsht_6 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_6 } # [ doc = "Checks if the value of the field is `ADCSHT_7`" ] # [ inline ( always ) ] pub fn is_adcsht_7 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_7 } # [ doc = "Checks if the value of the field is `ADCSHT_8`" ] # [ inline ( always ) ] pub fn is_adcsht_8 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_8 } # [ doc = "Checks if the value of the field is `ADCSHT_9`" ] # [ inline ( always ) ] pub fn is_adcsht_9 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_9 } # [ doc = "Checks if the value of the field is `ADCSHT_10`" ] # [ inline ( always ) ] pub fn is_adcsht_10 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_10 } # [ doc = "Checks if the value of the field is `ADCSHT_11`" ] # [ inline ( always ) ] pub fn is_adcsht_11 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_11 } # [ doc = "Checks if the value of the field is `ADCSHT_12`" ] # [ inline ( always ) ] pub fn is_adcsht_12 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_12 } # [ doc = "Checks if the value of the field is `ADCSHT_13`" ] # [ inline ( always ) ] pub fn is_adcsht_13 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_13 } # [ doc = "Checks if the value of the field is `ADCSHT_14`" ] # [ inline ( always ) ] pub fn is_adcsht_14 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_14 } # [ doc = "Checks if the value of the field is `ADCSHT_15`" ] # [ inline ( always ) ] pub fn is_adcsht_15 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_15 } }
# [ doc = "Write proxy for field `ADCSHT`" ] pub struct ADCSHT_W < 'a > { w : & 'a mut W , } impl < 'a > ADCSHT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCSHT_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "4 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_0 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_0 ) } # [ doc = "8 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_1 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_1 ) } # [ doc = "16 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_2 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_2 ) } # [ doc = "32 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_3 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_3 ) } # [ doc = "64 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_4 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_4 ) } # [ doc = "96 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_5 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_5 ) } # [ doc = "128 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_6 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_6 ) } # [ doc = "192 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_7 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_7 ) } # [ doc = "256 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_8 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_8 ) } # [ doc = "384 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_9 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_9 ) } # [ doc = "512 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_10 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_10 ) } # [ doc = "768 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_11 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_11 ) } # [ doc = "1024 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_12 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_12 ) } # [ doc = "1024 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_13 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_13 ) } # [ doc = "1024 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_14 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_14 ) } # [ doc = "1024 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_15 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_15 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 8 ) ) | ( ( ( value as u16 ) & 0x0f ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - start conversion" ] # [ inline ( always ) ] pub fn adcsc ( & self ) -> ADCSC_R { ADCSC_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - enable conversion" ] # [ inline ( always ) ] pub fn adcenc ( & self ) -> ADCENC_R { ADCENC_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - ADC on" ] # [ inline ( always ) ] pub fn adcon ( & self ) -> ADCON_R { ADCON_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - sample-and-hold time." ] # [ inline ( always ) ] pub fn adcmsc ( & self ) -> ADCMSC_R { ADCMSC_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:11 - sample-and-hold time." ] # [ inline ( always ) ] pub fn adcsht ( & self ) -> ADCSHT_R { ADCSHT_R :: new ( ( ( self . bits >> 8 ) & 0x0f ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - start conversion" ] # [ inline ( always ) ] pub fn adcsc ( & mut self ) -> ADCSC_W { ADCSC_W { w : self } }
# [ doc = "Bit 1 - enable conversion" ] # [ inline ( always ) ] pub fn adcenc ( & mut self ) -> ADCENC_W { ADCENC_W { w : self } }
# [ doc = "Bit 4 - ADC on" ] # [ inline ( always ) ] pub fn adcon ( & mut self ) -> ADCON_W { ADCON_W { w : self } }
# [ doc = "Bit 7 - sample-and-hold time." ] # [ inline ( always ) ] pub fn adcmsc ( & mut self ) -> ADCMSC_W { ADCMSC_W { w : self } }
# [ doc = "Bits 8:11 - sample-and-hold time." ] # [ inline ( always ) ] pub fn adcsht ( & mut self ) -> ADCSHT_W { ADCSHT_W { w : self } }
}
}
# [ doc = "ADC Control 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcctl1](adcctl1) module" ] pub type ADCCTL1 = crate :: Reg < u16 , _ADCCTL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADCCTL1 ;
# [ doc = "`read()` method returns [adcctl1::R](adcctl1::R) reader structure" ] impl crate :: Readable for ADCCTL1 { }
# [ doc = "`write(|w| ..)` method takes [adcctl1::W](adcctl1::W) writer structure" ] impl crate :: Writable for ADCCTL1 { }
# [ doc = "ADC Control 1" ] pub mod adcctl1 {
# [ doc = "Reader of register ADCCTL1" ] pub type R = crate :: R < u16 , super :: ADCCTL1 > ;
# [ doc = "Writer for register ADCCTL1" ] pub type W = crate :: W < u16 , super :: ADCCTL1 > ;
# [ doc = "Register ADCCTL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADCCTL1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "ADC busy\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCBUSY_A { # [ doc = "0: No operation is active." ] ADCBUSY_0 = 0 , # [ doc = "1: A sequence, sample, or conversion is active." ] ADCBUSY_1 = 1 } impl From < ADCBUSY_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCBUSY_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCBUSY`" ] pub type ADCBUSY_R = crate :: R < bool , ADCBUSY_A > ; impl ADCBUSY_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCBUSY_A { match self . bits { false => ADCBUSY_A :: ADCBUSY_0 , true => ADCBUSY_A :: ADCBUSY_1 } } # [ doc = "Checks if the value of the field is `ADCBUSY_0`" ] # [ inline ( always ) ] pub fn is_adcbusy_0 ( & self ) -> bool { * self == ADCBUSY_A :: ADCBUSY_0 } # [ doc = "Checks if the value of the field is `ADCBUSY_1`" ] # [ inline ( always ) ] pub fn is_adcbusy_1 ( & self ) -> bool { * self == ADCBUSY_A :: ADCBUSY_1 } }
# [ doc = "conversion sequence mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ADCCONSEQ_A { # [ doc = "0: Single-channel, single-conversion" ] ADCCONSEQ_0 = 0 , # [ doc = "1: Sequence-of-channels" ] ADCCONSEQ_1 = 1 , # [ doc = "2: Repeat-single-channel" ] ADCCONSEQ_2 = 2 , # [ doc = "3: Repeat-sequence-of-channels" ] ADCCONSEQ_3 = 3 } impl From < ADCCONSEQ_A > for u8 { # [ inline ( always ) ] fn from ( variant : ADCCONSEQ_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ADCCONSEQ`" ] pub type ADCCONSEQ_R = crate :: R < u8 , ADCCONSEQ_A > ; impl ADCCONSEQ_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCCONSEQ_A { match self . bits { 0 => ADCCONSEQ_A :: ADCCONSEQ_0 , 1 => ADCCONSEQ_A :: ADCCONSEQ_1 , 2 => ADCCONSEQ_A :: ADCCONSEQ_2 , 3 => ADCCONSEQ_A :: ADCCONSEQ_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `ADCCONSEQ_0`" ] # [ inline ( always ) ] pub fn is_adcconseq_0 ( & self ) -> bool { * self == ADCCONSEQ_A :: ADCCONSEQ_0 } # [ doc = "Checks if the value of the field is `ADCCONSEQ_1`" ] # [ inline ( always ) ] pub fn is_adcconseq_1 ( & self ) -> bool { * self == ADCCONSEQ_A :: ADCCONSEQ_1 } # [ doc = "Checks if the value of the field is `ADCCONSEQ_2`" ] # [ inline ( always ) ] pub fn is_adcconseq_2 ( & self ) -> bool { * self == ADCCONSEQ_A :: ADCCONSEQ_2 } # [ doc = "Checks if the value of the field is `ADCCONSEQ_3`" ] # [ inline ( always ) ] pub fn is_adcconseq_3 ( & self ) -> bool { * self == ADCCONSEQ_A :: ADCCONSEQ_3 } }
# [ doc = "Write proxy for field `ADCCONSEQ`" ] pub struct ADCCONSEQ_W < 'a > { w : & 'a mut W , } impl < 'a > ADCCONSEQ_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCCONSEQ_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Single-channel, single-conversion" ] # [ inline ( always ) ] pub fn adcconseq_0 ( self ) -> & 'a mut W { self . variant ( ADCCONSEQ_A :: ADCCONSEQ_0 ) } # [ doc = "Sequence-of-channels" ] # [ inline ( always ) ] pub fn adcconseq_1 ( self ) -> & 'a mut W { self . variant ( ADCCONSEQ_A :: ADCCONSEQ_1 ) } # [ doc = "Repeat-single-channel" ] # [ inline ( always ) ] pub fn adcconseq_2 ( self ) -> & 'a mut W { self . variant ( ADCCONSEQ_A :: ADCCONSEQ_2 ) } # [ doc = "Repeat-sequence-of-channels" ] # [ inline ( always ) ] pub fn adcconseq_3 ( self ) -> & 'a mut W { self . variant ( ADCCONSEQ_A :: ADCCONSEQ_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 1 ) ) | ( ( ( value as u16 ) & 0x03 ) << 1 ) ; self . w } }
# [ doc = "clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ADCSSEL_A { # [ doc = "0: ADCOSC (MODOSC)" ] ADCSSEL_0 = 0 , # [ doc = "1: ACLK" ] ADCSSEL_1 = 1 , # [ doc = "2: MCLK" ] ADCSSEL_2 = 2 , # [ doc = "3: SMCLK" ] ADCSSEL_3 = 3 } impl From < ADCSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : ADCSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ADCSSEL`" ] pub type ADCSSEL_R = crate :: R < u8 , ADCSSEL_A > ; impl ADCSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCSSEL_A { match self . bits { 0 => ADCSSEL_A :: ADCSSEL_0 , 1 => ADCSSEL_A :: ADCSSEL_1 , 2 => ADCSSEL_A :: ADCSSEL_2 , 3 => ADCSSEL_A :: ADCSSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `ADCSSEL_0`" ] # [ inline ( always ) ] pub fn is_adcssel_0 ( & self ) -> bool { * self == ADCSSEL_A :: ADCSSEL_0 } # [ doc = "Checks if the value of the field is `ADCSSEL_1`" ] # [ inline ( always ) ] pub fn is_adcssel_1 ( & self ) -> bool { * self == ADCSSEL_A :: ADCSSEL_1 } # [ doc = "Checks if the value of the field is `ADCSSEL_2`" ] # [ inline ( always ) ] pub fn is_adcssel_2 ( & self ) -> bool { * self == ADCSSEL_A :: ADCSSEL_2 } # [ doc = "Checks if the value of the field is `ADCSSEL_3`" ] # [ inline ( always ) ] pub fn is_adcssel_3 ( & self ) -> bool { * self == ADCSSEL_A :: ADCSSEL_3 } }
# [ doc = "Write proxy for field `ADCSSEL`" ] pub struct ADCSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > ADCSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "ADCOSC (MODOSC)" ] # [ inline ( always ) ] pub fn adcssel_0 ( self ) -> & 'a mut W { self . variant ( ADCSSEL_A :: ADCSSEL_0 ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn adcssel_1 ( self ) -> & 'a mut W { self . variant ( ADCSSEL_A :: ADCSSEL_1 ) } # [ doc = "MCLK" ] # [ inline ( always ) ] pub fn adcssel_2 ( self ) -> & 'a mut W { self . variant ( ADCSSEL_A :: ADCSSEL_2 ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn adcssel_3 ( self ) -> & 'a mut W { self . variant ( ADCSSEL_A :: ADCSSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 3 ) ) | ( ( ( value as u16 ) & 0x03 ) << 3 ) ; self . w } }
# [ doc = "clock divider\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ADCDIV_A { # [ doc = "0: /1" ] ADCDIV_0 = 0 , # [ doc = "1: /2" ] ADCDIV_1 = 1 , # [ doc = "2: /3" ] ADCDIV_2 = 2 , # [ doc = "3: /4" ] ADCDIV_3 = 3 , # [ doc = "4: /5" ] ADCDIV_4 = 4 , # [ doc = "5: /6" ] ADCDIV_5 = 5 , # [ doc = "6: /7" ] ADCDIV_6 = 6 , # [ doc = "7: /8" ] ADCDIV_7 = 7 } impl From < ADCDIV_A > for u8 { # [ inline ( always ) ] fn from ( variant : ADCDIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ADCDIV`" ] pub type ADCDIV_R = crate :: R < u8 , ADCDIV_A > ; impl ADCDIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCDIV_A { match self . bits { 0 => ADCDIV_A :: ADCDIV_0 , 1 => ADCDIV_A :: ADCDIV_1 , 2 => ADCDIV_A :: ADCDIV_2 , 3 => ADCDIV_A :: ADCDIV_3 , 4 => ADCDIV_A :: ADCDIV_4 , 5 => ADCDIV_A :: ADCDIV_5 , 6 => ADCDIV_A :: ADCDIV_6 , 7 => ADCDIV_A :: ADCDIV_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `ADCDIV_0`" ] # [ inline ( always ) ] pub fn is_adcdiv_0 ( & self ) -> bool { * self == ADCDIV_A :: ADCDIV_0 } # [ doc = "Checks if the value of the field is `ADCDIV_1`" ] # [ inline ( always ) ] pub fn is_adcdiv_1 ( & self ) -> bool { * self == ADCDIV_A :: ADCDIV_1 } # [ doc = "Checks if the value of the field is `ADCDIV_2`" ] # [ inline ( always ) ] pub fn is_adcdiv_2 ( & self ) -> bool { * self == ADCDIV_A :: ADCDIV_2 } # [ doc = "Checks if the value of the field is `ADCDIV_3`" ] # [ inline ( always ) ] pub fn is_adcdiv_3 ( & self ) -> bool { * self == ADCDIV_A :: ADCDIV_3 } # [ doc = "Checks if the value of the field is `ADCDIV_4`" ] # [ inline ( always ) ] pub fn is_adcdiv_4 ( & self ) -> bool { * self == ADCDIV_A :: ADCDIV_4 } # [ doc = "Checks if the value of the field is `ADCDIV_5`" ] # [ inline ( always ) ] pub fn is_adcdiv_5 ( & self ) -> bool { * self == ADCDIV_A :: ADCDIV_5 } # [ doc = "Checks if the value of the field is `ADCDIV_6`" ] # [ inline ( always ) ] pub fn is_adcdiv_6 ( & self ) -> bool { * self == ADCDIV_A :: ADCDIV_6 } # [ doc = "Checks if the value of the field is `ADCDIV_7`" ] # [ inline ( always ) ] pub fn is_adcdiv_7 ( & self ) -> bool { * self == ADCDIV_A :: ADCDIV_7 } }
# [ doc = "Write proxy for field `ADCDIV`" ] pub struct ADCDIV_W < 'a > { w : & 'a mut W , } impl < 'a > ADCDIV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCDIV_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "/1" ] # [ inline ( always ) ] pub fn adcdiv_0 ( self ) -> & 'a mut W { self . variant ( ADCDIV_A :: ADCDIV_0 ) } # [ doc = "/2" ] # [ inline ( always ) ] pub fn adcdiv_1 ( self ) -> & 'a mut W { self . variant ( ADCDIV_A :: ADCDIV_1 ) } # [ doc = "/3" ] # [ inline ( always ) ] pub fn adcdiv_2 ( self ) -> & 'a mut W { self . variant ( ADCDIV_A :: ADCDIV_2 ) } # [ doc = "/4" ] # [ inline ( always ) ] pub fn adcdiv_3 ( self ) -> & 'a mut W { self . variant ( ADCDIV_A :: ADCDIV_3 ) } # [ doc = "/5" ] # [ inline ( always ) ] pub fn adcdiv_4 ( self ) -> & 'a mut W { self . variant ( ADCDIV_A :: ADCDIV_4 ) } # [ doc = "/6" ] # [ inline ( always ) ] pub fn adcdiv_5 ( self ) -> & 'a mut W { self . variant ( ADCDIV_A :: ADCDIV_5 ) } # [ doc = "/7" ] # [ inline ( always ) ] pub fn adcdiv_6 ( self ) -> & 'a mut W { self . variant ( ADCDIV_A :: ADCDIV_6 ) } # [ doc = "/8" ] # [ inline ( always ) ] pub fn adcdiv_7 ( self ) -> & 'a mut W { self . variant ( ADCDIV_A :: ADCDIV_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "invert signal sample-and-hold\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCISSH_A { # [ doc = "0: The sample-input signal is not inverted." ] ADCISSH_0 = 0 , # [ doc = "1: The sample-input signal is inverted." ] ADCISSH_1 = 1 } impl From < ADCISSH_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCISSH_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCISSH`" ] pub type ADCISSH_R = crate :: R < bool , ADCISSH_A > ; impl ADCISSH_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCISSH_A { match self . bits { false => ADCISSH_A :: ADCISSH_0 , true => ADCISSH_A :: ADCISSH_1 } } # [ doc = "Checks if the value of the field is `ADCISSH_0`" ] # [ inline ( always ) ] pub fn is_adcissh_0 ( & self ) -> bool { * self == ADCISSH_A :: ADCISSH_0 } # [ doc = "Checks if the value of the field is `ADCISSH_1`" ] # [ inline ( always ) ] pub fn is_adcissh_1 ( & self ) -> bool { * self == ADCISSH_A :: ADCISSH_1 } }
# [ doc = "Write proxy for field `ADCISSH`" ] pub struct ADCISSH_W < 'a > { w : & 'a mut W , } impl < 'a > ADCISSH_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCISSH_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The sample-input signal is not inverted." ] # [ inline ( always ) ] pub fn adcissh_0 ( self ) -> & 'a mut W { self . variant ( ADCISSH_A :: ADCISSH_0 ) } # [ doc = "The sample-input signal is inverted." ] # [ inline ( always ) ] pub fn adcissh_1 ( self ) -> & 'a mut W { self . variant ( ADCISSH_A :: ADCISSH_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "sample-and-hold pulse-mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCSHP_A { # [ doc = "0: SAMPCON signal is sourced from the sample-input signal." ] ADCSHP_0 = 0 , # [ doc = "1: SAMPCON signal is sourced from the sampling timer." ] ADCSHP_1 = 1 } impl From < ADCSHP_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCSHP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCSHP`" ] pub type ADCSHP_R = crate :: R < bool , ADCSHP_A > ; impl ADCSHP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCSHP_A { match self . bits { false => ADCSHP_A :: ADCSHP_0 , true => ADCSHP_A :: ADCSHP_1 } } # [ doc = "Checks if the value of the field is `ADCSHP_0`" ] # [ inline ( always ) ] pub fn is_adcshp_0 ( & self ) -> bool { * self == ADCSHP_A :: ADCSHP_0 } # [ doc = "Checks if the value of the field is `ADCSHP_1`" ] # [ inline ( always ) ] pub fn is_adcshp_1 ( & self ) -> bool { * self == ADCSHP_A :: ADCSHP_1 } }
# [ doc = "Write proxy for field `ADCSHP`" ] pub struct ADCSHP_W < 'a > { w : & 'a mut W , } impl < 'a > ADCSHP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCSHP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SAMPCON signal is sourced from the sample-input signal." ] # [ inline ( always ) ] pub fn adcshp_0 ( self ) -> & 'a mut W { self . variant ( ADCSHP_A :: ADCSHP_0 ) } # [ doc = "SAMPCON signal is sourced from the sampling timer." ] # [ inline ( always ) ] pub fn adcshp_1 ( self ) -> & 'a mut W { self . variant ( ADCSHP_A :: ADCSHP_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "sample-and-hold source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ADCSHS_A { # [ doc = "0: ADCSC bit" ] ADCSHS_0 = 0 , # [ doc = "1: see the device-specific data sheet for source" ] ADCSHS_1 = 1 , # [ doc = "2: see the device-specific data sheet for source" ] ADCSHS_2 = 2 , # [ doc = "3: see the device-specific data sheet for source" ] ADCSHS_3 = 3 } impl From < ADCSHS_A > for u8 { # [ inline ( always ) ] fn from ( variant : ADCSHS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ADCSHS`" ] pub type ADCSHS_R = crate :: R < u8 , ADCSHS_A > ; impl ADCSHS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCSHS_A { match self . bits { 0 => ADCSHS_A :: ADCSHS_0 , 1 => ADCSHS_A :: ADCSHS_1 , 2 => ADCSHS_A :: ADCSHS_2 , 3 => ADCSHS_A :: ADCSHS_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `ADCSHS_0`" ] # [ inline ( always ) ] pub fn is_adcshs_0 ( & self ) -> bool { * self == ADCSHS_A :: ADCSHS_0 } # [ doc = "Checks if the value of the field is `ADCSHS_1`" ] # [ inline ( always ) ] pub fn is_adcshs_1 ( & self ) -> bool { * self == ADCSHS_A :: ADCSHS_1 } # [ doc = "Checks if the value of the field is `ADCSHS_2`" ] # [ inline ( always ) ] pub fn is_adcshs_2 ( & self ) -> bool { * self == ADCSHS_A :: ADCSHS_2 } # [ doc = "Checks if the value of the field is `ADCSHS_3`" ] # [ inline ( always ) ] pub fn is_adcshs_3 ( & self ) -> bool { * self == ADCSHS_A :: ADCSHS_3 } }
# [ doc = "Write proxy for field `ADCSHS`" ] pub struct ADCSHS_W < 'a > { w : & 'a mut W , } impl < 'a > ADCSHS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCSHS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "ADCSC bit" ] # [ inline ( always ) ] pub fn adcshs_0 ( self ) -> & 'a mut W { self . variant ( ADCSHS_A :: ADCSHS_0 ) } # [ doc = "see the device-specific data sheet for source" ] # [ inline ( always ) ] pub fn adcshs_1 ( self ) -> & 'a mut W { self . variant ( ADCSHS_A :: ADCSHS_1 ) } # [ doc = "see the device-specific data sheet for source" ] # [ inline ( always ) ] pub fn adcshs_2 ( self ) -> & 'a mut W { self . variant ( ADCSHS_A :: ADCSHS_2 ) } # [ doc = "see the device-specific data sheet for source" ] # [ inline ( always ) ] pub fn adcshs_3 ( self ) -> & 'a mut W { self . variant ( ADCSHS_A :: ADCSHS_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u16 ) & 0x03 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - ADC busy" ] # [ inline ( always ) ] pub fn adcbusy ( & self ) -> ADCBUSY_R { ADCBUSY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bits 1:2 - conversion sequence mode select" ] # [ inline ( always ) ] pub fn adcconseq ( & self ) -> ADCCONSEQ_R { ADCCONSEQ_R :: new ( ( ( self . bits >> 1 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 3:4 - clock source select" ] # [ inline ( always ) ] pub fn adcssel ( & self ) -> ADCSSEL_R { ADCSSEL_R :: new ( ( ( self . bits >> 3 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 5:7 - clock divider" ] # [ inline ( always ) ] pub fn adcdiv ( & self ) -> ADCDIV_R { ADCDIV_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - invert signal sample-and-hold" ] # [ inline ( always ) ] pub fn adcissh ( & self ) -> ADCISSH_R { ADCISSH_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - sample-and-hold pulse-mode select" ] # [ inline ( always ) ] pub fn adcshp ( & self ) -> ADCSHP_R { ADCSHP_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 10:11 - sample-and-hold source select" ] # [ inline ( always ) ] pub fn adcshs ( & self ) -> ADCSHS_R { ADCSHS_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 1:2 - conversion sequence mode select" ] # [ inline ( always ) ] pub fn adcconseq ( & mut self ) -> ADCCONSEQ_W { ADCCONSEQ_W { w : self } }
# [ doc = "Bits 3:4 - clock source select" ] # [ inline ( always ) ] pub fn adcssel ( & mut self ) -> ADCSSEL_W { ADCSSEL_W { w : self } }
# [ doc = "Bits 5:7 - clock divider" ] # [ inline ( always ) ] pub fn adcdiv ( & mut self ) -> ADCDIV_W { ADCDIV_W { w : self } }
# [ doc = "Bit 8 - invert signal sample-and-hold" ] # [ inline ( always ) ] pub fn adcissh ( & mut self ) -> ADCISSH_W { ADCISSH_W { w : self } }
# [ doc = "Bit 9 - sample-and-hold pulse-mode select" ] # [ inline ( always ) ] pub fn adcshp ( & mut self ) -> ADCSHP_W { ADCSHP_W { w : self } }
# [ doc = "Bits 10:11 - sample-and-hold source select" ] # [ inline ( always ) ] pub fn adcshs ( & mut self ) -> ADCSHS_W { ADCSHS_W { w : self } }
}
}
# [ doc = "ADC Control 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcctl2](adcctl2) module" ] pub type ADCCTL2 = crate :: Reg < u16 , _ADCCTL2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADCCTL2 ;
# [ doc = "`read()` method returns [adcctl2::R](adcctl2::R) reader structure" ] impl crate :: Readable for ADCCTL2 { }
# [ doc = "`write(|w| ..)` method takes [adcctl2::W](adcctl2::W) writer structure" ] impl crate :: Writable for ADCCTL2 { }
# [ doc = "ADC Control 2" ] pub mod adcctl2 {
# [ doc = "Reader of register ADCCTL2" ] pub type R = crate :: R < u16 , super :: ADCCTL2 > ;
# [ doc = "Writer for register ADCCTL2" ] pub type W = crate :: W < u16 , super :: ADCCTL2 > ;
# [ doc = "Register ADCCTL2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADCCTL2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "data read-back format\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCDF_A { # [ doc = "0: Binary unsigned. Theoretically the analog input voltage V(REF) results in 0000h, the analog input voltage +V(REF) results in 03FFh." ] ADCDF_0 = 0 , # [ doc = "1: Signed binary (2s complement), left aligned. Theoretically the analog input voltage V(REF) results in 8000h, the analog input voltage +V(REF) results in 7FC0h." ] ADCDF_1 = 1 } impl From < ADCDF_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCDF_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCDF`" ] pub type ADCDF_R = crate :: R < bool , ADCDF_A > ; impl ADCDF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCDF_A { match self . bits { false => ADCDF_A :: ADCDF_0 , true => ADCDF_A :: ADCDF_1 } } # [ doc = "Checks if the value of the field is `ADCDF_0`" ] # [ inline ( always ) ] pub fn is_adcdf_0 ( & self ) -> bool { * self == ADCDF_A :: ADCDF_0 } # [ doc = "Checks if the value of the field is `ADCDF_1`" ] # [ inline ( always ) ] pub fn is_adcdf_1 ( & self ) -> bool { * self == ADCDF_A :: ADCDF_1 } }
# [ doc = "Write proxy for field `ADCDF`" ] pub struct ADCDF_W < 'a > { w : & 'a mut W , } impl < 'a > ADCDF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCDF_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Binary unsigned. Theoretically the analog input voltage V(REF) results in 0000h, the analog input voltage +V(REF) results in 03FFh." ] # [ inline ( always ) ] pub fn adcdf_0 ( self ) -> & 'a mut W { self . variant ( ADCDF_A :: ADCDF_0 ) } # [ doc = "Signed binary (2s complement), left aligned. Theoretically the analog input voltage V(REF) results in 8000h, the analog input voltage +V(REF) results in 7FC0h." ] # [ inline ( always ) ] pub fn adcdf_1 ( self ) -> & 'a mut W { self . variant ( ADCDF_A :: ADCDF_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "resolution\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ADCRES_A { # [ doc = "0: 8 bit" ] ADCRES_0 = 0 , # [ doc = "1: 10 bit" ] ADCRES_1 = 1 , # [ doc = "2: 12 bit" ] ADCRES_2 = 2 , # [ doc = "3: Reserved" ] ADCRES_3 = 3 } impl From < ADCRES_A > for u8 { # [ inline ( always ) ] fn from ( variant : ADCRES_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ADCRES`" ] pub type ADCRES_R = crate :: R < u8 , ADCRES_A > ; impl ADCRES_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCRES_A { match self . bits { 0 => ADCRES_A :: ADCRES_0 , 1 => ADCRES_A :: ADCRES_1 , 2 => ADCRES_A :: ADCRES_2 , 3 => ADCRES_A :: ADCRES_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `ADCRES_0`" ] # [ inline ( always ) ] pub fn is_adcres_0 ( & self ) -> bool { * self == ADCRES_A :: ADCRES_0 } # [ doc = "Checks if the value of the field is `ADCRES_1`" ] # [ inline ( always ) ] pub fn is_adcres_1 ( & self ) -> bool { * self == ADCRES_A :: ADCRES_1 } # [ doc = "Checks if the value of the field is `ADCRES_2`" ] # [ inline ( always ) ] pub fn is_adcres_2 ( & self ) -> bool { * self == ADCRES_A :: ADCRES_2 } # [ doc = "Checks if the value of the field is `ADCRES_3`" ] # [ inline ( always ) ] pub fn is_adcres_3 ( & self ) -> bool { * self == ADCRES_A :: ADCRES_3 } }
# [ doc = "Write proxy for field `ADCRES`" ] pub struct ADCRES_W < 'a > { w : & 'a mut W , } impl < 'a > ADCRES_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCRES_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "8 bit" ] # [ inline ( always ) ] pub fn adcres_0 ( self ) -> & 'a mut W { self . variant ( ADCRES_A :: ADCRES_0 ) } # [ doc = "10 bit" ] # [ inline ( always ) ] pub fn adcres_1 ( self ) -> & 'a mut W { self . variant ( ADCRES_A :: ADCRES_1 ) } # [ doc = "12 bit" ] # [ inline ( always ) ] pub fn adcres_2 ( self ) -> & 'a mut W { self . variant ( ADCRES_A :: ADCRES_2 ) } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn adcres_3 ( self ) -> & 'a mut W { self . variant ( ADCRES_A :: ADCRES_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `ADCSR`" ] pub type ADCSR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ADCSR`" ] pub struct ADCSR_W < 'a > { w : & 'a mut W , } impl < 'a > ADCSR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "ADC predivider. This bit predivides the selected ADC clock source before it gets divided again using ADCDIVx.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ADCPDIV_A { # [ doc = "0: Predivide by 1" ] _1 = 0 , # [ doc = "1: Predivide by 4" ] _4 = 1 , # [ doc = "2: Predivide by 64" ] _64 = 2 , # [ doc = "3: Reserved" ] ADCPDIV_3 = 3 } impl From < ADCPDIV_A > for u8 { # [ inline ( always ) ] fn from ( variant : ADCPDIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ADCPDIV`" ] pub type ADCPDIV_R = crate :: R < u8 , ADCPDIV_A > ; impl ADCPDIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCPDIV_A { match self . bits { 0 => ADCPDIV_A :: _1 , 1 => ADCPDIV_A :: _4 , 2 => ADCPDIV_A :: _64 , 3 => ADCPDIV_A :: ADCPDIV_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == ADCPDIV_A :: _1 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == ADCPDIV_A :: _4 } # [ doc = "Checks if the value of the field is `_64`" ] # [ inline ( always ) ] pub fn is_64 ( & self ) -> bool { * self == ADCPDIV_A :: _64 } # [ doc = "Checks if the value of the field is `ADCPDIV_3`" ] # [ inline ( always ) ] pub fn is_adcpdiv_3 ( & self ) -> bool { * self == ADCPDIV_A :: ADCPDIV_3 } }
# [ doc = "Write proxy for field `ADCPDIV`" ] pub struct ADCPDIV_W < 'a > { w : & 'a mut W , } impl < 'a > ADCPDIV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCPDIV_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Predivide by 1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( ADCPDIV_A :: _1 ) } # [ doc = "Predivide by 4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( ADCPDIV_A :: _4 ) } # [ doc = "Predivide by 64" ] # [ inline ( always ) ] pub fn _64 ( self ) -> & 'a mut W { self . variant ( ADCPDIV_A :: _64 ) } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn adcpdiv_3 ( self ) -> & 'a mut W { self . variant ( ADCPDIV_A :: ADCPDIV_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bit 3 - data read-back format" ] # [ inline ( always ) ] pub fn adcdf ( & self ) -> ADCDF_R { ADCDF_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - resolution" ] # [ inline ( always ) ] pub fn adcres ( & self ) -> ADCRES_R { ADCRES_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 2 - ADC sampling rate." ] # [ inline ( always ) ] pub fn adcsr ( & self ) -> ADCSR_R { ADCSR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:9 - ADC predivider. This bit predivides the selected ADC clock source before it gets divided again using ADCDIVx." ] # [ inline ( always ) ] pub fn adcpdiv ( & self ) -> ADCPDIV_R { ADCPDIV_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 3 - data read-back format" ] # [ inline ( always ) ] pub fn adcdf ( & mut self ) -> ADCDF_W { ADCDF_W { w : self } }
# [ doc = "Bits 4:5 - resolution" ] # [ inline ( always ) ] pub fn adcres ( & mut self ) -> ADCRES_W { ADCRES_W { w : self } }
# [ doc = "Bit 2 - ADC sampling rate." ] # [ inline ( always ) ] pub fn adcsr ( & mut self ) -> ADCSR_W { ADCSR_W { w : self } }
# [ doc = "Bits 8:9 - ADC predivider. This bit predivides the selected ADC clock source before it gets divided again using ADCDIVx." ] # [ inline ( always ) ] pub fn adcpdiv ( & mut self ) -> ADCPDIV_W { ADCPDIV_W { w : self } }
}
}
# [ doc = "ADC Window Comparator Low Threshold Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adclo](adclo) module" ] pub type ADCLO = crate :: Reg < u16 , _ADCLO > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADCLO ;
# [ doc = "`read()` method returns [adclo::R](adclo::R) reader structure" ] impl crate :: Readable for ADCLO { }
# [ doc = "`write(|w| ..)` method takes [adclo::W](adclo::W) writer structure" ] impl crate :: Writable for ADCLO { }
# [ doc = "ADC Window Comparator Low Threshold Register" ] pub mod adclo {
# [ doc = "Reader of register ADCLO" ] pub type R = crate :: R < u16 , super :: ADCLO > ;
# [ doc = "Writer for register ADCLO" ] pub type W = crate :: W < u16 , super :: ADCLO > ;
# [ doc = "Register ADCLO `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADCLO { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "ADC Window Comparator High Threshold Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adchi](adchi) module" ] pub type ADCHI = crate :: Reg < u16 , _ADCHI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADCHI ;
# [ doc = "`read()` method returns [adchi::R](adchi::R) reader structure" ] impl crate :: Readable for ADCHI { }
# [ doc = "`write(|w| ..)` method takes [adchi::W](adchi::W) writer structure" ] impl crate :: Writable for ADCHI { }
# [ doc = "ADC Window Comparator High Threshold Register" ] pub mod adchi {
# [ doc = "Reader of register ADCHI" ] pub type R = crate :: R < u16 , super :: ADCHI > ;
# [ doc = "Writer for register ADCHI" ] pub type W = crate :: W < u16 , super :: ADCHI > ;
# [ doc = "Register ADCHI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADCHI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "ADC Conversion Memory Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcmctl0](adcmctl0) module" ] pub type ADCMCTL0 = crate :: Reg < u16 , _ADCMCTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADCMCTL0 ;
# [ doc = "`read()` method returns [adcmctl0::R](adcmctl0::R) reader structure" ] impl crate :: Readable for ADCMCTL0 { }
# [ doc = "`write(|w| ..)` method takes [adcmctl0::W](adcmctl0::W) writer structure" ] impl crate :: Writable for ADCMCTL0 { }
# [ doc = "ADC Conversion Memory Control Register" ] pub mod adcmctl0 {
# [ doc = "Reader of register ADCMCTL0" ] pub type R = crate :: R < u16 , super :: ADCMCTL0 > ;
# [ doc = "Writer for register ADCMCTL0" ] pub type W = crate :: W < u16 , super :: ADCMCTL0 > ;
# [ doc = "Register ADCMCTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADCMCTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Input channel select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ADCINCH_A { # [ doc = "0: A0 - see device-specific data sheet" ] ADCINCH_0 = 0 , # [ doc = "1: A1 - see device-specific data sheet" ] ADCINCH_1 = 1 , # [ doc = "2: A2 - see device-specific data sheet" ] ADCINCH_2 = 2 , # [ doc = "3: A3 - see device-specific data sheet" ] ADCINCH_3 = 3 , # [ doc = "4: A4 - see device-specific data sheet" ] ADCINCH_4 = 4 , # [ doc = "5: A5 - see device-specific data sheet" ] ADCINCH_5 = 5 , # [ doc = "6: A2 - see device-specific data sheet" ] ADCINCH_6 = 6 , # [ doc = "7: A7 - see device-specific data sheet" ] ADCINCH_7 = 7 , # [ doc = "8: A8 - see device-specific data sheet" ] ADCINCH_8 = 8 , # [ doc = "9: A9 - see device-specific data sheet" ] ADCINCH_9 = 9 , # [ doc = "10: A10 - see device-specific data sheet" ] ADCINCH_10 = 10 , # [ doc = "11: A11 - see device-specific data sheet" ] ADCINCH_11 = 11 , # [ doc = "12: A12 - see device-specific data sheet" ] ADCINCH_12 = 12 , # [ doc = "13: A13 - see device-specific data sheet" ] ADCINCH_13 = 13 , # [ doc = "14: A14 - see device-specific data sheet" ] ADCINCH_14 = 14 , # [ doc = "15: A15 - see device-specific data sheet" ] ADCINCH_15 = 15 } impl From < ADCINCH_A > for u8 { # [ inline ( always ) ] fn from ( variant : ADCINCH_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ADCINCH`" ] pub type ADCINCH_R = crate :: R < u8 , ADCINCH_A > ; impl ADCINCH_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCINCH_A { match self . bits { 0 => ADCINCH_A :: ADCINCH_0 , 1 => ADCINCH_A :: ADCINCH_1 , 2 => ADCINCH_A :: ADCINCH_2 , 3 => ADCINCH_A :: ADCINCH_3 , 4 => ADCINCH_A :: ADCINCH_4 , 5 => ADCINCH_A :: ADCINCH_5 , 6 => ADCINCH_A :: ADCINCH_6 , 7 => ADCINCH_A :: ADCINCH_7 , 8 => ADCINCH_A :: ADCINCH_8 , 9 => ADCINCH_A :: ADCINCH_9 , 10 => ADCINCH_A :: ADCINCH_10 , 11 => ADCINCH_A :: ADCINCH_11 , 12 => ADCINCH_A :: ADCINCH_12 , 13 => ADCINCH_A :: ADCINCH_13 , 14 => ADCINCH_A :: ADCINCH_14 , 15 => ADCINCH_A :: ADCINCH_15 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `ADCINCH_0`" ] # [ inline ( always ) ] pub fn is_adcinch_0 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_0 } # [ doc = "Checks if the value of the field is `ADCINCH_1`" ] # [ inline ( always ) ] pub fn is_adcinch_1 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_1 } # [ doc = "Checks if the value of the field is `ADCINCH_2`" ] # [ inline ( always ) ] pub fn is_adcinch_2 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_2 } # [ doc = "Checks if the value of the field is `ADCINCH_3`" ] # [ inline ( always ) ] pub fn is_adcinch_3 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_3 } # [ doc = "Checks if the value of the field is `ADCINCH_4`" ] # [ inline ( always ) ] pub fn is_adcinch_4 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_4 } # [ doc = "Checks if the value of the field is `ADCINCH_5`" ] # [ inline ( always ) ] pub fn is_adcinch_5 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_5 } # [ doc = "Checks if the value of the field is `ADCINCH_6`" ] # [ inline ( always ) ] pub fn is_adcinch_6 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_6 } # [ doc = "Checks if the value of the field is `ADCINCH_7`" ] # [ inline ( always ) ] pub fn is_adcinch_7 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_7 } # [ doc = "Checks if the value of the field is `ADCINCH_8`" ] # [ inline ( always ) ] pub fn is_adcinch_8 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_8 } # [ doc = "Checks if the value of the field is `ADCINCH_9`" ] # [ inline ( always ) ] pub fn is_adcinch_9 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_9 } # [ doc = "Checks if the value of the field is `ADCINCH_10`" ] # [ inline ( always ) ] pub fn is_adcinch_10 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_10 } # [ doc = "Checks if the value of the field is `ADCINCH_11`" ] # [ inline ( always ) ] pub fn is_adcinch_11 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_11 } # [ doc = "Checks if the value of the field is `ADCINCH_12`" ] # [ inline ( always ) ] pub fn is_adcinch_12 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_12 } # [ doc = "Checks if the value of the field is `ADCINCH_13`" ] # [ inline ( always ) ] pub fn is_adcinch_13 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_13 } # [ doc = "Checks if the value of the field is `ADCINCH_14`" ] # [ inline ( always ) ] pub fn is_adcinch_14 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_14 } # [ doc = "Checks if the value of the field is `ADCINCH_15`" ] # [ inline ( always ) ] pub fn is_adcinch_15 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_15 } }
# [ doc = "Write proxy for field `ADCINCH`" ] pub struct ADCINCH_W < 'a > { w : & 'a mut W , } impl < 'a > ADCINCH_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCINCH_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "A0 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_0 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_0 ) } # [ doc = "A1 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_1 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_1 ) } # [ doc = "A2 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_2 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_2 ) } # [ doc = "A3 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_3 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_3 ) } # [ doc = "A4 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_4 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_4 ) } # [ doc = "A5 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_5 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_5 ) } # [ doc = "A2 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_6 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_6 ) } # [ doc = "A7 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_7 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_7 ) } # [ doc = "A8 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_8 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_8 ) } # [ doc = "A9 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_9 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_9 ) } # [ doc = "A10 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_10 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_10 ) } # [ doc = "A11 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_11 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_11 ) } # [ doc = "A12 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_12 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_12 ) } # [ doc = "A13 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_13 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_13 ) } # [ doc = "A14 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_14 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_14 ) } # [ doc = "A15 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_15 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_15 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u16 ) & 0x0f ) ; self . w } }
# [ doc = "Select reference. It is not recommended to change this setting while a conversion is ongoing. Can be modified only when ADCENC = 0. Resetting ADCENC = 0 by software and changing these fields immediately shows an effect when a conversion is active.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ADCSREF_A { # [ doc = "0: 000b = V(R+) = AVCC and V(R-) = AVSS" ] ADCSREF_0 = 0 , # [ doc = "1: 001b = V(R+) = VREF and V(R-) = AVSS" ] ADCSREF_1 = 1 , # [ doc = "2: 010b = V(R+) = VEREF+ buffered and V(R-) = AVSS" ] ADCSREF_2 = 2 , # [ doc = "3: 011b =V(R+) = VEREF+ and V(R-) = AVSS" ] ADCSREF_3 = 3 , # [ doc = "4: 100b = V(R+) = AVCC and V(R-) = VEREF-" ] ADCSREF_4 = 4 , # [ doc = "5: 101b = V(R+) = VREF and V(R-) = VEREF-" ] ADCSREF_5 = 5 , # [ doc = "6: 110b = V(R+) = VEREF+ buffered and V(R-) = VEREF-" ] ADCSREF_6 = 6 , # [ doc = "7: 111b = V(R+) = VEREF+ and V(R-) = VEREF-" ] ADCSREF_7 = 7 } impl From < ADCSREF_A > for u8 { # [ inline ( always ) ] fn from ( variant : ADCSREF_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ADCSREF`" ] pub type ADCSREF_R = crate :: R < u8 , ADCSREF_A > ; impl ADCSREF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCSREF_A { match self . bits { 0 => ADCSREF_A :: ADCSREF_0 , 1 => ADCSREF_A :: ADCSREF_1 , 2 => ADCSREF_A :: ADCSREF_2 , 3 => ADCSREF_A :: ADCSREF_3 , 4 => ADCSREF_A :: ADCSREF_4 , 5 => ADCSREF_A :: ADCSREF_5 , 6 => ADCSREF_A :: ADCSREF_6 , 7 => ADCSREF_A :: ADCSREF_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `ADCSREF_0`" ] # [ inline ( always ) ] pub fn is_adcsref_0 ( & self ) -> bool { * self == ADCSREF_A :: ADCSREF_0 } # [ doc = "Checks if the value of the field is `ADCSREF_1`" ] # [ inline ( always ) ] pub fn is_adcsref_1 ( & self ) -> bool { * self == ADCSREF_A :: ADCSREF_1 } # [ doc = "Checks if the value of the field is `ADCSREF_2`" ] # [ inline ( always ) ] pub fn is_adcsref_2 ( & self ) -> bool { * self == ADCSREF_A :: ADCSREF_2 } # [ doc = "Checks if the value of the field is `ADCSREF_3`" ] # [ inline ( always ) ] pub fn is_adcsref_3 ( & self ) -> bool { * self == ADCSREF_A :: ADCSREF_3 } # [ doc = "Checks if the value of the field is `ADCSREF_4`" ] # [ inline ( always ) ] pub fn is_adcsref_4 ( & self ) -> bool { * self == ADCSREF_A :: ADCSREF_4 } # [ doc = "Checks if the value of the field is `ADCSREF_5`" ] # [ inline ( always ) ] pub fn is_adcsref_5 ( & self ) -> bool { * self == ADCSREF_A :: ADCSREF_5 } # [ doc = "Checks if the value of the field is `ADCSREF_6`" ] # [ inline ( always ) ] pub fn is_adcsref_6 ( & self ) -> bool { * self == ADCSREF_A :: ADCSREF_6 } # [ doc = "Checks if the value of the field is `ADCSREF_7`" ] # [ inline ( always ) ] pub fn is_adcsref_7 ( & self ) -> bool { * self == ADCSREF_A :: ADCSREF_7 } }
# [ doc = "Write proxy for field `ADCSREF`" ] pub struct ADCSREF_W < 'a > { w : & 'a mut W , } impl < 'a > ADCSREF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCSREF_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "000b = V(R+) = AVCC and V(R-) = AVSS" ] # [ inline ( always ) ] pub fn adcsref_0 ( self ) -> & 'a mut W { self . variant ( ADCSREF_A :: ADCSREF_0 ) } # [ doc = "001b = V(R+) = VREF and V(R-) = AVSS" ] # [ inline ( always ) ] pub fn adcsref_1 ( self ) -> & 'a mut W { self . variant ( ADCSREF_A :: ADCSREF_1 ) } # [ doc = "010b = V(R+) = VEREF+ buffered and V(R-) = AVSS" ] # [ inline ( always ) ] pub fn adcsref_2 ( self ) -> & 'a mut W { self . variant ( ADCSREF_A :: ADCSREF_2 ) } # [ doc = "011b =V(R+) = VEREF+ and V(R-) = AVSS" ] # [ inline ( always ) ] pub fn adcsref_3 ( self ) -> & 'a mut W { self . variant ( ADCSREF_A :: ADCSREF_3 ) } # [ doc = "100b = V(R+) = AVCC and V(R-) = VEREF-" ] # [ inline ( always ) ] pub fn adcsref_4 ( self ) -> & 'a mut W { self . variant ( ADCSREF_A :: ADCSREF_4 ) } # [ doc = "101b = V(R+) = VREF and V(R-) = VEREF-" ] # [ inline ( always ) ] pub fn adcsref_5 ( self ) -> & 'a mut W { self . variant ( ADCSREF_A :: ADCSREF_5 ) } # [ doc = "110b = V(R+) = VEREF+ buffered and V(R-) = VEREF-" ] # [ inline ( always ) ] pub fn adcsref_6 ( self ) -> & 'a mut W { self . variant ( ADCSREF_A :: ADCSREF_6 ) } # [ doc = "111b = V(R+) = VEREF+ and V(R-) = VEREF-" ] # [ inline ( always ) ] pub fn adcsref_7 ( self ) -> & 'a mut W { self . variant ( ADCSREF_A :: ADCSREF_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 4 ) ) | ( ( ( value as u16 ) & 0x07 ) << 4 ) ; self . w } }
# [ doc = "ADC input channels expanded\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EXPCHEN_A { # [ doc = "0: ADC channel expanded disable" ] EXPCHEN_0 = 0 , # [ doc = "1: ADC channel expanded enable" ] EXPCHEN_1 = 1 } impl From < EXPCHEN_A > for bool { # [ inline ( always ) ] fn from ( variant : EXPCHEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `EXPCHEN`" ] pub type EXPCHEN_R = crate :: R < bool , EXPCHEN_A > ; impl EXPCHEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> EXPCHEN_A { match self . bits { false => EXPCHEN_A :: EXPCHEN_0 , true => EXPCHEN_A :: EXPCHEN_1 } } # [ doc = "Checks if the value of the field is `EXPCHEN_0`" ] # [ inline ( always ) ] pub fn is_expchen_0 ( & self ) -> bool { * self == EXPCHEN_A :: EXPCHEN_0 } # [ doc = "Checks if the value of the field is `EXPCHEN_1`" ] # [ inline ( always ) ] pub fn is_expchen_1 ( & self ) -> bool { * self == EXPCHEN_A :: EXPCHEN_1 } }
# [ doc = "Write proxy for field `EXPCHEN`" ] pub struct EXPCHEN_W < 'a > { w : & 'a mut W , } impl < 'a > EXPCHEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : EXPCHEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "ADC channel expanded disable" ] # [ inline ( always ) ] pub fn expchen_0 ( self ) -> & 'a mut W { self . variant ( EXPCHEN_A :: EXPCHEN_0 ) } # [ doc = "ADC channel expanded enable" ] # [ inline ( always ) ] pub fn expchen_1 ( self ) -> & 'a mut W { self . variant ( EXPCHEN_A :: EXPCHEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:3 - Input channel select" ] # [ inline ( always ) ] pub fn adcinch ( & self ) -> ADCINCH_R { ADCINCH_R :: new ( ( self . bits & 0x0f ) as u8 ) }
# [ doc = "Bits 4:6 - Select reference. It is not recommended to change this setting while a conversion is ongoing. Can be modified only when ADCENC = 0. Resetting ADCENC = 0 by software and changing these fields immediately shows an effect when a conversion is active." ] # [ inline ( always ) ] pub fn adcsref ( & self ) -> ADCSREF_R { ADCSREF_R :: new ( ( ( self . bits >> 4 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - ADC input channels expanded" ] # [ inline ( always ) ] pub fn expchen ( & self ) -> EXPCHEN_R { EXPCHEN_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:3 - Input channel select" ] # [ inline ( always ) ] pub fn adcinch ( & mut self ) -> ADCINCH_W { ADCINCH_W { w : self } }
# [ doc = "Bits 4:6 - Select reference. It is not recommended to change this setting while a conversion is ongoing. Can be modified only when ADCENC = 0. Resetting ADCENC = 0 by software and changing these fields immediately shows an effect when a conversion is active." ] # [ inline ( always ) ] pub fn adcsref ( & mut self ) -> ADCSREF_W { ADCSREF_W { w : self } }
# [ doc = "Bit 8 - ADC input channels expanded" ] # [ inline ( always ) ] pub fn expchen ( & mut self ) -> EXPCHEN_W { EXPCHEN_W { w : self } }
}
}
# [ doc = "ADC Conversion Memory Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcmem0](adcmem0) module" ] pub type ADCMEM0 = crate :: Reg < u16 , _ADCMEM0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADCMEM0 ;
# [ doc = "`read()` method returns [adcmem0::R](adcmem0::R) reader structure" ] impl crate :: Readable for ADCMEM0 { }
# [ doc = "`write(|w| ..)` method takes [adcmem0::W](adcmem0::W) writer structure" ] impl crate :: Writable for ADCMEM0 { }
# [ doc = "ADC Conversion Memory Register" ] pub mod adcmem0 {
# [ doc = "Reader of register ADCMEM0" ] pub type R = crate :: R < u16 , super :: ADCMEM0 > ;
# [ doc = "Writer for register ADCMEM0" ] pub type W = crate :: W < u16 , super :: ADCMEM0 > ;
# [ doc = "Register ADCMEM0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADCMEM0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "ADC Interrupt Enable 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcie](adcie) module" ] pub type ADCIE = crate :: Reg < u16 , _ADCIE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADCIE ;
# [ doc = "`read()` method returns [adcie::R](adcie::R) reader structure" ] impl crate :: Readable for ADCIE { }
# [ doc = "`write(|w| ..)` method takes [adcie::W](adcie::W) writer structure" ] impl crate :: Writable for ADCIE { }
# [ doc = "ADC Interrupt Enable 0" ] pub mod adcie {
# [ doc = "Reader of register ADCIE" ] pub type R = crate :: R < u16 , super :: ADCIE > ;
# [ doc = "Writer for register ADCIE" ] pub type W = crate :: W < u16 , super :: ADCIE > ;
# [ doc = "Register ADCIE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADCIE { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Interrupt enable. This bits enable or disable the interrupt request for a completed ADC conversion.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCIE0_A { # [ doc = "0: 0b = Interrupt disabled" ] ADCIE0_0 = 0 , # [ doc = "1: 1b = Interrupt enabled" ] ADCIE0_1 = 1 } impl From < ADCIE0_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCIE0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCIE0`" ] pub type ADCIE0_R = crate :: R < bool , ADCIE0_A > ; impl ADCIE0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCIE0_A { match self . bits { false => ADCIE0_A :: ADCIE0_0 , true => ADCIE0_A :: ADCIE0_1 } } # [ doc = "Checks if the value of the field is `ADCIE0_0`" ] # [ inline ( always ) ] pub fn is_adcie0_0 ( & self ) -> bool { * self == ADCIE0_A :: ADCIE0_0 } # [ doc = "Checks if the value of the field is `ADCIE0_1`" ] # [ inline ( always ) ] pub fn is_adcie0_1 ( & self ) -> bool { * self == ADCIE0_A :: ADCIE0_1 } }
# [ doc = "Write proxy for field `ADCIE0`" ] pub struct ADCIE0_W < 'a > { w : & 'a mut W , } impl < 'a > ADCIE0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCIE0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "0b = Interrupt disabled" ] # [ inline ( always ) ] pub fn adcie0_0 ( self ) -> & 'a mut W { self . variant ( ADCIE0_A :: ADCIE0_0 ) } # [ doc = "1b = Interrupt enabled" ] # [ inline ( always ) ] pub fn adcie0_1 ( self ) -> & 'a mut W { self . variant ( ADCIE0_A :: ADCIE0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Interrupt enable for the inside of window interrupt of the window comparator.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCINIE_A { # [ doc = "0: 0b = Inside of window interrupt disabled" ] ADCINIE_0 = 0 , # [ doc = "1: 1b = Inside of window interrupt enabled" ] ADCINIE_1 = 1 } impl From < ADCINIE_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCINIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCINIE`" ] pub type ADCINIE_R = crate :: R < bool , ADCINIE_A > ; impl ADCINIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCINIE_A { match self . bits { false => ADCINIE_A :: ADCINIE_0 , true => ADCINIE_A :: ADCINIE_1 } } # [ doc = "Checks if the value of the field is `ADCINIE_0`" ] # [ inline ( always ) ] pub fn is_adcinie_0 ( & self ) -> bool { * self == ADCINIE_A :: ADCINIE_0 } # [ doc = "Checks if the value of the field is `ADCINIE_1`" ] # [ inline ( always ) ] pub fn is_adcinie_1 ( & self ) -> bool { * self == ADCINIE_A :: ADCINIE_1 } }
# [ doc = "Write proxy for field `ADCINIE`" ] pub struct ADCINIE_W < 'a > { w : & 'a mut W , } impl < 'a > ADCINIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCINIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "0b = Inside of window interrupt disabled" ] # [ inline ( always ) ] pub fn adcinie_0 ( self ) -> & 'a mut W { self . variant ( ADCINIE_A :: ADCINIE_0 ) } # [ doc = "1b = Inside of window interrupt enabled" ] # [ inline ( always ) ] pub fn adcinie_1 ( self ) -> & 'a mut W { self . variant ( ADCINIE_A :: ADCINIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Interrupt enable for the below lower threshold interrupt of the window comparator.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCLOIE_A { # [ doc = "0: 0b = Below lower threshold interrupt disabled" ] ADCLOIE_0 = 0 , # [ doc = "1: 1b = Below lower threshold interrupt enabled" ] ADCLOIE_1 = 1 } impl From < ADCLOIE_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCLOIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCLOIE`" ] pub type ADCLOIE_R = crate :: R < bool , ADCLOIE_A > ; impl ADCLOIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCLOIE_A { match self . bits { false => ADCLOIE_A :: ADCLOIE_0 , true => ADCLOIE_A :: ADCLOIE_1 } } # [ doc = "Checks if the value of the field is `ADCLOIE_0`" ] # [ inline ( always ) ] pub fn is_adcloie_0 ( & self ) -> bool { * self == ADCLOIE_A :: ADCLOIE_0 } # [ doc = "Checks if the value of the field is `ADCLOIE_1`" ] # [ inline ( always ) ] pub fn is_adcloie_1 ( & self ) -> bool { * self == ADCLOIE_A :: ADCLOIE_1 } }
# [ doc = "Write proxy for field `ADCLOIE`" ] pub struct ADCLOIE_W < 'a > { w : & 'a mut W , } impl < 'a > ADCLOIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCLOIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "0b = Below lower threshold interrupt disabled" ] # [ inline ( always ) ] pub fn adcloie_0 ( self ) -> & 'a mut W { self . variant ( ADCLOIE_A :: ADCLOIE_0 ) } # [ doc = "1b = Below lower threshold interrupt enabled" ] # [ inline ( always ) ] pub fn adcloie_1 ( self ) -> & 'a mut W { self . variant ( ADCLOIE_A :: ADCLOIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Interrupt enable for the above upper threshold interrupt of the window comparator.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCHIIE_A { # [ doc = "0: 0b = Above upper threshold interrupt disabled" ] ADCHIIE_0 = 0 , # [ doc = "1: 1b = Above upper threshold interrupt enabled" ] ADCHIIE_1 = 1 } impl From < ADCHIIE_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCHIIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCHIIE`" ] pub type ADCHIIE_R = crate :: R < bool , ADCHIIE_A > ; impl ADCHIIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCHIIE_A { match self . bits { false => ADCHIIE_A :: ADCHIIE_0 , true => ADCHIIE_A :: ADCHIIE_1 } } # [ doc = "Checks if the value of the field is `ADCHIIE_0`" ] # [ inline ( always ) ] pub fn is_adchiie_0 ( & self ) -> bool { * self == ADCHIIE_A :: ADCHIIE_0 } # [ doc = "Checks if the value of the field is `ADCHIIE_1`" ] # [ inline ( always ) ] pub fn is_adchiie_1 ( & self ) -> bool { * self == ADCHIIE_A :: ADCHIIE_1 } }
# [ doc = "Write proxy for field `ADCHIIE`" ] pub struct ADCHIIE_W < 'a > { w : & 'a mut W , } impl < 'a > ADCHIIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCHIIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "0b = Above upper threshold interrupt disabled" ] # [ inline ( always ) ] pub fn adchiie_0 ( self ) -> & 'a mut W { self . variant ( ADCHIIE_A :: ADCHIIE_0 ) } # [ doc = "1b = Above upper threshold interrupt enabled" ] # [ inline ( always ) ] pub fn adchiie_1 ( self ) -> & 'a mut W { self . variant ( ADCHIIE_A :: ADCHIIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "ADCMEM0 overflow interrupt enable.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCOVIE_A { # [ doc = "0: 0b = Overflow interrupt disabled" ] ADCOVIE_0 = 0 , # [ doc = "1: 1b = Overflow interrupt enabled" ] ADCOVIE_1 = 1 } impl From < ADCOVIE_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCOVIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCOVIE`" ] pub type ADCOVIE_R = crate :: R < bool , ADCOVIE_A > ; impl ADCOVIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCOVIE_A { match self . bits { false => ADCOVIE_A :: ADCOVIE_0 , true => ADCOVIE_A :: ADCOVIE_1 } } # [ doc = "Checks if the value of the field is `ADCOVIE_0`" ] # [ inline ( always ) ] pub fn is_adcovie_0 ( & self ) -> bool { * self == ADCOVIE_A :: ADCOVIE_0 } # [ doc = "Checks if the value of the field is `ADCOVIE_1`" ] # [ inline ( always ) ] pub fn is_adcovie_1 ( & self ) -> bool { * self == ADCOVIE_A :: ADCOVIE_1 } }
# [ doc = "Write proxy for field `ADCOVIE`" ] pub struct ADCOVIE_W < 'a > { w : & 'a mut W , } impl < 'a > ADCOVIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCOVIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "0b = Overflow interrupt disabled" ] # [ inline ( always ) ] pub fn adcovie_0 ( self ) -> & 'a mut W { self . variant ( ADCOVIE_A :: ADCOVIE_0 ) } # [ doc = "1b = Overflow interrupt enabled" ] # [ inline ( always ) ] pub fn adcovie_1 ( self ) -> & 'a mut W { self . variant ( ADCOVIE_A :: ADCOVIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "ADC conversion-time-overflow interrupt enable.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCTOVIE_A { # [ doc = "0: 0b = Conversion time overflow interrupt disabled" ] ADCTOVIE_0 = 0 , # [ doc = "1: 1b = Conversion time overflow interrupt enabled" ] ADCTOVIE_1 = 1 } impl From < ADCTOVIE_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCTOVIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCTOVIE`" ] pub type ADCTOVIE_R = crate :: R < bool , ADCTOVIE_A > ; impl ADCTOVIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCTOVIE_A { match self . bits { false => ADCTOVIE_A :: ADCTOVIE_0 , true => ADCTOVIE_A :: ADCTOVIE_1 } } # [ doc = "Checks if the value of the field is `ADCTOVIE_0`" ] # [ inline ( always ) ] pub fn is_adctovie_0 ( & self ) -> bool { * self == ADCTOVIE_A :: ADCTOVIE_0 } # [ doc = "Checks if the value of the field is `ADCTOVIE_1`" ] # [ inline ( always ) ] pub fn is_adctovie_1 ( & self ) -> bool { * self == ADCTOVIE_A :: ADCTOVIE_1 } }
# [ doc = "Write proxy for field `ADCTOVIE`" ] pub struct ADCTOVIE_W < 'a > { w : & 'a mut W , } impl < 'a > ADCTOVIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCTOVIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "0b = Conversion time overflow interrupt disabled" ] # [ inline ( always ) ] pub fn adctovie_0 ( self ) -> & 'a mut W { self . variant ( ADCTOVIE_A :: ADCTOVIE_0 ) } # [ doc = "1b = Conversion time overflow interrupt enabled" ] # [ inline ( always ) ] pub fn adctovie_1 ( self ) -> & 'a mut W { self . variant ( ADCTOVIE_A :: ADCTOVIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Interrupt enable. This bits enable or disable the interrupt request for a completed ADC conversion." ] # [ inline ( always ) ] pub fn adcie0 ( & self ) -> ADCIE0_R { ADCIE0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Interrupt enable for the inside of window interrupt of the window comparator." ] # [ inline ( always ) ] pub fn adcinie ( & self ) -> ADCINIE_R { ADCINIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Interrupt enable for the below lower threshold interrupt of the window comparator." ] # [ inline ( always ) ] pub fn adcloie ( & self ) -> ADCLOIE_R { ADCLOIE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Interrupt enable for the above upper threshold interrupt of the window comparator." ] # [ inline ( always ) ] pub fn adchiie ( & self ) -> ADCHIIE_R { ADCHIIE_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - ADCMEM0 overflow interrupt enable." ] # [ inline ( always ) ] pub fn adcovie ( & self ) -> ADCOVIE_R { ADCOVIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - ADC conversion-time-overflow interrupt enable." ] # [ inline ( always ) ] pub fn adctovie ( & self ) -> ADCTOVIE_R { ADCTOVIE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Interrupt enable. This bits enable or disable the interrupt request for a completed ADC conversion." ] # [ inline ( always ) ] pub fn adcie0 ( & mut self ) -> ADCIE0_W { ADCIE0_W { w : self } }
# [ doc = "Bit 1 - Interrupt enable for the inside of window interrupt of the window comparator." ] # [ inline ( always ) ] pub fn adcinie ( & mut self ) -> ADCINIE_W { ADCINIE_W { w : self } }
# [ doc = "Bit 2 - Interrupt enable for the below lower threshold interrupt of the window comparator." ] # [ inline ( always ) ] pub fn adcloie ( & mut self ) -> ADCLOIE_W { ADCLOIE_W { w : self } }
# [ doc = "Bit 3 - Interrupt enable for the above upper threshold interrupt of the window comparator." ] # [ inline ( always ) ] pub fn adchiie ( & mut self ) -> ADCHIIE_W { ADCHIIE_W { w : self } }
# [ doc = "Bit 4 - ADCMEM0 overflow interrupt enable." ] # [ inline ( always ) ] pub fn adcovie ( & mut self ) -> ADCOVIE_W { ADCOVIE_W { w : self } }
# [ doc = "Bit 5 - ADC conversion-time-overflow interrupt enable." ] # [ inline ( always ) ] pub fn adctovie ( & mut self ) -> ADCTOVIE_W { ADCTOVIE_W { w : self } }
}
}
# [ doc = "ADC Interrupt Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcifg](adcifg) module" ] pub type ADCIFG = crate :: Reg < u16 , _ADCIFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADCIFG ;
# [ doc = "`read()` method returns [adcifg::R](adcifg::R) reader structure" ] impl crate :: Readable for ADCIFG { }
# [ doc = "`write(|w| ..)` method takes [adcifg::W](adcifg::W) writer structure" ] impl crate :: Writable for ADCIFG { }
# [ doc = "ADC Interrupt Flag" ] pub mod adcifg {
# [ doc = "Reader of register ADCIFG" ] pub type R = crate :: R < u16 , super :: ADCIFG > ;
# [ doc = "Writer for register ADCIFG" ] pub type W = crate :: W < u16 , super :: ADCIFG > ;
# [ doc = "Register ADCIFG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADCIFG { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "ADCMEM0 interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCIFG0_A { # [ doc = "0: No interrupt pending" ] ADCIFG0_0 = 0 , # [ doc = "1: Interrupt pending" ] ADCIFG0_1 = 1 } impl From < ADCIFG0_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCIFG0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCIFG0`" ] pub type ADCIFG0_R = crate :: R < bool , ADCIFG0_A > ; impl ADCIFG0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCIFG0_A { match self . bits { false => ADCIFG0_A :: ADCIFG0_0 , true => ADCIFG0_A :: ADCIFG0_1 } } # [ doc = "Checks if the value of the field is `ADCIFG0_0`" ] # [ inline ( always ) ] pub fn is_adcifg0_0 ( & self ) -> bool { * self == ADCIFG0_A :: ADCIFG0_0 } # [ doc = "Checks if the value of the field is `ADCIFG0_1`" ] # [ inline ( always ) ] pub fn is_adcifg0_1 ( & self ) -> bool { * self == ADCIFG0_A :: ADCIFG0_1 } }
# [ doc = "Write proxy for field `ADCIFG0`" ] pub struct ADCIFG0_W < 'a > { w : & 'a mut W , } impl < 'a > ADCIFG0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCIFG0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn adcifg0_0 ( self ) -> & 'a mut W { self . variant ( ADCIFG0_A :: ADCIFG0_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn adcifg0_1 ( self ) -> & 'a mut W { self . variant ( ADCIFG0_A :: ADCIFG0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "The ADCINIFG is set when the result of the current ADC conversion is within the thresholds defined by the window comparator threshold registers.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCINIFG_A { # [ doc = "0: No interrupt pending" ] ADCINIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] ADCINIFG_1 = 1 } impl From < ADCINIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCINIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCINIFG`" ] pub type ADCINIFG_R = crate :: R < bool , ADCINIFG_A > ; impl ADCINIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCINIFG_A { match self . bits { false => ADCINIFG_A :: ADCINIFG_0 , true => ADCINIFG_A :: ADCINIFG_1 } } # [ doc = "Checks if the value of the field is `ADCINIFG_0`" ] # [ inline ( always ) ] pub fn is_adcinifg_0 ( & self ) -> bool { * self == ADCINIFG_A :: ADCINIFG_0 } # [ doc = "Checks if the value of the field is `ADCINIFG_1`" ] # [ inline ( always ) ] pub fn is_adcinifg_1 ( & self ) -> bool { * self == ADCINIFG_A :: ADCINIFG_1 } }
# [ doc = "Write proxy for field `ADCINIFG`" ] pub struct ADCINIFG_W < 'a > { w : & 'a mut W , } impl < 'a > ADCINIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCINIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn adcinifg_0 ( self ) -> & 'a mut W { self . variant ( ADCINIFG_A :: ADCINIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn adcinifg_1 ( self ) -> & 'a mut W { self . variant ( ADCINIFG_A :: ADCINIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "The ADCLOIFG is set when the result of the current ADC conversion is below the lower threshold defined by the window comparator lower threshold register.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCLOIFG_A { # [ doc = "0: No interrupt pending" ] ADCLOIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] ADCLOIFG_1 = 1 } impl From < ADCLOIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCLOIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCLOIFG`" ] pub type ADCLOIFG_R = crate :: R < bool , ADCLOIFG_A > ; impl ADCLOIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCLOIFG_A { match self . bits { false => ADCLOIFG_A :: ADCLOIFG_0 , true => ADCLOIFG_A :: ADCLOIFG_1 } } # [ doc = "Checks if the value of the field is `ADCLOIFG_0`" ] # [ inline ( always ) ] pub fn is_adcloifg_0 ( & self ) -> bool { * self == ADCLOIFG_A :: ADCLOIFG_0 } # [ doc = "Checks if the value of the field is `ADCLOIFG_1`" ] # [ inline ( always ) ] pub fn is_adcloifg_1 ( & self ) -> bool { * self == ADCLOIFG_A :: ADCLOIFG_1 } }
# [ doc = "Write proxy for field `ADCLOIFG`" ] pub struct ADCLOIFG_W < 'a > { w : & 'a mut W , } impl < 'a > ADCLOIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCLOIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn adcloifg_0 ( self ) -> & 'a mut W { self . variant ( ADCLOIFG_A :: ADCLOIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn adcloifg_1 ( self ) -> & 'a mut W { self . variant ( ADCLOIFG_A :: ADCLOIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "The ADCHIIFG is set when the result of the current ADC conversion is greater than the upper threshold defined by the window comparator upper threshold register.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCHIIFG_A { # [ doc = "0: No interrupt pending" ] ADCHIIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] ADCHIIFG_1 = 1 } impl From < ADCHIIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCHIIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCHIIFG`" ] pub type ADCHIIFG_R = crate :: R < bool , ADCHIIFG_A > ; impl ADCHIIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCHIIFG_A { match self . bits { false => ADCHIIFG_A :: ADCHIIFG_0 , true => ADCHIIFG_A :: ADCHIIFG_1 } } # [ doc = "Checks if the value of the field is `ADCHIIFG_0`" ] # [ inline ( always ) ] pub fn is_adchiifg_0 ( & self ) -> bool { * self == ADCHIIFG_A :: ADCHIIFG_0 } # [ doc = "Checks if the value of the field is `ADCHIIFG_1`" ] # [ inline ( always ) ] pub fn is_adchiifg_1 ( & self ) -> bool { * self == ADCHIIFG_A :: ADCHIIFG_1 } }
# [ doc = "Write proxy for field `ADCHIIFG`" ] pub struct ADCHIIFG_W < 'a > { w : & 'a mut W , } impl < 'a > ADCHIIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCHIIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn adchiifg_0 ( self ) -> & 'a mut W { self . variant ( ADCHIIFG_A :: ADCHIIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn adchiifg_1 ( self ) -> & 'a mut W { self . variant ( ADCHIIFG_A :: ADCHIIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "The ADCOVIFG is set when the ADCMEM0 register is written before the last conversion result has been read.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCOVIFG_A { # [ doc = "0: No interrupt pending" ] ADCOVIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] ADCOVIFG_1 = 1 } impl From < ADCOVIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCOVIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCOVIFG`" ] pub type ADCOVIFG_R = crate :: R < bool , ADCOVIFG_A > ; impl ADCOVIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCOVIFG_A { match self . bits { false => ADCOVIFG_A :: ADCOVIFG_0 , true => ADCOVIFG_A :: ADCOVIFG_1 } } # [ doc = "Checks if the value of the field is `ADCOVIFG_0`" ] # [ inline ( always ) ] pub fn is_adcovifg_0 ( & self ) -> bool { * self == ADCOVIFG_A :: ADCOVIFG_0 } # [ doc = "Checks if the value of the field is `ADCOVIFG_1`" ] # [ inline ( always ) ] pub fn is_adcovifg_1 ( & self ) -> bool { * self == ADCOVIFG_A :: ADCOVIFG_1 } }
# [ doc = "Write proxy for field `ADCOVIFG`" ] pub struct ADCOVIFG_W < 'a > { w : & 'a mut W , } impl < 'a > ADCOVIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCOVIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn adcovifg_0 ( self ) -> & 'a mut W { self . variant ( ADCOVIFG_A :: ADCOVIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn adcovifg_1 ( self ) -> & 'a mut W { self . variant ( ADCOVIFG_A :: ADCOVIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "The ADCTOVIFG is set when an ADC conversion is triggered before the actual conversion has completed.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCTOVIFG_A { # [ doc = "0: No interrupt pending" ] ADCOVIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] ADCTOVIFG_1 = 1 } impl From < ADCTOVIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCTOVIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCTOVIFG`" ] pub type ADCTOVIFG_R = crate :: R < bool , ADCTOVIFG_A > ; impl ADCTOVIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCTOVIFG_A { match self . bits { false => ADCTOVIFG_A :: ADCOVIFG_0 , true => ADCTOVIFG_A :: ADCTOVIFG_1 } } # [ doc = "Checks if the value of the field is `ADCOVIFG_0`" ] # [ inline ( always ) ] pub fn is_adcovifg_0 ( & self ) -> bool { * self == ADCTOVIFG_A :: ADCOVIFG_0 } # [ doc = "Checks if the value of the field is `ADCTOVIFG_1`" ] # [ inline ( always ) ] pub fn is_adctovifg_1 ( & self ) -> bool { * self == ADCTOVIFG_A :: ADCTOVIFG_1 } }
# [ doc = "Write proxy for field `ADCTOVIFG`" ] pub struct ADCTOVIFG_W < 'a > { w : & 'a mut W , } impl < 'a > ADCTOVIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCTOVIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn adcovifg_0 ( self ) -> & 'a mut W { self . variant ( ADCTOVIFG_A :: ADCOVIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn adctovifg_1 ( self ) -> & 'a mut W { self . variant ( ADCTOVIFG_A :: ADCTOVIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - ADCMEM0 interrupt flag" ] # [ inline ( always ) ] pub fn adcifg0 ( & self ) -> ADCIFG0_R { ADCIFG0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - The ADCINIFG is set when the result of the current ADC conversion is within the thresholds defined by the window comparator threshold registers." ] # [ inline ( always ) ] pub fn adcinifg ( & self ) -> ADCINIFG_R { ADCINIFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - The ADCLOIFG is set when the result of the current ADC conversion is below the lower threshold defined by the window comparator lower threshold register." ] # [ inline ( always ) ] pub fn adcloifg ( & self ) -> ADCLOIFG_R { ADCLOIFG_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - The ADCHIIFG is set when the result of the current ADC conversion is greater than the upper threshold defined by the window comparator upper threshold register." ] # [ inline ( always ) ] pub fn adchiifg ( & self ) -> ADCHIIFG_R { ADCHIIFG_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - The ADCOVIFG is set when the ADCMEM0 register is written before the last conversion result has been read." ] # [ inline ( always ) ] pub fn adcovifg ( & self ) -> ADCOVIFG_R { ADCOVIFG_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - The ADCTOVIFG is set when an ADC conversion is triggered before the actual conversion has completed." ] # [ inline ( always ) ] pub fn adctovifg ( & self ) -> ADCTOVIFG_R { ADCTOVIFG_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - ADCMEM0 interrupt flag" ] # [ inline ( always ) ] pub fn adcifg0 ( & mut self ) -> ADCIFG0_W { ADCIFG0_W { w : self } }
# [ doc = "Bit 1 - The ADCINIFG is set when the result of the current ADC conversion is within the thresholds defined by the window comparator threshold registers." ] # [ inline ( always ) ] pub fn adcinifg ( & mut self ) -> ADCINIFG_W { ADCINIFG_W { w : self } }
# [ doc = "Bit 2 - The ADCLOIFG is set when the result of the current ADC conversion is below the lower threshold defined by the window comparator lower threshold register." ] # [ inline ( always ) ] pub fn adcloifg ( & mut self ) -> ADCLOIFG_W { ADCLOIFG_W { w : self } }
# [ doc = "Bit 3 - The ADCHIIFG is set when the result of the current ADC conversion is greater than the upper threshold defined by the window comparator upper threshold register." ] # [ inline ( always ) ] pub fn adchiifg ( & mut self ) -> ADCHIIFG_W { ADCHIIFG_W { w : self } }
# [ doc = "Bit 4 - The ADCOVIFG is set when the ADCMEM0 register is written before the last conversion result has been read." ] # [ inline ( always ) ] pub fn adcovifg ( & mut self ) -> ADCOVIFG_W { ADCOVIFG_W { w : self } }
# [ doc = "Bit 5 - The ADCTOVIFG is set when an ADC conversion is triggered before the actual conversion has completed." ] # [ inline ( always ) ] pub fn adctovifg ( & mut self ) -> ADCTOVIFG_W { ADCTOVIFG_W { w : self } }
}
}
# [ doc = "ADC Interrupt Vector\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adciv](adciv) module" ] pub type ADCIV = crate :: Reg < u16 , _ADCIV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADCIV ;
# [ doc = "`read()` method returns [adciv::R](adciv::R) reader structure" ] impl crate :: Readable for ADCIV { }
# [ doc = "`write(|w| ..)` method takes [adciv::W](adciv::W) writer structure" ] impl crate :: Writable for ADCIV { }
# [ doc = "ADC Interrupt Vector" ] pub mod adciv {
# [ doc = "Reader of register ADCIV" ] pub type R = crate :: R < u16 , super :: ADCIV > ;
# [ doc = "Writer for register ADCIV" ] pub type W = crate :: W < u16 , super :: ADCIV > ;
# [ doc = "Register ADCIV `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADCIV { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum ADCIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: ADCMEM0 overflow; Interrupt Flag: ADCOVIFG; Interrupt Priority: Highest" ] ADCOVIFG = 2 , # [ doc = "4: Interrupt Source: Conversion time overflow; Interrupt Flag: ADCTOVIFG" ] ADCTOVIFG = 4 , # [ doc = "6: Interrupt Source: ADCHI Interrupt flag; Interrupt Flag: ADCHIIFG" ] ADCHIIFG = 6 , # [ doc = "8: Interrupt Source: ADCLO Interrupt flag; Interrupt Flag: ADCLOIFG" ] ADCLOIFG = 8 , # [ doc = "10: nterrupt Source: ADCIN Interrupt flag; Interrupt Flag: ADCINIFG" ] ADCINIFG = 10 , # [ doc = "12: Interrupt Source: ADC memory Interrupt flag; Interrupt Flag: ADCIFG0; Interrupt Priority: Lowest" ] ADCIFG0 = 12 } impl From < ADCIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : ADCIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ADCIV`" ] pub type ADCIV_R = crate :: R < u16 , ADCIV_A > ; impl ADCIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , ADCIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( ADCIV_A :: NONE ) , 2 => Val ( ADCIV_A :: ADCOVIFG ) , 4 => Val ( ADCIV_A :: ADCTOVIFG ) , 6 => Val ( ADCIV_A :: ADCHIIFG ) , 8 => Val ( ADCIV_A :: ADCLOIFG ) , 10 => Val ( ADCIV_A :: ADCINIFG ) , 12 => Val ( ADCIV_A :: ADCIFG0 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == ADCIV_A :: NONE } # [ doc = "Checks if the value of the field is `ADCOVIFG`" ] # [ inline ( always ) ] pub fn is_adcovifg ( & self ) -> bool { * self == ADCIV_A :: ADCOVIFG } # [ doc = "Checks if the value of the field is `ADCTOVIFG`" ] # [ inline ( always ) ] pub fn is_adctovifg ( & self ) -> bool { * self == ADCIV_A :: ADCTOVIFG } # [ doc = "Checks if the value of the field is `ADCHIIFG`" ] # [ inline ( always ) ] pub fn is_adchiifg ( & self ) -> bool { * self == ADCIV_A :: ADCHIIFG } # [ doc = "Checks if the value of the field is `ADCLOIFG`" ] # [ inline ( always ) ] pub fn is_adcloifg ( & self ) -> bool { * self == ADCIV_A :: ADCLOIFG } # [ doc = "Checks if the value of the field is `ADCINIFG`" ] # [ inline ( always ) ] pub fn is_adcinifg ( & self ) -> bool { * self == ADCIV_A :: ADCINIFG } # [ doc = "Checks if the value of the field is `ADCIFG0`" ] # [ inline ( always ) ] pub fn is_adcifg0 ( & self ) -> bool { * self == ADCIV_A :: ADCIFG0 } }
# [ doc = "Write proxy for field `ADCIV`" ] pub struct ADCIV_W < 'a > { w : & 'a mut W , } impl < 'a > ADCIV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCIV_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( ADCIV_A :: NONE ) } # [ doc = "Interrupt Source: ADCMEM0 overflow; Interrupt Flag: ADCOVIFG; Interrupt Priority: Highest" ] # [ inline ( always ) ] pub fn adcovifg ( self ) -> & 'a mut W { self . variant ( ADCIV_A :: ADCOVIFG ) } # [ doc = "Interrupt Source: Conversion time overflow; Interrupt Flag: ADCTOVIFG" ] # [ inline ( always ) ] pub fn adctovifg ( self ) -> & 'a mut W { self . variant ( ADCIV_A :: ADCTOVIFG ) } # [ doc = "Interrupt Source: ADCHI Interrupt flag; Interrupt Flag: ADCHIIFG" ] # [ inline ( always ) ] pub fn adchiifg ( self ) -> & 'a mut W { self . variant ( ADCIV_A :: ADCHIIFG ) } # [ doc = "Interrupt Source: ADCLO Interrupt flag; Interrupt Flag: ADCLOIFG" ] # [ inline ( always ) ] pub fn adcloifg ( self ) -> & 'a mut W { self . variant ( ADCIV_A :: ADCLOIFG ) } # [ doc = "nterrupt Source: ADCIN Interrupt flag; Interrupt Flag: ADCINIFG" ] # [ inline ( always ) ] pub fn adcinifg ( self ) -> & 'a mut W { self . variant ( ADCIV_A :: ADCINIFG ) } # [ doc = "Interrupt Source: ADC memory Interrupt flag; Interrupt Flag: ADCIFG0; Interrupt Priority: Lowest" ] # [ inline ( always ) ] pub fn adcifg0 ( self ) -> & 'a mut W { self . variant ( ADCIV_A :: ADCIFG0 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u16 ) & 0xffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - interrupt vector value" ] # [ inline ( always ) ] pub fn adciv ( & self ) -> ADCIV_R { ADCIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:15 - interrupt vector value" ] # [ inline ( always ) ] pub fn adciv ( & mut self ) -> ADCIV_W { ADCIV_W { w : self } }
}
}
}
# [ doc = "eCOMP0" ] pub struct E_COMP0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for E_COMP0 { } impl E_COMP0 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const e_comp0 :: RegisterBlock { 0x08e0 as * const _ } } impl Deref for E_COMP0 { type Target = e_comp0 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * E_COMP0 :: ptr ( ) } } }
# [ doc = "eCOMP0" ] pub mod e_comp0 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Comparator Control Register 0" ] pub cpctl0 : CPCTL0 , # [ doc = "0x02 - Comparator Control Register 1" ] pub cpctl1 : CPCTL1 , _reserved2 : [ u8 ; 2usize ] , # [ doc = "0x06 - Comparator Interrupt Control Register" ] pub cpint : CPINT , # [ doc = "0x08 - Comparator Interrupt Vector Word Register" ] pub cpiv : CPIV , _reserved4 : [ u8 ; 6usize ] , # [ doc = "0x10 - 6-bit Comparator built-in DAC Control Register" ] pub cpdacctl : CPDACCTL , # [ doc = "0x12 - 6-bit Comparator built-in DAC Data Register" ] pub cpdacdata : CPDACDATA , }
# [ doc = "Comparator Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cpctl0](cpctl0) module" ] pub type CPCTL0 = crate :: Reg < u16 , _CPCTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CPCTL0 ;
# [ doc = "`read()` method returns [cpctl0::R](cpctl0::R) reader structure" ] impl crate :: Readable for CPCTL0 { }
# [ doc = "`write(|w| ..)` method takes [cpctl0::W](cpctl0::W) writer structure" ] impl crate :: Writable for CPCTL0 { }
# [ doc = "Comparator Control Register 0" ] pub mod cpctl0 {
# [ doc = "Reader of register CPCTL0" ] pub type R = crate :: R < u16 , super :: CPCTL0 > ;
# [ doc = "Writer for register CPCTL0" ] pub type W = crate :: W < u16 , super :: CPCTL0 > ;
# [ doc = "Register CPCTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CPCTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Channel input enable for the V+ terminal\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPPEN_A { # [ doc = "0: Selected analog input channel for V+ terminal is disabled." ] CPPEN_0 = 0 , # [ doc = "1: Selected analog input channel for V+ terminal is enabled." ] CPPEN_1 = 1 } impl From < CPPEN_A > for bool { # [ inline ( always ) ] fn from ( variant : CPPEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPPEN`" ] pub type CPPEN_R = crate :: R < bool , CPPEN_A > ; impl CPPEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPPEN_A { match self . bits { false => CPPEN_A :: CPPEN_0 , true => CPPEN_A :: CPPEN_1 } } # [ doc = "Checks if the value of the field is `CPPEN_0`" ] # [ inline ( always ) ] pub fn is_cppen_0 ( & self ) -> bool { * self == CPPEN_A :: CPPEN_0 } # [ doc = "Checks if the value of the field is `CPPEN_1`" ] # [ inline ( always ) ] pub fn is_cppen_1 ( & self ) -> bool { * self == CPPEN_A :: CPPEN_1 } }
# [ doc = "Write proxy for field `CPPEN`" ] pub struct CPPEN_W < 'a > { w : & 'a mut W , } impl < 'a > CPPEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPPEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Selected analog input channel for V+ terminal is disabled." ] # [ inline ( always ) ] pub fn cppen_0 ( self ) -> & 'a mut W { self . variant ( CPPEN_A :: CPPEN_0 ) } # [ doc = "Selected analog input channel for V+ terminal is enabled." ] # [ inline ( always ) ] pub fn cppen_1 ( self ) -> & 'a mut W { self . variant ( CPPEN_A :: CPPEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Channel input selected for the - terminal\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPNSEL_A { # [ doc = "0: select external input source" ] CPNSEL_0 = 0 , # [ doc = "1: select external input source" ] CPNSEL_1 = 1 , # [ doc = "2: select external input source" ] CPNSEL_2 = 2 , # [ doc = "3: select external input source" ] CPNSEL_3 = 3 , # [ doc = "4: device specific, please refer to device data sheet for details" ] CPNSEL_4 = 4 , # [ doc = "5: device specific, please refer to device data sheet for details" ] CPNSEL_5 = 5 , # [ doc = "6: 6-bit DAC" ] CPNSEL_6 = 6 , # [ doc = "7: Reserved" ] CPNSEL_7 = 7 } impl From < CPNSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPNSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPNSEL`" ] pub type CPNSEL_R = crate :: R < u8 , CPNSEL_A > ; impl CPNSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPNSEL_A { match self . bits { 0 => CPNSEL_A :: CPNSEL_0 , 1 => CPNSEL_A :: CPNSEL_1 , 2 => CPNSEL_A :: CPNSEL_2 , 3 => CPNSEL_A :: CPNSEL_3 , 4 => CPNSEL_A :: CPNSEL_4 , 5 => CPNSEL_A :: CPNSEL_5 , 6 => CPNSEL_A :: CPNSEL_6 , 7 => CPNSEL_A :: CPNSEL_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPNSEL_0`" ] # [ inline ( always ) ] pub fn is_cpnsel_0 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_0 } # [ doc = "Checks if the value of the field is `CPNSEL_1`" ] # [ inline ( always ) ] pub fn is_cpnsel_1 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_1 } # [ doc = "Checks if the value of the field is `CPNSEL_2`" ] # [ inline ( always ) ] pub fn is_cpnsel_2 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_2 } # [ doc = "Checks if the value of the field is `CPNSEL_3`" ] # [ inline ( always ) ] pub fn is_cpnsel_3 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_3 } # [ doc = "Checks if the value of the field is `CPNSEL_4`" ] # [ inline ( always ) ] pub fn is_cpnsel_4 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_4 } # [ doc = "Checks if the value of the field is `CPNSEL_5`" ] # [ inline ( always ) ] pub fn is_cpnsel_5 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_5 } # [ doc = "Checks if the value of the field is `CPNSEL_6`" ] # [ inline ( always ) ] pub fn is_cpnsel_6 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_6 } # [ doc = "Checks if the value of the field is `CPNSEL_7`" ] # [ inline ( always ) ] pub fn is_cpnsel_7 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_7 } }
# [ doc = "Write proxy for field `CPNSEL`" ] pub struct CPNSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CPNSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPNSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cpnsel_0 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_0 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cpnsel_1 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_1 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cpnsel_2 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_2 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cpnsel_3 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_3 ) } # [ doc = "device specific, please refer to device data sheet for details" ] # [ inline ( always ) ] pub fn cpnsel_4 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_4 ) } # [ doc = "device specific, please refer to device data sheet for details" ] # [ inline ( always ) ] pub fn cpnsel_5 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_5 ) } # [ doc = "6-bit DAC" ] # [ inline ( always ) ] pub fn cpnsel_6 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_6 ) } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn cpnsel_7 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 8 ) ) | ( ( ( value as u16 ) & 0x07 ) << 8 ) ; self . w } }
# [ doc = "Channel input enable for the - terminal\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPNEN_A { # [ doc = "0: Selected analog input channel for V- terminal is disabled." ] CPNEN_0 = 0 , # [ doc = "1: Selected analog input channel for V- terminal is enabled." ] CPNEN_1 = 1 } impl From < CPNEN_A > for bool { # [ inline ( always ) ] fn from ( variant : CPNEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPNEN`" ] pub type CPNEN_R = crate :: R < bool , CPNEN_A > ; impl CPNEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPNEN_A { match self . bits { false => CPNEN_A :: CPNEN_0 , true => CPNEN_A :: CPNEN_1 } } # [ doc = "Checks if the value of the field is `CPNEN_0`" ] # [ inline ( always ) ] pub fn is_cpnen_0 ( & self ) -> bool { * self == CPNEN_A :: CPNEN_0 } # [ doc = "Checks if the value of the field is `CPNEN_1`" ] # [ inline ( always ) ] pub fn is_cpnen_1 ( & self ) -> bool { * self == CPNEN_A :: CPNEN_1 } }
# [ doc = "Write proxy for field `CPNEN`" ] pub struct CPNEN_W < 'a > { w : & 'a mut W , } impl < 'a > CPNEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPNEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Selected analog input channel for V- terminal is disabled." ] # [ inline ( always ) ] pub fn cpnen_0 ( self ) -> & 'a mut W { self . variant ( CPNEN_A :: CPNEN_0 ) } # [ doc = "Selected analog input channel for V- terminal is enabled." ] # [ inline ( always ) ] pub fn cpnen_1 ( self ) -> & 'a mut W { self . variant ( CPNEN_A :: CPNEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Channel input selected for the V+ terminal\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPPSEL_A { # [ doc = "0: select external input source" ] CPPSEL_0 = 0 , # [ doc = "1: select external input source" ] CPPSEL_1 = 1 , # [ doc = "2: select external input source" ] CPPSEL_2 = 2 , # [ doc = "3: select external input source" ] CPPSEL_3 = 3 , # [ doc = "4: device specific, please refer to device data sheet for details" ] CPPSEL_4 = 4 , # [ doc = "5: device specific, please refer to device data sheet for details" ] CPPSEL_5 = 5 , # [ doc = "6: 6-bit DAC" ] CPPSEL_6 = 6 , # [ doc = "7: Reserved" ] CPPSEL_7 = 7 } impl From < CPPSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPPSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPPSEL`" ] pub type CPPSEL_R = crate :: R < u8 , CPPSEL_A > ; impl CPPSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPPSEL_A { match self . bits { 0 => CPPSEL_A :: CPPSEL_0 , 1 => CPPSEL_A :: CPPSEL_1 , 2 => CPPSEL_A :: CPPSEL_2 , 3 => CPPSEL_A :: CPPSEL_3 , 4 => CPPSEL_A :: CPPSEL_4 , 5 => CPPSEL_A :: CPPSEL_5 , 6 => CPPSEL_A :: CPPSEL_6 , 7 => CPPSEL_A :: CPPSEL_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPPSEL_0`" ] # [ inline ( always ) ] pub fn is_cppsel_0 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_0 } # [ doc = "Checks if the value of the field is `CPPSEL_1`" ] # [ inline ( always ) ] pub fn is_cppsel_1 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_1 } # [ doc = "Checks if the value of the field is `CPPSEL_2`" ] # [ inline ( always ) ] pub fn is_cppsel_2 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_2 } # [ doc = "Checks if the value of the field is `CPPSEL_3`" ] # [ inline ( always ) ] pub fn is_cppsel_3 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_3 } # [ doc = "Checks if the value of the field is `CPPSEL_4`" ] # [ inline ( always ) ] pub fn is_cppsel_4 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_4 } # [ doc = "Checks if the value of the field is `CPPSEL_5`" ] # [ inline ( always ) ] pub fn is_cppsel_5 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_5 } # [ doc = "Checks if the value of the field is `CPPSEL_6`" ] # [ inline ( always ) ] pub fn is_cppsel_6 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_6 } # [ doc = "Checks if the value of the field is `CPPSEL_7`" ] # [ inline ( always ) ] pub fn is_cppsel_7 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_7 } }
# [ doc = "Write proxy for field `CPPSEL`" ] pub struct CPPSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CPPSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPPSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cppsel_0 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_0 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cppsel_1 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_1 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cppsel_2 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_2 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cppsel_3 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_3 ) } # [ doc = "device specific, please refer to device data sheet for details" ] # [ inline ( always ) ] pub fn cppsel_4 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_4 ) } # [ doc = "device specific, please refer to device data sheet for details" ] # [ inline ( always ) ] pub fn cppsel_5 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_5 ) } # [ doc = "6-bit DAC" ] # [ inline ( always ) ] pub fn cppsel_6 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_6 ) } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn cppsel_7 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u16 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bit 4 - Channel input enable for the V+ terminal" ] # [ inline ( always ) ] pub fn cppen ( & self ) -> CPPEN_R { CPPEN_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:10 - Channel input selected for the - terminal" ] # [ inline ( always ) ] pub fn cpnsel ( & self ) -> CPNSEL_R { CPNSEL_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 12 - Channel input enable for the - terminal" ] # [ inline ( always ) ] pub fn cpnen ( & self ) -> CPNEN_R { CPNEN_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 0:2 - Channel input selected for the V+ terminal" ] # [ inline ( always ) ] pub fn cppsel ( & self ) -> CPPSEL_R { CPPSEL_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bit 4 - Channel input enable for the V+ terminal" ] # [ inline ( always ) ] pub fn cppen ( & mut self ) -> CPPEN_W { CPPEN_W { w : self } }
# [ doc = "Bits 8:10 - Channel input selected for the - terminal" ] # [ inline ( always ) ] pub fn cpnsel ( & mut self ) -> CPNSEL_W { CPNSEL_W { w : self } }
# [ doc = "Bit 12 - Channel input enable for the - terminal" ] # [ inline ( always ) ] pub fn cpnen ( & mut self ) -> CPNEN_W { CPNEN_W { w : self } }
# [ doc = "Bits 0:2 - Channel input selected for the V+ terminal" ] # [ inline ( always ) ] pub fn cppsel ( & mut self ) -> CPPSEL_W { CPPSEL_W { w : self } }
}
}
# [ doc = "Comparator Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cpctl1](cpctl1) module" ] pub type CPCTL1 = crate :: Reg < u16 , _CPCTL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CPCTL1 ;
# [ doc = "`read()` method returns [cpctl1::R](cpctl1::R) reader structure" ] impl crate :: Readable for CPCTL1 { }
# [ doc = "`write(|w| ..)` method takes [cpctl1::W](cpctl1::W) writer structure" ] impl crate :: Writable for CPCTL1 { }
# [ doc = "Comparator Control Register 1" ] pub mod cpctl1 {
# [ doc = "Reader of register CPCTL1" ] pub type R = crate :: R < u16 , super :: CPCTL1 > ;
# [ doc = "Writer for register CPCTL1" ] pub type W = crate :: W < u16 , super :: CPCTL1 > ;
# [ doc = "Register CPCTL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CPCTL1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CPOUT`" ] pub type CPOUT_R = crate :: R < bool , bool > ;
# [ doc = "Comparator output polarity\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPINV_A { # [ doc = "0: Comparator output is non-inverted" ] CPINV_0 = 0 , # [ doc = "1: Comparator output is inverted" ] CPINV_1 = 1 } impl From < CPINV_A > for bool { # [ inline ( always ) ] fn from ( variant : CPINV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPINV`" ] pub type CPINV_R = crate :: R < bool , CPINV_A > ; impl CPINV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPINV_A { match self . bits { false => CPINV_A :: CPINV_0 , true => CPINV_A :: CPINV_1 } } # [ doc = "Checks if the value of the field is `CPINV_0`" ] # [ inline ( always ) ] pub fn is_cpinv_0 ( & self ) -> bool { * self == CPINV_A :: CPINV_0 } # [ doc = "Checks if the value of the field is `CPINV_1`" ] # [ inline ( always ) ] pub fn is_cpinv_1 ( & self ) -> bool { * self == CPINV_A :: CPINV_1 } }
# [ doc = "Write proxy for field `CPINV`" ] pub struct CPINV_W < 'a > { w : & 'a mut W , } impl < 'a > CPINV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPINV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Comparator output is non-inverted" ] # [ inline ( always ) ] pub fn cpinv_0 ( self ) -> & 'a mut W { self . variant ( CPINV_A :: CPINV_0 ) } # [ doc = "Comparator output is inverted" ] # [ inline ( always ) ] pub fn cpinv_1 ( self ) -> & 'a mut W { self . variant ( CPINV_A :: CPINV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Interrupt edge select for CEIIFG and CEIFG\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPIES_A { # [ doc = "0: Rising edge for CPIFG, falling edge for CPIIFG" ] CPIES_0 = 0 , # [ doc = "1: Falling edge for CPIFG, rising edge for CPIIFG" ] CPIES_1 = 1 } impl From < CPIES_A > for bool { # [ inline ( always ) ] fn from ( variant : CPIES_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPIES`" ] pub type CPIES_R = crate :: R < bool , CPIES_A > ; impl CPIES_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPIES_A { match self . bits { false => CPIES_A :: CPIES_0 , true => CPIES_A :: CPIES_1 } } # [ doc = "Checks if the value of the field is `CPIES_0`" ] # [ inline ( always ) ] pub fn is_cpies_0 ( & self ) -> bool { * self == CPIES_A :: CPIES_0 } # [ doc = "Checks if the value of the field is `CPIES_1`" ] # [ inline ( always ) ] pub fn is_cpies_1 ( & self ) -> bool { * self == CPIES_A :: CPIES_1 } }
# [ doc = "Write proxy for field `CPIES`" ] pub struct CPIES_W < 'a > { w : & 'a mut W , } impl < 'a > CPIES_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPIES_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Rising edge for CPIFG, falling edge for CPIIFG" ] # [ inline ( always ) ] pub fn cpies_0 ( self ) -> & 'a mut W { self . variant ( CPIES_A :: CPIES_0 ) } # [ doc = "Falling edge for CPIFG, rising edge for CPIIFG" ] # [ inline ( always ) ] pub fn cpies_1 ( self ) -> & 'a mut W { self . variant ( CPIES_A :: CPIES_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Analog Output Low Pass filter Selection. Changing CPFLT might set interrupt flag.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPFLT_A { # [ doc = "0: Comparator output is not filtered" ] CPFLT_0 = 0 , # [ doc = "1: Comparator output is filtered" ] CPFLT_1 = 1 } impl From < CPFLT_A > for bool { # [ inline ( always ) ] fn from ( variant : CPFLT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPFLT`" ] pub type CPFLT_R = crate :: R < bool , CPFLT_A > ; impl CPFLT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPFLT_A { match self . bits { false => CPFLT_A :: CPFLT_0 , true => CPFLT_A :: CPFLT_1 } } # [ doc = "Checks if the value of the field is `CPFLT_0`" ] # [ inline ( always ) ] pub fn is_cpflt_0 ( & self ) -> bool { * self == CPFLT_A :: CPFLT_0 } # [ doc = "Checks if the value of the field is `CPFLT_1`" ] # [ inline ( always ) ] pub fn is_cpflt_1 ( & self ) -> bool { * self == CPFLT_A :: CPFLT_1 } }
# [ doc = "Write proxy for field `CPFLT`" ] pub struct CPFLT_W < 'a > { w : & 'a mut W , } impl < 'a > CPFLT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPFLT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Comparator output is not filtered" ] # [ inline ( always ) ] pub fn cpflt_0 ( self ) -> & 'a mut W { self . variant ( CPFLT_A :: CPFLT_0 ) } # [ doc = "Comparator output is filtered" ] # [ inline ( always ) ] pub fn cpflt_1 ( self ) -> & 'a mut W { self . variant ( CPFLT_A :: CPFLT_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Analog Filter Delay selection. These bits are used to select the analog filter delay\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPFLTDLY_A { # [ doc = "0: Typical filter delay of 450ns" ] CPFLTDLY_0 = 0 , # [ doc = "1: Typical filter delay of 900ns" ] CPFLTDLY_1 = 1 , # [ doc = "2: Typical filter delay of 1800ns" ] CPFLTDLY_2 = 2 , # [ doc = "3: Typical filter delay of 3600ns" ] CPFLTDLY_3 = 3 } impl From < CPFLTDLY_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPFLTDLY_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPFLTDLY`" ] pub type CPFLTDLY_R = crate :: R < u8 , CPFLTDLY_A > ; impl CPFLTDLY_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPFLTDLY_A { match self . bits { 0 => CPFLTDLY_A :: CPFLTDLY_0 , 1 => CPFLTDLY_A :: CPFLTDLY_1 , 2 => CPFLTDLY_A :: CPFLTDLY_2 , 3 => CPFLTDLY_A :: CPFLTDLY_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPFLTDLY_0`" ] # [ inline ( always ) ] pub fn is_cpfltdly_0 ( & self ) -> bool { * self == CPFLTDLY_A :: CPFLTDLY_0 } # [ doc = "Checks if the value of the field is `CPFLTDLY_1`" ] # [ inline ( always ) ] pub fn is_cpfltdly_1 ( & self ) -> bool { * self == CPFLTDLY_A :: CPFLTDLY_1 } # [ doc = "Checks if the value of the field is `CPFLTDLY_2`" ] # [ inline ( always ) ] pub fn is_cpfltdly_2 ( & self ) -> bool { * self == CPFLTDLY_A :: CPFLTDLY_2 } # [ doc = "Checks if the value of the field is `CPFLTDLY_3`" ] # [ inline ( always ) ] pub fn is_cpfltdly_3 ( & self ) -> bool { * self == CPFLTDLY_A :: CPFLTDLY_3 } }
# [ doc = "Write proxy for field `CPFLTDLY`" ] pub struct CPFLTDLY_W < 'a > { w : & 'a mut W , } impl < 'a > CPFLTDLY_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPFLTDLY_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Typical filter delay of 450ns" ] # [ inline ( always ) ] pub fn cpfltdly_0 ( self ) -> & 'a mut W { self . variant ( CPFLTDLY_A :: CPFLTDLY_0 ) } # [ doc = "Typical filter delay of 900ns" ] # [ inline ( always ) ] pub fn cpfltdly_1 ( self ) -> & 'a mut W { self . variant ( CPFLTDLY_A :: CPFLTDLY_1 ) } # [ doc = "Typical filter delay of 1800ns" ] # [ inline ( always ) ] pub fn cpfltdly_2 ( self ) -> & 'a mut W { self . variant ( CPFLTDLY_A :: CPFLTDLY_2 ) } # [ doc = "Typical filter delay of 3600ns" ] # [ inline ( always ) ] pub fn cpfltdly_3 ( self ) -> & 'a mut W { self . variant ( CPFLTDLY_A :: CPFLTDLY_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Power mode selection.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPMSEL_A { # [ doc = "0: High-power & High speed mode (500nA)" ] CPMSEL_0 = 0 , # [ doc = "1: Low-power & Low speed mode (10nA)" ] CPMSEL_1 = 1 } impl From < CPMSEL_A > for bool { # [ inline ( always ) ] fn from ( variant : CPMSEL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPMSEL`" ] pub type CPMSEL_R = crate :: R < bool , CPMSEL_A > ; impl CPMSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPMSEL_A { match self . bits { false => CPMSEL_A :: CPMSEL_0 , true => CPMSEL_A :: CPMSEL_1 } } # [ doc = "Checks if the value of the field is `CPMSEL_0`" ] # [ inline ( always ) ] pub fn is_cpmsel_0 ( & self ) -> bool { * self == CPMSEL_A :: CPMSEL_0 } # [ doc = "Checks if the value of the field is `CPMSEL_1`" ] # [ inline ( always ) ] pub fn is_cpmsel_1 ( & self ) -> bool { * self == CPMSEL_A :: CPMSEL_1 } }
# [ doc = "Write proxy for field `CPMSEL`" ] pub struct CPMSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CPMSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPMSEL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "High-power & High speed mode (500nA)" ] # [ inline ( always ) ] pub fn cpmsel_0 ( self ) -> & 'a mut W { self . variant ( CPMSEL_A :: CPMSEL_0 ) } # [ doc = "Low-power & Low speed mode (10nA)" ] # [ inline ( always ) ] pub fn cpmsel_1 ( self ) -> & 'a mut W { self . variant ( CPMSEL_A :: CPMSEL_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Comparator enable/disable. This bit is used to disable/enable the comparator. When the comparator is disabled, the Comparator consumes no power.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPEN_A { # [ doc = "0: Comparator is disabled" ] CPEN_0 = 0 , # [ doc = "1: Comparator is enabled" ] CPEN_1 = 1 } impl From < CPEN_A > for bool { # [ inline ( always ) ] fn from ( variant : CPEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPEN`" ] pub type CPEN_R = crate :: R < bool , CPEN_A > ; impl CPEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPEN_A { match self . bits { false => CPEN_A :: CPEN_0 , true => CPEN_A :: CPEN_1 } } # [ doc = "Checks if the value of the field is `CPEN_0`" ] # [ inline ( always ) ] pub fn is_cpen_0 ( & self ) -> bool { * self == CPEN_A :: CPEN_0 } # [ doc = "Checks if the value of the field is `CPEN_1`" ] # [ inline ( always ) ] pub fn is_cpen_1 ( & self ) -> bool { * self == CPEN_A :: CPEN_1 } }
# [ doc = "Write proxy for field `CPEN`" ] pub struct CPEN_W < 'a > { w : & 'a mut W , } impl < 'a > CPEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Comparator is disabled" ] # [ inline ( always ) ] pub fn cpen_0 ( self ) -> & 'a mut W { self . variant ( CPEN_A :: CPEN_0 ) } # [ doc = "Comparator is enabled" ] # [ inline ( always ) ] pub fn cpen_1 ( self ) -> & 'a mut W { self . variant ( CPEN_A :: CPEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Programable Hysteresis mode. These bits are used to select the Hysteresis mode.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPHSEL_A { # [ doc = "0: disable" ] CPHSEL_0 = 0 , # [ doc = "1: 10mV" ] CPHSEL_1 = 1 , # [ doc = "2: 20mV" ] CPHSEL_2 = 2 , # [ doc = "3: 30mV" ] CPHSEL_3 = 3 } impl From < CPHSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPHSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPHSEL`" ] pub type CPHSEL_R = crate :: R < u8 , CPHSEL_A > ; impl CPHSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPHSEL_A { match self . bits { 0 => CPHSEL_A :: CPHSEL_0 , 1 => CPHSEL_A :: CPHSEL_1 , 2 => CPHSEL_A :: CPHSEL_2 , 3 => CPHSEL_A :: CPHSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPHSEL_0`" ] # [ inline ( always ) ] pub fn is_cphsel_0 ( & self ) -> bool { * self == CPHSEL_A :: CPHSEL_0 } # [ doc = "Checks if the value of the field is `CPHSEL_1`" ] # [ inline ( always ) ] pub fn is_cphsel_1 ( & self ) -> bool { * self == CPHSEL_A :: CPHSEL_1 } # [ doc = "Checks if the value of the field is `CPHSEL_2`" ] # [ inline ( always ) ] pub fn is_cphsel_2 ( & self ) -> bool { * self == CPHSEL_A :: CPHSEL_2 } # [ doc = "Checks if the value of the field is `CPHSEL_3`" ] # [ inline ( always ) ] pub fn is_cphsel_3 ( & self ) -> bool { * self == CPHSEL_A :: CPHSEL_3 } }
# [ doc = "Write proxy for field `CPHSEL`" ] pub struct CPHSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CPHSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPHSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "disable" ] # [ inline ( always ) ] pub fn cphsel_0 ( self ) -> & 'a mut W { self . variant ( CPHSEL_A :: CPHSEL_0 ) } # [ doc = "10mV" ] # [ inline ( always ) ] pub fn cphsel_1 ( self ) -> & 'a mut W { self . variant ( CPHSEL_A :: CPHSEL_1 ) } # [ doc = "20mV" ] # [ inline ( always ) ] pub fn cphsel_2 ( self ) -> & 'a mut W { self . variant ( CPHSEL_A :: CPHSEL_2 ) } # [ doc = "30mV" ] # [ inline ( always ) ] pub fn cphsel_3 ( self ) -> & 'a mut W { self . variant ( CPHSEL_A :: CPHSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u16 ) & 0x03 ) << 10 ) ; self . w } }
# [ doc = "Comparator interrupt output enable bit\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPIE_A { # [ doc = "0: Interrupt output is disabled" ] CPIE_0 = 0 , # [ doc = "1: Interrupt output is enabled" ] CPIE_1 = 1 } impl From < CPIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CPIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPIE`" ] pub type CPIE_R = crate :: R < bool , CPIE_A > ; impl CPIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPIE_A { match self . bits { false => CPIE_A :: CPIE_0 , true => CPIE_A :: CPIE_1 } } # [ doc = "Checks if the value of the field is `CPIE_0`" ] # [ inline ( always ) ] pub fn is_cpie_0 ( & self ) -> bool { * self == CPIE_A :: CPIE_0 } # [ doc = "Checks if the value of the field is `CPIE_1`" ] # [ inline ( always ) ] pub fn is_cpie_1 ( & self ) -> bool { * self == CPIE_A :: CPIE_1 } }
# [ doc = "Write proxy for field `CPIE`" ] pub struct CPIE_W < 'a > { w : & 'a mut W , } impl < 'a > CPIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt output is disabled" ] # [ inline ( always ) ] pub fn cpie_0 ( self ) -> & 'a mut W { self . variant ( CPIE_A :: CPIE_0 ) } # [ doc = "Interrupt output is enabled" ] # [ inline ( always ) ] pub fn cpie_1 ( self ) -> & 'a mut W { self . variant ( CPIE_A :: CPIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Comparator inverted interrupt output enable bit\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPIIE_A { # [ doc = "0: Interrupt inverted output is disabled" ] CPIIE_0 = 0 , # [ doc = "1: Interrupt inverted output is enabled" ] CPIIE_1 = 1 } impl From < CPIIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CPIIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPIIE`" ] pub type CPIIE_R = crate :: R < bool , CPIIE_A > ; impl CPIIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPIIE_A { match self . bits { false => CPIIE_A :: CPIIE_0 , true => CPIIE_A :: CPIIE_1 } } # [ doc = "Checks if the value of the field is `CPIIE_0`" ] # [ inline ( always ) ] pub fn is_cpiie_0 ( & self ) -> bool { * self == CPIIE_A :: CPIIE_0 } # [ doc = "Checks if the value of the field is `CPIIE_1`" ] # [ inline ( always ) ] pub fn is_cpiie_1 ( & self ) -> bool { * self == CPIIE_A :: CPIIE_1 } }
# [ doc = "Write proxy for field `CPIIE`" ] pub struct CPIIE_W < 'a > { w : & 'a mut W , } impl < 'a > CPIIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPIIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt inverted output is disabled" ] # [ inline ( always ) ] pub fn cpiie_0 ( self ) -> & 'a mut W { self . variant ( CPIIE_A :: CPIIE_0 ) } # [ doc = "Interrupt inverted output is enabled" ] # [ inline ( always ) ] pub fn cpiie_1 ( self ) -> & 'a mut W { self . variant ( CPIIE_A :: CPIIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Comparator output value" ] # [ inline ( always ) ] pub fn cpout ( & self ) -> CPOUT_R { CPOUT_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Comparator output polarity" ] # [ inline ( always ) ] pub fn cpinv ( & self ) -> CPINV_R { CPINV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Interrupt edge select for CEIIFG and CEIFG" ] # [ inline ( always ) ] pub fn cpies ( & self ) -> CPIES_R { CPIES_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Analog Output Low Pass filter Selection. Changing CPFLT might set interrupt flag." ] # [ inline ( always ) ] pub fn cpflt ( & self ) -> CPFLT_R { CPFLT_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - Analog Filter Delay selection. These bits are used to select the analog filter delay" ] # [ inline ( always ) ] pub fn cpfltdly ( & self ) -> CPFLTDLY_R { CPFLTDLY_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Power mode selection." ] # [ inline ( always ) ] pub fn cpmsel ( & self ) -> CPMSEL_R { CPMSEL_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Comparator enable/disable. This bit is used to disable/enable the comparator. When the comparator is disabled, the Comparator consumes no power." ] # [ inline ( always ) ] pub fn cpen ( & self ) -> CPEN_R { CPEN_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 10:11 - Programable Hysteresis mode. These bits are used to select the Hysteresis mode." ] # [ inline ( always ) ] pub fn cphsel ( & self ) -> CPHSEL_R { CPHSEL_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 14 - Comparator interrupt output enable bit" ] # [ inline ( always ) ] pub fn cpie ( & self ) -> CPIE_R { CPIE_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Comparator inverted interrupt output enable bit" ] # [ inline ( always ) ] pub fn cpiie ( & self ) -> CPIIE_R { CPIIE_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 1 - Comparator output polarity" ] # [ inline ( always ) ] pub fn cpinv ( & mut self ) -> CPINV_W { CPINV_W { w : self } }
# [ doc = "Bit 4 - Interrupt edge select for CEIIFG and CEIFG" ] # [ inline ( always ) ] pub fn cpies ( & mut self ) -> CPIES_W { CPIES_W { w : self } }
# [ doc = "Bit 5 - Analog Output Low Pass filter Selection. Changing CPFLT might set interrupt flag." ] # [ inline ( always ) ] pub fn cpflt ( & mut self ) -> CPFLT_W { CPFLT_W { w : self } }
# [ doc = "Bits 6:7 - Analog Filter Delay selection. These bits are used to select the analog filter delay" ] # [ inline ( always ) ] pub fn cpfltdly ( & mut self ) -> CPFLTDLY_W { CPFLTDLY_W { w : self } }
# [ doc = "Bit 8 - Power mode selection." ] # [ inline ( always ) ] pub fn cpmsel ( & mut self ) -> CPMSEL_W { CPMSEL_W { w : self } }
# [ doc = "Bit 9 - Comparator enable/disable. This bit is used to disable/enable the comparator. When the comparator is disabled, the Comparator consumes no power." ] # [ inline ( always ) ] pub fn cpen ( & mut self ) -> CPEN_W { CPEN_W { w : self } }
# [ doc = "Bits 10:11 - Programable Hysteresis mode. These bits are used to select the Hysteresis mode." ] # [ inline ( always ) ] pub fn cphsel ( & mut self ) -> CPHSEL_W { CPHSEL_W { w : self } }
# [ doc = "Bit 14 - Comparator interrupt output enable bit" ] # [ inline ( always ) ] pub fn cpie ( & mut self ) -> CPIE_W { CPIE_W { w : self } }
# [ doc = "Bit 15 - Comparator inverted interrupt output enable bit" ] # [ inline ( always ) ] pub fn cpiie ( & mut self ) -> CPIIE_W { CPIIE_W { w : self } }
}
}
# [ doc = "Comparator Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cpint](cpint) module" ] pub type CPINT = crate :: Reg < u16 , _CPINT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CPINT ;
# [ doc = "`read()` method returns [cpint::R](cpint::R) reader structure" ] impl crate :: Readable for CPINT { }
# [ doc = "`write(|w| ..)` method takes [cpint::W](cpint::W) writer structure" ] impl crate :: Writable for CPINT { }
# [ doc = "Comparator Interrupt Control Register" ] pub mod cpint {
# [ doc = "Reader of register CPINT" ] pub type R = crate :: R < u16 , super :: CPINT > ;
# [ doc = "Writer for register CPINT" ] pub type W = crate :: W < u16 , super :: CPINT > ;
# [ doc = "Register CPINT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CPINT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Comparator output interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPIFG_A { # [ doc = "0: No interrupt pending." ] CPIFG_0 = 0 , # [ doc = "1: Output interrupt pending." ] CPIFG_1 = 1 } impl From < CPIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CPIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPIFG`" ] pub type CPIFG_R = crate :: R < bool , CPIFG_A > ; impl CPIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPIFG_A { match self . bits { false => CPIFG_A :: CPIFG_0 , true => CPIFG_A :: CPIFG_1 } } # [ doc = "Checks if the value of the field is `CPIFG_0`" ] # [ inline ( always ) ] pub fn is_cpifg_0 ( & self ) -> bool { * self == CPIFG_A :: CPIFG_0 } # [ doc = "Checks if the value of the field is `CPIFG_1`" ] # [ inline ( always ) ] pub fn is_cpifg_1 ( & self ) -> bool { * self == CPIFG_A :: CPIFG_1 } }
# [ doc = "Write proxy for field `CPIFG`" ] pub struct CPIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CPIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending." ] # [ inline ( always ) ] pub fn cpifg_0 ( self ) -> & 'a mut W { self . variant ( CPIFG_A :: CPIFG_0 ) } # [ doc = "Output interrupt pending." ] # [ inline ( always ) ] pub fn cpifg_1 ( self ) -> & 'a mut W { self . variant ( CPIFG_A :: CPIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Comparator output inverted interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPIIFG_A { # [ doc = "0: No interrupt pending." ] CPIIFG_0 = 0 , # [ doc = "1: Output interrupt pending." ] CPIIFG_1 = 1 } impl From < CPIIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CPIIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPIIFG`" ] pub type CPIIFG_R = crate :: R < bool , CPIIFG_A > ; impl CPIIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPIIFG_A { match self . bits { false => CPIIFG_A :: CPIIFG_0 , true => CPIIFG_A :: CPIIFG_1 } } # [ doc = "Checks if the value of the field is `CPIIFG_0`" ] # [ inline ( always ) ] pub fn is_cpiifg_0 ( & self ) -> bool { * self == CPIIFG_A :: CPIIFG_0 } # [ doc = "Checks if the value of the field is `CPIIFG_1`" ] # [ inline ( always ) ] pub fn is_cpiifg_1 ( & self ) -> bool { * self == CPIIFG_A :: CPIIFG_1 } }
# [ doc = "Write proxy for field `CPIIFG`" ] pub struct CPIIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CPIIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPIIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending." ] # [ inline ( always ) ] pub fn cpiifg_0 ( self ) -> & 'a mut W { self . variant ( CPIIFG_A :: CPIIFG_0 ) } # [ doc = "Output interrupt pending." ] # [ inline ( always ) ] pub fn cpiifg_1 ( self ) -> & 'a mut W { self . variant ( CPIIFG_A :: CPIIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Comparator output interrupt flag" ] # [ inline ( always ) ] pub fn cpifg ( & self ) -> CPIFG_R { CPIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Comparator output inverted interrupt flag" ] # [ inline ( always ) ] pub fn cpiifg ( & self ) -> CPIIFG_R { CPIIFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Comparator output interrupt flag" ] # [ inline ( always ) ] pub fn cpifg ( & mut self ) -> CPIFG_W { CPIFG_W { w : self } }
# [ doc = "Bit 1 - Comparator output inverted interrupt flag" ] # [ inline ( always ) ] pub fn cpiifg ( & mut self ) -> CPIIFG_W { CPIIFG_W { w : self } }
}
}
# [ doc = "Comparator Interrupt Vector Word Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cpiv](cpiv) module" ] pub type CPIV = crate :: Reg < u16 , _CPIV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CPIV ;
# [ doc = "`read()` method returns [cpiv::R](cpiv::R) reader structure" ] impl crate :: Readable for CPIV { }
# [ doc = "Comparator Interrupt Vector Word Register" ] pub mod cpiv {
# [ doc = "Reader of register CPIV" ] pub type R = crate :: R < u16 , super :: CPIV > ;
# [ doc = "Comparator interrupt vector word register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum CPIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: CPIFG" ] CPIFG = 2 , # [ doc = "4: CPIIFG" ] CPIIFG = 4 } impl From < CPIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : CPIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPIV`" ] pub type CPIV_R = crate :: R < u16 , CPIV_A > ; impl CPIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , CPIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CPIV_A :: NONE ) , 2 => Val ( CPIV_A :: CPIFG ) , 4 => Val ( CPIV_A :: CPIIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CPIV_A :: NONE } # [ doc = "Checks if the value of the field is `CPIFG`" ] # [ inline ( always ) ] pub fn is_cpifg ( & self ) -> bool { * self == CPIV_A :: CPIFG } # [ doc = "Checks if the value of the field is `CPIIFG`" ] # [ inline ( always ) ] pub fn is_cpiifg ( & self ) -> bool { * self == CPIV_A :: CPIIFG } }
impl R {
# [ doc = "Bits 0:15 - Comparator interrupt vector word register" ] # [ inline ( always ) ] pub fn cpiv ( & self ) -> CPIV_R { CPIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
# [ doc = "6-bit Comparator built-in DAC Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cpdacctl](cpdacctl) module" ] pub type CPDACCTL = crate :: Reg < u16 , _CPDACCTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CPDACCTL ;
# [ doc = "`read()` method returns [cpdacctl::R](cpdacctl::R) reader structure" ] impl crate :: Readable for CPDACCTL { }
# [ doc = "`write(|w| ..)` method takes [cpdacctl::W](cpdacctl::W) writer structure" ] impl crate :: Writable for CPDACCTL { }
# [ doc = "6-bit Comparator built-in DAC Control Register" ] pub mod cpdacctl {
# [ doc = "Reader of register CPDACCTL" ] pub type R = crate :: R < u16 , super :: CPDACCTL > ;
# [ doc = "Writer for register CPDACCTL" ] pub type W = crate :: W < u16 , super :: CPDACCTL > ;
# [ doc = "Register CPDACCTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CPDACCTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "This bit is only valid when CPDACBUFS is set to 1.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPDACSW_A { # [ doc = "0: CPDACBUF1 selected" ] CPDACSW_0 = 0 , # [ doc = "1: CPDACBUF2 selected" ] CPDACSW_1 = 1 } impl From < CPDACSW_A > for bool { # [ inline ( always ) ] fn from ( variant : CPDACSW_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPDACSW`" ] pub type CPDACSW_R = crate :: R < bool , CPDACSW_A > ; impl CPDACSW_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACSW_A { match self . bits { false => CPDACSW_A :: CPDACSW_0 , true => CPDACSW_A :: CPDACSW_1 } } # [ doc = "Checks if the value of the field is `CPDACSW_0`" ] # [ inline ( always ) ] pub fn is_cpdacsw_0 ( & self ) -> bool { * self == CPDACSW_A :: CPDACSW_0 } # [ doc = "Checks if the value of the field is `CPDACSW_1`" ] # [ inline ( always ) ] pub fn is_cpdacsw_1 ( & self ) -> bool { * self == CPDACSW_A :: CPDACSW_1 } }
# [ doc = "Write proxy for field `CPDACSW`" ] pub struct CPDACSW_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACSW_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACSW_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "CPDACBUF1 selected" ] # [ inline ( always ) ] pub fn cpdacsw_0 ( self ) -> & 'a mut W { self . variant ( CPDACSW_A :: CPDACSW_0 ) } # [ doc = "CPDACBUF2 selected" ] # [ inline ( always ) ] pub fn cpdacsw_1 ( self ) -> & 'a mut W { self . variant ( CPDACSW_A :: CPDACSW_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Comparator built-in DAC buffer controlled source selection.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPDACBUFS_A { # [ doc = "0: Comparator output is selected as the buffer control source" ] CPDACBUFS_0 = 0 , # [ doc = "1: CPDACSW bit is selected as the buffer control source" ] CPDACBUFS_1 = 1 } impl From < CPDACBUFS_A > for bool { # [ inline ( always ) ] fn from ( variant : CPDACBUFS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPDACBUFS`" ] pub type CPDACBUFS_R = crate :: R < bool , CPDACBUFS_A > ; impl CPDACBUFS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACBUFS_A { match self . bits { false => CPDACBUFS_A :: CPDACBUFS_0 , true => CPDACBUFS_A :: CPDACBUFS_1 } } # [ doc = "Checks if the value of the field is `CPDACBUFS_0`" ] # [ inline ( always ) ] pub fn is_cpdacbufs_0 ( & self ) -> bool { * self == CPDACBUFS_A :: CPDACBUFS_0 } # [ doc = "Checks if the value of the field is `CPDACBUFS_1`" ] # [ inline ( always ) ] pub fn is_cpdacbufs_1 ( & self ) -> bool { * self == CPDACBUFS_A :: CPDACBUFS_1 } }
# [ doc = "Write proxy for field `CPDACBUFS`" ] pub struct CPDACBUFS_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACBUFS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACBUFS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Comparator output is selected as the buffer control source" ] # [ inline ( always ) ] pub fn cpdacbufs_0 ( self ) -> & 'a mut W { self . variant ( CPDACBUFS_A :: CPDACBUFS_0 ) } # [ doc = "CPDACSW bit is selected as the buffer control source" ] # [ inline ( always ) ] pub fn cpdacbufs_1 ( self ) -> & 'a mut W { self . variant ( CPDACBUFS_A :: CPDACBUFS_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Comparator built-in DAC reference voltage selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPDACREFS_A { # [ doc = "0: VDD selected" ] CPDACREFS_0 = 0 , # [ doc = "1: on-chip VREF selected" ] CPDACREFS_1 = 1 } impl From < CPDACREFS_A > for bool { # [ inline ( always ) ] fn from ( variant : CPDACREFS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPDACREFS`" ] pub type CPDACREFS_R = crate :: R < bool , CPDACREFS_A > ; impl CPDACREFS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACREFS_A { match self . bits { false => CPDACREFS_A :: CPDACREFS_0 , true => CPDACREFS_A :: CPDACREFS_1 } } # [ doc = "Checks if the value of the field is `CPDACREFS_0`" ] # [ inline ( always ) ] pub fn is_cpdacrefs_0 ( & self ) -> bool { * self == CPDACREFS_A :: CPDACREFS_0 } # [ doc = "Checks if the value of the field is `CPDACREFS_1`" ] # [ inline ( always ) ] pub fn is_cpdacrefs_1 ( & self ) -> bool { * self == CPDACREFS_A :: CPDACREFS_1 } }
# [ doc = "Write proxy for field `CPDACREFS`" ] pub struct CPDACREFS_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACREFS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACREFS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "VDD selected" ] # [ inline ( always ) ] pub fn cpdacrefs_0 ( self ) -> & 'a mut W { self . variant ( CPDACREFS_A :: CPDACREFS_0 ) } # [ doc = "on-chip VREF selected" ] # [ inline ( always ) ] pub fn cpdacrefs_1 ( self ) -> & 'a mut W { self . variant ( CPDACREFS_A :: CPDACREFS_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Comparator built-in DAC output control bit.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPDACEN_A { # [ doc = "0: DAC output is disabled." ] CPDACEN_0 = 0 , # [ doc = "1: DAC output is enabled." ] CPDACEN_1 = 1 } impl From < CPDACEN_A > for bool { # [ inline ( always ) ] fn from ( variant : CPDACEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPDACEN`" ] pub type CPDACEN_R = crate :: R < bool , CPDACEN_A > ; impl CPDACEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACEN_A { match self . bits { false => CPDACEN_A :: CPDACEN_0 , true => CPDACEN_A :: CPDACEN_1 } } # [ doc = "Checks if the value of the field is `CPDACEN_0`" ] # [ inline ( always ) ] pub fn is_cpdacen_0 ( & self ) -> bool { * self == CPDACEN_A :: CPDACEN_0 } # [ doc = "Checks if the value of the field is `CPDACEN_1`" ] # [ inline ( always ) ] pub fn is_cpdacen_1 ( & self ) -> bool { * self == CPDACEN_A :: CPDACEN_1 } }
# [ doc = "Write proxy for field `CPDACEN`" ] pub struct CPDACEN_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "DAC output is disabled." ] # [ inline ( always ) ] pub fn cpdacen_0 ( self ) -> & 'a mut W { self . variant ( CPDACEN_A :: CPDACEN_0 ) } # [ doc = "DAC output is enabled." ] # [ inline ( always ) ] pub fn cpdacen_1 ( self ) -> & 'a mut W { self . variant ( CPDACEN_A :: CPDACEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - This bit is only valid when CPDACBUFS is set to 1." ] # [ inline ( always ) ] pub fn cpdacsw ( & self ) -> CPDACSW_R { CPDACSW_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Comparator built-in DAC buffer controlled source selection." ] # [ inline ( always ) ] pub fn cpdacbufs ( & self ) -> CPDACBUFS_R { CPDACBUFS_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Comparator built-in DAC reference voltage selection" ] # [ inline ( always ) ] pub fn cpdacrefs ( & self ) -> CPDACREFS_R { CPDACREFS_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Comparator built-in DAC output control bit." ] # [ inline ( always ) ] pub fn cpdacen ( & self ) -> CPDACEN_R { CPDACEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - This bit is only valid when CPDACBUFS is set to 1." ] # [ inline ( always ) ] pub fn cpdacsw ( & mut self ) -> CPDACSW_W { CPDACSW_W { w : self } }
# [ doc = "Bit 1 - Comparator built-in DAC buffer controlled source selection." ] # [ inline ( always ) ] pub fn cpdacbufs ( & mut self ) -> CPDACBUFS_W { CPDACBUFS_W { w : self } }
# [ doc = "Bit 2 - Comparator built-in DAC reference voltage selection" ] # [ inline ( always ) ] pub fn cpdacrefs ( & mut self ) -> CPDACREFS_W { CPDACREFS_W { w : self } }
# [ doc = "Bit 7 - Comparator built-in DAC output control bit." ] # [ inline ( always ) ] pub fn cpdacen ( & mut self ) -> CPDACEN_W { CPDACEN_W { w : self } }
}
}
# [ doc = "6-bit Comparator built-in DAC Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cpdacdata](cpdacdata) module" ] pub type CPDACDATA = crate :: Reg < u16 , _CPDACDATA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CPDACDATA ;
# [ doc = "`read()` method returns [cpdacdata::R](cpdacdata::R) reader structure" ] impl crate :: Readable for CPDACDATA { }
# [ doc = "`write(|w| ..)` method takes [cpdacdata::W](cpdacdata::W) writer structure" ] impl crate :: Writable for CPDACDATA { }
# [ doc = "6-bit Comparator built-in DAC Data Register" ] pub mod cpdacdata {
# [ doc = "Reader of register CPDACDATA" ] pub type R = crate :: R < u16 , super :: CPDACDATA > ;
# [ doc = "Writer for register CPDACDATA" ] pub type W = crate :: W < u16 , super :: CPDACDATA > ;
# [ doc = "Register CPDACDATA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CPDACDATA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "1st 6-bit DAC buffer Data\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPDACBUF1_A { # [ doc = "0: 0v" ] CPDACBUF1_0 = 0 , # [ doc = "1: selected reference voltage * 1/64" ] CPDACBUF1_1 = 1 , # [ doc = "2: selected reference voltage * 2/64" ] CPDACBUF1_2 = 2 , # [ doc = "3: selected reference voltage * 3/64" ] CPDACBUF1_3 = 3 , # [ doc = "4: selected reference voltage * 4/64" ] CPDACBUF1_4 = 4 , # [ doc = "5: selected reference voltage * 5/64" ] CPDACBUF1_5 = 5 , # [ doc = "6: selected reference voltage * 6/64" ] CPDACBUF1_6 = 6 , # [ doc = "7: selected reference voltage * 7/64" ] CPDACBUF1_7 = 7 , # [ doc = "8: selected reference voltage * 8/64" ] CPDACBUF1_8 = 8 , # [ doc = "9: selected reference voltage *9/64" ] CPDACBUF1_9 = 9 , # [ doc = "10: selected reference voltage * 10/64" ] CPDACBUF1_10 = 10 , # [ doc = "11: selected reference voltage * 11/64" ] CPDACBUF1_11 = 11 , # [ doc = "12: selected reference voltage * 12/64" ] CPDACBUF1_12 = 12 , # [ doc = "13: selected reference voltage * 13/64" ] CPDACBUF1_13 = 13 , # [ doc = "14: selected reference voltage * 14/64" ] CPDACBUF1_14 = 14 , # [ doc = "15: selected reference voltage * 15/64" ] CPDACBUF1_15 = 15 , # [ doc = "16: selected reference voltage * 16/64" ] CPDACBUF1_16 = 16 , # [ doc = "17: selected reference voltage * 17/64" ] CPDACBUF1_17 = 17 , # [ doc = "18: selected reference voltage * 18/64" ] CPDACBUF1_18 = 18 , # [ doc = "19: selected reference voltage * 19/64" ] CPDACBUF1_19 = 19 , # [ doc = "20: selected reference voltage * 20/64" ] CPDACBUF1_20 = 20 , # [ doc = "21: selected reference voltage * 21/64" ] CPDACBUF1_21 = 21 , # [ doc = "22: selected reference voltage * 22/64" ] CPDACBUF1_22 = 22 , # [ doc = "23: selected reference voltage * 23/64" ] CPDACBUF1_23 = 23 , # [ doc = "24: selected reference voltage * 24/64" ] CPDACBUF1_24 = 24 , # [ doc = "25: selected reference voltage * 25/64" ] CPDACBUF1_25 = 25 , # [ doc = "26: selected reference voltage * 26/64" ] CPDACBUF1_26 = 26 , # [ doc = "27: selected reference voltage * 27/64" ] CPDACBUF1_27 = 27 , # [ doc = "28: selected reference voltage * 28/64" ] CPDACBUF1_28 = 28 , # [ doc = "29: selected reference voltage * 29/64" ] CPDACBUF1_29 = 29 , # [ doc = "30: selected reference voltage * 30/64" ] CPDACBUF1_30 = 30 , # [ doc = "31: selected reference voltage * 31/64" ] CPDACBUF1_31 = 31 , # [ doc = "32: selected reference voltage * 32/64" ] CPDACBUF1_32 = 32 , # [ doc = "33: selected reference voltage * 33/64" ] CPDACBUF1_33 = 33 , # [ doc = "34: selected reference voltage * 34/64" ] CPDACBUF1_34 = 34 , # [ doc = "35: selected reference voltage * 35/64" ] CPDACBUF1_35 = 35 , # [ doc = "36: selected reference voltage * 36/64" ] CPDACBUF1_36 = 36 , # [ doc = "37: selected reference voltage * 37/64" ] CPDACBUF1_37 = 37 , # [ doc = "38: selected reference voltage * 38/64" ] CPDACBUF1_38 = 38 , # [ doc = "39: selected reference voltage * 39/64" ] CPDACBUF1_39 = 39 , # [ doc = "40: selected reference voltage * 40/64" ] CPDACBUF1_40 = 40 , # [ doc = "41: selected reference voltage * 41/64" ] CPDACBUF1_41 = 41 , # [ doc = "42: selected reference voltage * 42/64" ] CPDACBUF1_42 = 42 , # [ doc = "43: selected reference voltage * 43/64" ] CPDACBUF1_43 = 43 , # [ doc = "44: selected reference voltage * 44/64" ] CPDACBUF1_44 = 44 , # [ doc = "45: selected reference voltage * 45/64" ] CPDACBUF1_45 = 45 , # [ doc = "46: selected reference voltage * 46/64" ] CPDACBUF1_46 = 46 , # [ doc = "47: selected reference voltage * 47/64" ] CPDACBUF1_47 = 47 , # [ doc = "48: selected reference voltage * 48/64" ] CPDACBUF1_48 = 48 , # [ doc = "49: selected reference voltage * 49/64" ] CPDACBUF1_49 = 49 , # [ doc = "50: selected reference voltage * 50/64" ] CPDACBUF1_50 = 50 , # [ doc = "51: selected reference voltage * 51/64" ] CPDACBUF1_51 = 51 , # [ doc = "52: selected reference voltage * 52/64" ] CPDACBUF1_52 = 52 , # [ doc = "53: selected reference voltage * 53/64" ] CPDACBUF1_53 = 53 , # [ doc = "54: selected reference voltage * 54/64" ] CPDACBUF1_54 = 54 , # [ doc = "55: selected reference voltage * 55/64" ] CPDACBUF1_55 = 55 , # [ doc = "56: selected reference voltage * 56/64" ] CPDACBUF1_56 = 56 , # [ doc = "57: selected reference voltage * 57/64" ] CPDACBUF1_57 = 57 , # [ doc = "58: selected reference voltage * 58/64" ] CPDACBUF1_58 = 58 , # [ doc = "59: selected reference voltage * 59/64" ] CPDACBUF1_59 = 59 , # [ doc = "60: selected reference voltage * 60/64" ] CPDACBUF1_60 = 60 , # [ doc = "61: selected reference voltage * 61/64" ] CPDACBUF1_61 = 61 , # [ doc = "62: selected reference voltage * 62/64" ] CPDACBUF1_62 = 62 , # [ doc = "63: selected reference voltage * 63/64" ] CPDACBUF1_63 = 63 } impl From < CPDACBUF1_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPDACBUF1_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPDACBUF1`" ] pub type CPDACBUF1_R = crate :: R < u8 , CPDACBUF1_A > ; impl CPDACBUF1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACBUF1_A { match self . bits { 0 => CPDACBUF1_A :: CPDACBUF1_0 , 1 => CPDACBUF1_A :: CPDACBUF1_1 , 2 => CPDACBUF1_A :: CPDACBUF1_2 , 3 => CPDACBUF1_A :: CPDACBUF1_3 , 4 => CPDACBUF1_A :: CPDACBUF1_4 , 5 => CPDACBUF1_A :: CPDACBUF1_5 , 6 => CPDACBUF1_A :: CPDACBUF1_6 , 7 => CPDACBUF1_A :: CPDACBUF1_7 , 8 => CPDACBUF1_A :: CPDACBUF1_8 , 9 => CPDACBUF1_A :: CPDACBUF1_9 , 10 => CPDACBUF1_A :: CPDACBUF1_10 , 11 => CPDACBUF1_A :: CPDACBUF1_11 , 12 => CPDACBUF1_A :: CPDACBUF1_12 , 13 => CPDACBUF1_A :: CPDACBUF1_13 , 14 => CPDACBUF1_A :: CPDACBUF1_14 , 15 => CPDACBUF1_A :: CPDACBUF1_15 , 16 => CPDACBUF1_A :: CPDACBUF1_16 , 17 => CPDACBUF1_A :: CPDACBUF1_17 , 18 => CPDACBUF1_A :: CPDACBUF1_18 , 19 => CPDACBUF1_A :: CPDACBUF1_19 , 20 => CPDACBUF1_A :: CPDACBUF1_20 , 21 => CPDACBUF1_A :: CPDACBUF1_21 , 22 => CPDACBUF1_A :: CPDACBUF1_22 , 23 => CPDACBUF1_A :: CPDACBUF1_23 , 24 => CPDACBUF1_A :: CPDACBUF1_24 , 25 => CPDACBUF1_A :: CPDACBUF1_25 , 26 => CPDACBUF1_A :: CPDACBUF1_26 , 27 => CPDACBUF1_A :: CPDACBUF1_27 , 28 => CPDACBUF1_A :: CPDACBUF1_28 , 29 => CPDACBUF1_A :: CPDACBUF1_29 , 30 => CPDACBUF1_A :: CPDACBUF1_30 , 31 => CPDACBUF1_A :: CPDACBUF1_31 , 32 => CPDACBUF1_A :: CPDACBUF1_32 , 33 => CPDACBUF1_A :: CPDACBUF1_33 , 34 => CPDACBUF1_A :: CPDACBUF1_34 , 35 => CPDACBUF1_A :: CPDACBUF1_35 , 36 => CPDACBUF1_A :: CPDACBUF1_36 , 37 => CPDACBUF1_A :: CPDACBUF1_37 , 38 => CPDACBUF1_A :: CPDACBUF1_38 , 39 => CPDACBUF1_A :: CPDACBUF1_39 , 40 => CPDACBUF1_A :: CPDACBUF1_40 , 41 => CPDACBUF1_A :: CPDACBUF1_41 , 42 => CPDACBUF1_A :: CPDACBUF1_42 , 43 => CPDACBUF1_A :: CPDACBUF1_43 , 44 => CPDACBUF1_A :: CPDACBUF1_44 , 45 => CPDACBUF1_A :: CPDACBUF1_45 , 46 => CPDACBUF1_A :: CPDACBUF1_46 , 47 => CPDACBUF1_A :: CPDACBUF1_47 , 48 => CPDACBUF1_A :: CPDACBUF1_48 , 49 => CPDACBUF1_A :: CPDACBUF1_49 , 50 => CPDACBUF1_A :: CPDACBUF1_50 , 51 => CPDACBUF1_A :: CPDACBUF1_51 , 52 => CPDACBUF1_A :: CPDACBUF1_52 , 53 => CPDACBUF1_A :: CPDACBUF1_53 , 54 => CPDACBUF1_A :: CPDACBUF1_54 , 55 => CPDACBUF1_A :: CPDACBUF1_55 , 56 => CPDACBUF1_A :: CPDACBUF1_56 , 57 => CPDACBUF1_A :: CPDACBUF1_57 , 58 => CPDACBUF1_A :: CPDACBUF1_58 , 59 => CPDACBUF1_A :: CPDACBUF1_59 , 60 => CPDACBUF1_A :: CPDACBUF1_60 , 61 => CPDACBUF1_A :: CPDACBUF1_61 , 62 => CPDACBUF1_A :: CPDACBUF1_62 , 63 => CPDACBUF1_A :: CPDACBUF1_63 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPDACBUF1_0`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_0 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_0 } # [ doc = "Checks if the value of the field is `CPDACBUF1_1`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_1 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_1 } # [ doc = "Checks if the value of the field is `CPDACBUF1_2`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_2 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_2 } # [ doc = "Checks if the value of the field is `CPDACBUF1_3`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_3 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_3 } # [ doc = "Checks if the value of the field is `CPDACBUF1_4`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_4 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_4 } # [ doc = "Checks if the value of the field is `CPDACBUF1_5`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_5 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_5 } # [ doc = "Checks if the value of the field is `CPDACBUF1_6`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_6 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_6 } # [ doc = "Checks if the value of the field is `CPDACBUF1_7`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_7 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_7 } # [ doc = "Checks if the value of the field is `CPDACBUF1_8`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_8 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_8 } # [ doc = "Checks if the value of the field is `CPDACBUF1_9`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_9 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_9 } # [ doc = "Checks if the value of the field is `CPDACBUF1_10`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_10 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_10 } # [ doc = "Checks if the value of the field is `CPDACBUF1_11`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_11 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_11 } # [ doc = "Checks if the value of the field is `CPDACBUF1_12`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_12 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_12 } # [ doc = "Checks if the value of the field is `CPDACBUF1_13`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_13 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_13 } # [ doc = "Checks if the value of the field is `CPDACBUF1_14`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_14 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_14 } # [ doc = "Checks if the value of the field is `CPDACBUF1_15`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_15 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_15 } # [ doc = "Checks if the value of the field is `CPDACBUF1_16`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_16 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_16 } # [ doc = "Checks if the value of the field is `CPDACBUF1_17`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_17 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_17 } # [ doc = "Checks if the value of the field is `CPDACBUF1_18`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_18 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_18 } # [ doc = "Checks if the value of the field is `CPDACBUF1_19`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_19 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_19 } # [ doc = "Checks if the value of the field is `CPDACBUF1_20`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_20 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_20 } # [ doc = "Checks if the value of the field is `CPDACBUF1_21`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_21 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_21 } # [ doc = "Checks if the value of the field is `CPDACBUF1_22`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_22 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_22 } # [ doc = "Checks if the value of the field is `CPDACBUF1_23`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_23 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_23 } # [ doc = "Checks if the value of the field is `CPDACBUF1_24`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_24 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_24 } # [ doc = "Checks if the value of the field is `CPDACBUF1_25`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_25 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_25 } # [ doc = "Checks if the value of the field is `CPDACBUF1_26`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_26 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_26 } # [ doc = "Checks if the value of the field is `CPDACBUF1_27`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_27 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_27 } # [ doc = "Checks if the value of the field is `CPDACBUF1_28`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_28 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_28 } # [ doc = "Checks if the value of the field is `CPDACBUF1_29`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_29 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_29 } # [ doc = "Checks if the value of the field is `CPDACBUF1_30`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_30 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_30 } # [ doc = "Checks if the value of the field is `CPDACBUF1_31`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_31 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_31 } # [ doc = "Checks if the value of the field is `CPDACBUF1_32`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_32 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_32 } # [ doc = "Checks if the value of the field is `CPDACBUF1_33`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_33 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_33 } # [ doc = "Checks if the value of the field is `CPDACBUF1_34`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_34 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_34 } # [ doc = "Checks if the value of the field is `CPDACBUF1_35`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_35 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_35 } # [ doc = "Checks if the value of the field is `CPDACBUF1_36`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_36 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_36 } # [ doc = "Checks if the value of the field is `CPDACBUF1_37`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_37 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_37 } # [ doc = "Checks if the value of the field is `CPDACBUF1_38`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_38 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_38 } # [ doc = "Checks if the value of the field is `CPDACBUF1_39`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_39 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_39 } # [ doc = "Checks if the value of the field is `CPDACBUF1_40`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_40 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_40 } # [ doc = "Checks if the value of the field is `CPDACBUF1_41`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_41 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_41 } # [ doc = "Checks if the value of the field is `CPDACBUF1_42`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_42 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_42 } # [ doc = "Checks if the value of the field is `CPDACBUF1_43`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_43 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_43 } # [ doc = "Checks if the value of the field is `CPDACBUF1_44`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_44 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_44 } # [ doc = "Checks if the value of the field is `CPDACBUF1_45`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_45 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_45 } # [ doc = "Checks if the value of the field is `CPDACBUF1_46`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_46 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_46 } # [ doc = "Checks if the value of the field is `CPDACBUF1_47`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_47 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_47 } # [ doc = "Checks if the value of the field is `CPDACBUF1_48`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_48 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_48 } # [ doc = "Checks if the value of the field is `CPDACBUF1_49`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_49 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_49 } # [ doc = "Checks if the value of the field is `CPDACBUF1_50`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_50 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_50 } # [ doc = "Checks if the value of the field is `CPDACBUF1_51`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_51 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_51 } # [ doc = "Checks if the value of the field is `CPDACBUF1_52`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_52 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_52 } # [ doc = "Checks if the value of the field is `CPDACBUF1_53`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_53 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_53 } # [ doc = "Checks if the value of the field is `CPDACBUF1_54`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_54 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_54 } # [ doc = "Checks if the value of the field is `CPDACBUF1_55`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_55 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_55 } # [ doc = "Checks if the value of the field is `CPDACBUF1_56`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_56 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_56 } # [ doc = "Checks if the value of the field is `CPDACBUF1_57`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_57 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_57 } # [ doc = "Checks if the value of the field is `CPDACBUF1_58`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_58 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_58 } # [ doc = "Checks if the value of the field is `CPDACBUF1_59`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_59 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_59 } # [ doc = "Checks if the value of the field is `CPDACBUF1_60`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_60 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_60 } # [ doc = "Checks if the value of the field is `CPDACBUF1_61`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_61 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_61 } # [ doc = "Checks if the value of the field is `CPDACBUF1_62`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_62 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_62 } # [ doc = "Checks if the value of the field is `CPDACBUF1_63`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_63 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_63 } }
# [ doc = "Write proxy for field `CPDACBUF1`" ] pub struct CPDACBUF1_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACBUF1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACBUF1_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "0v" ] # [ inline ( always ) ] pub fn cpdacbuf1_0 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_0 ) } # [ doc = "selected reference voltage * 1/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_1 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_1 ) } # [ doc = "selected reference voltage * 2/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_2 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_2 ) } # [ doc = "selected reference voltage * 3/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_3 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_3 ) } # [ doc = "selected reference voltage * 4/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_4 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_4 ) } # [ doc = "selected reference voltage * 5/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_5 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_5 ) } # [ doc = "selected reference voltage * 6/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_6 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_6 ) } # [ doc = "selected reference voltage * 7/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_7 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_7 ) } # [ doc = "selected reference voltage * 8/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_8 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_8 ) } # [ doc = "selected reference voltage *9/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_9 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_9 ) } # [ doc = "selected reference voltage * 10/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_10 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_10 ) } # [ doc = "selected reference voltage * 11/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_11 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_11 ) } # [ doc = "selected reference voltage * 12/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_12 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_12 ) } # [ doc = "selected reference voltage * 13/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_13 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_13 ) } # [ doc = "selected reference voltage * 14/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_14 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_14 ) } # [ doc = "selected reference voltage * 15/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_15 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_15 ) } # [ doc = "selected reference voltage * 16/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_16 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_16 ) } # [ doc = "selected reference voltage * 17/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_17 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_17 ) } # [ doc = "selected reference voltage * 18/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_18 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_18 ) } # [ doc = "selected reference voltage * 19/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_19 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_19 ) } # [ doc = "selected reference voltage * 20/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_20 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_20 ) } # [ doc = "selected reference voltage * 21/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_21 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_21 ) } # [ doc = "selected reference voltage * 22/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_22 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_22 ) } # [ doc = "selected reference voltage * 23/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_23 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_23 ) } # [ doc = "selected reference voltage * 24/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_24 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_24 ) } # [ doc = "selected reference voltage * 25/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_25 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_25 ) } # [ doc = "selected reference voltage * 26/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_26 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_26 ) } # [ doc = "selected reference voltage * 27/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_27 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_27 ) } # [ doc = "selected reference voltage * 28/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_28 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_28 ) } # [ doc = "selected reference voltage * 29/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_29 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_29 ) } # [ doc = "selected reference voltage * 30/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_30 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_30 ) } # [ doc = "selected reference voltage * 31/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_31 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_31 ) } # [ doc = "selected reference voltage * 32/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_32 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_32 ) } # [ doc = "selected reference voltage * 33/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_33 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_33 ) } # [ doc = "selected reference voltage * 34/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_34 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_34 ) } # [ doc = "selected reference voltage * 35/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_35 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_35 ) } # [ doc = "selected reference voltage * 36/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_36 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_36 ) } # [ doc = "selected reference voltage * 37/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_37 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_37 ) } # [ doc = "selected reference voltage * 38/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_38 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_38 ) } # [ doc = "selected reference voltage * 39/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_39 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_39 ) } # [ doc = "selected reference voltage * 40/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_40 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_40 ) } # [ doc = "selected reference voltage * 41/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_41 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_41 ) } # [ doc = "selected reference voltage * 42/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_42 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_42 ) } # [ doc = "selected reference voltage * 43/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_43 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_43 ) } # [ doc = "selected reference voltage * 44/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_44 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_44 ) } # [ doc = "selected reference voltage * 45/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_45 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_45 ) } # [ doc = "selected reference voltage * 46/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_46 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_46 ) } # [ doc = "selected reference voltage * 47/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_47 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_47 ) } # [ doc = "selected reference voltage * 48/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_48 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_48 ) } # [ doc = "selected reference voltage * 49/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_49 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_49 ) } # [ doc = "selected reference voltage * 50/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_50 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_50 ) } # [ doc = "selected reference voltage * 51/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_51 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_51 ) } # [ doc = "selected reference voltage * 52/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_52 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_52 ) } # [ doc = "selected reference voltage * 53/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_53 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_53 ) } # [ doc = "selected reference voltage * 54/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_54 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_54 ) } # [ doc = "selected reference voltage * 55/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_55 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_55 ) } # [ doc = "selected reference voltage * 56/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_56 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_56 ) } # [ doc = "selected reference voltage * 57/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_57 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_57 ) } # [ doc = "selected reference voltage * 58/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_58 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_58 ) } # [ doc = "selected reference voltage * 59/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_59 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_59 ) } # [ doc = "selected reference voltage * 60/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_60 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_60 ) } # [ doc = "selected reference voltage * 61/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_61 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_61 ) } # [ doc = "selected reference voltage * 62/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_62 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_62 ) } # [ doc = "selected reference voltage * 63/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_63 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_63 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u16 ) & 0x3f ) ; self . w } }
# [ doc = "2nd 6-bit DAC buffer Data\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPDACBUF2_A { # [ doc = "0: 0v" ] CPDACBUF2_0 = 0 , # [ doc = "1: selected reference voltage * 1/64" ] CPDACBUF2_1 = 1 , # [ doc = "2: selected reference voltage * 2/64" ] CPDACBUF2_2 = 2 , # [ doc = "3: selected reference voltage * 3/64" ] CPDACBUF2_3 = 3 , # [ doc = "4: selected reference voltage * 4/64" ] CPDACBUF2_4 = 4 , # [ doc = "5: selected reference voltage * 5/64" ] CPDACBUF2_5 = 5 , # [ doc = "6: selected reference voltage * 6/64" ] CPDACBUF2_6 = 6 , # [ doc = "7: selected reference voltage * 7/64" ] CPDACBUF2_7 = 7 , # [ doc = "8: selected reference voltage * 8/64" ] CPDACBUF2_8 = 8 , # [ doc = "9: selected reference voltage * 9/64" ] CPDACBUF2_9 = 9 , # [ doc = "10: selected reference voltage * 10/64" ] CPDACBUF2_10 = 10 , # [ doc = "11: selected reference voltage * 11/64" ] CPDACBUF2_11 = 11 , # [ doc = "12: selected reference voltage * 12/64" ] CPDACBUF2_12 = 12 , # [ doc = "13: selected reference voltage * 13/64" ] CPDACBUF2_13 = 13 , # [ doc = "14: selected reference voltage * 14/64" ] CPDACBUF2_14 = 14 , # [ doc = "15: selected reference voltage * 15/64" ] CPDACBUF2_15 = 15 , # [ doc = "16: selected reference voltage * 16/64" ] CPDACBUF2_16 = 16 , # [ doc = "17: selected reference voltage * 17/64" ] CPDACBUF2_17 = 17 , # [ doc = "18: selected reference voltage * 18/64" ] CPDACBUF2_18 = 18 , # [ doc = "19: selected reference voltage * 19/64" ] CPDACBUF2_19 = 19 , # [ doc = "20: selected reference voltage * 20/64" ] CPDACBUF2_20 = 20 , # [ doc = "21: selected reference voltage * 21/64" ] CPDACBUF2_21 = 21 , # [ doc = "22: selected reference voltage * 22/64" ] CPDACBUF2_22 = 22 , # [ doc = "23: selected reference voltage * 23/64" ] CPDACBUF2_23 = 23 , # [ doc = "24: selected reference voltage * 24/64" ] CPDACBUF2_24 = 24 , # [ doc = "25: selected reference voltage * 25/64" ] CPDACBUF2_25 = 25 , # [ doc = "26: selected reference voltage * 26/64" ] CPDACBUF2_26 = 26 , # [ doc = "27: selected reference voltage * 27/64" ] CPDACBUF2_27 = 27 , # [ doc = "28: selected reference voltage * 28/64" ] CPDACBUF2_28 = 28 , # [ doc = "29: selected reference voltage * 29/64" ] CPDACBUF2_29 = 29 , # [ doc = "30: selected reference voltage * 30/64" ] CPDACBUF2_30 = 30 , # [ doc = "31: selected reference voltage * 31/64" ] CPDACBUF2_31 = 31 , # [ doc = "32: selected reference voltage * 32/64" ] CPDACBUF2_32 = 32 , # [ doc = "33: selected reference voltage * 33/64" ] CPDACBUF2_33 = 33 , # [ doc = "34: selected reference voltage * 34/64" ] CPDACBUF2_34 = 34 , # [ doc = "35: selected reference voltage * 35/64" ] CPDACBUF2_35 = 35 , # [ doc = "36: selected reference voltage * 36/64" ] CPDACBUF2_36 = 36 , # [ doc = "37: selected reference voltage * 37/64" ] CPDACBUF2_37 = 37 , # [ doc = "38: selected reference voltage * 38/64" ] CPDACBUF2_38 = 38 , # [ doc = "39: selected reference voltage * 39/64" ] CPDACBUF2_39 = 39 , # [ doc = "40: selected reference voltage * 40/64" ] CPDACBUF2_40 = 40 , # [ doc = "41: selected reference voltage * 41/64" ] CPDACBUF2_41 = 41 , # [ doc = "42: selected reference voltage * 42/64" ] CPDACBUF2_42 = 42 , # [ doc = "43: selected reference voltage * 43/64" ] CPDACBUF2_43 = 43 , # [ doc = "44: selected reference voltage * 44/64" ] CPDACBUF2_44 = 44 , # [ doc = "45: selected reference voltage * 45/64" ] CPDACBUF2_45 = 45 , # [ doc = "46: selected reference voltage * 46/64" ] CPDACBUF2_46 = 46 , # [ doc = "47: selected reference voltage * 47/64" ] CPDACBUF2_47 = 47 , # [ doc = "48: selected reference voltage * 48/64" ] CPDACBUF2_48 = 48 , # [ doc = "49: selected reference voltage * 49/64" ] CPDACBUF2_49 = 49 , # [ doc = "50: selected reference voltage * 50/64" ] CPDACBUF2_50 = 50 , # [ doc = "51: selected reference voltage * 51/64" ] CPDACBUF2_51 = 51 , # [ doc = "52: selected reference voltage * 52/64" ] CPDACBUF2_52 = 52 , # [ doc = "53: selected reference voltage * 53/64" ] CPDACBUF2_53 = 53 , # [ doc = "54: selected reference voltage * 54/64" ] CPDACBUF2_54 = 54 , # [ doc = "55: selected reference voltage * 55/64" ] CPDACBUF2_55 = 55 , # [ doc = "56: selected reference voltage * 56/64" ] CPDACBUF2_56 = 56 , # [ doc = "57: selected reference voltage * 57/64" ] CPDACBUF2_57 = 57 , # [ doc = "58: selected reference voltage * 58/64" ] CPDACBUF2_58 = 58 , # [ doc = "59: selected reference voltage * 59/64" ] CPDACBUF2_59 = 59 , # [ doc = "60: selected reference voltage * 60/64" ] CPDACBUF2_60 = 60 , # [ doc = "61: selected reference voltage * 61/64" ] CPDACBUF2_61 = 61 , # [ doc = "62: selected reference voltage * 62/64" ] CPDACBUF2_62 = 62 , # [ doc = "63: selected reference voltage * 63/64" ] CPDACBUF2_63 = 63 } impl From < CPDACBUF2_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPDACBUF2_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPDACBUF2`" ] pub type CPDACBUF2_R = crate :: R < u8 , CPDACBUF2_A > ; impl CPDACBUF2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACBUF2_A { match self . bits { 0 => CPDACBUF2_A :: CPDACBUF2_0 , 1 => CPDACBUF2_A :: CPDACBUF2_1 , 2 => CPDACBUF2_A :: CPDACBUF2_2 , 3 => CPDACBUF2_A :: CPDACBUF2_3 , 4 => CPDACBUF2_A :: CPDACBUF2_4 , 5 => CPDACBUF2_A :: CPDACBUF2_5 , 6 => CPDACBUF2_A :: CPDACBUF2_6 , 7 => CPDACBUF2_A :: CPDACBUF2_7 , 8 => CPDACBUF2_A :: CPDACBUF2_8 , 9 => CPDACBUF2_A :: CPDACBUF2_9 , 10 => CPDACBUF2_A :: CPDACBUF2_10 , 11 => CPDACBUF2_A :: CPDACBUF2_11 , 12 => CPDACBUF2_A :: CPDACBUF2_12 , 13 => CPDACBUF2_A :: CPDACBUF2_13 , 14 => CPDACBUF2_A :: CPDACBUF2_14 , 15 => CPDACBUF2_A :: CPDACBUF2_15 , 16 => CPDACBUF2_A :: CPDACBUF2_16 , 17 => CPDACBUF2_A :: CPDACBUF2_17 , 18 => CPDACBUF2_A :: CPDACBUF2_18 , 19 => CPDACBUF2_A :: CPDACBUF2_19 , 20 => CPDACBUF2_A :: CPDACBUF2_20 , 21 => CPDACBUF2_A :: CPDACBUF2_21 , 22 => CPDACBUF2_A :: CPDACBUF2_22 , 23 => CPDACBUF2_A :: CPDACBUF2_23 , 24 => CPDACBUF2_A :: CPDACBUF2_24 , 25 => CPDACBUF2_A :: CPDACBUF2_25 , 26 => CPDACBUF2_A :: CPDACBUF2_26 , 27 => CPDACBUF2_A :: CPDACBUF2_27 , 28 => CPDACBUF2_A :: CPDACBUF2_28 , 29 => CPDACBUF2_A :: CPDACBUF2_29 , 30 => CPDACBUF2_A :: CPDACBUF2_30 , 31 => CPDACBUF2_A :: CPDACBUF2_31 , 32 => CPDACBUF2_A :: CPDACBUF2_32 , 33 => CPDACBUF2_A :: CPDACBUF2_33 , 34 => CPDACBUF2_A :: CPDACBUF2_34 , 35 => CPDACBUF2_A :: CPDACBUF2_35 , 36 => CPDACBUF2_A :: CPDACBUF2_36 , 37 => CPDACBUF2_A :: CPDACBUF2_37 , 38 => CPDACBUF2_A :: CPDACBUF2_38 , 39 => CPDACBUF2_A :: CPDACBUF2_39 , 40 => CPDACBUF2_A :: CPDACBUF2_40 , 41 => CPDACBUF2_A :: CPDACBUF2_41 , 42 => CPDACBUF2_A :: CPDACBUF2_42 , 43 => CPDACBUF2_A :: CPDACBUF2_43 , 44 => CPDACBUF2_A :: CPDACBUF2_44 , 45 => CPDACBUF2_A :: CPDACBUF2_45 , 46 => CPDACBUF2_A :: CPDACBUF2_46 , 47 => CPDACBUF2_A :: CPDACBUF2_47 , 48 => CPDACBUF2_A :: CPDACBUF2_48 , 49 => CPDACBUF2_A :: CPDACBUF2_49 , 50 => CPDACBUF2_A :: CPDACBUF2_50 , 51 => CPDACBUF2_A :: CPDACBUF2_51 , 52 => CPDACBUF2_A :: CPDACBUF2_52 , 53 => CPDACBUF2_A :: CPDACBUF2_53 , 54 => CPDACBUF2_A :: CPDACBUF2_54 , 55 => CPDACBUF2_A :: CPDACBUF2_55 , 56 => CPDACBUF2_A :: CPDACBUF2_56 , 57 => CPDACBUF2_A :: CPDACBUF2_57 , 58 => CPDACBUF2_A :: CPDACBUF2_58 , 59 => CPDACBUF2_A :: CPDACBUF2_59 , 60 => CPDACBUF2_A :: CPDACBUF2_60 , 61 => CPDACBUF2_A :: CPDACBUF2_61 , 62 => CPDACBUF2_A :: CPDACBUF2_62 , 63 => CPDACBUF2_A :: CPDACBUF2_63 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPDACBUF2_0`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_0 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_0 } # [ doc = "Checks if the value of the field is `CPDACBUF2_1`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_1 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_1 } # [ doc = "Checks if the value of the field is `CPDACBUF2_2`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_2 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_2 } # [ doc = "Checks if the value of the field is `CPDACBUF2_3`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_3 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_3 } # [ doc = "Checks if the value of the field is `CPDACBUF2_4`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_4 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_4 } # [ doc = "Checks if the value of the field is `CPDACBUF2_5`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_5 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_5 } # [ doc = "Checks if the value of the field is `CPDACBUF2_6`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_6 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_6 } # [ doc = "Checks if the value of the field is `CPDACBUF2_7`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_7 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_7 } # [ doc = "Checks if the value of the field is `CPDACBUF2_8`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_8 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_8 } # [ doc = "Checks if the value of the field is `CPDACBUF2_9`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_9 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_9 } # [ doc = "Checks if the value of the field is `CPDACBUF2_10`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_10 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_10 } # [ doc = "Checks if the value of the field is `CPDACBUF2_11`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_11 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_11 } # [ doc = "Checks if the value of the field is `CPDACBUF2_12`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_12 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_12 } # [ doc = "Checks if the value of the field is `CPDACBUF2_13`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_13 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_13 } # [ doc = "Checks if the value of the field is `CPDACBUF2_14`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_14 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_14 } # [ doc = "Checks if the value of the field is `CPDACBUF2_15`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_15 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_15 } # [ doc = "Checks if the value of the field is `CPDACBUF2_16`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_16 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_16 } # [ doc = "Checks if the value of the field is `CPDACBUF2_17`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_17 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_17 } # [ doc = "Checks if the value of the field is `CPDACBUF2_18`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_18 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_18 } # [ doc = "Checks if the value of the field is `CPDACBUF2_19`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_19 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_19 } # [ doc = "Checks if the value of the field is `CPDACBUF2_20`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_20 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_20 } # [ doc = "Checks if the value of the field is `CPDACBUF2_21`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_21 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_21 } # [ doc = "Checks if the value of the field is `CPDACBUF2_22`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_22 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_22 } # [ doc = "Checks if the value of the field is `CPDACBUF2_23`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_23 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_23 } # [ doc = "Checks if the value of the field is `CPDACBUF2_24`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_24 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_24 } # [ doc = "Checks if the value of the field is `CPDACBUF2_25`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_25 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_25 } # [ doc = "Checks if the value of the field is `CPDACBUF2_26`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_26 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_26 } # [ doc = "Checks if the value of the field is `CPDACBUF2_27`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_27 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_27 } # [ doc = "Checks if the value of the field is `CPDACBUF2_28`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_28 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_28 } # [ doc = "Checks if the value of the field is `CPDACBUF2_29`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_29 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_29 } # [ doc = "Checks if the value of the field is `CPDACBUF2_30`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_30 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_30 } # [ doc = "Checks if the value of the field is `CPDACBUF2_31`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_31 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_31 } # [ doc = "Checks if the value of the field is `CPDACBUF2_32`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_32 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_32 } # [ doc = "Checks if the value of the field is `CPDACBUF2_33`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_33 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_33 } # [ doc = "Checks if the value of the field is `CPDACBUF2_34`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_34 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_34 } # [ doc = "Checks if the value of the field is `CPDACBUF2_35`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_35 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_35 } # [ doc = "Checks if the value of the field is `CPDACBUF2_36`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_36 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_36 } # [ doc = "Checks if the value of the field is `CPDACBUF2_37`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_37 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_37 } # [ doc = "Checks if the value of the field is `CPDACBUF2_38`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_38 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_38 } # [ doc = "Checks if the value of the field is `CPDACBUF2_39`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_39 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_39 } # [ doc = "Checks if the value of the field is `CPDACBUF2_40`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_40 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_40 } # [ doc = "Checks if the value of the field is `CPDACBUF2_41`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_41 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_41 } # [ doc = "Checks if the value of the field is `CPDACBUF2_42`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_42 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_42 } # [ doc = "Checks if the value of the field is `CPDACBUF2_43`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_43 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_43 } # [ doc = "Checks if the value of the field is `CPDACBUF2_44`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_44 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_44 } # [ doc = "Checks if the value of the field is `CPDACBUF2_45`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_45 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_45 } # [ doc = "Checks if the value of the field is `CPDACBUF2_46`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_46 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_46 } # [ doc = "Checks if the value of the field is `CPDACBUF2_47`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_47 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_47 } # [ doc = "Checks if the value of the field is `CPDACBUF2_48`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_48 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_48 } # [ doc = "Checks if the value of the field is `CPDACBUF2_49`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_49 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_49 } # [ doc = "Checks if the value of the field is `CPDACBUF2_50`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_50 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_50 } # [ doc = "Checks if the value of the field is `CPDACBUF2_51`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_51 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_51 } # [ doc = "Checks if the value of the field is `CPDACBUF2_52`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_52 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_52 } # [ doc = "Checks if the value of the field is `CPDACBUF2_53`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_53 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_53 } # [ doc = "Checks if the value of the field is `CPDACBUF2_54`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_54 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_54 } # [ doc = "Checks if the value of the field is `CPDACBUF2_55`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_55 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_55 } # [ doc = "Checks if the value of the field is `CPDACBUF2_56`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_56 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_56 } # [ doc = "Checks if the value of the field is `CPDACBUF2_57`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_57 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_57 } # [ doc = "Checks if the value of the field is `CPDACBUF2_58`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_58 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_58 } # [ doc = "Checks if the value of the field is `CPDACBUF2_59`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_59 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_59 } # [ doc = "Checks if the value of the field is `CPDACBUF2_60`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_60 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_60 } # [ doc = "Checks if the value of the field is `CPDACBUF2_61`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_61 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_61 } # [ doc = "Checks if the value of the field is `CPDACBUF2_62`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_62 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_62 } # [ doc = "Checks if the value of the field is `CPDACBUF2_63`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_63 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_63 } }
# [ doc = "Write proxy for field `CPDACBUF2`" ] pub struct CPDACBUF2_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACBUF2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACBUF2_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "0v" ] # [ inline ( always ) ] pub fn cpdacbuf2_0 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_0 ) } # [ doc = "selected reference voltage * 1/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_1 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_1 ) } # [ doc = "selected reference voltage * 2/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_2 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_2 ) } # [ doc = "selected reference voltage * 3/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_3 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_3 ) } # [ doc = "selected reference voltage * 4/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_4 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_4 ) } # [ doc = "selected reference voltage * 5/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_5 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_5 ) } # [ doc = "selected reference voltage * 6/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_6 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_6 ) } # [ doc = "selected reference voltage * 7/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_7 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_7 ) } # [ doc = "selected reference voltage * 8/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_8 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_8 ) } # [ doc = "selected reference voltage * 9/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_9 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_9 ) } # [ doc = "selected reference voltage * 10/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_10 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_10 ) } # [ doc = "selected reference voltage * 11/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_11 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_11 ) } # [ doc = "selected reference voltage * 12/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_12 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_12 ) } # [ doc = "selected reference voltage * 13/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_13 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_13 ) } # [ doc = "selected reference voltage * 14/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_14 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_14 ) } # [ doc = "selected reference voltage * 15/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_15 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_15 ) } # [ doc = "selected reference voltage * 16/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_16 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_16 ) } # [ doc = "selected reference voltage * 17/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_17 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_17 ) } # [ doc = "selected reference voltage * 18/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_18 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_18 ) } # [ doc = "selected reference voltage * 19/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_19 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_19 ) } # [ doc = "selected reference voltage * 20/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_20 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_20 ) } # [ doc = "selected reference voltage * 21/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_21 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_21 ) } # [ doc = "selected reference voltage * 22/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_22 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_22 ) } # [ doc = "selected reference voltage * 23/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_23 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_23 ) } # [ doc = "selected reference voltage * 24/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_24 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_24 ) } # [ doc = "selected reference voltage * 25/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_25 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_25 ) } # [ doc = "selected reference voltage * 26/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_26 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_26 ) } # [ doc = "selected reference voltage * 27/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_27 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_27 ) } # [ doc = "selected reference voltage * 28/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_28 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_28 ) } # [ doc = "selected reference voltage * 29/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_29 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_29 ) } # [ doc = "selected reference voltage * 30/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_30 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_30 ) } # [ doc = "selected reference voltage * 31/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_31 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_31 ) } # [ doc = "selected reference voltage * 32/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_32 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_32 ) } # [ doc = "selected reference voltage * 33/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_33 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_33 ) } # [ doc = "selected reference voltage * 34/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_34 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_34 ) } # [ doc = "selected reference voltage * 35/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_35 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_35 ) } # [ doc = "selected reference voltage * 36/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_36 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_36 ) } # [ doc = "selected reference voltage * 37/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_37 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_37 ) } # [ doc = "selected reference voltage * 38/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_38 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_38 ) } # [ doc = "selected reference voltage * 39/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_39 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_39 ) } # [ doc = "selected reference voltage * 40/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_40 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_40 ) } # [ doc = "selected reference voltage * 41/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_41 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_41 ) } # [ doc = "selected reference voltage * 42/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_42 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_42 ) } # [ doc = "selected reference voltage * 43/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_43 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_43 ) } # [ doc = "selected reference voltage * 44/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_44 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_44 ) } # [ doc = "selected reference voltage * 45/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_45 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_45 ) } # [ doc = "selected reference voltage * 46/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_46 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_46 ) } # [ doc = "selected reference voltage * 47/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_47 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_47 ) } # [ doc = "selected reference voltage * 48/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_48 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_48 ) } # [ doc = "selected reference voltage * 49/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_49 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_49 ) } # [ doc = "selected reference voltage * 50/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_50 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_50 ) } # [ doc = "selected reference voltage * 51/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_51 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_51 ) } # [ doc = "selected reference voltage * 52/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_52 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_52 ) } # [ doc = "selected reference voltage * 53/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_53 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_53 ) } # [ doc = "selected reference voltage * 54/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_54 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_54 ) } # [ doc = "selected reference voltage * 55/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_55 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_55 ) } # [ doc = "selected reference voltage * 56/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_56 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_56 ) } # [ doc = "selected reference voltage * 57/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_57 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_57 ) } # [ doc = "selected reference voltage * 58/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_58 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_58 ) } # [ doc = "selected reference voltage * 59/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_59 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_59 ) } # [ doc = "selected reference voltage * 60/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_60 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_60 ) } # [ doc = "selected reference voltage * 61/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_61 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_61 ) } # [ doc = "selected reference voltage * 62/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_62 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_62 ) } # [ doc = "selected reference voltage * 63/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_63 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_63 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 8 ) ) | ( ( ( value as u16 ) & 0x3f ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:5 - 1st 6-bit DAC buffer Data" ] # [ inline ( always ) ] pub fn cpdacbuf1 ( & self ) -> CPDACBUF1_R { CPDACBUF1_R :: new ( ( self . bits & 0x3f ) as u8 ) }
# [ doc = "Bits 8:13 - 2nd 6-bit DAC buffer Data" ] # [ inline ( always ) ] pub fn cpdacbuf2 ( & self ) -> CPDACBUF2_R { CPDACBUF2_R :: new ( ( ( self . bits >> 8 ) & 0x3f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:5 - 1st 6-bit DAC buffer Data" ] # [ inline ( always ) ] pub fn cpdacbuf1 ( & mut self ) -> CPDACBUF1_W { CPDACBUF1_W { w : self } }
# [ doc = "Bits 8:13 - 2nd 6-bit DAC buffer Data" ] # [ inline ( always ) ] pub fn cpdacbuf2 ( & mut self ) -> CPDACBUF2_W { CPDACBUF2_W { w : self } }
}
}
}
# [ doc = "eCOMP1" ] pub struct E_COMP1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for E_COMP1 { } impl E_COMP1 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const e_comp1 :: RegisterBlock { 0x0900 as * const _ } } impl Deref for E_COMP1 { type Target = e_comp1 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * E_COMP1 :: ptr ( ) } } }
# [ doc = "eCOMP1" ] pub mod e_comp1 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Comparator Control Register 0" ] pub cp1ctl0 : CP1CTL0 , # [ doc = "0x02 - Comparator Control Register 1" ] pub cp1ctl1 : CP1CTL1 , _reserved2 : [ u8 ; 2usize ] , # [ doc = "0x06 - Comparator Interrupt Control Register" ] pub cp1int : CP1INT , # [ doc = "0x08 - Comparator Interrupt Vector Word Register" ] pub cp1iv : CP1IV , _reserved4 : [ u8 ; 6usize ] , # [ doc = "0x10 - 6-bit Comparator built-in DAC Control Register" ] pub cp1dacctl : CP1DACCTL , # [ doc = "0x12 - 6-bit Comparator built-in DAC Data Register" ] pub cp1dacdata : CP1DACDATA , }
# [ doc = "Comparator Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cp1ctl0](cp1ctl0) module" ] pub type CP1CTL0 = crate :: Reg < u16 , _CP1CTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CP1CTL0 ;
# [ doc = "`read()` method returns [cp1ctl0::R](cp1ctl0::R) reader structure" ] impl crate :: Readable for CP1CTL0 { }
# [ doc = "`write(|w| ..)` method takes [cp1ctl0::W](cp1ctl0::W) writer structure" ] impl crate :: Writable for CP1CTL0 { }
# [ doc = "Comparator Control Register 0" ] pub mod cp1ctl0 {
# [ doc = "Reader of register CP1CTL0" ] pub type R = crate :: R < u16 , super :: CP1CTL0 > ;
# [ doc = "Writer for register CP1CTL0" ] pub type W = crate :: W < u16 , super :: CP1CTL0 > ;
# [ doc = "Register CP1CTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CP1CTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Channel input enable for the V+ terminal\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPPEN_A { # [ doc = "0: Selected analog input channel for V+ terminal is disabled." ] CPPEN_0 = 0 , # [ doc = "1: Selected analog input channel for V+ terminal is enabled." ] CPPEN_1 = 1 } impl From < CPPEN_A > for bool { # [ inline ( always ) ] fn from ( variant : CPPEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPPEN`" ] pub type CPPEN_R = crate :: R < bool , CPPEN_A > ; impl CPPEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPPEN_A { match self . bits { false => CPPEN_A :: CPPEN_0 , true => CPPEN_A :: CPPEN_1 } } # [ doc = "Checks if the value of the field is `CPPEN_0`" ] # [ inline ( always ) ] pub fn is_cppen_0 ( & self ) -> bool { * self == CPPEN_A :: CPPEN_0 } # [ doc = "Checks if the value of the field is `CPPEN_1`" ] # [ inline ( always ) ] pub fn is_cppen_1 ( & self ) -> bool { * self == CPPEN_A :: CPPEN_1 } }
# [ doc = "Write proxy for field `CPPEN`" ] pub struct CPPEN_W < 'a > { w : & 'a mut W , } impl < 'a > CPPEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPPEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Selected analog input channel for V+ terminal is disabled." ] # [ inline ( always ) ] pub fn cppen_0 ( self ) -> & 'a mut W { self . variant ( CPPEN_A :: CPPEN_0 ) } # [ doc = "Selected analog input channel for V+ terminal is enabled." ] # [ inline ( always ) ] pub fn cppen_1 ( self ) -> & 'a mut W { self . variant ( CPPEN_A :: CPPEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Channel input selected for the - terminal\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPNSEL_A { # [ doc = "0: select external input source" ] CPNSEL_0 = 0 , # [ doc = "1: select external input source" ] CPNSEL_1 = 1 , # [ doc = "2: select external input source" ] CPNSEL_2 = 2 , # [ doc = "3: select external input source" ] CPNSEL_3 = 3 , # [ doc = "4: device specific, please refer to device data sheet for details" ] CPNSEL_4 = 4 , # [ doc = "5: device specific, please refer to device data sheet for details" ] CPNSEL_5 = 5 , # [ doc = "6: 6-bit DAC" ] CPNSEL_6 = 6 , # [ doc = "7: Reserved" ] CPNSEL_7 = 7 } impl From < CPNSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPNSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPNSEL`" ] pub type CPNSEL_R = crate :: R < u8 , CPNSEL_A > ; impl CPNSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPNSEL_A { match self . bits { 0 => CPNSEL_A :: CPNSEL_0 , 1 => CPNSEL_A :: CPNSEL_1 , 2 => CPNSEL_A :: CPNSEL_2 , 3 => CPNSEL_A :: CPNSEL_3 , 4 => CPNSEL_A :: CPNSEL_4 , 5 => CPNSEL_A :: CPNSEL_5 , 6 => CPNSEL_A :: CPNSEL_6 , 7 => CPNSEL_A :: CPNSEL_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPNSEL_0`" ] # [ inline ( always ) ] pub fn is_cpnsel_0 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_0 } # [ doc = "Checks if the value of the field is `CPNSEL_1`" ] # [ inline ( always ) ] pub fn is_cpnsel_1 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_1 } # [ doc = "Checks if the value of the field is `CPNSEL_2`" ] # [ inline ( always ) ] pub fn is_cpnsel_2 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_2 } # [ doc = "Checks if the value of the field is `CPNSEL_3`" ] # [ inline ( always ) ] pub fn is_cpnsel_3 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_3 } # [ doc = "Checks if the value of the field is `CPNSEL_4`" ] # [ inline ( always ) ] pub fn is_cpnsel_4 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_4 } # [ doc = "Checks if the value of the field is `CPNSEL_5`" ] # [ inline ( always ) ] pub fn is_cpnsel_5 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_5 } # [ doc = "Checks if the value of the field is `CPNSEL_6`" ] # [ inline ( always ) ] pub fn is_cpnsel_6 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_6 } # [ doc = "Checks if the value of the field is `CPNSEL_7`" ] # [ inline ( always ) ] pub fn is_cpnsel_7 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_7 } }
# [ doc = "Write proxy for field `CPNSEL`" ] pub struct CPNSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CPNSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPNSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cpnsel_0 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_0 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cpnsel_1 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_1 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cpnsel_2 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_2 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cpnsel_3 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_3 ) } # [ doc = "device specific, please refer to device data sheet for details" ] # [ inline ( always ) ] pub fn cpnsel_4 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_4 ) } # [ doc = "device specific, please refer to device data sheet for details" ] # [ inline ( always ) ] pub fn cpnsel_5 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_5 ) } # [ doc = "6-bit DAC" ] # [ inline ( always ) ] pub fn cpnsel_6 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_6 ) } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn cpnsel_7 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 8 ) ) | ( ( ( value as u16 ) & 0x07 ) << 8 ) ; self . w } }
# [ doc = "Channel input enable for the - terminal\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPNEN_A { # [ doc = "0: Selected analog input channel for V- terminal is disabled." ] CPNEN_0 = 0 , # [ doc = "1: Selected analog input channel for V- terminal is enabled." ] CPNEN_1 = 1 } impl From < CPNEN_A > for bool { # [ inline ( always ) ] fn from ( variant : CPNEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPNEN`" ] pub type CPNEN_R = crate :: R < bool , CPNEN_A > ; impl CPNEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPNEN_A { match self . bits { false => CPNEN_A :: CPNEN_0 , true => CPNEN_A :: CPNEN_1 } } # [ doc = "Checks if the value of the field is `CPNEN_0`" ] # [ inline ( always ) ] pub fn is_cpnen_0 ( & self ) -> bool { * self == CPNEN_A :: CPNEN_0 } # [ doc = "Checks if the value of the field is `CPNEN_1`" ] # [ inline ( always ) ] pub fn is_cpnen_1 ( & self ) -> bool { * self == CPNEN_A :: CPNEN_1 } }
# [ doc = "Write proxy for field `CPNEN`" ] pub struct CPNEN_W < 'a > { w : & 'a mut W , } impl < 'a > CPNEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPNEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Selected analog input channel for V- terminal is disabled." ] # [ inline ( always ) ] pub fn cpnen_0 ( self ) -> & 'a mut W { self . variant ( CPNEN_A :: CPNEN_0 ) } # [ doc = "Selected analog input channel for V- terminal is enabled." ] # [ inline ( always ) ] pub fn cpnen_1 ( self ) -> & 'a mut W { self . variant ( CPNEN_A :: CPNEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Channel input selected for the V+ terminal\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPPSEL_A { # [ doc = "0: select external input source" ] CPPSEL_0 = 0 , # [ doc = "1: select external input source" ] CPPSEL_1 = 1 , # [ doc = "2: select external input source" ] CPPSEL_2 = 2 , # [ doc = "3: select external input source" ] CPPSEL_3 = 3 , # [ doc = "4: device specific, please refer to device data sheet for details" ] CPPSEL_4 = 4 , # [ doc = "5: device specific, please refer to device data sheet for details" ] CPPSEL_5 = 5 , # [ doc = "6: 6-bit DAC" ] CPPSEL_6 = 6 , # [ doc = "7: Reserved" ] CPPSEL_7 = 7 } impl From < CPPSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPPSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPPSEL`" ] pub type CPPSEL_R = crate :: R < u8 , CPPSEL_A > ; impl CPPSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPPSEL_A { match self . bits { 0 => CPPSEL_A :: CPPSEL_0 , 1 => CPPSEL_A :: CPPSEL_1 , 2 => CPPSEL_A :: CPPSEL_2 , 3 => CPPSEL_A :: CPPSEL_3 , 4 => CPPSEL_A :: CPPSEL_4 , 5 => CPPSEL_A :: CPPSEL_5 , 6 => CPPSEL_A :: CPPSEL_6 , 7 => CPPSEL_A :: CPPSEL_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPPSEL_0`" ] # [ inline ( always ) ] pub fn is_cppsel_0 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_0 } # [ doc = "Checks if the value of the field is `CPPSEL_1`" ] # [ inline ( always ) ] pub fn is_cppsel_1 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_1 } # [ doc = "Checks if the value of the field is `CPPSEL_2`" ] # [ inline ( always ) ] pub fn is_cppsel_2 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_2 } # [ doc = "Checks if the value of the field is `CPPSEL_3`" ] # [ inline ( always ) ] pub fn is_cppsel_3 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_3 } # [ doc = "Checks if the value of the field is `CPPSEL_4`" ] # [ inline ( always ) ] pub fn is_cppsel_4 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_4 } # [ doc = "Checks if the value of the field is `CPPSEL_5`" ] # [ inline ( always ) ] pub fn is_cppsel_5 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_5 } # [ doc = "Checks if the value of the field is `CPPSEL_6`" ] # [ inline ( always ) ] pub fn is_cppsel_6 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_6 } # [ doc = "Checks if the value of the field is `CPPSEL_7`" ] # [ inline ( always ) ] pub fn is_cppsel_7 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_7 } }
# [ doc = "Write proxy for field `CPPSEL`" ] pub struct CPPSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CPPSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPPSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cppsel_0 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_0 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cppsel_1 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_1 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cppsel_2 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_2 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cppsel_3 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_3 ) } # [ doc = "device specific, please refer to device data sheet for details" ] # [ inline ( always ) ] pub fn cppsel_4 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_4 ) } # [ doc = "device specific, please refer to device data sheet for details" ] # [ inline ( always ) ] pub fn cppsel_5 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_5 ) } # [ doc = "6-bit DAC" ] # [ inline ( always ) ] pub fn cppsel_6 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_6 ) } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn cppsel_7 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u16 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bit 4 - Channel input enable for the V+ terminal" ] # [ inline ( always ) ] pub fn cppen ( & self ) -> CPPEN_R { CPPEN_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:10 - Channel input selected for the - terminal" ] # [ inline ( always ) ] pub fn cpnsel ( & self ) -> CPNSEL_R { CPNSEL_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 12 - Channel input enable for the - terminal" ] # [ inline ( always ) ] pub fn cpnen ( & self ) -> CPNEN_R { CPNEN_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 0:2 - Channel input selected for the V+ terminal" ] # [ inline ( always ) ] pub fn cppsel ( & self ) -> CPPSEL_R { CPPSEL_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bit 4 - Channel input enable for the V+ terminal" ] # [ inline ( always ) ] pub fn cppen ( & mut self ) -> CPPEN_W { CPPEN_W { w : self } }
# [ doc = "Bits 8:10 - Channel input selected for the - terminal" ] # [ inline ( always ) ] pub fn cpnsel ( & mut self ) -> CPNSEL_W { CPNSEL_W { w : self } }
# [ doc = "Bit 12 - Channel input enable for the - terminal" ] # [ inline ( always ) ] pub fn cpnen ( & mut self ) -> CPNEN_W { CPNEN_W { w : self } }
# [ doc = "Bits 0:2 - Channel input selected for the V+ terminal" ] # [ inline ( always ) ] pub fn cppsel ( & mut self ) -> CPPSEL_W { CPPSEL_W { w : self } }
}
}
# [ doc = "Comparator Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cp1ctl1](cp1ctl1) module" ] pub type CP1CTL1 = crate :: Reg < u16 , _CP1CTL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CP1CTL1 ;
# [ doc = "`read()` method returns [cp1ctl1::R](cp1ctl1::R) reader structure" ] impl crate :: Readable for CP1CTL1 { }
# [ doc = "`write(|w| ..)` method takes [cp1ctl1::W](cp1ctl1::W) writer structure" ] impl crate :: Writable for CP1CTL1 { }
# [ doc = "Comparator Control Register 1" ] pub mod cp1ctl1 {
# [ doc = "Reader of register CP1CTL1" ] pub type R = crate :: R < u16 , super :: CP1CTL1 > ;
# [ doc = "Writer for register CP1CTL1" ] pub type W = crate :: W < u16 , super :: CP1CTL1 > ;
# [ doc = "Register CP1CTL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CP1CTL1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CPOUT`" ] pub type CPOUT_R = crate :: R < bool , bool > ;
# [ doc = "Comparator output polarity\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPINV_A { # [ doc = "0: Comparator output is non-inverted" ] CPINV_0 = 0 , # [ doc = "1: Comparator output is inverted" ] CPINV_1 = 1 } impl From < CPINV_A > for bool { # [ inline ( always ) ] fn from ( variant : CPINV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPINV`" ] pub type CPINV_R = crate :: R < bool , CPINV_A > ; impl CPINV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPINV_A { match self . bits { false => CPINV_A :: CPINV_0 , true => CPINV_A :: CPINV_1 } } # [ doc = "Checks if the value of the field is `CPINV_0`" ] # [ inline ( always ) ] pub fn is_cpinv_0 ( & self ) -> bool { * self == CPINV_A :: CPINV_0 } # [ doc = "Checks if the value of the field is `CPINV_1`" ] # [ inline ( always ) ] pub fn is_cpinv_1 ( & self ) -> bool { * self == CPINV_A :: CPINV_1 } }
# [ doc = "Write proxy for field `CPINV`" ] pub struct CPINV_W < 'a > { w : & 'a mut W , } impl < 'a > CPINV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPINV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Comparator output is non-inverted" ] # [ inline ( always ) ] pub fn cpinv_0 ( self ) -> & 'a mut W { self . variant ( CPINV_A :: CPINV_0 ) } # [ doc = "Comparator output is inverted" ] # [ inline ( always ) ] pub fn cpinv_1 ( self ) -> & 'a mut W { self . variant ( CPINV_A :: CPINV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Interrupt edge select for CEIIFG and CEIFG\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPIES_A { # [ doc = "0: Rising edge for CPIFG, falling edge for CPIIFG" ] CPIES_0 = 0 , # [ doc = "1: Falling edge for CPIFG, rising edge for CPIIFG" ] CPIES_1 = 1 } impl From < CPIES_A > for bool { # [ inline ( always ) ] fn from ( variant : CPIES_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPIES`" ] pub type CPIES_R = crate :: R < bool , CPIES_A > ; impl CPIES_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPIES_A { match self . bits { false => CPIES_A :: CPIES_0 , true => CPIES_A :: CPIES_1 } } # [ doc = "Checks if the value of the field is `CPIES_0`" ] # [ inline ( always ) ] pub fn is_cpies_0 ( & self ) -> bool { * self == CPIES_A :: CPIES_0 } # [ doc = "Checks if the value of the field is `CPIES_1`" ] # [ inline ( always ) ] pub fn is_cpies_1 ( & self ) -> bool { * self == CPIES_A :: CPIES_1 } }
# [ doc = "Write proxy for field `CPIES`" ] pub struct CPIES_W < 'a > { w : & 'a mut W , } impl < 'a > CPIES_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPIES_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Rising edge for CPIFG, falling edge for CPIIFG" ] # [ inline ( always ) ] pub fn cpies_0 ( self ) -> & 'a mut W { self . variant ( CPIES_A :: CPIES_0 ) } # [ doc = "Falling edge for CPIFG, rising edge for CPIIFG" ] # [ inline ( always ) ] pub fn cpies_1 ( self ) -> & 'a mut W { self . variant ( CPIES_A :: CPIES_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Analog Output Low Pass filter Selection. Changing CPFLT might set interrupt flag.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPFLT_A { # [ doc = "0: Comparator output is not filtered" ] CPFLT_0 = 0 , # [ doc = "1: Comparator output is filtered" ] CPFLT_1 = 1 } impl From < CPFLT_A > for bool { # [ inline ( always ) ] fn from ( variant : CPFLT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPFLT`" ] pub type CPFLT_R = crate :: R < bool , CPFLT_A > ; impl CPFLT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPFLT_A { match self . bits { false => CPFLT_A :: CPFLT_0 , true => CPFLT_A :: CPFLT_1 } } # [ doc = "Checks if the value of the field is `CPFLT_0`" ] # [ inline ( always ) ] pub fn is_cpflt_0 ( & self ) -> bool { * self == CPFLT_A :: CPFLT_0 } # [ doc = "Checks if the value of the field is `CPFLT_1`" ] # [ inline ( always ) ] pub fn is_cpflt_1 ( & self ) -> bool { * self == CPFLT_A :: CPFLT_1 } }
# [ doc = "Write proxy for field `CPFLT`" ] pub struct CPFLT_W < 'a > { w : & 'a mut W , } impl < 'a > CPFLT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPFLT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Comparator output is not filtered" ] # [ inline ( always ) ] pub fn cpflt_0 ( self ) -> & 'a mut W { self . variant ( CPFLT_A :: CPFLT_0 ) } # [ doc = "Comparator output is filtered" ] # [ inline ( always ) ] pub fn cpflt_1 ( self ) -> & 'a mut W { self . variant ( CPFLT_A :: CPFLT_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Analog Filter Delay selection. These bits are used to select the analog filter delay\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPFLTDLY_A { # [ doc = "0: Typical filter delay of 450ns" ] CPFLTDLY_0 = 0 , # [ doc = "1: Typical filter delay of 900ns" ] CPFLTDLY_1 = 1 , # [ doc = "2: Typical filter delay of 1800ns" ] CPFLTDLY_2 = 2 , # [ doc = "3: Typical filter delay of 3600ns" ] CPFLTDLY_3 = 3 } impl From < CPFLTDLY_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPFLTDLY_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPFLTDLY`" ] pub type CPFLTDLY_R = crate :: R < u8 , CPFLTDLY_A > ; impl CPFLTDLY_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPFLTDLY_A { match self . bits { 0 => CPFLTDLY_A :: CPFLTDLY_0 , 1 => CPFLTDLY_A :: CPFLTDLY_1 , 2 => CPFLTDLY_A :: CPFLTDLY_2 , 3 => CPFLTDLY_A :: CPFLTDLY_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPFLTDLY_0`" ] # [ inline ( always ) ] pub fn is_cpfltdly_0 ( & self ) -> bool { * self == CPFLTDLY_A :: CPFLTDLY_0 } # [ doc = "Checks if the value of the field is `CPFLTDLY_1`" ] # [ inline ( always ) ] pub fn is_cpfltdly_1 ( & self ) -> bool { * self == CPFLTDLY_A :: CPFLTDLY_1 } # [ doc = "Checks if the value of the field is `CPFLTDLY_2`" ] # [ inline ( always ) ] pub fn is_cpfltdly_2 ( & self ) -> bool { * self == CPFLTDLY_A :: CPFLTDLY_2 } # [ doc = "Checks if the value of the field is `CPFLTDLY_3`" ] # [ inline ( always ) ] pub fn is_cpfltdly_3 ( & self ) -> bool { * self == CPFLTDLY_A :: CPFLTDLY_3 } }
# [ doc = "Write proxy for field `CPFLTDLY`" ] pub struct CPFLTDLY_W < 'a > { w : & 'a mut W , } impl < 'a > CPFLTDLY_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPFLTDLY_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Typical filter delay of 450ns" ] # [ inline ( always ) ] pub fn cpfltdly_0 ( self ) -> & 'a mut W { self . variant ( CPFLTDLY_A :: CPFLTDLY_0 ) } # [ doc = "Typical filter delay of 900ns" ] # [ inline ( always ) ] pub fn cpfltdly_1 ( self ) -> & 'a mut W { self . variant ( CPFLTDLY_A :: CPFLTDLY_1 ) } # [ doc = "Typical filter delay of 1800ns" ] # [ inline ( always ) ] pub fn cpfltdly_2 ( self ) -> & 'a mut W { self . variant ( CPFLTDLY_A :: CPFLTDLY_2 ) } # [ doc = "Typical filter delay of 3600ns" ] # [ inline ( always ) ] pub fn cpfltdly_3 ( self ) -> & 'a mut W { self . variant ( CPFLTDLY_A :: CPFLTDLY_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Power mode selection.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPMSEL_A { # [ doc = "0: High-power & High speed mode (500nA)" ] CPMSEL_0 = 0 , # [ doc = "1: Low-power & Low speed mode (10nA)" ] CPMSEL_1 = 1 } impl From < CPMSEL_A > for bool { # [ inline ( always ) ] fn from ( variant : CPMSEL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPMSEL`" ] pub type CPMSEL_R = crate :: R < bool , CPMSEL_A > ; impl CPMSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPMSEL_A { match self . bits { false => CPMSEL_A :: CPMSEL_0 , true => CPMSEL_A :: CPMSEL_1 } } # [ doc = "Checks if the value of the field is `CPMSEL_0`" ] # [ inline ( always ) ] pub fn is_cpmsel_0 ( & self ) -> bool { * self == CPMSEL_A :: CPMSEL_0 } # [ doc = "Checks if the value of the field is `CPMSEL_1`" ] # [ inline ( always ) ] pub fn is_cpmsel_1 ( & self ) -> bool { * self == CPMSEL_A :: CPMSEL_1 } }
# [ doc = "Write proxy for field `CPMSEL`" ] pub struct CPMSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CPMSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPMSEL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "High-power & High speed mode (500nA)" ] # [ inline ( always ) ] pub fn cpmsel_0 ( self ) -> & 'a mut W { self . variant ( CPMSEL_A :: CPMSEL_0 ) } # [ doc = "Low-power & Low speed mode (10nA)" ] # [ inline ( always ) ] pub fn cpmsel_1 ( self ) -> & 'a mut W { self . variant ( CPMSEL_A :: CPMSEL_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Comparator enable/disable. This bit is used to disable/enable the comparator. When the comparator is disabled, the Comparator consumes no power.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPEN_A { # [ doc = "0: Comparator is disabled" ] CPEN_0 = 0 , # [ doc = "1: Comparator is enabled" ] CPEN_1 = 1 } impl From < CPEN_A > for bool { # [ inline ( always ) ] fn from ( variant : CPEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPEN`" ] pub type CPEN_R = crate :: R < bool , CPEN_A > ; impl CPEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPEN_A { match self . bits { false => CPEN_A :: CPEN_0 , true => CPEN_A :: CPEN_1 } } # [ doc = "Checks if the value of the field is `CPEN_0`" ] # [ inline ( always ) ] pub fn is_cpen_0 ( & self ) -> bool { * self == CPEN_A :: CPEN_0 } # [ doc = "Checks if the value of the field is `CPEN_1`" ] # [ inline ( always ) ] pub fn is_cpen_1 ( & self ) -> bool { * self == CPEN_A :: CPEN_1 } }
# [ doc = "Write proxy for field `CPEN`" ] pub struct CPEN_W < 'a > { w : & 'a mut W , } impl < 'a > CPEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Comparator is disabled" ] # [ inline ( always ) ] pub fn cpen_0 ( self ) -> & 'a mut W { self . variant ( CPEN_A :: CPEN_0 ) } # [ doc = "Comparator is enabled" ] # [ inline ( always ) ] pub fn cpen_1 ( self ) -> & 'a mut W { self . variant ( CPEN_A :: CPEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Programable Hysteresis mode. These bits are used to select the Hysteresis mode.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPHSEL_A { # [ doc = "0: disable" ] CPHSEL_0 = 0 , # [ doc = "1: 10mV" ] CPHSEL_1 = 1 , # [ doc = "2: 20mV" ] CPHSEL_2 = 2 , # [ doc = "3: 30mV" ] CPHSEL_3 = 3 } impl From < CPHSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPHSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPHSEL`" ] pub type CPHSEL_R = crate :: R < u8 , CPHSEL_A > ; impl CPHSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPHSEL_A { match self . bits { 0 => CPHSEL_A :: CPHSEL_0 , 1 => CPHSEL_A :: CPHSEL_1 , 2 => CPHSEL_A :: CPHSEL_2 , 3 => CPHSEL_A :: CPHSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPHSEL_0`" ] # [ inline ( always ) ] pub fn is_cphsel_0 ( & self ) -> bool { * self == CPHSEL_A :: CPHSEL_0 } # [ doc = "Checks if the value of the field is `CPHSEL_1`" ] # [ inline ( always ) ] pub fn is_cphsel_1 ( & self ) -> bool { * self == CPHSEL_A :: CPHSEL_1 } # [ doc = "Checks if the value of the field is `CPHSEL_2`" ] # [ inline ( always ) ] pub fn is_cphsel_2 ( & self ) -> bool { * self == CPHSEL_A :: CPHSEL_2 } # [ doc = "Checks if the value of the field is `CPHSEL_3`" ] # [ inline ( always ) ] pub fn is_cphsel_3 ( & self ) -> bool { * self == CPHSEL_A :: CPHSEL_3 } }
# [ doc = "Write proxy for field `CPHSEL`" ] pub struct CPHSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CPHSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPHSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "disable" ] # [ inline ( always ) ] pub fn cphsel_0 ( self ) -> & 'a mut W { self . variant ( CPHSEL_A :: CPHSEL_0 ) } # [ doc = "10mV" ] # [ inline ( always ) ] pub fn cphsel_1 ( self ) -> & 'a mut W { self . variant ( CPHSEL_A :: CPHSEL_1 ) } # [ doc = "20mV" ] # [ inline ( always ) ] pub fn cphsel_2 ( self ) -> & 'a mut W { self . variant ( CPHSEL_A :: CPHSEL_2 ) } # [ doc = "30mV" ] # [ inline ( always ) ] pub fn cphsel_3 ( self ) -> & 'a mut W { self . variant ( CPHSEL_A :: CPHSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u16 ) & 0x03 ) << 10 ) ; self . w } }
# [ doc = "Comparator interrupt output enable bit\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPIE_A { # [ doc = "0: Interrupt output is disabled" ] CPIE_0 = 0 , # [ doc = "1: Interrupt output is enabled" ] CPIE_1 = 1 } impl From < CPIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CPIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPIE`" ] pub type CPIE_R = crate :: R < bool , CPIE_A > ; impl CPIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPIE_A { match self . bits { false => CPIE_A :: CPIE_0 , true => CPIE_A :: CPIE_1 } } # [ doc = "Checks if the value of the field is `CPIE_0`" ] # [ inline ( always ) ] pub fn is_cpie_0 ( & self ) -> bool { * self == CPIE_A :: CPIE_0 } # [ doc = "Checks if the value of the field is `CPIE_1`" ] # [ inline ( always ) ] pub fn is_cpie_1 ( & self ) -> bool { * self == CPIE_A :: CPIE_1 } }
# [ doc = "Write proxy for field `CPIE`" ] pub struct CPIE_W < 'a > { w : & 'a mut W , } impl < 'a > CPIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt output is disabled" ] # [ inline ( always ) ] pub fn cpie_0 ( self ) -> & 'a mut W { self . variant ( CPIE_A :: CPIE_0 ) } # [ doc = "Interrupt output is enabled" ] # [ inline ( always ) ] pub fn cpie_1 ( self ) -> & 'a mut W { self . variant ( CPIE_A :: CPIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Comparator inverted interrupt output enable bit\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPIIE_A { # [ doc = "0: Interrupt inverted output is disabled" ] CPIIE_0 = 0 , # [ doc = "1: Interrupt inverted output is enabled" ] CPIIE_1 = 1 } impl From < CPIIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CPIIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPIIE`" ] pub type CPIIE_R = crate :: R < bool , CPIIE_A > ; impl CPIIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPIIE_A { match self . bits { false => CPIIE_A :: CPIIE_0 , true => CPIIE_A :: CPIIE_1 } } # [ doc = "Checks if the value of the field is `CPIIE_0`" ] # [ inline ( always ) ] pub fn is_cpiie_0 ( & self ) -> bool { * self == CPIIE_A :: CPIIE_0 } # [ doc = "Checks if the value of the field is `CPIIE_1`" ] # [ inline ( always ) ] pub fn is_cpiie_1 ( & self ) -> bool { * self == CPIIE_A :: CPIIE_1 } }
# [ doc = "Write proxy for field `CPIIE`" ] pub struct CPIIE_W < 'a > { w : & 'a mut W , } impl < 'a > CPIIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPIIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt inverted output is disabled" ] # [ inline ( always ) ] pub fn cpiie_0 ( self ) -> & 'a mut W { self . variant ( CPIIE_A :: CPIIE_0 ) } # [ doc = "Interrupt inverted output is enabled" ] # [ inline ( always ) ] pub fn cpiie_1 ( self ) -> & 'a mut W { self . variant ( CPIIE_A :: CPIIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Comparator output value" ] # [ inline ( always ) ] pub fn cpout ( & self ) -> CPOUT_R { CPOUT_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Comparator output polarity" ] # [ inline ( always ) ] pub fn cpinv ( & self ) -> CPINV_R { CPINV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Interrupt edge select for CEIIFG and CEIFG" ] # [ inline ( always ) ] pub fn cpies ( & self ) -> CPIES_R { CPIES_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Analog Output Low Pass filter Selection. Changing CPFLT might set interrupt flag." ] # [ inline ( always ) ] pub fn cpflt ( & self ) -> CPFLT_R { CPFLT_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - Analog Filter Delay selection. These bits are used to select the analog filter delay" ] # [ inline ( always ) ] pub fn cpfltdly ( & self ) -> CPFLTDLY_R { CPFLTDLY_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Power mode selection." ] # [ inline ( always ) ] pub fn cpmsel ( & self ) -> CPMSEL_R { CPMSEL_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Comparator enable/disable. This bit is used to disable/enable the comparator. When the comparator is disabled, the Comparator consumes no power." ] # [ inline ( always ) ] pub fn cpen ( & self ) -> CPEN_R { CPEN_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 10:11 - Programable Hysteresis mode. These bits are used to select the Hysteresis mode." ] # [ inline ( always ) ] pub fn cphsel ( & self ) -> CPHSEL_R { CPHSEL_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 14 - Comparator interrupt output enable bit" ] # [ inline ( always ) ] pub fn cpie ( & self ) -> CPIE_R { CPIE_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Comparator inverted interrupt output enable bit" ] # [ inline ( always ) ] pub fn cpiie ( & self ) -> CPIIE_R { CPIIE_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 1 - Comparator output polarity" ] # [ inline ( always ) ] pub fn cpinv ( & mut self ) -> CPINV_W { CPINV_W { w : self } }
# [ doc = "Bit 4 - Interrupt edge select for CEIIFG and CEIFG" ] # [ inline ( always ) ] pub fn cpies ( & mut self ) -> CPIES_W { CPIES_W { w : self } }
# [ doc = "Bit 5 - Analog Output Low Pass filter Selection. Changing CPFLT might set interrupt flag." ] # [ inline ( always ) ] pub fn cpflt ( & mut self ) -> CPFLT_W { CPFLT_W { w : self } }
# [ doc = "Bits 6:7 - Analog Filter Delay selection. These bits are used to select the analog filter delay" ] # [ inline ( always ) ] pub fn cpfltdly ( & mut self ) -> CPFLTDLY_W { CPFLTDLY_W { w : self } }
# [ doc = "Bit 8 - Power mode selection." ] # [ inline ( always ) ] pub fn cpmsel ( & mut self ) -> CPMSEL_W { CPMSEL_W { w : self } }
# [ doc = "Bit 9 - Comparator enable/disable. This bit is used to disable/enable the comparator. When the comparator is disabled, the Comparator consumes no power." ] # [ inline ( always ) ] pub fn cpen ( & mut self ) -> CPEN_W { CPEN_W { w : self } }
# [ doc = "Bits 10:11 - Programable Hysteresis mode. These bits are used to select the Hysteresis mode." ] # [ inline ( always ) ] pub fn cphsel ( & mut self ) -> CPHSEL_W { CPHSEL_W { w : self } }
# [ doc = "Bit 14 - Comparator interrupt output enable bit" ] # [ inline ( always ) ] pub fn cpie ( & mut self ) -> CPIE_W { CPIE_W { w : self } }
# [ doc = "Bit 15 - Comparator inverted interrupt output enable bit" ] # [ inline ( always ) ] pub fn cpiie ( & mut self ) -> CPIIE_W { CPIIE_W { w : self } }
}
}
# [ doc = "Comparator Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cp1int](cp1int) module" ] pub type CP1INT = crate :: Reg < u16 , _CP1INT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CP1INT ;
# [ doc = "`read()` method returns [cp1int::R](cp1int::R) reader structure" ] impl crate :: Readable for CP1INT { }
# [ doc = "`write(|w| ..)` method takes [cp1int::W](cp1int::W) writer structure" ] impl crate :: Writable for CP1INT { }
# [ doc = "Comparator Interrupt Control Register" ] pub mod cp1int {
# [ doc = "Reader of register CP1INT" ] pub type R = crate :: R < u16 , super :: CP1INT > ;
# [ doc = "Writer for register CP1INT" ] pub type W = crate :: W < u16 , super :: CP1INT > ;
# [ doc = "Register CP1INT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CP1INT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Comparator output interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPIFG_A { # [ doc = "0: No interrupt pending." ] CPIFG_0 = 0 , # [ doc = "1: Output interrupt pending." ] CPIFG_1 = 1 } impl From < CPIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CPIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPIFG`" ] pub type CPIFG_R = crate :: R < bool , CPIFG_A > ; impl CPIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPIFG_A { match self . bits { false => CPIFG_A :: CPIFG_0 , true => CPIFG_A :: CPIFG_1 } } # [ doc = "Checks if the value of the field is `CPIFG_0`" ] # [ inline ( always ) ] pub fn is_cpifg_0 ( & self ) -> bool { * self == CPIFG_A :: CPIFG_0 } # [ doc = "Checks if the value of the field is `CPIFG_1`" ] # [ inline ( always ) ] pub fn is_cpifg_1 ( & self ) -> bool { * self == CPIFG_A :: CPIFG_1 } }
# [ doc = "Write proxy for field `CPIFG`" ] pub struct CPIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CPIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending." ] # [ inline ( always ) ] pub fn cpifg_0 ( self ) -> & 'a mut W { self . variant ( CPIFG_A :: CPIFG_0 ) } # [ doc = "Output interrupt pending." ] # [ inline ( always ) ] pub fn cpifg_1 ( self ) -> & 'a mut W { self . variant ( CPIFG_A :: CPIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Comparator output inverted interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPIIFG_A { # [ doc = "0: No interrupt pending." ] CPIIFG_0 = 0 , # [ doc = "1: Output interrupt pending." ] CPIIFG_1 = 1 } impl From < CPIIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CPIIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPIIFG`" ] pub type CPIIFG_R = crate :: R < bool , CPIIFG_A > ; impl CPIIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPIIFG_A { match self . bits { false => CPIIFG_A :: CPIIFG_0 , true => CPIIFG_A :: CPIIFG_1 } } # [ doc = "Checks if the value of the field is `CPIIFG_0`" ] # [ inline ( always ) ] pub fn is_cpiifg_0 ( & self ) -> bool { * self == CPIIFG_A :: CPIIFG_0 } # [ doc = "Checks if the value of the field is `CPIIFG_1`" ] # [ inline ( always ) ] pub fn is_cpiifg_1 ( & self ) -> bool { * self == CPIIFG_A :: CPIIFG_1 } }
# [ doc = "Write proxy for field `CPIIFG`" ] pub struct CPIIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CPIIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPIIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending." ] # [ inline ( always ) ] pub fn cpiifg_0 ( self ) -> & 'a mut W { self . variant ( CPIIFG_A :: CPIIFG_0 ) } # [ doc = "Output interrupt pending." ] # [ inline ( always ) ] pub fn cpiifg_1 ( self ) -> & 'a mut W { self . variant ( CPIIFG_A :: CPIIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Comparator output interrupt flag" ] # [ inline ( always ) ] pub fn cpifg ( & self ) -> CPIFG_R { CPIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Comparator output inverted interrupt flag" ] # [ inline ( always ) ] pub fn cpiifg ( & self ) -> CPIIFG_R { CPIIFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Comparator output interrupt flag" ] # [ inline ( always ) ] pub fn cpifg ( & mut self ) -> CPIFG_W { CPIFG_W { w : self } }
# [ doc = "Bit 1 - Comparator output inverted interrupt flag" ] # [ inline ( always ) ] pub fn cpiifg ( & mut self ) -> CPIIFG_W { CPIIFG_W { w : self } }
}
}
# [ doc = "Comparator Interrupt Vector Word Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cp1iv](cp1iv) module" ] pub type CP1IV = crate :: Reg < u16 , _CP1IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CP1IV ;
# [ doc = "`read()` method returns [cp1iv::R](cp1iv::R) reader structure" ] impl crate :: Readable for CP1IV { }
# [ doc = "Comparator Interrupt Vector Word Register" ] pub mod cp1iv {
# [ doc = "Reader of register CP1IV" ] pub type R = crate :: R < u16 , super :: CP1IV > ;
# [ doc = "Comparator interrupt vector word register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum CPIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: CPIFG" ] CPIFG = 2 , # [ doc = "4: CPIIFG" ] CPIIFG = 4 } impl From < CPIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : CPIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPIV`" ] pub type CPIV_R = crate :: R < u16 , CPIV_A > ; impl CPIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , CPIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CPIV_A :: NONE ) , 2 => Val ( CPIV_A :: CPIFG ) , 4 => Val ( CPIV_A :: CPIIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CPIV_A :: NONE } # [ doc = "Checks if the value of the field is `CPIFG`" ] # [ inline ( always ) ] pub fn is_cpifg ( & self ) -> bool { * self == CPIV_A :: CPIFG } # [ doc = "Checks if the value of the field is `CPIIFG`" ] # [ inline ( always ) ] pub fn is_cpiifg ( & self ) -> bool { * self == CPIV_A :: CPIIFG } }
impl R {
# [ doc = "Bits 0:15 - Comparator interrupt vector word register" ] # [ inline ( always ) ] pub fn cpiv ( & self ) -> CPIV_R { CPIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
# [ doc = "6-bit Comparator built-in DAC Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cp1dacctl](cp1dacctl) module" ] pub type CP1DACCTL = crate :: Reg < u16 , _CP1DACCTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CP1DACCTL ;
# [ doc = "`read()` method returns [cp1dacctl::R](cp1dacctl::R) reader structure" ] impl crate :: Readable for CP1DACCTL { }
# [ doc = "`write(|w| ..)` method takes [cp1dacctl::W](cp1dacctl::W) writer structure" ] impl crate :: Writable for CP1DACCTL { }
# [ doc = "6-bit Comparator built-in DAC Control Register" ] pub mod cp1dacctl {
# [ doc = "Reader of register CP1DACCTL" ] pub type R = crate :: R < u16 , super :: CP1DACCTL > ;
# [ doc = "Writer for register CP1DACCTL" ] pub type W = crate :: W < u16 , super :: CP1DACCTL > ;
# [ doc = "Register CP1DACCTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CP1DACCTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "This bit is only valid when CPDACBUFS is set to 1.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPDACSW_A { # [ doc = "0: CPDACBUF1 selected" ] CPDACSW_0 = 0 , # [ doc = "1: CPDACBUF2 selected" ] CPDACSW_1 = 1 } impl From < CPDACSW_A > for bool { # [ inline ( always ) ] fn from ( variant : CPDACSW_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPDACSW`" ] pub type CPDACSW_R = crate :: R < bool , CPDACSW_A > ; impl CPDACSW_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACSW_A { match self . bits { false => CPDACSW_A :: CPDACSW_0 , true => CPDACSW_A :: CPDACSW_1 } } # [ doc = "Checks if the value of the field is `CPDACSW_0`" ] # [ inline ( always ) ] pub fn is_cpdacsw_0 ( & self ) -> bool { * self == CPDACSW_A :: CPDACSW_0 } # [ doc = "Checks if the value of the field is `CPDACSW_1`" ] # [ inline ( always ) ] pub fn is_cpdacsw_1 ( & self ) -> bool { * self == CPDACSW_A :: CPDACSW_1 } }
# [ doc = "Write proxy for field `CPDACSW`" ] pub struct CPDACSW_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACSW_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACSW_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "CPDACBUF1 selected" ] # [ inline ( always ) ] pub fn cpdacsw_0 ( self ) -> & 'a mut W { self . variant ( CPDACSW_A :: CPDACSW_0 ) } # [ doc = "CPDACBUF2 selected" ] # [ inline ( always ) ] pub fn cpdacsw_1 ( self ) -> & 'a mut W { self . variant ( CPDACSW_A :: CPDACSW_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Comparator built-in DAC buffer controlled source selection.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPDACBUFS_A { # [ doc = "0: Comparator output is selected as the buffer control source" ] CPDACBUFS_0 = 0 , # [ doc = "1: CPDACSW bit is selected as the buffer control source" ] CPDACBUFS_1 = 1 } impl From < CPDACBUFS_A > for bool { # [ inline ( always ) ] fn from ( variant : CPDACBUFS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPDACBUFS`" ] pub type CPDACBUFS_R = crate :: R < bool , CPDACBUFS_A > ; impl CPDACBUFS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACBUFS_A { match self . bits { false => CPDACBUFS_A :: CPDACBUFS_0 , true => CPDACBUFS_A :: CPDACBUFS_1 } } # [ doc = "Checks if the value of the field is `CPDACBUFS_0`" ] # [ inline ( always ) ] pub fn is_cpdacbufs_0 ( & self ) -> bool { * self == CPDACBUFS_A :: CPDACBUFS_0 } # [ doc = "Checks if the value of the field is `CPDACBUFS_1`" ] # [ inline ( always ) ] pub fn is_cpdacbufs_1 ( & self ) -> bool { * self == CPDACBUFS_A :: CPDACBUFS_1 } }
# [ doc = "Write proxy for field `CPDACBUFS`" ] pub struct CPDACBUFS_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACBUFS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACBUFS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Comparator output is selected as the buffer control source" ] # [ inline ( always ) ] pub fn cpdacbufs_0 ( self ) -> & 'a mut W { self . variant ( CPDACBUFS_A :: CPDACBUFS_0 ) } # [ doc = "CPDACSW bit is selected as the buffer control source" ] # [ inline ( always ) ] pub fn cpdacbufs_1 ( self ) -> & 'a mut W { self . variant ( CPDACBUFS_A :: CPDACBUFS_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Comparator built-in DAC reference voltage selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPDACREFS_A { # [ doc = "0: VDD selected" ] CPDACREFS_0 = 0 , # [ doc = "1: on-chip VREF selected" ] CPDACREFS_1 = 1 } impl From < CPDACREFS_A > for bool { # [ inline ( always ) ] fn from ( variant : CPDACREFS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPDACREFS`" ] pub type CPDACREFS_R = crate :: R < bool , CPDACREFS_A > ; impl CPDACREFS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACREFS_A { match self . bits { false => CPDACREFS_A :: CPDACREFS_0 , true => CPDACREFS_A :: CPDACREFS_1 } } # [ doc = "Checks if the value of the field is `CPDACREFS_0`" ] # [ inline ( always ) ] pub fn is_cpdacrefs_0 ( & self ) -> bool { * self == CPDACREFS_A :: CPDACREFS_0 } # [ doc = "Checks if the value of the field is `CPDACREFS_1`" ] # [ inline ( always ) ] pub fn is_cpdacrefs_1 ( & self ) -> bool { * self == CPDACREFS_A :: CPDACREFS_1 } }
# [ doc = "Write proxy for field `CPDACREFS`" ] pub struct CPDACREFS_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACREFS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACREFS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "VDD selected" ] # [ inline ( always ) ] pub fn cpdacrefs_0 ( self ) -> & 'a mut W { self . variant ( CPDACREFS_A :: CPDACREFS_0 ) } # [ doc = "on-chip VREF selected" ] # [ inline ( always ) ] pub fn cpdacrefs_1 ( self ) -> & 'a mut W { self . variant ( CPDACREFS_A :: CPDACREFS_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Comparator built-in DAC output control bit.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPDACEN_A { # [ doc = "0: DAC output is disabled." ] CPDACEN_0 = 0 , # [ doc = "1: DAC output is enabled." ] CPDACEN_1 = 1 } impl From < CPDACEN_A > for bool { # [ inline ( always ) ] fn from ( variant : CPDACEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPDACEN`" ] pub type CPDACEN_R = crate :: R < bool , CPDACEN_A > ; impl CPDACEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACEN_A { match self . bits { false => CPDACEN_A :: CPDACEN_0 , true => CPDACEN_A :: CPDACEN_1 } } # [ doc = "Checks if the value of the field is `CPDACEN_0`" ] # [ inline ( always ) ] pub fn is_cpdacen_0 ( & self ) -> bool { * self == CPDACEN_A :: CPDACEN_0 } # [ doc = "Checks if the value of the field is `CPDACEN_1`" ] # [ inline ( always ) ] pub fn is_cpdacen_1 ( & self ) -> bool { * self == CPDACEN_A :: CPDACEN_1 } }
# [ doc = "Write proxy for field `CPDACEN`" ] pub struct CPDACEN_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "DAC output is disabled." ] # [ inline ( always ) ] pub fn cpdacen_0 ( self ) -> & 'a mut W { self . variant ( CPDACEN_A :: CPDACEN_0 ) } # [ doc = "DAC output is enabled." ] # [ inline ( always ) ] pub fn cpdacen_1 ( self ) -> & 'a mut W { self . variant ( CPDACEN_A :: CPDACEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - This bit is only valid when CPDACBUFS is set to 1." ] # [ inline ( always ) ] pub fn cpdacsw ( & self ) -> CPDACSW_R { CPDACSW_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Comparator built-in DAC buffer controlled source selection." ] # [ inline ( always ) ] pub fn cpdacbufs ( & self ) -> CPDACBUFS_R { CPDACBUFS_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Comparator built-in DAC reference voltage selection" ] # [ inline ( always ) ] pub fn cpdacrefs ( & self ) -> CPDACREFS_R { CPDACREFS_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Comparator built-in DAC output control bit." ] # [ inline ( always ) ] pub fn cpdacen ( & self ) -> CPDACEN_R { CPDACEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - This bit is only valid when CPDACBUFS is set to 1." ] # [ inline ( always ) ] pub fn cpdacsw ( & mut self ) -> CPDACSW_W { CPDACSW_W { w : self } }
# [ doc = "Bit 1 - Comparator built-in DAC buffer controlled source selection." ] # [ inline ( always ) ] pub fn cpdacbufs ( & mut self ) -> CPDACBUFS_W { CPDACBUFS_W { w : self } }
# [ doc = "Bit 2 - Comparator built-in DAC reference voltage selection" ] # [ inline ( always ) ] pub fn cpdacrefs ( & mut self ) -> CPDACREFS_W { CPDACREFS_W { w : self } }
# [ doc = "Bit 7 - Comparator built-in DAC output control bit." ] # [ inline ( always ) ] pub fn cpdacen ( & mut self ) -> CPDACEN_W { CPDACEN_W { w : self } }
}
}
# [ doc = "6-bit Comparator built-in DAC Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cp1dacdata](cp1dacdata) module" ] pub type CP1DACDATA = crate :: Reg < u16 , _CP1DACDATA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CP1DACDATA ;
# [ doc = "`read()` method returns [cp1dacdata::R](cp1dacdata::R) reader structure" ] impl crate :: Readable for CP1DACDATA { }
# [ doc = "`write(|w| ..)` method takes [cp1dacdata::W](cp1dacdata::W) writer structure" ] impl crate :: Writable for CP1DACDATA { }
# [ doc = "6-bit Comparator built-in DAC Data Register" ] pub mod cp1dacdata {
# [ doc = "Reader of register CP1DACDATA" ] pub type R = crate :: R < u16 , super :: CP1DACDATA > ;
# [ doc = "Writer for register CP1DACDATA" ] pub type W = crate :: W < u16 , super :: CP1DACDATA > ;
# [ doc = "Register CP1DACDATA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CP1DACDATA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "1st 6-bit DAC buffer Data\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPDACBUF1_A { # [ doc = "0: 0v" ] CPDACBUF1_0 = 0 , # [ doc = "1: selected reference voltage * 1/64" ] CPDACBUF1_1 = 1 , # [ doc = "2: selected reference voltage * 2/64" ] CPDACBUF1_2 = 2 , # [ doc = "3: selected reference voltage * 3/64" ] CPDACBUF1_3 = 3 , # [ doc = "4: selected reference voltage * 4/64" ] CPDACBUF1_4 = 4 , # [ doc = "5: selected reference voltage * 5/64" ] CPDACBUF1_5 = 5 , # [ doc = "6: selected reference voltage * 6/64" ] CPDACBUF1_6 = 6 , # [ doc = "7: selected reference voltage * 7/64" ] CPDACBUF1_7 = 7 , # [ doc = "8: selected reference voltage * 8/64" ] CPDACBUF1_8 = 8 , # [ doc = "9: selected reference voltage *9/64" ] CPDACBUF1_9 = 9 , # [ doc = "10: selected reference voltage * 10/64" ] CPDACBUF1_10 = 10 , # [ doc = "11: selected reference voltage * 11/64" ] CPDACBUF1_11 = 11 , # [ doc = "12: selected reference voltage * 12/64" ] CPDACBUF1_12 = 12 , # [ doc = "13: selected reference voltage * 13/64" ] CPDACBUF1_13 = 13 , # [ doc = "14: selected reference voltage * 14/64" ] CPDACBUF1_14 = 14 , # [ doc = "15: selected reference voltage * 15/64" ] CPDACBUF1_15 = 15 , # [ doc = "16: selected reference voltage * 16/64" ] CPDACBUF1_16 = 16 , # [ doc = "17: selected reference voltage * 17/64" ] CPDACBUF1_17 = 17 , # [ doc = "18: selected reference voltage * 18/64" ] CPDACBUF1_18 = 18 , # [ doc = "19: selected reference voltage * 19/64" ] CPDACBUF1_19 = 19 , # [ doc = "20: selected reference voltage * 20/64" ] CPDACBUF1_20 = 20 , # [ doc = "21: selected reference voltage * 21/64" ] CPDACBUF1_21 = 21 , # [ doc = "22: selected reference voltage * 22/64" ] CPDACBUF1_22 = 22 , # [ doc = "23: selected reference voltage * 23/64" ] CPDACBUF1_23 = 23 , # [ doc = "24: selected reference voltage * 24/64" ] CPDACBUF1_24 = 24 , # [ doc = "25: selected reference voltage * 25/64" ] CPDACBUF1_25 = 25 , # [ doc = "26: selected reference voltage * 26/64" ] CPDACBUF1_26 = 26 , # [ doc = "27: selected reference voltage * 27/64" ] CPDACBUF1_27 = 27 , # [ doc = "28: selected reference voltage * 28/64" ] CPDACBUF1_28 = 28 , # [ doc = "29: selected reference voltage * 29/64" ] CPDACBUF1_29 = 29 , # [ doc = "30: selected reference voltage * 30/64" ] CPDACBUF1_30 = 30 , # [ doc = "31: selected reference voltage * 31/64" ] CPDACBUF1_31 = 31 , # [ doc = "32: selected reference voltage * 32/64" ] CPDACBUF1_32 = 32 , # [ doc = "33: selected reference voltage * 33/64" ] CPDACBUF1_33 = 33 , # [ doc = "34: selected reference voltage * 34/64" ] CPDACBUF1_34 = 34 , # [ doc = "35: selected reference voltage * 35/64" ] CPDACBUF1_35 = 35 , # [ doc = "36: selected reference voltage * 36/64" ] CPDACBUF1_36 = 36 , # [ doc = "37: selected reference voltage * 37/64" ] CPDACBUF1_37 = 37 , # [ doc = "38: selected reference voltage * 38/64" ] CPDACBUF1_38 = 38 , # [ doc = "39: selected reference voltage * 39/64" ] CPDACBUF1_39 = 39 , # [ doc = "40: selected reference voltage * 40/64" ] CPDACBUF1_40 = 40 , # [ doc = "41: selected reference voltage * 41/64" ] CPDACBUF1_41 = 41 , # [ doc = "42: selected reference voltage * 42/64" ] CPDACBUF1_42 = 42 , # [ doc = "43: selected reference voltage * 43/64" ] CPDACBUF1_43 = 43 , # [ doc = "44: selected reference voltage * 44/64" ] CPDACBUF1_44 = 44 , # [ doc = "45: selected reference voltage * 45/64" ] CPDACBUF1_45 = 45 , # [ doc = "46: selected reference voltage * 46/64" ] CPDACBUF1_46 = 46 , # [ doc = "47: selected reference voltage * 47/64" ] CPDACBUF1_47 = 47 , # [ doc = "48: selected reference voltage * 48/64" ] CPDACBUF1_48 = 48 , # [ doc = "49: selected reference voltage * 49/64" ] CPDACBUF1_49 = 49 , # [ doc = "50: selected reference voltage * 50/64" ] CPDACBUF1_50 = 50 , # [ doc = "51: selected reference voltage * 51/64" ] CPDACBUF1_51 = 51 , # [ doc = "52: selected reference voltage * 52/64" ] CPDACBUF1_52 = 52 , # [ doc = "53: selected reference voltage * 53/64" ] CPDACBUF1_53 = 53 , # [ doc = "54: selected reference voltage * 54/64" ] CPDACBUF1_54 = 54 , # [ doc = "55: selected reference voltage * 55/64" ] CPDACBUF1_55 = 55 , # [ doc = "56: selected reference voltage * 56/64" ] CPDACBUF1_56 = 56 , # [ doc = "57: selected reference voltage * 57/64" ] CPDACBUF1_57 = 57 , # [ doc = "58: selected reference voltage * 58/64" ] CPDACBUF1_58 = 58 , # [ doc = "59: selected reference voltage * 59/64" ] CPDACBUF1_59 = 59 , # [ doc = "60: selected reference voltage * 60/64" ] CPDACBUF1_60 = 60 , # [ doc = "61: selected reference voltage * 61/64" ] CPDACBUF1_61 = 61 , # [ doc = "62: selected reference voltage * 62/64" ] CPDACBUF1_62 = 62 , # [ doc = "63: selected reference voltage * 63/64" ] CPDACBUF1_63 = 63 } impl From < CPDACBUF1_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPDACBUF1_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPDACBUF1`" ] pub type CPDACBUF1_R = crate :: R < u8 , CPDACBUF1_A > ; impl CPDACBUF1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACBUF1_A { match self . bits { 0 => CPDACBUF1_A :: CPDACBUF1_0 , 1 => CPDACBUF1_A :: CPDACBUF1_1 , 2 => CPDACBUF1_A :: CPDACBUF1_2 , 3 => CPDACBUF1_A :: CPDACBUF1_3 , 4 => CPDACBUF1_A :: CPDACBUF1_4 , 5 => CPDACBUF1_A :: CPDACBUF1_5 , 6 => CPDACBUF1_A :: CPDACBUF1_6 , 7 => CPDACBUF1_A :: CPDACBUF1_7 , 8 => CPDACBUF1_A :: CPDACBUF1_8 , 9 => CPDACBUF1_A :: CPDACBUF1_9 , 10 => CPDACBUF1_A :: CPDACBUF1_10 , 11 => CPDACBUF1_A :: CPDACBUF1_11 , 12 => CPDACBUF1_A :: CPDACBUF1_12 , 13 => CPDACBUF1_A :: CPDACBUF1_13 , 14 => CPDACBUF1_A :: CPDACBUF1_14 , 15 => CPDACBUF1_A :: CPDACBUF1_15 , 16 => CPDACBUF1_A :: CPDACBUF1_16 , 17 => CPDACBUF1_A :: CPDACBUF1_17 , 18 => CPDACBUF1_A :: CPDACBUF1_18 , 19 => CPDACBUF1_A :: CPDACBUF1_19 , 20 => CPDACBUF1_A :: CPDACBUF1_20 , 21 => CPDACBUF1_A :: CPDACBUF1_21 , 22 => CPDACBUF1_A :: CPDACBUF1_22 , 23 => CPDACBUF1_A :: CPDACBUF1_23 , 24 => CPDACBUF1_A :: CPDACBUF1_24 , 25 => CPDACBUF1_A :: CPDACBUF1_25 , 26 => CPDACBUF1_A :: CPDACBUF1_26 , 27 => CPDACBUF1_A :: CPDACBUF1_27 , 28 => CPDACBUF1_A :: CPDACBUF1_28 , 29 => CPDACBUF1_A :: CPDACBUF1_29 , 30 => CPDACBUF1_A :: CPDACBUF1_30 , 31 => CPDACBUF1_A :: CPDACBUF1_31 , 32 => CPDACBUF1_A :: CPDACBUF1_32 , 33 => CPDACBUF1_A :: CPDACBUF1_33 , 34 => CPDACBUF1_A :: CPDACBUF1_34 , 35 => CPDACBUF1_A :: CPDACBUF1_35 , 36 => CPDACBUF1_A :: CPDACBUF1_36 , 37 => CPDACBUF1_A :: CPDACBUF1_37 , 38 => CPDACBUF1_A :: CPDACBUF1_38 , 39 => CPDACBUF1_A :: CPDACBUF1_39 , 40 => CPDACBUF1_A :: CPDACBUF1_40 , 41 => CPDACBUF1_A :: CPDACBUF1_41 , 42 => CPDACBUF1_A :: CPDACBUF1_42 , 43 => CPDACBUF1_A :: CPDACBUF1_43 , 44 => CPDACBUF1_A :: CPDACBUF1_44 , 45 => CPDACBUF1_A :: CPDACBUF1_45 , 46 => CPDACBUF1_A :: CPDACBUF1_46 , 47 => CPDACBUF1_A :: CPDACBUF1_47 , 48 => CPDACBUF1_A :: CPDACBUF1_48 , 49 => CPDACBUF1_A :: CPDACBUF1_49 , 50 => CPDACBUF1_A :: CPDACBUF1_50 , 51 => CPDACBUF1_A :: CPDACBUF1_51 , 52 => CPDACBUF1_A :: CPDACBUF1_52 , 53 => CPDACBUF1_A :: CPDACBUF1_53 , 54 => CPDACBUF1_A :: CPDACBUF1_54 , 55 => CPDACBUF1_A :: CPDACBUF1_55 , 56 => CPDACBUF1_A :: CPDACBUF1_56 , 57 => CPDACBUF1_A :: CPDACBUF1_57 , 58 => CPDACBUF1_A :: CPDACBUF1_58 , 59 => CPDACBUF1_A :: CPDACBUF1_59 , 60 => CPDACBUF1_A :: CPDACBUF1_60 , 61 => CPDACBUF1_A :: CPDACBUF1_61 , 62 => CPDACBUF1_A :: CPDACBUF1_62 , 63 => CPDACBUF1_A :: CPDACBUF1_63 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPDACBUF1_0`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_0 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_0 } # [ doc = "Checks if the value of the field is `CPDACBUF1_1`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_1 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_1 } # [ doc = "Checks if the value of the field is `CPDACBUF1_2`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_2 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_2 } # [ doc = "Checks if the value of the field is `CPDACBUF1_3`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_3 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_3 } # [ doc = "Checks if the value of the field is `CPDACBUF1_4`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_4 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_4 } # [ doc = "Checks if the value of the field is `CPDACBUF1_5`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_5 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_5 } # [ doc = "Checks if the value of the field is `CPDACBUF1_6`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_6 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_6 } # [ doc = "Checks if the value of the field is `CPDACBUF1_7`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_7 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_7 } # [ doc = "Checks if the value of the field is `CPDACBUF1_8`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_8 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_8 } # [ doc = "Checks if the value of the field is `CPDACBUF1_9`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_9 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_9 } # [ doc = "Checks if the value of the field is `CPDACBUF1_10`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_10 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_10 } # [ doc = "Checks if the value of the field is `CPDACBUF1_11`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_11 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_11 } # [ doc = "Checks if the value of the field is `CPDACBUF1_12`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_12 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_12 } # [ doc = "Checks if the value of the field is `CPDACBUF1_13`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_13 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_13 } # [ doc = "Checks if the value of the field is `CPDACBUF1_14`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_14 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_14 } # [ doc = "Checks if the value of the field is `CPDACBUF1_15`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_15 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_15 } # [ doc = "Checks if the value of the field is `CPDACBUF1_16`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_16 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_16 } # [ doc = "Checks if the value of the field is `CPDACBUF1_17`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_17 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_17 } # [ doc = "Checks if the value of the field is `CPDACBUF1_18`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_18 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_18 } # [ doc = "Checks if the value of the field is `CPDACBUF1_19`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_19 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_19 } # [ doc = "Checks if the value of the field is `CPDACBUF1_20`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_20 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_20 } # [ doc = "Checks if the value of the field is `CPDACBUF1_21`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_21 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_21 } # [ doc = "Checks if the value of the field is `CPDACBUF1_22`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_22 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_22 } # [ doc = "Checks if the value of the field is `CPDACBUF1_23`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_23 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_23 } # [ doc = "Checks if the value of the field is `CPDACBUF1_24`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_24 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_24 } # [ doc = "Checks if the value of the field is `CPDACBUF1_25`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_25 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_25 } # [ doc = "Checks if the value of the field is `CPDACBUF1_26`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_26 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_26 } # [ doc = "Checks if the value of the field is `CPDACBUF1_27`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_27 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_27 } # [ doc = "Checks if the value of the field is `CPDACBUF1_28`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_28 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_28 } # [ doc = "Checks if the value of the field is `CPDACBUF1_29`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_29 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_29 } # [ doc = "Checks if the value of the field is `CPDACBUF1_30`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_30 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_30 } # [ doc = "Checks if the value of the field is `CPDACBUF1_31`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_31 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_31 } # [ doc = "Checks if the value of the field is `CPDACBUF1_32`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_32 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_32 } # [ doc = "Checks if the value of the field is `CPDACBUF1_33`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_33 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_33 } # [ doc = "Checks if the value of the field is `CPDACBUF1_34`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_34 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_34 } # [ doc = "Checks if the value of the field is `CPDACBUF1_35`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_35 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_35 } # [ doc = "Checks if the value of the field is `CPDACBUF1_36`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_36 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_36 } # [ doc = "Checks if the value of the field is `CPDACBUF1_37`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_37 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_37 } # [ doc = "Checks if the value of the field is `CPDACBUF1_38`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_38 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_38 } # [ doc = "Checks if the value of the field is `CPDACBUF1_39`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_39 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_39 } # [ doc = "Checks if the value of the field is `CPDACBUF1_40`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_40 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_40 } # [ doc = "Checks if the value of the field is `CPDACBUF1_41`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_41 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_41 } # [ doc = "Checks if the value of the field is `CPDACBUF1_42`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_42 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_42 } # [ doc = "Checks if the value of the field is `CPDACBUF1_43`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_43 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_43 } # [ doc = "Checks if the value of the field is `CPDACBUF1_44`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_44 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_44 } # [ doc = "Checks if the value of the field is `CPDACBUF1_45`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_45 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_45 } # [ doc = "Checks if the value of the field is `CPDACBUF1_46`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_46 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_46 } # [ doc = "Checks if the value of the field is `CPDACBUF1_47`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_47 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_47 } # [ doc = "Checks if the value of the field is `CPDACBUF1_48`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_48 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_48 } # [ doc = "Checks if the value of the field is `CPDACBUF1_49`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_49 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_49 } # [ doc = "Checks if the value of the field is `CPDACBUF1_50`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_50 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_50 } # [ doc = "Checks if the value of the field is `CPDACBUF1_51`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_51 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_51 } # [ doc = "Checks if the value of the field is `CPDACBUF1_52`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_52 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_52 } # [ doc = "Checks if the value of the field is `CPDACBUF1_53`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_53 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_53 } # [ doc = "Checks if the value of the field is `CPDACBUF1_54`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_54 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_54 } # [ doc = "Checks if the value of the field is `CPDACBUF1_55`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_55 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_55 } # [ doc = "Checks if the value of the field is `CPDACBUF1_56`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_56 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_56 } # [ doc = "Checks if the value of the field is `CPDACBUF1_57`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_57 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_57 } # [ doc = "Checks if the value of the field is `CPDACBUF1_58`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_58 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_58 } # [ doc = "Checks if the value of the field is `CPDACBUF1_59`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_59 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_59 } # [ doc = "Checks if the value of the field is `CPDACBUF1_60`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_60 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_60 } # [ doc = "Checks if the value of the field is `CPDACBUF1_61`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_61 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_61 } # [ doc = "Checks if the value of the field is `CPDACBUF1_62`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_62 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_62 } # [ doc = "Checks if the value of the field is `CPDACBUF1_63`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_63 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_63 } }
# [ doc = "Write proxy for field `CPDACBUF1`" ] pub struct CPDACBUF1_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACBUF1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACBUF1_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "0v" ] # [ inline ( always ) ] pub fn cpdacbuf1_0 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_0 ) } # [ doc = "selected reference voltage * 1/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_1 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_1 ) } # [ doc = "selected reference voltage * 2/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_2 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_2 ) } # [ doc = "selected reference voltage * 3/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_3 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_3 ) } # [ doc = "selected reference voltage * 4/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_4 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_4 ) } # [ doc = "selected reference voltage * 5/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_5 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_5 ) } # [ doc = "selected reference voltage * 6/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_6 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_6 ) } # [ doc = "selected reference voltage * 7/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_7 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_7 ) } # [ doc = "selected reference voltage * 8/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_8 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_8 ) } # [ doc = "selected reference voltage *9/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_9 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_9 ) } # [ doc = "selected reference voltage * 10/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_10 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_10 ) } # [ doc = "selected reference voltage * 11/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_11 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_11 ) } # [ doc = "selected reference voltage * 12/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_12 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_12 ) } # [ doc = "selected reference voltage * 13/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_13 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_13 ) } # [ doc = "selected reference voltage * 14/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_14 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_14 ) } # [ doc = "selected reference voltage * 15/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_15 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_15 ) } # [ doc = "selected reference voltage * 16/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_16 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_16 ) } # [ doc = "selected reference voltage * 17/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_17 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_17 ) } # [ doc = "selected reference voltage * 18/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_18 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_18 ) } # [ doc = "selected reference voltage * 19/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_19 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_19 ) } # [ doc = "selected reference voltage * 20/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_20 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_20 ) } # [ doc = "selected reference voltage * 21/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_21 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_21 ) } # [ doc = "selected reference voltage * 22/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_22 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_22 ) } # [ doc = "selected reference voltage * 23/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_23 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_23 ) } # [ doc = "selected reference voltage * 24/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_24 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_24 ) } # [ doc = "selected reference voltage * 25/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_25 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_25 ) } # [ doc = "selected reference voltage * 26/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_26 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_26 ) } # [ doc = "selected reference voltage * 27/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_27 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_27 ) } # [ doc = "selected reference voltage * 28/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_28 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_28 ) } # [ doc = "selected reference voltage * 29/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_29 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_29 ) } # [ doc = "selected reference voltage * 30/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_30 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_30 ) } # [ doc = "selected reference voltage * 31/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_31 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_31 ) } # [ doc = "selected reference voltage * 32/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_32 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_32 ) } # [ doc = "selected reference voltage * 33/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_33 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_33 ) } # [ doc = "selected reference voltage * 34/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_34 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_34 ) } # [ doc = "selected reference voltage * 35/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_35 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_35 ) } # [ doc = "selected reference voltage * 36/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_36 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_36 ) } # [ doc = "selected reference voltage * 37/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_37 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_37 ) } # [ doc = "selected reference voltage * 38/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_38 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_38 ) } # [ doc = "selected reference voltage * 39/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_39 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_39 ) } # [ doc = "selected reference voltage * 40/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_40 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_40 ) } # [ doc = "selected reference voltage * 41/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_41 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_41 ) } # [ doc = "selected reference voltage * 42/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_42 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_42 ) } # [ doc = "selected reference voltage * 43/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_43 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_43 ) } # [ doc = "selected reference voltage * 44/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_44 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_44 ) } # [ doc = "selected reference voltage * 45/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_45 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_45 ) } # [ doc = "selected reference voltage * 46/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_46 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_46 ) } # [ doc = "selected reference voltage * 47/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_47 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_47 ) } # [ doc = "selected reference voltage * 48/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_48 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_48 ) } # [ doc = "selected reference voltage * 49/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_49 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_49 ) } # [ doc = "selected reference voltage * 50/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_50 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_50 ) } # [ doc = "selected reference voltage * 51/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_51 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_51 ) } # [ doc = "selected reference voltage * 52/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_52 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_52 ) } # [ doc = "selected reference voltage * 53/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_53 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_53 ) } # [ doc = "selected reference voltage * 54/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_54 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_54 ) } # [ doc = "selected reference voltage * 55/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_55 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_55 ) } # [ doc = "selected reference voltage * 56/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_56 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_56 ) } # [ doc = "selected reference voltage * 57/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_57 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_57 ) } # [ doc = "selected reference voltage * 58/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_58 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_58 ) } # [ doc = "selected reference voltage * 59/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_59 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_59 ) } # [ doc = "selected reference voltage * 60/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_60 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_60 ) } # [ doc = "selected reference voltage * 61/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_61 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_61 ) } # [ doc = "selected reference voltage * 62/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_62 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_62 ) } # [ doc = "selected reference voltage * 63/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_63 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_63 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u16 ) & 0x3f ) ; self . w } }
# [ doc = "2nd 6-bit DAC buffer Data\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPDACBUF2_A { # [ doc = "0: 0v" ] CPDACBUF2_0 = 0 , # [ doc = "1: selected reference voltage * 1/64" ] CPDACBUF2_1 = 1 , # [ doc = "2: selected reference voltage * 2/64" ] CPDACBUF2_2 = 2 , # [ doc = "3: selected reference voltage * 3/64" ] CPDACBUF2_3 = 3 , # [ doc = "4: selected reference voltage * 4/64" ] CPDACBUF2_4 = 4 , # [ doc = "5: selected reference voltage * 5/64" ] CPDACBUF2_5 = 5 , # [ doc = "6: selected reference voltage * 6/64" ] CPDACBUF2_6 = 6 , # [ doc = "7: selected reference voltage * 7/64" ] CPDACBUF2_7 = 7 , # [ doc = "8: selected reference voltage * 8/64" ] CPDACBUF2_8 = 8 , # [ doc = "9: selected reference voltage * 9/64" ] CPDACBUF2_9 = 9 , # [ doc = "10: selected reference voltage * 10/64" ] CPDACBUF2_10 = 10 , # [ doc = "11: selected reference voltage * 11/64" ] CPDACBUF2_11 = 11 , # [ doc = "12: selected reference voltage * 12/64" ] CPDACBUF2_12 = 12 , # [ doc = "13: selected reference voltage * 13/64" ] CPDACBUF2_13 = 13 , # [ doc = "14: selected reference voltage * 14/64" ] CPDACBUF2_14 = 14 , # [ doc = "15: selected reference voltage * 15/64" ] CPDACBUF2_15 = 15 , # [ doc = "16: selected reference voltage * 16/64" ] CPDACBUF2_16 = 16 , # [ doc = "17: selected reference voltage * 17/64" ] CPDACBUF2_17 = 17 , # [ doc = "18: selected reference voltage * 18/64" ] CPDACBUF2_18 = 18 , # [ doc = "19: selected reference voltage * 19/64" ] CPDACBUF2_19 = 19 , # [ doc = "20: selected reference voltage * 20/64" ] CPDACBUF2_20 = 20 , # [ doc = "21: selected reference voltage * 21/64" ] CPDACBUF2_21 = 21 , # [ doc = "22: selected reference voltage * 22/64" ] CPDACBUF2_22 = 22 , # [ doc = "23: selected reference voltage * 23/64" ] CPDACBUF2_23 = 23 , # [ doc = "24: selected reference voltage * 24/64" ] CPDACBUF2_24 = 24 , # [ doc = "25: selected reference voltage * 25/64" ] CPDACBUF2_25 = 25 , # [ doc = "26: selected reference voltage * 26/64" ] CPDACBUF2_26 = 26 , # [ doc = "27: selected reference voltage * 27/64" ] CPDACBUF2_27 = 27 , # [ doc = "28: selected reference voltage * 28/64" ] CPDACBUF2_28 = 28 , # [ doc = "29: selected reference voltage * 29/64" ] CPDACBUF2_29 = 29 , # [ doc = "30: selected reference voltage * 30/64" ] CPDACBUF2_30 = 30 , # [ doc = "31: selected reference voltage * 31/64" ] CPDACBUF2_31 = 31 , # [ doc = "32: selected reference voltage * 32/64" ] CPDACBUF2_32 = 32 , # [ doc = "33: selected reference voltage * 33/64" ] CPDACBUF2_33 = 33 , # [ doc = "34: selected reference voltage * 34/64" ] CPDACBUF2_34 = 34 , # [ doc = "35: selected reference voltage * 35/64" ] CPDACBUF2_35 = 35 , # [ doc = "36: selected reference voltage * 36/64" ] CPDACBUF2_36 = 36 , # [ doc = "37: selected reference voltage * 37/64" ] CPDACBUF2_37 = 37 , # [ doc = "38: selected reference voltage * 38/64" ] CPDACBUF2_38 = 38 , # [ doc = "39: selected reference voltage * 39/64" ] CPDACBUF2_39 = 39 , # [ doc = "40: selected reference voltage * 40/64" ] CPDACBUF2_40 = 40 , # [ doc = "41: selected reference voltage * 41/64" ] CPDACBUF2_41 = 41 , # [ doc = "42: selected reference voltage * 42/64" ] CPDACBUF2_42 = 42 , # [ doc = "43: selected reference voltage * 43/64" ] CPDACBUF2_43 = 43 , # [ doc = "44: selected reference voltage * 44/64" ] CPDACBUF2_44 = 44 , # [ doc = "45: selected reference voltage * 45/64" ] CPDACBUF2_45 = 45 , # [ doc = "46: selected reference voltage * 46/64" ] CPDACBUF2_46 = 46 , # [ doc = "47: selected reference voltage * 47/64" ] CPDACBUF2_47 = 47 , # [ doc = "48: selected reference voltage * 48/64" ] CPDACBUF2_48 = 48 , # [ doc = "49: selected reference voltage * 49/64" ] CPDACBUF2_49 = 49 , # [ doc = "50: selected reference voltage * 50/64" ] CPDACBUF2_50 = 50 , # [ doc = "51: selected reference voltage * 51/64" ] CPDACBUF2_51 = 51 , # [ doc = "52: selected reference voltage * 52/64" ] CPDACBUF2_52 = 52 , # [ doc = "53: selected reference voltage * 53/64" ] CPDACBUF2_53 = 53 , # [ doc = "54: selected reference voltage * 54/64" ] CPDACBUF2_54 = 54 , # [ doc = "55: selected reference voltage * 55/64" ] CPDACBUF2_55 = 55 , # [ doc = "56: selected reference voltage * 56/64" ] CPDACBUF2_56 = 56 , # [ doc = "57: selected reference voltage * 57/64" ] CPDACBUF2_57 = 57 , # [ doc = "58: selected reference voltage * 58/64" ] CPDACBUF2_58 = 58 , # [ doc = "59: selected reference voltage * 59/64" ] CPDACBUF2_59 = 59 , # [ doc = "60: selected reference voltage * 60/64" ] CPDACBUF2_60 = 60 , # [ doc = "61: selected reference voltage * 61/64" ] CPDACBUF2_61 = 61 , # [ doc = "62: selected reference voltage * 62/64" ] CPDACBUF2_62 = 62 , # [ doc = "63: selected reference voltage * 63/64" ] CPDACBUF2_63 = 63 } impl From < CPDACBUF2_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPDACBUF2_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPDACBUF2`" ] pub type CPDACBUF2_R = crate :: R < u8 , CPDACBUF2_A > ; impl CPDACBUF2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACBUF2_A { match self . bits { 0 => CPDACBUF2_A :: CPDACBUF2_0 , 1 => CPDACBUF2_A :: CPDACBUF2_1 , 2 => CPDACBUF2_A :: CPDACBUF2_2 , 3 => CPDACBUF2_A :: CPDACBUF2_3 , 4 => CPDACBUF2_A :: CPDACBUF2_4 , 5 => CPDACBUF2_A :: CPDACBUF2_5 , 6 => CPDACBUF2_A :: CPDACBUF2_6 , 7 => CPDACBUF2_A :: CPDACBUF2_7 , 8 => CPDACBUF2_A :: CPDACBUF2_8 , 9 => CPDACBUF2_A :: CPDACBUF2_9 , 10 => CPDACBUF2_A :: CPDACBUF2_10 , 11 => CPDACBUF2_A :: CPDACBUF2_11 , 12 => CPDACBUF2_A :: CPDACBUF2_12 , 13 => CPDACBUF2_A :: CPDACBUF2_13 , 14 => CPDACBUF2_A :: CPDACBUF2_14 , 15 => CPDACBUF2_A :: CPDACBUF2_15 , 16 => CPDACBUF2_A :: CPDACBUF2_16 , 17 => CPDACBUF2_A :: CPDACBUF2_17 , 18 => CPDACBUF2_A :: CPDACBUF2_18 , 19 => CPDACBUF2_A :: CPDACBUF2_19 , 20 => CPDACBUF2_A :: CPDACBUF2_20 , 21 => CPDACBUF2_A :: CPDACBUF2_21 , 22 => CPDACBUF2_A :: CPDACBUF2_22 , 23 => CPDACBUF2_A :: CPDACBUF2_23 , 24 => CPDACBUF2_A :: CPDACBUF2_24 , 25 => CPDACBUF2_A :: CPDACBUF2_25 , 26 => CPDACBUF2_A :: CPDACBUF2_26 , 27 => CPDACBUF2_A :: CPDACBUF2_27 , 28 => CPDACBUF2_A :: CPDACBUF2_28 , 29 => CPDACBUF2_A :: CPDACBUF2_29 , 30 => CPDACBUF2_A :: CPDACBUF2_30 , 31 => CPDACBUF2_A :: CPDACBUF2_31 , 32 => CPDACBUF2_A :: CPDACBUF2_32 , 33 => CPDACBUF2_A :: CPDACBUF2_33 , 34 => CPDACBUF2_A :: CPDACBUF2_34 , 35 => CPDACBUF2_A :: CPDACBUF2_35 , 36 => CPDACBUF2_A :: CPDACBUF2_36 , 37 => CPDACBUF2_A :: CPDACBUF2_37 , 38 => CPDACBUF2_A :: CPDACBUF2_38 , 39 => CPDACBUF2_A :: CPDACBUF2_39 , 40 => CPDACBUF2_A :: CPDACBUF2_40 , 41 => CPDACBUF2_A :: CPDACBUF2_41 , 42 => CPDACBUF2_A :: CPDACBUF2_42 , 43 => CPDACBUF2_A :: CPDACBUF2_43 , 44 => CPDACBUF2_A :: CPDACBUF2_44 , 45 => CPDACBUF2_A :: CPDACBUF2_45 , 46 => CPDACBUF2_A :: CPDACBUF2_46 , 47 => CPDACBUF2_A :: CPDACBUF2_47 , 48 => CPDACBUF2_A :: CPDACBUF2_48 , 49 => CPDACBUF2_A :: CPDACBUF2_49 , 50 => CPDACBUF2_A :: CPDACBUF2_50 , 51 => CPDACBUF2_A :: CPDACBUF2_51 , 52 => CPDACBUF2_A :: CPDACBUF2_52 , 53 => CPDACBUF2_A :: CPDACBUF2_53 , 54 => CPDACBUF2_A :: CPDACBUF2_54 , 55 => CPDACBUF2_A :: CPDACBUF2_55 , 56 => CPDACBUF2_A :: CPDACBUF2_56 , 57 => CPDACBUF2_A :: CPDACBUF2_57 , 58 => CPDACBUF2_A :: CPDACBUF2_58 , 59 => CPDACBUF2_A :: CPDACBUF2_59 , 60 => CPDACBUF2_A :: CPDACBUF2_60 , 61 => CPDACBUF2_A :: CPDACBUF2_61 , 62 => CPDACBUF2_A :: CPDACBUF2_62 , 63 => CPDACBUF2_A :: CPDACBUF2_63 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPDACBUF2_0`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_0 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_0 } # [ doc = "Checks if the value of the field is `CPDACBUF2_1`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_1 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_1 } # [ doc = "Checks if the value of the field is `CPDACBUF2_2`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_2 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_2 } # [ doc = "Checks if the value of the field is `CPDACBUF2_3`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_3 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_3 } # [ doc = "Checks if the value of the field is `CPDACBUF2_4`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_4 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_4 } # [ doc = "Checks if the value of the field is `CPDACBUF2_5`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_5 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_5 } # [ doc = "Checks if the value of the field is `CPDACBUF2_6`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_6 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_6 } # [ doc = "Checks if the value of the field is `CPDACBUF2_7`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_7 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_7 } # [ doc = "Checks if the value of the field is `CPDACBUF2_8`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_8 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_8 } # [ doc = "Checks if the value of the field is `CPDACBUF2_9`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_9 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_9 } # [ doc = "Checks if the value of the field is `CPDACBUF2_10`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_10 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_10 } # [ doc = "Checks if the value of the field is `CPDACBUF2_11`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_11 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_11 } # [ doc = "Checks if the value of the field is `CPDACBUF2_12`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_12 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_12 } # [ doc = "Checks if the value of the field is `CPDACBUF2_13`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_13 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_13 } # [ doc = "Checks if the value of the field is `CPDACBUF2_14`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_14 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_14 } # [ doc = "Checks if the value of the field is `CPDACBUF2_15`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_15 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_15 } # [ doc = "Checks if the value of the field is `CPDACBUF2_16`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_16 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_16 } # [ doc = "Checks if the value of the field is `CPDACBUF2_17`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_17 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_17 } # [ doc = "Checks if the value of the field is `CPDACBUF2_18`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_18 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_18 } # [ doc = "Checks if the value of the field is `CPDACBUF2_19`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_19 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_19 } # [ doc = "Checks if the value of the field is `CPDACBUF2_20`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_20 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_20 } # [ doc = "Checks if the value of the field is `CPDACBUF2_21`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_21 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_21 } # [ doc = "Checks if the value of the field is `CPDACBUF2_22`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_22 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_22 } # [ doc = "Checks if the value of the field is `CPDACBUF2_23`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_23 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_23 } # [ doc = "Checks if the value of the field is `CPDACBUF2_24`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_24 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_24 } # [ doc = "Checks if the value of the field is `CPDACBUF2_25`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_25 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_25 } # [ doc = "Checks if the value of the field is `CPDACBUF2_26`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_26 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_26 } # [ doc = "Checks if the value of the field is `CPDACBUF2_27`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_27 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_27 } # [ doc = "Checks if the value of the field is `CPDACBUF2_28`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_28 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_28 } # [ doc = "Checks if the value of the field is `CPDACBUF2_29`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_29 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_29 } # [ doc = "Checks if the value of the field is `CPDACBUF2_30`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_30 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_30 } # [ doc = "Checks if the value of the field is `CPDACBUF2_31`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_31 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_31 } # [ doc = "Checks if the value of the field is `CPDACBUF2_32`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_32 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_32 } # [ doc = "Checks if the value of the field is `CPDACBUF2_33`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_33 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_33 } # [ doc = "Checks if the value of the field is `CPDACBUF2_34`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_34 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_34 } # [ doc = "Checks if the value of the field is `CPDACBUF2_35`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_35 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_35 } # [ doc = "Checks if the value of the field is `CPDACBUF2_36`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_36 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_36 } # [ doc = "Checks if the value of the field is `CPDACBUF2_37`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_37 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_37 } # [ doc = "Checks if the value of the field is `CPDACBUF2_38`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_38 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_38 } # [ doc = "Checks if the value of the field is `CPDACBUF2_39`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_39 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_39 } # [ doc = "Checks if the value of the field is `CPDACBUF2_40`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_40 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_40 } # [ doc = "Checks if the value of the field is `CPDACBUF2_41`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_41 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_41 } # [ doc = "Checks if the value of the field is `CPDACBUF2_42`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_42 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_42 } # [ doc = "Checks if the value of the field is `CPDACBUF2_43`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_43 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_43 } # [ doc = "Checks if the value of the field is `CPDACBUF2_44`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_44 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_44 } # [ doc = "Checks if the value of the field is `CPDACBUF2_45`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_45 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_45 } # [ doc = "Checks if the value of the field is `CPDACBUF2_46`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_46 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_46 } # [ doc = "Checks if the value of the field is `CPDACBUF2_47`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_47 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_47 } # [ doc = "Checks if the value of the field is `CPDACBUF2_48`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_48 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_48 } # [ doc = "Checks if the value of the field is `CPDACBUF2_49`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_49 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_49 } # [ doc = "Checks if the value of the field is `CPDACBUF2_50`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_50 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_50 } # [ doc = "Checks if the value of the field is `CPDACBUF2_51`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_51 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_51 } # [ doc = "Checks if the value of the field is `CPDACBUF2_52`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_52 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_52 } # [ doc = "Checks if the value of the field is `CPDACBUF2_53`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_53 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_53 } # [ doc = "Checks if the value of the field is `CPDACBUF2_54`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_54 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_54 } # [ doc = "Checks if the value of the field is `CPDACBUF2_55`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_55 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_55 } # [ doc = "Checks if the value of the field is `CPDACBUF2_56`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_56 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_56 } # [ doc = "Checks if the value of the field is `CPDACBUF2_57`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_57 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_57 } # [ doc = "Checks if the value of the field is `CPDACBUF2_58`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_58 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_58 } # [ doc = "Checks if the value of the field is `CPDACBUF2_59`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_59 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_59 } # [ doc = "Checks if the value of the field is `CPDACBUF2_60`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_60 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_60 } # [ doc = "Checks if the value of the field is `CPDACBUF2_61`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_61 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_61 } # [ doc = "Checks if the value of the field is `CPDACBUF2_62`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_62 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_62 } # [ doc = "Checks if the value of the field is `CPDACBUF2_63`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_63 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_63 } }
# [ doc = "Write proxy for field `CPDACBUF2`" ] pub struct CPDACBUF2_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACBUF2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACBUF2_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "0v" ] # [ inline ( always ) ] pub fn cpdacbuf2_0 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_0 ) } # [ doc = "selected reference voltage * 1/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_1 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_1 ) } # [ doc = "selected reference voltage * 2/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_2 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_2 ) } # [ doc = "selected reference voltage * 3/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_3 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_3 ) } # [ doc = "selected reference voltage * 4/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_4 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_4 ) } # [ doc = "selected reference voltage * 5/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_5 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_5 ) } # [ doc = "selected reference voltage * 6/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_6 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_6 ) } # [ doc = "selected reference voltage * 7/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_7 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_7 ) } # [ doc = "selected reference voltage * 8/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_8 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_8 ) } # [ doc = "selected reference voltage * 9/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_9 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_9 ) } # [ doc = "selected reference voltage * 10/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_10 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_10 ) } # [ doc = "selected reference voltage * 11/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_11 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_11 ) } # [ doc = "selected reference voltage * 12/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_12 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_12 ) } # [ doc = "selected reference voltage * 13/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_13 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_13 ) } # [ doc = "selected reference voltage * 14/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_14 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_14 ) } # [ doc = "selected reference voltage * 15/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_15 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_15 ) } # [ doc = "selected reference voltage * 16/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_16 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_16 ) } # [ doc = "selected reference voltage * 17/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_17 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_17 ) } # [ doc = "selected reference voltage * 18/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_18 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_18 ) } # [ doc = "selected reference voltage * 19/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_19 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_19 ) } # [ doc = "selected reference voltage * 20/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_20 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_20 ) } # [ doc = "selected reference voltage * 21/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_21 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_21 ) } # [ doc = "selected reference voltage * 22/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_22 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_22 ) } # [ doc = "selected reference voltage * 23/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_23 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_23 ) } # [ doc = "selected reference voltage * 24/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_24 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_24 ) } # [ doc = "selected reference voltage * 25/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_25 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_25 ) } # [ doc = "selected reference voltage * 26/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_26 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_26 ) } # [ doc = "selected reference voltage * 27/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_27 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_27 ) } # [ doc = "selected reference voltage * 28/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_28 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_28 ) } # [ doc = "selected reference voltage * 29/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_29 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_29 ) } # [ doc = "selected reference voltage * 30/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_30 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_30 ) } # [ doc = "selected reference voltage * 31/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_31 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_31 ) } # [ doc = "selected reference voltage * 32/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_32 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_32 ) } # [ doc = "selected reference voltage * 33/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_33 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_33 ) } # [ doc = "selected reference voltage * 34/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_34 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_34 ) } # [ doc = "selected reference voltage * 35/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_35 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_35 ) } # [ doc = "selected reference voltage * 36/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_36 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_36 ) } # [ doc = "selected reference voltage * 37/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_37 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_37 ) } # [ doc = "selected reference voltage * 38/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_38 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_38 ) } # [ doc = "selected reference voltage * 39/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_39 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_39 ) } # [ doc = "selected reference voltage * 40/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_40 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_40 ) } # [ doc = "selected reference voltage * 41/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_41 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_41 ) } # [ doc = "selected reference voltage * 42/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_42 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_42 ) } # [ doc = "selected reference voltage * 43/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_43 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_43 ) } # [ doc = "selected reference voltage * 44/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_44 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_44 ) } # [ doc = "selected reference voltage * 45/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_45 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_45 ) } # [ doc = "selected reference voltage * 46/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_46 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_46 ) } # [ doc = "selected reference voltage * 47/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_47 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_47 ) } # [ doc = "selected reference voltage * 48/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_48 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_48 ) } # [ doc = "selected reference voltage * 49/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_49 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_49 ) } # [ doc = "selected reference voltage * 50/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_50 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_50 ) } # [ doc = "selected reference voltage * 51/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_51 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_51 ) } # [ doc = "selected reference voltage * 52/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_52 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_52 ) } # [ doc = "selected reference voltage * 53/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_53 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_53 ) } # [ doc = "selected reference voltage * 54/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_54 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_54 ) } # [ doc = "selected reference voltage * 55/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_55 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_55 ) } # [ doc = "selected reference voltage * 56/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_56 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_56 ) } # [ doc = "selected reference voltage * 57/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_57 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_57 ) } # [ doc = "selected reference voltage * 58/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_58 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_58 ) } # [ doc = "selected reference voltage * 59/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_59 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_59 ) } # [ doc = "selected reference voltage * 60/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_60 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_60 ) } # [ doc = "selected reference voltage * 61/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_61 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_61 ) } # [ doc = "selected reference voltage * 62/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_62 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_62 ) } # [ doc = "selected reference voltage * 63/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_63 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_63 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 8 ) ) | ( ( ( value as u16 ) & 0x3f ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:5 - 1st 6-bit DAC buffer Data" ] # [ inline ( always ) ] pub fn cpdacbuf1 ( & self ) -> CPDACBUF1_R { CPDACBUF1_R :: new ( ( self . bits & 0x3f ) as u8 ) }
# [ doc = "Bits 8:13 - 2nd 6-bit DAC buffer Data" ] # [ inline ( always ) ] pub fn cpdacbuf2 ( & self ) -> CPDACBUF2_R { CPDACBUF2_R :: new ( ( ( self . bits >> 8 ) & 0x3f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:5 - 1st 6-bit DAC buffer Data" ] # [ inline ( always ) ] pub fn cpdacbuf1 ( & mut self ) -> CPDACBUF1_W { CPDACBUF1_W { w : self } }
# [ doc = "Bits 8:13 - 2nd 6-bit DAC buffer Data" ] # [ inline ( always ) ] pub fn cpdacbuf2 ( & mut self ) -> CPDACBUF2_W { CPDACBUF2_W { w : self } }
}
}
}
# [ doc = "SAC0" ] pub struct SAC0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SAC0 { } impl SAC0 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const sac0 :: RegisterBlock { 0x0c80 as * const _ } } impl Deref for SAC0 { type Target = sac0 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * SAC0 :: ptr ( ) } } }
# [ doc = "SAC0" ] pub mod sac0 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - SAC OA Control Register" ] pub sac0oa : SAC0OA , # [ doc = "0x02 - SAC PGA Control Register" ] pub sac0pga : SAC0PGA , # [ doc = "0x04 - SAC DAC Control Register" ] pub sac0dac : SAC0DAC , # [ doc = "0x06 - SAC DAC Data Register" ] pub sac0dat : SAC0DAT , # [ doc = "0x08 - SAC DAC Status Register" ] pub sac0dacsts : SAC0DACSTS , # [ doc = "0x0a - SAC Interrupt Vector Register" ] pub sac0iv : SAC0IV , }
# [ doc = "SAC OA Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac0oa](sac0oa) module" ] pub type SAC0OA = crate :: Reg < u16 , _SAC0OA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC0OA ;
# [ doc = "`read()` method returns [sac0oa::R](sac0oa::R) reader structure" ] impl crate :: Readable for SAC0OA { }
# [ doc = "`write(|w| ..)` method takes [sac0oa::W](sac0oa::W) writer structure" ] impl crate :: Writable for SAC0OA { }
# [ doc = "SAC OA Control Register" ] pub mod sac0oa {
# [ doc = "Reader of register SAC0OA" ] pub type R = crate :: R < u16 , super :: SAC0OA > ;
# [ doc = "Writer for register SAC0OA" ] pub type W = crate :: W < u16 , super :: SAC0OA > ;
# [ doc = "Register SAC0OA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC0OA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC OA Positive input source selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum PSEL_A { # [ doc = "0: External source selected" ] PSEL_0 = 0 , # [ doc = "1: 12-bit reference DAC source selected" ] PSEL_1 = 1 , # [ doc = "2: Pair OA source selected" ] PSEL_2 = 2 } impl From < PSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : PSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `PSEL`" ] pub type PSEL_R = crate :: R < u8 , PSEL_A > ; impl PSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , PSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( PSEL_A :: PSEL_0 ) , 1 => Val ( PSEL_A :: PSEL_1 ) , 2 => Val ( PSEL_A :: PSEL_2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `PSEL_0`" ] # [ inline ( always ) ] pub fn is_psel_0 ( & self ) -> bool { * self == PSEL_A :: PSEL_0 } # [ doc = "Checks if the value of the field is `PSEL_1`" ] # [ inline ( always ) ] pub fn is_psel_1 ( & self ) -> bool { * self == PSEL_A :: PSEL_1 } # [ doc = "Checks if the value of the field is `PSEL_2`" ] # [ inline ( always ) ] pub fn is_psel_2 ( & self ) -> bool { * self == PSEL_A :: PSEL_2 } }
# [ doc = "Write proxy for field `PSEL`" ] pub struct PSEL_W < 'a > { w : & 'a mut W , } impl < 'a > PSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "External source selected" ] # [ inline ( always ) ] pub fn psel_0 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_0 ) } # [ doc = "12-bit reference DAC source selected" ] # [ inline ( always ) ] pub fn psel_1 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_1 ) } # [ doc = "Pair OA source selected" ] # [ inline ( always ) ] pub fn psel_2 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_2 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "SAC Positive input MUX control.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PMUXEN_A { # [ doc = "0: All positive input sources are disconnected to OA positive port" ] PMUXEN_0 = 0 , # [ doc = "1: All positive input sources are connected to OA positive port" ] PMUXEN_1 = 1 } impl From < PMUXEN_A > for bool { # [ inline ( always ) ] fn from ( variant : PMUXEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `PMUXEN`" ] pub type PMUXEN_R = crate :: R < bool , PMUXEN_A > ; impl PMUXEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PMUXEN_A { match self . bits { false => PMUXEN_A :: PMUXEN_0 , true => PMUXEN_A :: PMUXEN_1 } } # [ doc = "Checks if the value of the field is `PMUXEN_0`" ] # [ inline ( always ) ] pub fn is_pmuxen_0 ( & self ) -> bool { * self == PMUXEN_A :: PMUXEN_0 } # [ doc = "Checks if the value of the field is `PMUXEN_1`" ] # [ inline ( always ) ] pub fn is_pmuxen_1 ( & self ) -> bool { * self == PMUXEN_A :: PMUXEN_1 } }
# [ doc = "Write proxy for field `PMUXEN`" ] pub struct PMUXEN_W < 'a > { w : & 'a mut W , } impl < 'a > PMUXEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PMUXEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "All positive input sources are disconnected to OA positive port" ] # [ inline ( always ) ] pub fn pmuxen_0 ( self ) -> & 'a mut W { self . variant ( PMUXEN_A :: PMUXEN_0 ) } # [ doc = "All positive input sources are connected to OA positive port" ] # [ inline ( always ) ] pub fn pmuxen_1 ( self ) -> & 'a mut W { self . variant ( PMUXEN_A :: PMUXEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "SAC OA Negative input source selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum NSEL_A { # [ doc = "0: External source selected" ] NSEL_0 = 0 , # [ doc = "1: PGA source selected" ] NSEL_1 = 1 , # [ doc = "2: Device Specific" ] NSEL_2 = 2 } impl From < NSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : NSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `NSEL`" ] pub type NSEL_R = crate :: R < u8 , NSEL_A > ; impl NSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , NSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( NSEL_A :: NSEL_0 ) , 1 => Val ( NSEL_A :: NSEL_1 ) , 2 => Val ( NSEL_A :: NSEL_2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NSEL_0`" ] # [ inline ( always ) ] pub fn is_nsel_0 ( & self ) -> bool { * self == NSEL_A :: NSEL_0 } # [ doc = "Checks if the value of the field is `NSEL_1`" ] # [ inline ( always ) ] pub fn is_nsel_1 ( & self ) -> bool { * self == NSEL_A :: NSEL_1 } # [ doc = "Checks if the value of the field is `NSEL_2`" ] # [ inline ( always ) ] pub fn is_nsel_2 ( & self ) -> bool { * self == NSEL_A :: NSEL_2 } }
# [ doc = "Write proxy for field `NSEL`" ] pub struct NSEL_W < 'a > { w : & 'a mut W , } impl < 'a > NSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "External source selected" ] # [ inline ( always ) ] pub fn nsel_0 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_0 ) } # [ doc = "PGA source selected" ] # [ inline ( always ) ] pub fn nsel_1 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_1 ) } # [ doc = "Device Specific" ] # [ inline ( always ) ] pub fn nsel_2 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_2 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "SAC Negative input MUX controL\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum NMUXEN_A { # [ doc = "0: All negative input sources are disconnected to OA negative port" ] NMUXEN_0 = 0 , # [ doc = "1: All negative input sources are connected to OA negative port" ] NMUXEN_1 = 1 } impl From < NMUXEN_A > for bool { # [ inline ( always ) ] fn from ( variant : NMUXEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `NMUXEN`" ] pub type NMUXEN_R = crate :: R < bool , NMUXEN_A > ; impl NMUXEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> NMUXEN_A { match self . bits { false => NMUXEN_A :: NMUXEN_0 , true => NMUXEN_A :: NMUXEN_1 } } # [ doc = "Checks if the value of the field is `NMUXEN_0`" ] # [ inline ( always ) ] pub fn is_nmuxen_0 ( & self ) -> bool { * self == NMUXEN_A :: NMUXEN_0 } # [ doc = "Checks if the value of the field is `NMUXEN_1`" ] # [ inline ( always ) ] pub fn is_nmuxen_1 ( & self ) -> bool { * self == NMUXEN_A :: NMUXEN_1 } }
# [ doc = "Write proxy for field `NMUXEN`" ] pub struct NMUXEN_W < 'a > { w : & 'a mut W , } impl < 'a > NMUXEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NMUXEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "All negative input sources are disconnected to OA negative port" ] # [ inline ( always ) ] pub fn nmuxen_0 ( self ) -> & 'a mut W { self . variant ( NMUXEN_A :: NMUXEN_0 ) } # [ doc = "All negative input sources are connected to OA negative port" ] # [ inline ( always ) ] pub fn nmuxen_1 ( self ) -> & 'a mut W { self . variant ( NMUXEN_A :: NMUXEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "SAC OA Enable selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OAEN_A { # [ doc = "0: SAC OA is disabled, then the SAC OA output high impedance" ] OAEN_0 = 0 , # [ doc = "1: SAC OA is enabled, normal mode" ] OAEN_1 = 1 } impl From < OAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : OAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OAEN`" ] pub type OAEN_R = crate :: R < bool , OAEN_A > ; impl OAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OAEN_A { match self . bits { false => OAEN_A :: OAEN_0 , true => OAEN_A :: OAEN_1 } } # [ doc = "Checks if the value of the field is `OAEN_0`" ] # [ inline ( always ) ] pub fn is_oaen_0 ( & self ) -> bool { * self == OAEN_A :: OAEN_0 } # [ doc = "Checks if the value of the field is `OAEN_1`" ] # [ inline ( always ) ] pub fn is_oaen_1 ( & self ) -> bool { * self == OAEN_A :: OAEN_1 } }
# [ doc = "Write proxy for field `OAEN`" ] pub struct OAEN_W < 'a > { w : & 'a mut W , } impl < 'a > OAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SAC OA is disabled, then the SAC OA output high impedance" ] # [ inline ( always ) ] pub fn oaen_0 ( self ) -> & 'a mut W { self . variant ( OAEN_A :: OAEN_0 ) } # [ doc = "SAC OA is enabled, normal mode" ] # [ inline ( always ) ] pub fn oaen_1 ( self ) -> & 'a mut W { self . variant ( OAEN_A :: OAEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "SAC OA power mode selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OAPM_A { # [ doc = "0: High speed and high power" ] OAPM_0 = 0 , # [ doc = "1: Llow speed and low power" ] OAPM_1 = 1 } impl From < OAPM_A > for bool { # [ inline ( always ) ] fn from ( variant : OAPM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OAPM`" ] pub type OAPM_R = crate :: R < bool , OAPM_A > ; impl OAPM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OAPM_A { match self . bits { false => OAPM_A :: OAPM_0 , true => OAPM_A :: OAPM_1 } } # [ doc = "Checks if the value of the field is `OAPM_0`" ] # [ inline ( always ) ] pub fn is_oapm_0 ( & self ) -> bool { * self == OAPM_A :: OAPM_0 } # [ doc = "Checks if the value of the field is `OAPM_1`" ] # [ inline ( always ) ] pub fn is_oapm_1 ( & self ) -> bool { * self == OAPM_A :: OAPM_1 } }
# [ doc = "Write proxy for field `OAPM`" ] pub struct OAPM_W < 'a > { w : & 'a mut W , } impl < 'a > OAPM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OAPM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "High speed and high power" ] # [ inline ( always ) ] pub fn oapm_0 ( self ) -> & 'a mut W { self . variant ( OAPM_A :: OAPM_0 ) } # [ doc = "Llow speed and low power" ] # [ inline ( always ) ] pub fn oapm_1 ( self ) -> & 'a mut W { self . variant ( OAPM_A :: OAPM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "SAC Enable selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SACEN_A { # [ doc = "0: SAC all modules are disabled, then the SAC output high impedance" ] SACEN_0 = 0 , # [ doc = "1: SAC all modules are enabled, normal mode" ] SACEN_1 = 1 } impl From < SACEN_A > for bool { # [ inline ( always ) ] fn from ( variant : SACEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SACEN`" ] pub type SACEN_R = crate :: R < bool , SACEN_A > ; impl SACEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SACEN_A { match self . bits { false => SACEN_A :: SACEN_0 , true => SACEN_A :: SACEN_1 } } # [ doc = "Checks if the value of the field is `SACEN_0`" ] # [ inline ( always ) ] pub fn is_sacen_0 ( & self ) -> bool { * self == SACEN_A :: SACEN_0 } # [ doc = "Checks if the value of the field is `SACEN_1`" ] # [ inline ( always ) ] pub fn is_sacen_1 ( & self ) -> bool { * self == SACEN_A :: SACEN_1 } }
# [ doc = "Write proxy for field `SACEN`" ] pub struct SACEN_W < 'a > { w : & 'a mut W , } impl < 'a > SACEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SACEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SAC all modules are disabled, then the SAC output high impedance" ] # [ inline ( always ) ] pub fn sacen_0 ( self ) -> & 'a mut W { self . variant ( SACEN_A :: SACEN_0 ) } # [ doc = "SAC all modules are enabled, normal mode" ] # [ inline ( always ) ] pub fn sacen_1 ( self ) -> & 'a mut W { self . variant ( SACEN_A :: SACEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - SAC OA Positive input source selection" ] # [ inline ( always ) ] pub fn psel ( & self ) -> PSEL_R { PSEL_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bit 3 - SAC Positive input MUX control." ] # [ inline ( always ) ] pub fn pmuxen ( & self ) -> PMUXEN_R { PMUXEN_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - SAC OA Negative input source selection" ] # [ inline ( always ) ] pub fn nsel ( & self ) -> NSEL_R { NSEL_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 7 - SAC Negative input MUX controL" ] # [ inline ( always ) ] pub fn nmuxen ( & self ) -> NMUXEN_R { NMUXEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - SAC OA Enable selection" ] # [ inline ( always ) ] pub fn oaen ( & self ) -> OAEN_R { OAEN_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - SAC OA power mode selection" ] # [ inline ( always ) ] pub fn oapm ( & self ) -> OAPM_R { OAPM_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - SAC Enable selection" ] # [ inline ( always ) ] pub fn sacen ( & self ) -> SACEN_R { SACEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:1 - SAC OA Positive input source selection" ] # [ inline ( always ) ] pub fn psel ( & mut self ) -> PSEL_W { PSEL_W { w : self } }
# [ doc = "Bit 3 - SAC Positive input MUX control." ] # [ inline ( always ) ] pub fn pmuxen ( & mut self ) -> PMUXEN_W { PMUXEN_W { w : self } }
# [ doc = "Bits 4:5 - SAC OA Negative input source selection" ] # [ inline ( always ) ] pub fn nsel ( & mut self ) -> NSEL_W { NSEL_W { w : self } }
# [ doc = "Bit 7 - SAC Negative input MUX controL" ] # [ inline ( always ) ] pub fn nmuxen ( & mut self ) -> NMUXEN_W { NMUXEN_W { w : self } }
# [ doc = "Bit 8 - SAC OA Enable selection" ] # [ inline ( always ) ] pub fn oaen ( & mut self ) -> OAEN_W { OAEN_W { w : self } }
# [ doc = "Bit 9 - SAC OA power mode selection" ] # [ inline ( always ) ] pub fn oapm ( & mut self ) -> OAPM_W { OAPM_W { w : self } }
# [ doc = "Bit 10 - SAC Enable selection" ] # [ inline ( always ) ] pub fn sacen ( & mut self ) -> SACEN_W { SACEN_W { w : self } }
}
}
# [ doc = "SAC PGA Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac0pga](sac0pga) module" ] pub type SAC0PGA = crate :: Reg < u16 , _SAC0PGA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC0PGA ;
# [ doc = "`read()` method returns [sac0pga::R](sac0pga::R) reader structure" ] impl crate :: Readable for SAC0PGA { }
# [ doc = "`write(|w| ..)` method takes [sac0pga::W](sac0pga::W) writer structure" ] impl crate :: Writable for SAC0PGA { }
# [ doc = "SAC PGA Control Register" ] pub mod sac0pga {
# [ doc = "Reader of register SAC0PGA" ] pub type R = crate :: R < u16 , super :: SAC0PGA > ;
# [ doc = "Writer for register SAC0PGA" ] pub type W = crate :: W < u16 , super :: SAC0PGA > ;
# [ doc = "Register SAC0PGA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC0PGA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC PGA Mode Selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum MSEL_A { # [ doc = "0: Inverting PGA mode (external pad IN- is selected)" ] MSEL_0 = 0 , # [ doc = "1: Buffer mode (floating is selected )" ] MSEL_1 = 1 , # [ doc = "2: Non-inverting mode" ] MSEL_2 = 2 , # [ doc = "3: Cascade OA Inverting mode" ] MSEL_3 = 3 } impl From < MSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : MSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `MSEL`" ] pub type MSEL_R = crate :: R < u8 , MSEL_A > ; impl MSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MSEL_A { match self . bits { 0 => MSEL_A :: MSEL_0 , 1 => MSEL_A :: MSEL_1 , 2 => MSEL_A :: MSEL_2 , 3 => MSEL_A :: MSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `MSEL_0`" ] # [ inline ( always ) ] pub fn is_msel_0 ( & self ) -> bool { * self == MSEL_A :: MSEL_0 } # [ doc = "Checks if the value of the field is `MSEL_1`" ] # [ inline ( always ) ] pub fn is_msel_1 ( & self ) -> bool { * self == MSEL_A :: MSEL_1 } # [ doc = "Checks if the value of the field is `MSEL_2`" ] # [ inline ( always ) ] pub fn is_msel_2 ( & self ) -> bool { * self == MSEL_A :: MSEL_2 } # [ doc = "Checks if the value of the field is `MSEL_3`" ] # [ inline ( always ) ] pub fn is_msel_3 ( & self ) -> bool { * self == MSEL_A :: MSEL_3 } }
# [ doc = "Write proxy for field `MSEL`" ] pub struct MSEL_W < 'a > { w : & 'a mut W , } impl < 'a > MSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Inverting PGA mode (external pad IN- is selected)" ] # [ inline ( always ) ] pub fn msel_0 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_0 ) } # [ doc = "Buffer mode (floating is selected )" ] # [ inline ( always ) ] pub fn msel_1 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_1 ) } # [ doc = "Non-inverting mode" ] # [ inline ( always ) ] pub fn msel_2 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_2 ) } # [ doc = "Cascade OA Inverting mode" ] # [ inline ( always ) ] pub fn msel_3 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `GAIN`" ] pub type GAIN_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `GAIN`" ] pub struct GAIN_W < 'a > { w : & 'a mut W , } impl < 'a > GAIN_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 4 ) ) | ( ( ( value as u16 ) & 0x07 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - SAC PGA Mode Selection" ] # [ inline ( always ) ] pub fn msel ( & self ) -> MSEL_R { MSEL_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 4:6 - SAC PGA Gain configuration" ] # [ inline ( always ) ] pub fn gain ( & self ) -> GAIN_R { GAIN_R :: new ( ( ( self . bits >> 4 ) & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - SAC PGA Mode Selection" ] # [ inline ( always ) ] pub fn msel ( & mut self ) -> MSEL_W { MSEL_W { w : self } }
# [ doc = "Bits 4:6 - SAC PGA Gain configuration" ] # [ inline ( always ) ] pub fn gain ( & mut self ) -> GAIN_W { GAIN_W { w : self } }
}
}
# [ doc = "SAC DAC Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac0dac](sac0dac) module" ] pub type SAC0DAC = crate :: Reg < u16 , _SAC0DAC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC0DAC ;
# [ doc = "`read()` method returns [sac0dac::R](sac0dac::R) reader structure" ] impl crate :: Readable for SAC0DAC { }
# [ doc = "`write(|w| ..)` method takes [sac0dac::W](sac0dac::W) writer structure" ] impl crate :: Writable for SAC0DAC { }
# [ doc = "SAC DAC Control Register" ] pub mod sac0dac {
# [ doc = "Reader of register SAC0DAC" ] pub type R = crate :: R < u16 , super :: SAC0DAC > ;
# [ doc = "Writer for register SAC0DAC" ] pub type W = crate :: W < u16 , super :: SAC0DAC > ;
# [ doc = "Register SAC0DAC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC0DAC { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC DAC enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACEN_A { # [ doc = "0: Disabled" ] DACEN_0 = 0 , # [ doc = "1: Enabled" ] DACEN_1 = 1 } impl From < DACEN_A > for bool { # [ inline ( always ) ] fn from ( variant : DACEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACEN`" ] pub type DACEN_R = crate :: R < bool , DACEN_A > ; impl DACEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACEN_A { match self . bits { false => DACEN_A :: DACEN_0 , true => DACEN_A :: DACEN_1 } } # [ doc = "Checks if the value of the field is `DACEN_0`" ] # [ inline ( always ) ] pub fn is_dacen_0 ( & self ) -> bool { * self == DACEN_A :: DACEN_0 } # [ doc = "Checks if the value of the field is `DACEN_1`" ] # [ inline ( always ) ] pub fn is_dacen_1 ( & self ) -> bool { * self == DACEN_A :: DACEN_1 } }
# [ doc = "Write proxy for field `DACEN`" ] pub struct DACEN_W < 'a > { w : & 'a mut W , } impl < 'a > DACEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn dacen_0 ( self ) -> & 'a mut W { self . variant ( DACEN_A :: DACEN_0 ) } # [ doc = "Enabled" ] # [ inline ( always ) ] pub fn dacen_1 ( self ) -> & 'a mut W { self . variant ( DACEN_A :: DACEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "SAC DAC interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACIE_A { # [ doc = "0: Disabled" ] DACIE_0 = 0 , # [ doc = "1: Enabled" ] DACIE_1 = 1 } impl From < DACIE_A > for bool { # [ inline ( always ) ] fn from ( variant : DACIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACIE`" ] pub type DACIE_R = crate :: R < bool , DACIE_A > ; impl DACIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACIE_A { match self . bits { false => DACIE_A :: DACIE_0 , true => DACIE_A :: DACIE_1 } } # [ doc = "Checks if the value of the field is `DACIE_0`" ] # [ inline ( always ) ] pub fn is_dacie_0 ( & self ) -> bool { * self == DACIE_A :: DACIE_0 } # [ doc = "Checks if the value of the field is `DACIE_1`" ] # [ inline ( always ) ] pub fn is_dacie_1 ( & self ) -> bool { * self == DACIE_A :: DACIE_1 } }
# [ doc = "Write proxy for field `DACIE`" ] pub struct DACIE_W < 'a > { w : & 'a mut W , } impl < 'a > DACIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn dacie_0 ( self ) -> & 'a mut W { self . variant ( DACIE_A :: DACIE_0 ) } # [ doc = "Enabled" ] # [ inline ( always ) ] pub fn dacie_1 ( self ) -> & 'a mut W { self . variant ( DACIE_A :: DACIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "SAC DAC DMA request enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACDMAE_A { # [ doc = "0: DMA request disabled" ] DACDMAE_0 = 0 , # [ doc = "1: DMA request enabled" ] DACDMAE_1 = 1 } impl From < DACDMAE_A > for bool { # [ inline ( always ) ] fn from ( variant : DACDMAE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACDMAE`" ] pub type DACDMAE_R = crate :: R < bool , DACDMAE_A > ; impl DACDMAE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACDMAE_A { match self . bits { false => DACDMAE_A :: DACDMAE_0 , true => DACDMAE_A :: DACDMAE_1 } } # [ doc = "Checks if the value of the field is `DACDMAE_0`" ] # [ inline ( always ) ] pub fn is_dacdmae_0 ( & self ) -> bool { * self == DACDMAE_A :: DACDMAE_0 } # [ doc = "Checks if the value of the field is `DACDMAE_1`" ] # [ inline ( always ) ] pub fn is_dacdmae_1 ( & self ) -> bool { * self == DACDMAE_A :: DACDMAE_1 } }
# [ doc = "Write proxy for field `DACDMAE`" ] pub struct DACDMAE_W < 'a > { w : & 'a mut W , } impl < 'a > DACDMAE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACDMAE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "DMA request disabled" ] # [ inline ( always ) ] pub fn dacdmae_0 ( self ) -> & 'a mut W { self . variant ( DACDMAE_A :: DACDMAE_0 ) } # [ doc = "DMA request enabled" ] # [ inline ( always ) ] pub fn dacdmae_1 ( self ) -> & 'a mut W { self . variant ( DACDMAE_A :: DACDMAE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "SAC DAC load select. Selects the load trigger for the DAC latch.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum DACLSEL_A { # [ doc = "0: DAC latch loads when DACDAT written" ] DACLSEL_0 = 0 , # [ doc = "2: Device specific 0. DAC always loads data from DACDAT at the positive edge of this signal" ] DACLSEL_2 = 2 , # [ doc = "3: Device specific 1. DAC always loads data from DACDAT at the positive edge of this signal" ] DACLSEL_3 = 3 } impl From < DACLSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : DACLSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `DACLSEL`" ] pub type DACLSEL_R = crate :: R < u8 , DACLSEL_A > ; impl DACLSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , DACLSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( DACLSEL_A :: DACLSEL_0 ) , 2 => Val ( DACLSEL_A :: DACLSEL_2 ) , 3 => Val ( DACLSEL_A :: DACLSEL_3 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DACLSEL_0`" ] # [ inline ( always ) ] pub fn is_daclsel_0 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_0 } # [ doc = "Checks if the value of the field is `DACLSEL_2`" ] # [ inline ( always ) ] pub fn is_daclsel_2 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_2 } # [ doc = "Checks if the value of the field is `DACLSEL_3`" ] # [ inline ( always ) ] pub fn is_daclsel_3 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_3 } }
# [ doc = "Write proxy for field `DACLSEL`" ] pub struct DACLSEL_W < 'a > { w : & 'a mut W , } impl < 'a > DACLSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACLSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "DAC latch loads when DACDAT written" ] # [ inline ( always ) ] pub fn daclsel_0 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_0 ) } # [ doc = "Device specific 0. DAC always loads data from DACDAT at the positive edge of this signal" ] # [ inline ( always ) ] pub fn daclsel_2 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_2 ) } # [ doc = "Device specific 1. DAC always loads data from DACDAT at the positive edge of this signal" ] # [ inline ( always ) ] pub fn daclsel_3 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "SAC DAC select reference voltage\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACSREF_A { # [ doc = "0: AVCC" ] DACSREF_0 = 0 , # [ doc = "1: Alternative reference" ] DACSREF_1 = 1 } impl From < DACSREF_A > for bool { # [ inline ( always ) ] fn from ( variant : DACSREF_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACSREF`" ] pub type DACSREF_R = crate :: R < bool , DACSREF_A > ; impl DACSREF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACSREF_A { match self . bits { false => DACSREF_A :: DACSREF_0 , true => DACSREF_A :: DACSREF_1 } } # [ doc = "Checks if the value of the field is `DACSREF_0`" ] # [ inline ( always ) ] pub fn is_dacsref_0 ( & self ) -> bool { * self == DACSREF_A :: DACSREF_0 } # [ doc = "Checks if the value of the field is `DACSREF_1`" ] # [ inline ( always ) ] pub fn is_dacsref_1 ( & self ) -> bool { * self == DACSREF_A :: DACSREF_1 } }
# [ doc = "Write proxy for field `DACSREF`" ] pub struct DACSREF_W < 'a > { w : & 'a mut W , } impl < 'a > DACSREF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACSREF_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "AVCC" ] # [ inline ( always ) ] pub fn dacsref_0 ( self ) -> & 'a mut W { self . variant ( DACSREF_A :: DACSREF_0 ) } # [ doc = "Alternative reference" ] # [ inline ( always ) ] pub fn dacsref_1 ( self ) -> & 'a mut W { self . variant ( DACSREF_A :: DACSREF_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - SAC DAC enable" ] # [ inline ( always ) ] pub fn dacen ( & self ) -> DACEN_R { DACEN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - SAC DAC interrupt enable" ] # [ inline ( always ) ] pub fn dacie ( & self ) -> DACIE_R { DACIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - SAC DAC DMA request enable" ] # [ inline ( always ) ] pub fn dacdmae ( & self ) -> DACDMAE_R { DACDMAE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:9 - SAC DAC load select. Selects the load trigger for the DAC latch." ] # [ inline ( always ) ] pub fn daclsel ( & self ) -> DACLSEL_R { DACLSEL_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 12 - SAC DAC select reference voltage" ] # [ inline ( always ) ] pub fn dacsref ( & self ) -> DACSREF_R { DACSREF_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - SAC DAC enable" ] # [ inline ( always ) ] pub fn dacen ( & mut self ) -> DACEN_W { DACEN_W { w : self } }
# [ doc = "Bit 1 - SAC DAC interrupt enable" ] # [ inline ( always ) ] pub fn dacie ( & mut self ) -> DACIE_W { DACIE_W { w : self } }
# [ doc = "Bit 2 - SAC DAC DMA request enable" ] # [ inline ( always ) ] pub fn dacdmae ( & mut self ) -> DACDMAE_W { DACDMAE_W { w : self } }
# [ doc = "Bits 8:9 - SAC DAC load select. Selects the load trigger for the DAC latch." ] # [ inline ( always ) ] pub fn daclsel ( & mut self ) -> DACLSEL_W { DACLSEL_W { w : self } }
# [ doc = "Bit 12 - SAC DAC select reference voltage" ] # [ inline ( always ) ] pub fn dacsref ( & mut self ) -> DACSREF_W { DACSREF_W { w : self } }
}
}
# [ doc = "SAC DAC Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac0dat](sac0dat) module" ] pub type SAC0DAT = crate :: Reg < u16 , _SAC0DAT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC0DAT ;
# [ doc = "`read()` method returns [sac0dat::R](sac0dat::R) reader structure" ] impl crate :: Readable for SAC0DAT { }
# [ doc = "`write(|w| ..)` method takes [sac0dat::W](sac0dat::W) writer structure" ] impl crate :: Writable for SAC0DAT { }
# [ doc = "SAC DAC Data Register" ] pub mod sac0dat {
# [ doc = "Reader of register SAC0DAT" ] pub type R = crate :: R < u16 , super :: SAC0DAT > ;
# [ doc = "Writer for register SAC0DAT" ] pub type W = crate :: W < u16 , super :: SAC0DAT > ;
# [ doc = "Register SAC0DAT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC0DAT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DACData`" ] pub type DACDATA_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `DACData`" ] pub struct DACDATA_W < 'a > { w : & 'a mut W , } impl < 'a > DACDATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0fff ) | ( ( value as u16 ) & 0x0fff ) ; self . w } }
impl R {
# [ doc = "Bits 0:11 - SAC DAC data in unsigned format." ] # [ inline ( always ) ] pub fn dacdata ( & self ) -> DACDATA_R { DACDATA_R :: new ( ( self . bits & 0x0fff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:11 - SAC DAC data in unsigned format." ] # [ inline ( always ) ] pub fn dacdata ( & mut self ) -> DACDATA_W { DACDATA_W { w : self } }
}
}
# [ doc = "SAC DAC Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac0dacsts](sac0dacsts) module" ] pub type SAC0DACSTS = crate :: Reg < u16 , _SAC0DACSTS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC0DACSTS ;
# [ doc = "`read()` method returns [sac0dacsts::R](sac0dacsts::R) reader structure" ] impl crate :: Readable for SAC0DACSTS { }
# [ doc = "`write(|w| ..)` method takes [sac0dacsts::W](sac0dacsts::W) writer structure" ] impl crate :: Writable for SAC0DACSTS { }
# [ doc = "SAC DAC Status Register" ] pub mod sac0dacsts {
# [ doc = "Reader of register SAC0DACSTS" ] pub type R = crate :: R < u16 , super :: SAC0DACSTS > ;
# [ doc = "Writer for register SAC0DACSTS" ] pub type W = crate :: W < u16 , super :: SAC0DACSTS > ;
# [ doc = "Register SAC0DACSTS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC0DACSTS { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DACIFG`" ] pub type DACIFG_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DACIFG`" ] pub struct DACIFG_W < 'a > { w : & 'a mut W , } impl < 'a > DACIFG_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - SAC DAC data update flag" ] # [ inline ( always ) ] pub fn dacifg ( & self ) -> DACIFG_R { DACIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - SAC DAC data update flag" ] # [ inline ( always ) ] pub fn dacifg ( & mut self ) -> DACIFG_W { DACIFG_W { w : self } }
}
}
# [ doc = "SAC Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac0iv](sac0iv) module" ] pub type SAC0IV = crate :: Reg < u16 , _SAC0IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC0IV ;
# [ doc = "`read()` method returns [sac0iv::R](sac0iv::R) reader structure" ] impl crate :: Readable for SAC0IV { }
# [ doc = "SAC Interrupt Vector Register" ] pub mod sac0iv {
# [ doc = "Reader of register SAC0IV" ] pub type R = crate :: R < u16 , super :: SAC0IV > ;
# [ doc = "SAC Interrupt Vector Register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum SACIV0_A { # [ doc = "0: No interrupt pending" ] SACIV_0 = 0 , # [ doc = "2: S&H completed interrupt flag (Highest priority)" ] SACIV_2 = 2 , # [ doc = "4: DAC channel update interrupt flag" ] SACIV_4 = 4 } impl From < SACIV0_A > for u16 { # [ inline ( always ) ] fn from ( variant : SACIV0_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `SACIV0`" ] pub type SACIV0_R = crate :: R < u16 , SACIV0_A > ; impl SACIV0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , SACIV0_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SACIV0_A :: SACIV_0 ) , 2 => Val ( SACIV0_A :: SACIV_2 ) , 4 => Val ( SACIV0_A :: SACIV_4 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `SACIV_0`" ] # [ inline ( always ) ] pub fn is_saciv_0 ( & self ) -> bool { * self == SACIV0_A :: SACIV_0 } # [ doc = "Checks if the value of the field is `SACIV_2`" ] # [ inline ( always ) ] pub fn is_saciv_2 ( & self ) -> bool { * self == SACIV0_A :: SACIV_2 } # [ doc = "Checks if the value of the field is `SACIV_4`" ] # [ inline ( always ) ] pub fn is_saciv_4 ( & self ) -> bool { * self == SACIV0_A :: SACIV_4 } }
impl R {
# [ doc = "Bits 0:15 - SAC Interrupt Vector Register" ] # [ inline ( always ) ] pub fn saciv0 ( & self ) -> SACIV0_R { SACIV0_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "SAC1" ] pub struct SAC1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SAC1 { } impl SAC1 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const sac1 :: RegisterBlock { 0x0c90 as * const _ } } impl Deref for SAC1 { type Target = sac1 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * SAC1 :: ptr ( ) } } }
# [ doc = "SAC1" ] pub mod sac1 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - SAC OA Control Register" ] pub sac1oa : SAC1OA , # [ doc = "0x02 - SAC PGA Control Register" ] pub sac1pga : SAC1PGA , # [ doc = "0x04 - SAC DAC Control Register" ] pub sac1dac : SAC1DAC , # [ doc = "0x06 - SAC DAC Data Register" ] pub sac1dat : SAC1DAT , # [ doc = "0x08 - SAC DAC Status Register" ] pub sac1dacsts : SAC1DACSTS , # [ doc = "0x0a - SAC Interrupt Vector Register" ] pub sac1iv : SAC1IV , }
# [ doc = "SAC OA Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac1oa](sac1oa) module" ] pub type SAC1OA = crate :: Reg < u16 , _SAC1OA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC1OA ;
# [ doc = "`read()` method returns [sac1oa::R](sac1oa::R) reader structure" ] impl crate :: Readable for SAC1OA { }
# [ doc = "`write(|w| ..)` method takes [sac1oa::W](sac1oa::W) writer structure" ] impl crate :: Writable for SAC1OA { }
# [ doc = "SAC OA Control Register" ] pub mod sac1oa {
# [ doc = "Reader of register SAC1OA" ] pub type R = crate :: R < u16 , super :: SAC1OA > ;
# [ doc = "Writer for register SAC1OA" ] pub type W = crate :: W < u16 , super :: SAC1OA > ;
# [ doc = "Register SAC1OA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC1OA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC OA Positive input source selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum PSEL_A { # [ doc = "0: External source selected" ] PSEL_0 = 0 , # [ doc = "1: 12-bit reference DAC source selected" ] PSEL_1 = 1 , # [ doc = "2: Pair OA source selected" ] PSEL_2 = 2 } impl From < PSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : PSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `PSEL`" ] pub type PSEL_R = crate :: R < u8 , PSEL_A > ; impl PSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , PSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( PSEL_A :: PSEL_0 ) , 1 => Val ( PSEL_A :: PSEL_1 ) , 2 => Val ( PSEL_A :: PSEL_2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `PSEL_0`" ] # [ inline ( always ) ] pub fn is_psel_0 ( & self ) -> bool { * self == PSEL_A :: PSEL_0 } # [ doc = "Checks if the value of the field is `PSEL_1`" ] # [ inline ( always ) ] pub fn is_psel_1 ( & self ) -> bool { * self == PSEL_A :: PSEL_1 } # [ doc = "Checks if the value of the field is `PSEL_2`" ] # [ inline ( always ) ] pub fn is_psel_2 ( & self ) -> bool { * self == PSEL_A :: PSEL_2 } }
# [ doc = "Write proxy for field `PSEL`" ] pub struct PSEL_W < 'a > { w : & 'a mut W , } impl < 'a > PSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "External source selected" ] # [ inline ( always ) ] pub fn psel_0 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_0 ) } # [ doc = "12-bit reference DAC source selected" ] # [ inline ( always ) ] pub fn psel_1 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_1 ) } # [ doc = "Pair OA source selected" ] # [ inline ( always ) ] pub fn psel_2 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_2 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "SAC Positive input MUX control.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PMUXEN_A { # [ doc = "0: All positive input sources are disconnected to OA positive port" ] PMUXEN_0 = 0 , # [ doc = "1: All positive input sources are connected to OA positive port" ] PMUXEN_1 = 1 } impl From < PMUXEN_A > for bool { # [ inline ( always ) ] fn from ( variant : PMUXEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `PMUXEN`" ] pub type PMUXEN_R = crate :: R < bool , PMUXEN_A > ; impl PMUXEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PMUXEN_A { match self . bits { false => PMUXEN_A :: PMUXEN_0 , true => PMUXEN_A :: PMUXEN_1 } } # [ doc = "Checks if the value of the field is `PMUXEN_0`" ] # [ inline ( always ) ] pub fn is_pmuxen_0 ( & self ) -> bool { * self == PMUXEN_A :: PMUXEN_0 } # [ doc = "Checks if the value of the field is `PMUXEN_1`" ] # [ inline ( always ) ] pub fn is_pmuxen_1 ( & self ) -> bool { * self == PMUXEN_A :: PMUXEN_1 } }
# [ doc = "Write proxy for field `PMUXEN`" ] pub struct PMUXEN_W < 'a > { w : & 'a mut W , } impl < 'a > PMUXEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PMUXEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "All positive input sources are disconnected to OA positive port" ] # [ inline ( always ) ] pub fn pmuxen_0 ( self ) -> & 'a mut W { self . variant ( PMUXEN_A :: PMUXEN_0 ) } # [ doc = "All positive input sources are connected to OA positive port" ] # [ inline ( always ) ] pub fn pmuxen_1 ( self ) -> & 'a mut W { self . variant ( PMUXEN_A :: PMUXEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "SAC OA Negative input source selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum NSEL_A { # [ doc = "0: External source selected" ] NSEL_0 = 0 , # [ doc = "1: PGA source selected" ] NSEL_1 = 1 , # [ doc = "2: Device Specific" ] NSEL_2 = 2 } impl From < NSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : NSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `NSEL`" ] pub type NSEL_R = crate :: R < u8 , NSEL_A > ; impl NSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , NSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( NSEL_A :: NSEL_0 ) , 1 => Val ( NSEL_A :: NSEL_1 ) , 2 => Val ( NSEL_A :: NSEL_2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NSEL_0`" ] # [ inline ( always ) ] pub fn is_nsel_0 ( & self ) -> bool { * self == NSEL_A :: NSEL_0 } # [ doc = "Checks if the value of the field is `NSEL_1`" ] # [ inline ( always ) ] pub fn is_nsel_1 ( & self ) -> bool { * self == NSEL_A :: NSEL_1 } # [ doc = "Checks if the value of the field is `NSEL_2`" ] # [ inline ( always ) ] pub fn is_nsel_2 ( & self ) -> bool { * self == NSEL_A :: NSEL_2 } }
# [ doc = "Write proxy for field `NSEL`" ] pub struct NSEL_W < 'a > { w : & 'a mut W , } impl < 'a > NSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "External source selected" ] # [ inline ( always ) ] pub fn nsel_0 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_0 ) } # [ doc = "PGA source selected" ] # [ inline ( always ) ] pub fn nsel_1 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_1 ) } # [ doc = "Device Specific" ] # [ inline ( always ) ] pub fn nsel_2 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_2 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "SAC Negative input MUX controL\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum NMUXEN_A { # [ doc = "0: All negative input sources are disconnected to OA negative port" ] NMUXEN_0 = 0 , # [ doc = "1: All negative input sources are connected to OA negative port" ] NMUXEN_1 = 1 } impl From < NMUXEN_A > for bool { # [ inline ( always ) ] fn from ( variant : NMUXEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `NMUXEN`" ] pub type NMUXEN_R = crate :: R < bool , NMUXEN_A > ; impl NMUXEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> NMUXEN_A { match self . bits { false => NMUXEN_A :: NMUXEN_0 , true => NMUXEN_A :: NMUXEN_1 } } # [ doc = "Checks if the value of the field is `NMUXEN_0`" ] # [ inline ( always ) ] pub fn is_nmuxen_0 ( & self ) -> bool { * self == NMUXEN_A :: NMUXEN_0 } # [ doc = "Checks if the value of the field is `NMUXEN_1`" ] # [ inline ( always ) ] pub fn is_nmuxen_1 ( & self ) -> bool { * self == NMUXEN_A :: NMUXEN_1 } }
# [ doc = "Write proxy for field `NMUXEN`" ] pub struct NMUXEN_W < 'a > { w : & 'a mut W , } impl < 'a > NMUXEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NMUXEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "All negative input sources are disconnected to OA negative port" ] # [ inline ( always ) ] pub fn nmuxen_0 ( self ) -> & 'a mut W { self . variant ( NMUXEN_A :: NMUXEN_0 ) } # [ doc = "All negative input sources are connected to OA negative port" ] # [ inline ( always ) ] pub fn nmuxen_1 ( self ) -> & 'a mut W { self . variant ( NMUXEN_A :: NMUXEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "SAC OA Enable selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OAEN_A { # [ doc = "0: SAC OA is disabled, then the SAC OA output high impedance" ] OAEN_0 = 0 , # [ doc = "1: SAC OA is enabled, normal mode" ] OAEN_1 = 1 } impl From < OAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : OAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OAEN`" ] pub type OAEN_R = crate :: R < bool , OAEN_A > ; impl OAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OAEN_A { match self . bits { false => OAEN_A :: OAEN_0 , true => OAEN_A :: OAEN_1 } } # [ doc = "Checks if the value of the field is `OAEN_0`" ] # [ inline ( always ) ] pub fn is_oaen_0 ( & self ) -> bool { * self == OAEN_A :: OAEN_0 } # [ doc = "Checks if the value of the field is `OAEN_1`" ] # [ inline ( always ) ] pub fn is_oaen_1 ( & self ) -> bool { * self == OAEN_A :: OAEN_1 } }
# [ doc = "Write proxy for field `OAEN`" ] pub struct OAEN_W < 'a > { w : & 'a mut W , } impl < 'a > OAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SAC OA is disabled, then the SAC OA output high impedance" ] # [ inline ( always ) ] pub fn oaen_0 ( self ) -> & 'a mut W { self . variant ( OAEN_A :: OAEN_0 ) } # [ doc = "SAC OA is enabled, normal mode" ] # [ inline ( always ) ] pub fn oaen_1 ( self ) -> & 'a mut W { self . variant ( OAEN_A :: OAEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "SAC OA power mode selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OAPM_A { # [ doc = "0: High speed and high power" ] OAPM_0 = 0 , # [ doc = "1: Llow speed and low power" ] OAPM_1 = 1 } impl From < OAPM_A > for bool { # [ inline ( always ) ] fn from ( variant : OAPM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OAPM`" ] pub type OAPM_R = crate :: R < bool , OAPM_A > ; impl OAPM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OAPM_A { match self . bits { false => OAPM_A :: OAPM_0 , true => OAPM_A :: OAPM_1 } } # [ doc = "Checks if the value of the field is `OAPM_0`" ] # [ inline ( always ) ] pub fn is_oapm_0 ( & self ) -> bool { * self == OAPM_A :: OAPM_0 } # [ doc = "Checks if the value of the field is `OAPM_1`" ] # [ inline ( always ) ] pub fn is_oapm_1 ( & self ) -> bool { * self == OAPM_A :: OAPM_1 } }
# [ doc = "Write proxy for field `OAPM`" ] pub struct OAPM_W < 'a > { w : & 'a mut W , } impl < 'a > OAPM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OAPM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "High speed and high power" ] # [ inline ( always ) ] pub fn oapm_0 ( self ) -> & 'a mut W { self . variant ( OAPM_A :: OAPM_0 ) } # [ doc = "Llow speed and low power" ] # [ inline ( always ) ] pub fn oapm_1 ( self ) -> & 'a mut W { self . variant ( OAPM_A :: OAPM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "SAC Enable selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SACEN_A { # [ doc = "0: SAC all modules are disabled, then the SAC output high impedance" ] SACEN_0 = 0 , # [ doc = "1: SAC all modules are enabled, normal mode" ] SACEN_1 = 1 } impl From < SACEN_A > for bool { # [ inline ( always ) ] fn from ( variant : SACEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SACEN`" ] pub type SACEN_R = crate :: R < bool , SACEN_A > ; impl SACEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SACEN_A { match self . bits { false => SACEN_A :: SACEN_0 , true => SACEN_A :: SACEN_1 } } # [ doc = "Checks if the value of the field is `SACEN_0`" ] # [ inline ( always ) ] pub fn is_sacen_0 ( & self ) -> bool { * self == SACEN_A :: SACEN_0 } # [ doc = "Checks if the value of the field is `SACEN_1`" ] # [ inline ( always ) ] pub fn is_sacen_1 ( & self ) -> bool { * self == SACEN_A :: SACEN_1 } }
# [ doc = "Write proxy for field `SACEN`" ] pub struct SACEN_W < 'a > { w : & 'a mut W , } impl < 'a > SACEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SACEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SAC all modules are disabled, then the SAC output high impedance" ] # [ inline ( always ) ] pub fn sacen_0 ( self ) -> & 'a mut W { self . variant ( SACEN_A :: SACEN_0 ) } # [ doc = "SAC all modules are enabled, normal mode" ] # [ inline ( always ) ] pub fn sacen_1 ( self ) -> & 'a mut W { self . variant ( SACEN_A :: SACEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - SAC OA Positive input source selection" ] # [ inline ( always ) ] pub fn psel ( & self ) -> PSEL_R { PSEL_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bit 3 - SAC Positive input MUX control." ] # [ inline ( always ) ] pub fn pmuxen ( & self ) -> PMUXEN_R { PMUXEN_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - SAC OA Negative input source selection" ] # [ inline ( always ) ] pub fn nsel ( & self ) -> NSEL_R { NSEL_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 7 - SAC Negative input MUX controL" ] # [ inline ( always ) ] pub fn nmuxen ( & self ) -> NMUXEN_R { NMUXEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - SAC OA Enable selection" ] # [ inline ( always ) ] pub fn oaen ( & self ) -> OAEN_R { OAEN_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - SAC OA power mode selection" ] # [ inline ( always ) ] pub fn oapm ( & self ) -> OAPM_R { OAPM_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - SAC Enable selection" ] # [ inline ( always ) ] pub fn sacen ( & self ) -> SACEN_R { SACEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:1 - SAC OA Positive input source selection" ] # [ inline ( always ) ] pub fn psel ( & mut self ) -> PSEL_W { PSEL_W { w : self } }
# [ doc = "Bit 3 - SAC Positive input MUX control." ] # [ inline ( always ) ] pub fn pmuxen ( & mut self ) -> PMUXEN_W { PMUXEN_W { w : self } }
# [ doc = "Bits 4:5 - SAC OA Negative input source selection" ] # [ inline ( always ) ] pub fn nsel ( & mut self ) -> NSEL_W { NSEL_W { w : self } }
# [ doc = "Bit 7 - SAC Negative input MUX controL" ] # [ inline ( always ) ] pub fn nmuxen ( & mut self ) -> NMUXEN_W { NMUXEN_W { w : self } }
# [ doc = "Bit 8 - SAC OA Enable selection" ] # [ inline ( always ) ] pub fn oaen ( & mut self ) -> OAEN_W { OAEN_W { w : self } }
# [ doc = "Bit 9 - SAC OA power mode selection" ] # [ inline ( always ) ] pub fn oapm ( & mut self ) -> OAPM_W { OAPM_W { w : self } }
# [ doc = "Bit 10 - SAC Enable selection" ] # [ inline ( always ) ] pub fn sacen ( & mut self ) -> SACEN_W { SACEN_W { w : self } }
}
}
# [ doc = "SAC PGA Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac1pga](sac1pga) module" ] pub type SAC1PGA = crate :: Reg < u16 , _SAC1PGA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC1PGA ;
# [ doc = "`read()` method returns [sac1pga::R](sac1pga::R) reader structure" ] impl crate :: Readable for SAC1PGA { }
# [ doc = "`write(|w| ..)` method takes [sac1pga::W](sac1pga::W) writer structure" ] impl crate :: Writable for SAC1PGA { }
# [ doc = "SAC PGA Control Register" ] pub mod sac1pga {
# [ doc = "Reader of register SAC1PGA" ] pub type R = crate :: R < u16 , super :: SAC1PGA > ;
# [ doc = "Writer for register SAC1PGA" ] pub type W = crate :: W < u16 , super :: SAC1PGA > ;
# [ doc = "Register SAC1PGA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC1PGA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC PGA Mode Selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum MSEL_A { # [ doc = "0: Inverting PGA mode (external pad IN- is selected)" ] MSEL_0 = 0 , # [ doc = "1: Buffer mode (floating is selected )" ] MSEL_1 = 1 , # [ doc = "2: Non-inverting mode" ] MSEL_2 = 2 , # [ doc = "3: Cascade OA Inverting mode" ] MSEL_3 = 3 } impl From < MSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : MSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `MSEL`" ] pub type MSEL_R = crate :: R < u8 , MSEL_A > ; impl MSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MSEL_A { match self . bits { 0 => MSEL_A :: MSEL_0 , 1 => MSEL_A :: MSEL_1 , 2 => MSEL_A :: MSEL_2 , 3 => MSEL_A :: MSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `MSEL_0`" ] # [ inline ( always ) ] pub fn is_msel_0 ( & self ) -> bool { * self == MSEL_A :: MSEL_0 } # [ doc = "Checks if the value of the field is `MSEL_1`" ] # [ inline ( always ) ] pub fn is_msel_1 ( & self ) -> bool { * self == MSEL_A :: MSEL_1 } # [ doc = "Checks if the value of the field is `MSEL_2`" ] # [ inline ( always ) ] pub fn is_msel_2 ( & self ) -> bool { * self == MSEL_A :: MSEL_2 } # [ doc = "Checks if the value of the field is `MSEL_3`" ] # [ inline ( always ) ] pub fn is_msel_3 ( & self ) -> bool { * self == MSEL_A :: MSEL_3 } }
# [ doc = "Write proxy for field `MSEL`" ] pub struct MSEL_W < 'a > { w : & 'a mut W , } impl < 'a > MSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Inverting PGA mode (external pad IN- is selected)" ] # [ inline ( always ) ] pub fn msel_0 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_0 ) } # [ doc = "Buffer mode (floating is selected )" ] # [ inline ( always ) ] pub fn msel_1 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_1 ) } # [ doc = "Non-inverting mode" ] # [ inline ( always ) ] pub fn msel_2 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_2 ) } # [ doc = "Cascade OA Inverting mode" ] # [ inline ( always ) ] pub fn msel_3 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `GAIN`" ] pub type GAIN_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `GAIN`" ] pub struct GAIN_W < 'a > { w : & 'a mut W , } impl < 'a > GAIN_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 4 ) ) | ( ( ( value as u16 ) & 0x07 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - SAC PGA Mode Selection" ] # [ inline ( always ) ] pub fn msel ( & self ) -> MSEL_R { MSEL_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 4:6 - SAC PGA Gain configuration" ] # [ inline ( always ) ] pub fn gain ( & self ) -> GAIN_R { GAIN_R :: new ( ( ( self . bits >> 4 ) & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - SAC PGA Mode Selection" ] # [ inline ( always ) ] pub fn msel ( & mut self ) -> MSEL_W { MSEL_W { w : self } }
# [ doc = "Bits 4:6 - SAC PGA Gain configuration" ] # [ inline ( always ) ] pub fn gain ( & mut self ) -> GAIN_W { GAIN_W { w : self } }
}
}
# [ doc = "SAC DAC Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac1dac](sac1dac) module" ] pub type SAC1DAC = crate :: Reg < u16 , _SAC1DAC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC1DAC ;
# [ doc = "`read()` method returns [sac1dac::R](sac1dac::R) reader structure" ] impl crate :: Readable for SAC1DAC { }
# [ doc = "`write(|w| ..)` method takes [sac1dac::W](sac1dac::W) writer structure" ] impl crate :: Writable for SAC1DAC { }
# [ doc = "SAC DAC Control Register" ] pub mod sac1dac {
# [ doc = "Reader of register SAC1DAC" ] pub type R = crate :: R < u16 , super :: SAC1DAC > ;
# [ doc = "Writer for register SAC1DAC" ] pub type W = crate :: W < u16 , super :: SAC1DAC > ;
# [ doc = "Register SAC1DAC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC1DAC { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC DAC enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACEN_A { # [ doc = "0: Disabled" ] DACEN_0 = 0 , # [ doc = "1: Enabled" ] DACEN_1 = 1 } impl From < DACEN_A > for bool { # [ inline ( always ) ] fn from ( variant : DACEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACEN`" ] pub type DACEN_R = crate :: R < bool , DACEN_A > ; impl DACEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACEN_A { match self . bits { false => DACEN_A :: DACEN_0 , true => DACEN_A :: DACEN_1 } } # [ doc = "Checks if the value of the field is `DACEN_0`" ] # [ inline ( always ) ] pub fn is_dacen_0 ( & self ) -> bool { * self == DACEN_A :: DACEN_0 } # [ doc = "Checks if the value of the field is `DACEN_1`" ] # [ inline ( always ) ] pub fn is_dacen_1 ( & self ) -> bool { * self == DACEN_A :: DACEN_1 } }
# [ doc = "Write proxy for field `DACEN`" ] pub struct DACEN_W < 'a > { w : & 'a mut W , } impl < 'a > DACEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn dacen_0 ( self ) -> & 'a mut W { self . variant ( DACEN_A :: DACEN_0 ) } # [ doc = "Enabled" ] # [ inline ( always ) ] pub fn dacen_1 ( self ) -> & 'a mut W { self . variant ( DACEN_A :: DACEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "SAC DAC interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACIE_A { # [ doc = "0: Disabled" ] DACIE_0 = 0 , # [ doc = "1: Enabled" ] DACIE_1 = 1 } impl From < DACIE_A > for bool { # [ inline ( always ) ] fn from ( variant : DACIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACIE`" ] pub type DACIE_R = crate :: R < bool , DACIE_A > ; impl DACIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACIE_A { match self . bits { false => DACIE_A :: DACIE_0 , true => DACIE_A :: DACIE_1 } } # [ doc = "Checks if the value of the field is `DACIE_0`" ] # [ inline ( always ) ] pub fn is_dacie_0 ( & self ) -> bool { * self == DACIE_A :: DACIE_0 } # [ doc = "Checks if the value of the field is `DACIE_1`" ] # [ inline ( always ) ] pub fn is_dacie_1 ( & self ) -> bool { * self == DACIE_A :: DACIE_1 } }
# [ doc = "Write proxy for field `DACIE`" ] pub struct DACIE_W < 'a > { w : & 'a mut W , } impl < 'a > DACIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn dacie_0 ( self ) -> & 'a mut W { self . variant ( DACIE_A :: DACIE_0 ) } # [ doc = "Enabled" ] # [ inline ( always ) ] pub fn dacie_1 ( self ) -> & 'a mut W { self . variant ( DACIE_A :: DACIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "SAC DAC DMA request enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACDMAE_A { # [ doc = "0: DMA request disabled" ] DACDMAE_0 = 0 , # [ doc = "1: DMA request enabled" ] DACDMAE_1 = 1 } impl From < DACDMAE_A > for bool { # [ inline ( always ) ] fn from ( variant : DACDMAE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACDMAE`" ] pub type DACDMAE_R = crate :: R < bool , DACDMAE_A > ; impl DACDMAE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACDMAE_A { match self . bits { false => DACDMAE_A :: DACDMAE_0 , true => DACDMAE_A :: DACDMAE_1 } } # [ doc = "Checks if the value of the field is `DACDMAE_0`" ] # [ inline ( always ) ] pub fn is_dacdmae_0 ( & self ) -> bool { * self == DACDMAE_A :: DACDMAE_0 } # [ doc = "Checks if the value of the field is `DACDMAE_1`" ] # [ inline ( always ) ] pub fn is_dacdmae_1 ( & self ) -> bool { * self == DACDMAE_A :: DACDMAE_1 } }
# [ doc = "Write proxy for field `DACDMAE`" ] pub struct DACDMAE_W < 'a > { w : & 'a mut W , } impl < 'a > DACDMAE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACDMAE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "DMA request disabled" ] # [ inline ( always ) ] pub fn dacdmae_0 ( self ) -> & 'a mut W { self . variant ( DACDMAE_A :: DACDMAE_0 ) } # [ doc = "DMA request enabled" ] # [ inline ( always ) ] pub fn dacdmae_1 ( self ) -> & 'a mut W { self . variant ( DACDMAE_A :: DACDMAE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "SAC DAC load select. Selects the load trigger for the DAC latch.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum DACLSEL_A { # [ doc = "0: DAC latch loads when DACDAT written" ] DACLSEL_0 = 0 , # [ doc = "2: Device specific 0. DAC always loads data from DACDAT at the positive edge of this signal" ] DACLSEL_2 = 2 , # [ doc = "3: Device specific 1. DAC always loads data from DACDAT at the positive edge of this signal" ] DACLSEL_3 = 3 } impl From < DACLSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : DACLSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `DACLSEL`" ] pub type DACLSEL_R = crate :: R < u8 , DACLSEL_A > ; impl DACLSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , DACLSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( DACLSEL_A :: DACLSEL_0 ) , 2 => Val ( DACLSEL_A :: DACLSEL_2 ) , 3 => Val ( DACLSEL_A :: DACLSEL_3 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DACLSEL_0`" ] # [ inline ( always ) ] pub fn is_daclsel_0 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_0 } # [ doc = "Checks if the value of the field is `DACLSEL_2`" ] # [ inline ( always ) ] pub fn is_daclsel_2 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_2 } # [ doc = "Checks if the value of the field is `DACLSEL_3`" ] # [ inline ( always ) ] pub fn is_daclsel_3 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_3 } }
# [ doc = "Write proxy for field `DACLSEL`" ] pub struct DACLSEL_W < 'a > { w : & 'a mut W , } impl < 'a > DACLSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACLSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "DAC latch loads when DACDAT written" ] # [ inline ( always ) ] pub fn daclsel_0 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_0 ) } # [ doc = "Device specific 0. DAC always loads data from DACDAT at the positive edge of this signal" ] # [ inline ( always ) ] pub fn daclsel_2 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_2 ) } # [ doc = "Device specific 1. DAC always loads data from DACDAT at the positive edge of this signal" ] # [ inline ( always ) ] pub fn daclsel_3 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "SAC DAC select reference voltage\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACSREF_A { # [ doc = "0: AVCC" ] DACSREF_0 = 0 , # [ doc = "1: Alternative reference" ] DACSREF_1 = 1 } impl From < DACSREF_A > for bool { # [ inline ( always ) ] fn from ( variant : DACSREF_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACSREF`" ] pub type DACSREF_R = crate :: R < bool , DACSREF_A > ; impl DACSREF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACSREF_A { match self . bits { false => DACSREF_A :: DACSREF_0 , true => DACSREF_A :: DACSREF_1 } } # [ doc = "Checks if the value of the field is `DACSREF_0`" ] # [ inline ( always ) ] pub fn is_dacsref_0 ( & self ) -> bool { * self == DACSREF_A :: DACSREF_0 } # [ doc = "Checks if the value of the field is `DACSREF_1`" ] # [ inline ( always ) ] pub fn is_dacsref_1 ( & self ) -> bool { * self == DACSREF_A :: DACSREF_1 } }
# [ doc = "Write proxy for field `DACSREF`" ] pub struct DACSREF_W < 'a > { w : & 'a mut W , } impl < 'a > DACSREF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACSREF_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "AVCC" ] # [ inline ( always ) ] pub fn dacsref_0 ( self ) -> & 'a mut W { self . variant ( DACSREF_A :: DACSREF_0 ) } # [ doc = "Alternative reference" ] # [ inline ( always ) ] pub fn dacsref_1 ( self ) -> & 'a mut W { self . variant ( DACSREF_A :: DACSREF_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - SAC DAC enable" ] # [ inline ( always ) ] pub fn dacen ( & self ) -> DACEN_R { DACEN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - SAC DAC interrupt enable" ] # [ inline ( always ) ] pub fn dacie ( & self ) -> DACIE_R { DACIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - SAC DAC DMA request enable" ] # [ inline ( always ) ] pub fn dacdmae ( & self ) -> DACDMAE_R { DACDMAE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:9 - SAC DAC load select. Selects the load trigger for the DAC latch." ] # [ inline ( always ) ] pub fn daclsel ( & self ) -> DACLSEL_R { DACLSEL_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 12 - SAC DAC select reference voltage" ] # [ inline ( always ) ] pub fn dacsref ( & self ) -> DACSREF_R { DACSREF_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - SAC DAC enable" ] # [ inline ( always ) ] pub fn dacen ( & mut self ) -> DACEN_W { DACEN_W { w : self } }
# [ doc = "Bit 1 - SAC DAC interrupt enable" ] # [ inline ( always ) ] pub fn dacie ( & mut self ) -> DACIE_W { DACIE_W { w : self } }
# [ doc = "Bit 2 - SAC DAC DMA request enable" ] # [ inline ( always ) ] pub fn dacdmae ( & mut self ) -> DACDMAE_W { DACDMAE_W { w : self } }
# [ doc = "Bits 8:9 - SAC DAC load select. Selects the load trigger for the DAC latch." ] # [ inline ( always ) ] pub fn daclsel ( & mut self ) -> DACLSEL_W { DACLSEL_W { w : self } }
# [ doc = "Bit 12 - SAC DAC select reference voltage" ] # [ inline ( always ) ] pub fn dacsref ( & mut self ) -> DACSREF_W { DACSREF_W { w : self } }
}
}
# [ doc = "SAC DAC Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac1dat](sac1dat) module" ] pub type SAC1DAT = crate :: Reg < u16 , _SAC1DAT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC1DAT ;
# [ doc = "`read()` method returns [sac1dat::R](sac1dat::R) reader structure" ] impl crate :: Readable for SAC1DAT { }
# [ doc = "`write(|w| ..)` method takes [sac1dat::W](sac1dat::W) writer structure" ] impl crate :: Writable for SAC1DAT { }
# [ doc = "SAC DAC Data Register" ] pub mod sac1dat {
# [ doc = "Reader of register SAC1DAT" ] pub type R = crate :: R < u16 , super :: SAC1DAT > ;
# [ doc = "Writer for register SAC1DAT" ] pub type W = crate :: W < u16 , super :: SAC1DAT > ;
# [ doc = "Register SAC1DAT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC1DAT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DACData`" ] pub type DACDATA_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `DACData`" ] pub struct DACDATA_W < 'a > { w : & 'a mut W , } impl < 'a > DACDATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0fff ) | ( ( value as u16 ) & 0x0fff ) ; self . w } }
impl R {
# [ doc = "Bits 0:11 - SAC DAC data in unsigned format." ] # [ inline ( always ) ] pub fn dacdata ( & self ) -> DACDATA_R { DACDATA_R :: new ( ( self . bits & 0x0fff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:11 - SAC DAC data in unsigned format." ] # [ inline ( always ) ] pub fn dacdata ( & mut self ) -> DACDATA_W { DACDATA_W { w : self } }
}
}
# [ doc = "SAC DAC Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac1dacsts](sac1dacsts) module" ] pub type SAC1DACSTS = crate :: Reg < u16 , _SAC1DACSTS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC1DACSTS ;
# [ doc = "`read()` method returns [sac1dacsts::R](sac1dacsts::R) reader structure" ] impl crate :: Readable for SAC1DACSTS { }
# [ doc = "`write(|w| ..)` method takes [sac1dacsts::W](sac1dacsts::W) writer structure" ] impl crate :: Writable for SAC1DACSTS { }
# [ doc = "SAC DAC Status Register" ] pub mod sac1dacsts {
# [ doc = "Reader of register SAC1DACSTS" ] pub type R = crate :: R < u16 , super :: SAC1DACSTS > ;
# [ doc = "Writer for register SAC1DACSTS" ] pub type W = crate :: W < u16 , super :: SAC1DACSTS > ;
# [ doc = "Register SAC1DACSTS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC1DACSTS { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DACIFG`" ] pub type DACIFG_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DACIFG`" ] pub struct DACIFG_W < 'a > { w : & 'a mut W , } impl < 'a > DACIFG_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - SAC DAC data update flag" ] # [ inline ( always ) ] pub fn dacifg ( & self ) -> DACIFG_R { DACIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - SAC DAC data update flag" ] # [ inline ( always ) ] pub fn dacifg ( & mut self ) -> DACIFG_W { DACIFG_W { w : self } }
}
}
# [ doc = "SAC Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac1iv](sac1iv) module" ] pub type SAC1IV = crate :: Reg < u16 , _SAC1IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC1IV ;
# [ doc = "`read()` method returns [sac1iv::R](sac1iv::R) reader structure" ] impl crate :: Readable for SAC1IV { }
# [ doc = "SAC Interrupt Vector Register" ] pub mod sac1iv {
# [ doc = "Reader of register SAC1IV" ] pub type R = crate :: R < u16 , super :: SAC1IV > ;
# [ doc = "SAC Interrupt Vector Register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum SACIV1_A { # [ doc = "0: No interrupt pending" ] SACIV_0 = 0 , # [ doc = "2: S&H completed interrupt flag (Highest priority)" ] SACIV_2 = 2 , # [ doc = "4: DAC channel update interrupt flag" ] SACIV_4 = 4 } impl From < SACIV1_A > for u16 { # [ inline ( always ) ] fn from ( variant : SACIV1_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `SACIV1`" ] pub type SACIV1_R = crate :: R < u16 , SACIV1_A > ; impl SACIV1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , SACIV1_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SACIV1_A :: SACIV_0 ) , 2 => Val ( SACIV1_A :: SACIV_2 ) , 4 => Val ( SACIV1_A :: SACIV_4 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `SACIV_0`" ] # [ inline ( always ) ] pub fn is_saciv_0 ( & self ) -> bool { * self == SACIV1_A :: SACIV_0 } # [ doc = "Checks if the value of the field is `SACIV_2`" ] # [ inline ( always ) ] pub fn is_saciv_2 ( & self ) -> bool { * self == SACIV1_A :: SACIV_2 } # [ doc = "Checks if the value of the field is `SACIV_4`" ] # [ inline ( always ) ] pub fn is_saciv_4 ( & self ) -> bool { * self == SACIV1_A :: SACIV_4 } }
impl R {
# [ doc = "Bits 0:15 - SAC Interrupt Vector Register" ] # [ inline ( always ) ] pub fn saciv1 ( & self ) -> SACIV1_R { SACIV1_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "SAC2" ] pub struct SAC2 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SAC2 { } impl SAC2 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const sac2 :: RegisterBlock { 0x0ca0 as * const _ } } impl Deref for SAC2 { type Target = sac2 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * SAC2 :: ptr ( ) } } }
# [ doc = "SAC2" ] pub mod sac2 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - SAC OA Control Register" ] pub sac2oa : SAC2OA , # [ doc = "0x02 - SAC PGA Control Register" ] pub sac2pga : SAC2PGA , # [ doc = "0x04 - SAC DAC Control Register" ] pub sac2dac : SAC2DAC , # [ doc = "0x06 - SAC DAC Data Register" ] pub sac2dat : SAC2DAT , # [ doc = "0x08 - SAC DAC Status Register" ] pub sac2dacsts : SAC2DACSTS , # [ doc = "0x0a - SAC Interrupt Vector Register" ] pub sac2iv : SAC2IV , }
# [ doc = "SAC OA Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac2oa](sac2oa) module" ] pub type SAC2OA = crate :: Reg < u16 , _SAC2OA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC2OA ;
# [ doc = "`read()` method returns [sac2oa::R](sac2oa::R) reader structure" ] impl crate :: Readable for SAC2OA { }
# [ doc = "`write(|w| ..)` method takes [sac2oa::W](sac2oa::W) writer structure" ] impl crate :: Writable for SAC2OA { }
# [ doc = "SAC OA Control Register" ] pub mod sac2oa {
# [ doc = "Reader of register SAC2OA" ] pub type R = crate :: R < u16 , super :: SAC2OA > ;
# [ doc = "Writer for register SAC2OA" ] pub type W = crate :: W < u16 , super :: SAC2OA > ;
# [ doc = "Register SAC2OA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC2OA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC OA Positive input source selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum PSEL_A { # [ doc = "0: External source selected" ] PSEL_0 = 0 , # [ doc = "1: 12-bit reference DAC source selected" ] PSEL_1 = 1 , # [ doc = "2: Pair OA source selected" ] PSEL_2 = 2 } impl From < PSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : PSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `PSEL`" ] pub type PSEL_R = crate :: R < u8 , PSEL_A > ; impl PSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , PSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( PSEL_A :: PSEL_0 ) , 1 => Val ( PSEL_A :: PSEL_1 ) , 2 => Val ( PSEL_A :: PSEL_2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `PSEL_0`" ] # [ inline ( always ) ] pub fn is_psel_0 ( & self ) -> bool { * self == PSEL_A :: PSEL_0 } # [ doc = "Checks if the value of the field is `PSEL_1`" ] # [ inline ( always ) ] pub fn is_psel_1 ( & self ) -> bool { * self == PSEL_A :: PSEL_1 } # [ doc = "Checks if the value of the field is `PSEL_2`" ] # [ inline ( always ) ] pub fn is_psel_2 ( & self ) -> bool { * self == PSEL_A :: PSEL_2 } }
# [ doc = "Write proxy for field `PSEL`" ] pub struct PSEL_W < 'a > { w : & 'a mut W , } impl < 'a > PSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "External source selected" ] # [ inline ( always ) ] pub fn psel_0 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_0 ) } # [ doc = "12-bit reference DAC source selected" ] # [ inline ( always ) ] pub fn psel_1 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_1 ) } # [ doc = "Pair OA source selected" ] # [ inline ( always ) ] pub fn psel_2 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_2 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "SAC Positive input MUX control.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PMUXEN_A { # [ doc = "0: All positive input sources are disconnected to OA positive port" ] PMUXEN_0 = 0 , # [ doc = "1: All positive input sources are connected to OA positive port" ] PMUXEN_1 = 1 } impl From < PMUXEN_A > for bool { # [ inline ( always ) ] fn from ( variant : PMUXEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `PMUXEN`" ] pub type PMUXEN_R = crate :: R < bool , PMUXEN_A > ; impl PMUXEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PMUXEN_A { match self . bits { false => PMUXEN_A :: PMUXEN_0 , true => PMUXEN_A :: PMUXEN_1 } } # [ doc = "Checks if the value of the field is `PMUXEN_0`" ] # [ inline ( always ) ] pub fn is_pmuxen_0 ( & self ) -> bool { * self == PMUXEN_A :: PMUXEN_0 } # [ doc = "Checks if the value of the field is `PMUXEN_1`" ] # [ inline ( always ) ] pub fn is_pmuxen_1 ( & self ) -> bool { * self == PMUXEN_A :: PMUXEN_1 } }
# [ doc = "Write proxy for field `PMUXEN`" ] pub struct PMUXEN_W < 'a > { w : & 'a mut W , } impl < 'a > PMUXEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PMUXEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "All positive input sources are disconnected to OA positive port" ] # [ inline ( always ) ] pub fn pmuxen_0 ( self ) -> & 'a mut W { self . variant ( PMUXEN_A :: PMUXEN_0 ) } # [ doc = "All positive input sources are connected to OA positive port" ] # [ inline ( always ) ] pub fn pmuxen_1 ( self ) -> & 'a mut W { self . variant ( PMUXEN_A :: PMUXEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "SAC OA Negative input source selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum NSEL_A { # [ doc = "0: External source selected" ] NSEL_0 = 0 , # [ doc = "1: PGA source selected" ] NSEL_1 = 1 , # [ doc = "2: Device Specific" ] NSEL_2 = 2 } impl From < NSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : NSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `NSEL`" ] pub type NSEL_R = crate :: R < u8 , NSEL_A > ; impl NSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , NSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( NSEL_A :: NSEL_0 ) , 1 => Val ( NSEL_A :: NSEL_1 ) , 2 => Val ( NSEL_A :: NSEL_2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NSEL_0`" ] # [ inline ( always ) ] pub fn is_nsel_0 ( & self ) -> bool { * self == NSEL_A :: NSEL_0 } # [ doc = "Checks if the value of the field is `NSEL_1`" ] # [ inline ( always ) ] pub fn is_nsel_1 ( & self ) -> bool { * self == NSEL_A :: NSEL_1 } # [ doc = "Checks if the value of the field is `NSEL_2`" ] # [ inline ( always ) ] pub fn is_nsel_2 ( & self ) -> bool { * self == NSEL_A :: NSEL_2 } }
# [ doc = "Write proxy for field `NSEL`" ] pub struct NSEL_W < 'a > { w : & 'a mut W , } impl < 'a > NSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "External source selected" ] # [ inline ( always ) ] pub fn nsel_0 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_0 ) } # [ doc = "PGA source selected" ] # [ inline ( always ) ] pub fn nsel_1 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_1 ) } # [ doc = "Device Specific" ] # [ inline ( always ) ] pub fn nsel_2 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_2 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "SAC Negative input MUX controL\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum NMUXEN_A { # [ doc = "0: All negative input sources are disconnected to OA negative port" ] NMUXEN_0 = 0 , # [ doc = "1: All negative input sources are connected to OA negative port" ] NMUXEN_1 = 1 } impl From < NMUXEN_A > for bool { # [ inline ( always ) ] fn from ( variant : NMUXEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `NMUXEN`" ] pub type NMUXEN_R = crate :: R < bool , NMUXEN_A > ; impl NMUXEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> NMUXEN_A { match self . bits { false => NMUXEN_A :: NMUXEN_0 , true => NMUXEN_A :: NMUXEN_1 } } # [ doc = "Checks if the value of the field is `NMUXEN_0`" ] # [ inline ( always ) ] pub fn is_nmuxen_0 ( & self ) -> bool { * self == NMUXEN_A :: NMUXEN_0 } # [ doc = "Checks if the value of the field is `NMUXEN_1`" ] # [ inline ( always ) ] pub fn is_nmuxen_1 ( & self ) -> bool { * self == NMUXEN_A :: NMUXEN_1 } }
# [ doc = "Write proxy for field `NMUXEN`" ] pub struct NMUXEN_W < 'a > { w : & 'a mut W , } impl < 'a > NMUXEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NMUXEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "All negative input sources are disconnected to OA negative port" ] # [ inline ( always ) ] pub fn nmuxen_0 ( self ) -> & 'a mut W { self . variant ( NMUXEN_A :: NMUXEN_0 ) } # [ doc = "All negative input sources are connected to OA negative port" ] # [ inline ( always ) ] pub fn nmuxen_1 ( self ) -> & 'a mut W { self . variant ( NMUXEN_A :: NMUXEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "SAC OA Enable selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OAEN_A { # [ doc = "0: SAC OA is disabled, then the SAC OA output high impedance" ] OAEN_0 = 0 , # [ doc = "1: SAC OA is enabled, normal mode" ] OAEN_1 = 1 } impl From < OAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : OAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OAEN`" ] pub type OAEN_R = crate :: R < bool , OAEN_A > ; impl OAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OAEN_A { match self . bits { false => OAEN_A :: OAEN_0 , true => OAEN_A :: OAEN_1 } } # [ doc = "Checks if the value of the field is `OAEN_0`" ] # [ inline ( always ) ] pub fn is_oaen_0 ( & self ) -> bool { * self == OAEN_A :: OAEN_0 } # [ doc = "Checks if the value of the field is `OAEN_1`" ] # [ inline ( always ) ] pub fn is_oaen_1 ( & self ) -> bool { * self == OAEN_A :: OAEN_1 } }
# [ doc = "Write proxy for field `OAEN`" ] pub struct OAEN_W < 'a > { w : & 'a mut W , } impl < 'a > OAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SAC OA is disabled, then the SAC OA output high impedance" ] # [ inline ( always ) ] pub fn oaen_0 ( self ) -> & 'a mut W { self . variant ( OAEN_A :: OAEN_0 ) } # [ doc = "SAC OA is enabled, normal mode" ] # [ inline ( always ) ] pub fn oaen_1 ( self ) -> & 'a mut W { self . variant ( OAEN_A :: OAEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "SAC OA power mode selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OAPM_A { # [ doc = "0: High speed and high power" ] OAPM_0 = 0 , # [ doc = "1: Llow speed and low power" ] OAPM_1 = 1 } impl From < OAPM_A > for bool { # [ inline ( always ) ] fn from ( variant : OAPM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OAPM`" ] pub type OAPM_R = crate :: R < bool , OAPM_A > ; impl OAPM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OAPM_A { match self . bits { false => OAPM_A :: OAPM_0 , true => OAPM_A :: OAPM_1 } } # [ doc = "Checks if the value of the field is `OAPM_0`" ] # [ inline ( always ) ] pub fn is_oapm_0 ( & self ) -> bool { * self == OAPM_A :: OAPM_0 } # [ doc = "Checks if the value of the field is `OAPM_1`" ] # [ inline ( always ) ] pub fn is_oapm_1 ( & self ) -> bool { * self == OAPM_A :: OAPM_1 } }
# [ doc = "Write proxy for field `OAPM`" ] pub struct OAPM_W < 'a > { w : & 'a mut W , } impl < 'a > OAPM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OAPM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "High speed and high power" ] # [ inline ( always ) ] pub fn oapm_0 ( self ) -> & 'a mut W { self . variant ( OAPM_A :: OAPM_0 ) } # [ doc = "Llow speed and low power" ] # [ inline ( always ) ] pub fn oapm_1 ( self ) -> & 'a mut W { self . variant ( OAPM_A :: OAPM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "SAC Enable selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SACEN_A { # [ doc = "0: SAC all modules are disabled, then the SAC output high impedance" ] SACEN_0 = 0 , # [ doc = "1: SAC all modules are enabled, normal mode" ] SACEN_1 = 1 } impl From < SACEN_A > for bool { # [ inline ( always ) ] fn from ( variant : SACEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SACEN`" ] pub type SACEN_R = crate :: R < bool , SACEN_A > ; impl SACEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SACEN_A { match self . bits { false => SACEN_A :: SACEN_0 , true => SACEN_A :: SACEN_1 } } # [ doc = "Checks if the value of the field is `SACEN_0`" ] # [ inline ( always ) ] pub fn is_sacen_0 ( & self ) -> bool { * self == SACEN_A :: SACEN_0 } # [ doc = "Checks if the value of the field is `SACEN_1`" ] # [ inline ( always ) ] pub fn is_sacen_1 ( & self ) -> bool { * self == SACEN_A :: SACEN_1 } }
# [ doc = "Write proxy for field `SACEN`" ] pub struct SACEN_W < 'a > { w : & 'a mut W , } impl < 'a > SACEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SACEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SAC all modules are disabled, then the SAC output high impedance" ] # [ inline ( always ) ] pub fn sacen_0 ( self ) -> & 'a mut W { self . variant ( SACEN_A :: SACEN_0 ) } # [ doc = "SAC all modules are enabled, normal mode" ] # [ inline ( always ) ] pub fn sacen_1 ( self ) -> & 'a mut W { self . variant ( SACEN_A :: SACEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - SAC OA Positive input source selection" ] # [ inline ( always ) ] pub fn psel ( & self ) -> PSEL_R { PSEL_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bit 3 - SAC Positive input MUX control." ] # [ inline ( always ) ] pub fn pmuxen ( & self ) -> PMUXEN_R { PMUXEN_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - SAC OA Negative input source selection" ] # [ inline ( always ) ] pub fn nsel ( & self ) -> NSEL_R { NSEL_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 7 - SAC Negative input MUX controL" ] # [ inline ( always ) ] pub fn nmuxen ( & self ) -> NMUXEN_R { NMUXEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - SAC OA Enable selection" ] # [ inline ( always ) ] pub fn oaen ( & self ) -> OAEN_R { OAEN_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - SAC OA power mode selection" ] # [ inline ( always ) ] pub fn oapm ( & self ) -> OAPM_R { OAPM_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - SAC Enable selection" ] # [ inline ( always ) ] pub fn sacen ( & self ) -> SACEN_R { SACEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:1 - SAC OA Positive input source selection" ] # [ inline ( always ) ] pub fn psel ( & mut self ) -> PSEL_W { PSEL_W { w : self } }
# [ doc = "Bit 3 - SAC Positive input MUX control." ] # [ inline ( always ) ] pub fn pmuxen ( & mut self ) -> PMUXEN_W { PMUXEN_W { w : self } }
# [ doc = "Bits 4:5 - SAC OA Negative input source selection" ] # [ inline ( always ) ] pub fn nsel ( & mut self ) -> NSEL_W { NSEL_W { w : self } }
# [ doc = "Bit 7 - SAC Negative input MUX controL" ] # [ inline ( always ) ] pub fn nmuxen ( & mut self ) -> NMUXEN_W { NMUXEN_W { w : self } }
# [ doc = "Bit 8 - SAC OA Enable selection" ] # [ inline ( always ) ] pub fn oaen ( & mut self ) -> OAEN_W { OAEN_W { w : self } }
# [ doc = "Bit 9 - SAC OA power mode selection" ] # [ inline ( always ) ] pub fn oapm ( & mut self ) -> OAPM_W { OAPM_W { w : self } }
# [ doc = "Bit 10 - SAC Enable selection" ] # [ inline ( always ) ] pub fn sacen ( & mut self ) -> SACEN_W { SACEN_W { w : self } }
}
}
# [ doc = "SAC PGA Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac2pga](sac2pga) module" ] pub type SAC2PGA = crate :: Reg < u16 , _SAC2PGA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC2PGA ;
# [ doc = "`read()` method returns [sac2pga::R](sac2pga::R) reader structure" ] impl crate :: Readable for SAC2PGA { }
# [ doc = "`write(|w| ..)` method takes [sac2pga::W](sac2pga::W) writer structure" ] impl crate :: Writable for SAC2PGA { }
# [ doc = "SAC PGA Control Register" ] pub mod sac2pga {
# [ doc = "Reader of register SAC2PGA" ] pub type R = crate :: R < u16 , super :: SAC2PGA > ;
# [ doc = "Writer for register SAC2PGA" ] pub type W = crate :: W < u16 , super :: SAC2PGA > ;
# [ doc = "Register SAC2PGA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC2PGA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC PGA Mode Selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum MSEL_A { # [ doc = "0: Inverting PGA mode (external pad IN- is selected)" ] MSEL_0 = 0 , # [ doc = "1: Buffer mode (floating is selected )" ] MSEL_1 = 1 , # [ doc = "2: Non-inverting mode" ] MSEL_2 = 2 , # [ doc = "3: Cascade OA Inverting mode" ] MSEL_3 = 3 } impl From < MSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : MSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `MSEL`" ] pub type MSEL_R = crate :: R < u8 , MSEL_A > ; impl MSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MSEL_A { match self . bits { 0 => MSEL_A :: MSEL_0 , 1 => MSEL_A :: MSEL_1 , 2 => MSEL_A :: MSEL_2 , 3 => MSEL_A :: MSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `MSEL_0`" ] # [ inline ( always ) ] pub fn is_msel_0 ( & self ) -> bool { * self == MSEL_A :: MSEL_0 } # [ doc = "Checks if the value of the field is `MSEL_1`" ] # [ inline ( always ) ] pub fn is_msel_1 ( & self ) -> bool { * self == MSEL_A :: MSEL_1 } # [ doc = "Checks if the value of the field is `MSEL_2`" ] # [ inline ( always ) ] pub fn is_msel_2 ( & self ) -> bool { * self == MSEL_A :: MSEL_2 } # [ doc = "Checks if the value of the field is `MSEL_3`" ] # [ inline ( always ) ] pub fn is_msel_3 ( & self ) -> bool { * self == MSEL_A :: MSEL_3 } }
# [ doc = "Write proxy for field `MSEL`" ] pub struct MSEL_W < 'a > { w : & 'a mut W , } impl < 'a > MSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Inverting PGA mode (external pad IN- is selected)" ] # [ inline ( always ) ] pub fn msel_0 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_0 ) } # [ doc = "Buffer mode (floating is selected )" ] # [ inline ( always ) ] pub fn msel_1 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_1 ) } # [ doc = "Non-inverting mode" ] # [ inline ( always ) ] pub fn msel_2 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_2 ) } # [ doc = "Cascade OA Inverting mode" ] # [ inline ( always ) ] pub fn msel_3 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `GAIN`" ] pub type GAIN_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `GAIN`" ] pub struct GAIN_W < 'a > { w : & 'a mut W , } impl < 'a > GAIN_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 4 ) ) | ( ( ( value as u16 ) & 0x07 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - SAC PGA Mode Selection" ] # [ inline ( always ) ] pub fn msel ( & self ) -> MSEL_R { MSEL_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 4:6 - SAC PGA Gain configuration" ] # [ inline ( always ) ] pub fn gain ( & self ) -> GAIN_R { GAIN_R :: new ( ( ( self . bits >> 4 ) & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - SAC PGA Mode Selection" ] # [ inline ( always ) ] pub fn msel ( & mut self ) -> MSEL_W { MSEL_W { w : self } }
# [ doc = "Bits 4:6 - SAC PGA Gain configuration" ] # [ inline ( always ) ] pub fn gain ( & mut self ) -> GAIN_W { GAIN_W { w : self } }
}
}
# [ doc = "SAC DAC Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac2dac](sac2dac) module" ] pub type SAC2DAC = crate :: Reg < u16 , _SAC2DAC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC2DAC ;
# [ doc = "`read()` method returns [sac2dac::R](sac2dac::R) reader structure" ] impl crate :: Readable for SAC2DAC { }
# [ doc = "`write(|w| ..)` method takes [sac2dac::W](sac2dac::W) writer structure" ] impl crate :: Writable for SAC2DAC { }
# [ doc = "SAC DAC Control Register" ] pub mod sac2dac {
# [ doc = "Reader of register SAC2DAC" ] pub type R = crate :: R < u16 , super :: SAC2DAC > ;
# [ doc = "Writer for register SAC2DAC" ] pub type W = crate :: W < u16 , super :: SAC2DAC > ;
# [ doc = "Register SAC2DAC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC2DAC { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC DAC enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACEN_A { # [ doc = "0: Disabled" ] DACEN_0 = 0 , # [ doc = "1: Enabled" ] DACEN_1 = 1 } impl From < DACEN_A > for bool { # [ inline ( always ) ] fn from ( variant : DACEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACEN`" ] pub type DACEN_R = crate :: R < bool , DACEN_A > ; impl DACEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACEN_A { match self . bits { false => DACEN_A :: DACEN_0 , true => DACEN_A :: DACEN_1 } } # [ doc = "Checks if the value of the field is `DACEN_0`" ] # [ inline ( always ) ] pub fn is_dacen_0 ( & self ) -> bool { * self == DACEN_A :: DACEN_0 } # [ doc = "Checks if the value of the field is `DACEN_1`" ] # [ inline ( always ) ] pub fn is_dacen_1 ( & self ) -> bool { * self == DACEN_A :: DACEN_1 } }
# [ doc = "Write proxy for field `DACEN`" ] pub struct DACEN_W < 'a > { w : & 'a mut W , } impl < 'a > DACEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn dacen_0 ( self ) -> & 'a mut W { self . variant ( DACEN_A :: DACEN_0 ) } # [ doc = "Enabled" ] # [ inline ( always ) ] pub fn dacen_1 ( self ) -> & 'a mut W { self . variant ( DACEN_A :: DACEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "SAC DAC interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACIE_A { # [ doc = "0: Disabled" ] DACIE_0 = 0 , # [ doc = "1: Enabled" ] DACIE_1 = 1 } impl From < DACIE_A > for bool { # [ inline ( always ) ] fn from ( variant : DACIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACIE`" ] pub type DACIE_R = crate :: R < bool , DACIE_A > ; impl DACIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACIE_A { match self . bits { false => DACIE_A :: DACIE_0 , true => DACIE_A :: DACIE_1 } } # [ doc = "Checks if the value of the field is `DACIE_0`" ] # [ inline ( always ) ] pub fn is_dacie_0 ( & self ) -> bool { * self == DACIE_A :: DACIE_0 } # [ doc = "Checks if the value of the field is `DACIE_1`" ] # [ inline ( always ) ] pub fn is_dacie_1 ( & self ) -> bool { * self == DACIE_A :: DACIE_1 } }
# [ doc = "Write proxy for field `DACIE`" ] pub struct DACIE_W < 'a > { w : & 'a mut W , } impl < 'a > DACIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn dacie_0 ( self ) -> & 'a mut W { self . variant ( DACIE_A :: DACIE_0 ) } # [ doc = "Enabled" ] # [ inline ( always ) ] pub fn dacie_1 ( self ) -> & 'a mut W { self . variant ( DACIE_A :: DACIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "SAC DAC DMA request enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACDMAE_A { # [ doc = "0: DMA request disabled" ] DACDMAE_0 = 0 , # [ doc = "1: DMA request enabled" ] DACDMAE_1 = 1 } impl From < DACDMAE_A > for bool { # [ inline ( always ) ] fn from ( variant : DACDMAE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACDMAE`" ] pub type DACDMAE_R = crate :: R < bool , DACDMAE_A > ; impl DACDMAE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACDMAE_A { match self . bits { false => DACDMAE_A :: DACDMAE_0 , true => DACDMAE_A :: DACDMAE_1 } } # [ doc = "Checks if the value of the field is `DACDMAE_0`" ] # [ inline ( always ) ] pub fn is_dacdmae_0 ( & self ) -> bool { * self == DACDMAE_A :: DACDMAE_0 } # [ doc = "Checks if the value of the field is `DACDMAE_1`" ] # [ inline ( always ) ] pub fn is_dacdmae_1 ( & self ) -> bool { * self == DACDMAE_A :: DACDMAE_1 } }
# [ doc = "Write proxy for field `DACDMAE`" ] pub struct DACDMAE_W < 'a > { w : & 'a mut W , } impl < 'a > DACDMAE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACDMAE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "DMA request disabled" ] # [ inline ( always ) ] pub fn dacdmae_0 ( self ) -> & 'a mut W { self . variant ( DACDMAE_A :: DACDMAE_0 ) } # [ doc = "DMA request enabled" ] # [ inline ( always ) ] pub fn dacdmae_1 ( self ) -> & 'a mut W { self . variant ( DACDMAE_A :: DACDMAE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "SAC DAC load select. Selects the load trigger for the DAC latch.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum DACLSEL_A { # [ doc = "0: DAC latch loads when DACDAT written" ] DACLSEL_0 = 0 , # [ doc = "2: Device specific 0. DAC always loads data from DACDAT at the positive edge of this signal" ] DACLSEL_2 = 2 , # [ doc = "3: Device specific 1. DAC always loads data from DACDAT at the positive edge of this signal" ] DACLSEL_3 = 3 } impl From < DACLSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : DACLSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `DACLSEL`" ] pub type DACLSEL_R = crate :: R < u8 , DACLSEL_A > ; impl DACLSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , DACLSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( DACLSEL_A :: DACLSEL_0 ) , 2 => Val ( DACLSEL_A :: DACLSEL_2 ) , 3 => Val ( DACLSEL_A :: DACLSEL_3 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DACLSEL_0`" ] # [ inline ( always ) ] pub fn is_daclsel_0 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_0 } # [ doc = "Checks if the value of the field is `DACLSEL_2`" ] # [ inline ( always ) ] pub fn is_daclsel_2 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_2 } # [ doc = "Checks if the value of the field is `DACLSEL_3`" ] # [ inline ( always ) ] pub fn is_daclsel_3 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_3 } }
# [ doc = "Write proxy for field `DACLSEL`" ] pub struct DACLSEL_W < 'a > { w : & 'a mut W , } impl < 'a > DACLSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACLSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "DAC latch loads when DACDAT written" ] # [ inline ( always ) ] pub fn daclsel_0 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_0 ) } # [ doc = "Device specific 0. DAC always loads data from DACDAT at the positive edge of this signal" ] # [ inline ( always ) ] pub fn daclsel_2 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_2 ) } # [ doc = "Device specific 1. DAC always loads data from DACDAT at the positive edge of this signal" ] # [ inline ( always ) ] pub fn daclsel_3 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "SAC DAC select reference voltage\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACSREF_A { # [ doc = "0: AVCC" ] DACSREF_0 = 0 , # [ doc = "1: Alternative reference" ] DACSREF_1 = 1 } impl From < DACSREF_A > for bool { # [ inline ( always ) ] fn from ( variant : DACSREF_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACSREF`" ] pub type DACSREF_R = crate :: R < bool , DACSREF_A > ; impl DACSREF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACSREF_A { match self . bits { false => DACSREF_A :: DACSREF_0 , true => DACSREF_A :: DACSREF_1 } } # [ doc = "Checks if the value of the field is `DACSREF_0`" ] # [ inline ( always ) ] pub fn is_dacsref_0 ( & self ) -> bool { * self == DACSREF_A :: DACSREF_0 } # [ doc = "Checks if the value of the field is `DACSREF_1`" ] # [ inline ( always ) ] pub fn is_dacsref_1 ( & self ) -> bool { * self == DACSREF_A :: DACSREF_1 } }
# [ doc = "Write proxy for field `DACSREF`" ] pub struct DACSREF_W < 'a > { w : & 'a mut W , } impl < 'a > DACSREF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACSREF_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "AVCC" ] # [ inline ( always ) ] pub fn dacsref_0 ( self ) -> & 'a mut W { self . variant ( DACSREF_A :: DACSREF_0 ) } # [ doc = "Alternative reference" ] # [ inline ( always ) ] pub fn dacsref_1 ( self ) -> & 'a mut W { self . variant ( DACSREF_A :: DACSREF_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - SAC DAC enable" ] # [ inline ( always ) ] pub fn dacen ( & self ) -> DACEN_R { DACEN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - SAC DAC interrupt enable" ] # [ inline ( always ) ] pub fn dacie ( & self ) -> DACIE_R { DACIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - SAC DAC DMA request enable" ] # [ inline ( always ) ] pub fn dacdmae ( & self ) -> DACDMAE_R { DACDMAE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:9 - SAC DAC load select. Selects the load trigger for the DAC latch." ] # [ inline ( always ) ] pub fn daclsel ( & self ) -> DACLSEL_R { DACLSEL_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 12 - SAC DAC select reference voltage" ] # [ inline ( always ) ] pub fn dacsref ( & self ) -> DACSREF_R { DACSREF_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - SAC DAC enable" ] # [ inline ( always ) ] pub fn dacen ( & mut self ) -> DACEN_W { DACEN_W { w : self } }
# [ doc = "Bit 1 - SAC DAC interrupt enable" ] # [ inline ( always ) ] pub fn dacie ( & mut self ) -> DACIE_W { DACIE_W { w : self } }
# [ doc = "Bit 2 - SAC DAC DMA request enable" ] # [ inline ( always ) ] pub fn dacdmae ( & mut self ) -> DACDMAE_W { DACDMAE_W { w : self } }
# [ doc = "Bits 8:9 - SAC DAC load select. Selects the load trigger for the DAC latch." ] # [ inline ( always ) ] pub fn daclsel ( & mut self ) -> DACLSEL_W { DACLSEL_W { w : self } }
# [ doc = "Bit 12 - SAC DAC select reference voltage" ] # [ inline ( always ) ] pub fn dacsref ( & mut self ) -> DACSREF_W { DACSREF_W { w : self } }
}
}
# [ doc = "SAC DAC Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac2dat](sac2dat) module" ] pub type SAC2DAT = crate :: Reg < u16 , _SAC2DAT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC2DAT ;
# [ doc = "`read()` method returns [sac2dat::R](sac2dat::R) reader structure" ] impl crate :: Readable for SAC2DAT { }
# [ doc = "`write(|w| ..)` method takes [sac2dat::W](sac2dat::W) writer structure" ] impl crate :: Writable for SAC2DAT { }
# [ doc = "SAC DAC Data Register" ] pub mod sac2dat {
# [ doc = "Reader of register SAC2DAT" ] pub type R = crate :: R < u16 , super :: SAC2DAT > ;
# [ doc = "Writer for register SAC2DAT" ] pub type W = crate :: W < u16 , super :: SAC2DAT > ;
# [ doc = "Register SAC2DAT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC2DAT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DACData`" ] pub type DACDATA_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `DACData`" ] pub struct DACDATA_W < 'a > { w : & 'a mut W , } impl < 'a > DACDATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0fff ) | ( ( value as u16 ) & 0x0fff ) ; self . w } }
impl R {
# [ doc = "Bits 0:11 - SAC DAC data in unsigned format." ] # [ inline ( always ) ] pub fn dacdata ( & self ) -> DACDATA_R { DACDATA_R :: new ( ( self . bits & 0x0fff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:11 - SAC DAC data in unsigned format." ] # [ inline ( always ) ] pub fn dacdata ( & mut self ) -> DACDATA_W { DACDATA_W { w : self } }
}
}
# [ doc = "SAC DAC Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac2dacsts](sac2dacsts) module" ] pub type SAC2DACSTS = crate :: Reg < u16 , _SAC2DACSTS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC2DACSTS ;
# [ doc = "`read()` method returns [sac2dacsts::R](sac2dacsts::R) reader structure" ] impl crate :: Readable for SAC2DACSTS { }
# [ doc = "`write(|w| ..)` method takes [sac2dacsts::W](sac2dacsts::W) writer structure" ] impl crate :: Writable for SAC2DACSTS { }
# [ doc = "SAC DAC Status Register" ] pub mod sac2dacsts {
# [ doc = "Reader of register SAC2DACSTS" ] pub type R = crate :: R < u16 , super :: SAC2DACSTS > ;
# [ doc = "Writer for register SAC2DACSTS" ] pub type W = crate :: W < u16 , super :: SAC2DACSTS > ;
# [ doc = "Register SAC2DACSTS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC2DACSTS { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DACIFG`" ] pub type DACIFG_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DACIFG`" ] pub struct DACIFG_W < 'a > { w : & 'a mut W , } impl < 'a > DACIFG_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - SAC DAC data update flag" ] # [ inline ( always ) ] pub fn dacifg ( & self ) -> DACIFG_R { DACIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - SAC DAC data update flag" ] # [ inline ( always ) ] pub fn dacifg ( & mut self ) -> DACIFG_W { DACIFG_W { w : self } }
}
}
# [ doc = "SAC Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac2iv](sac2iv) module" ] pub type SAC2IV = crate :: Reg < u16 , _SAC2IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC2IV ;
# [ doc = "`read()` method returns [sac2iv::R](sac2iv::R) reader structure" ] impl crate :: Readable for SAC2IV { }
# [ doc = "SAC Interrupt Vector Register" ] pub mod sac2iv {
# [ doc = "Reader of register SAC2IV" ] pub type R = crate :: R < u16 , super :: SAC2IV > ;
# [ doc = "SAC Interrupt Vector Register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum SACIV2_A { # [ doc = "0: No interrupt pending" ] SACIV_0 = 0 , # [ doc = "2: S&H completed interrupt flag (Highest priority)" ] SACIV_2 = 2 , # [ doc = "4: DAC channel update interrupt flag" ] SACIV_4 = 4 } impl From < SACIV2_A > for u16 { # [ inline ( always ) ] fn from ( variant : SACIV2_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `SACIV2`" ] pub type SACIV2_R = crate :: R < u16 , SACIV2_A > ; impl SACIV2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , SACIV2_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SACIV2_A :: SACIV_0 ) , 2 => Val ( SACIV2_A :: SACIV_2 ) , 4 => Val ( SACIV2_A :: SACIV_4 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `SACIV_0`" ] # [ inline ( always ) ] pub fn is_saciv_0 ( & self ) -> bool { * self == SACIV2_A :: SACIV_0 } # [ doc = "Checks if the value of the field is `SACIV_2`" ] # [ inline ( always ) ] pub fn is_saciv_2 ( & self ) -> bool { * self == SACIV2_A :: SACIV_2 } # [ doc = "Checks if the value of the field is `SACIV_4`" ] # [ inline ( always ) ] pub fn is_saciv_4 ( & self ) -> bool { * self == SACIV2_A :: SACIV_4 } }
impl R {
# [ doc = "Bits 0:15 - SAC Interrupt Vector Register" ] # [ inline ( always ) ] pub fn saciv2 ( & self ) -> SACIV2_R { SACIV2_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "SAC3" ] pub struct SAC3 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SAC3 { } impl SAC3 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const sac3 :: RegisterBlock { 0x0cb0 as * const _ } } impl Deref for SAC3 { type Target = sac3 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * SAC3 :: ptr ( ) } } }
# [ doc = "SAC3" ] pub mod sac3 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - SAC OA Control Register" ] pub sac3oa : SAC3OA , # [ doc = "0x02 - SAC PGA Control Register" ] pub sac3pga : SAC3PGA , # [ doc = "0x04 - SAC DAC Control Register" ] pub sac3dac : SAC3DAC , # [ doc = "0x06 - SAC DAC Data Register" ] pub sac3dat : SAC3DAT , # [ doc = "0x08 - SAC DAC Status Register" ] pub sac3dacsts : SAC3DACSTS , # [ doc = "0x0a - SAC Interrupt Vector Register" ] pub sac3iv : SAC3IV , }
# [ doc = "SAC OA Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac3oa](sac3oa) module" ] pub type SAC3OA = crate :: Reg < u16 , _SAC3OA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC3OA ;
# [ doc = "`read()` method returns [sac3oa::R](sac3oa::R) reader structure" ] impl crate :: Readable for SAC3OA { }
# [ doc = "`write(|w| ..)` method takes [sac3oa::W](sac3oa::W) writer structure" ] impl crate :: Writable for SAC3OA { }
# [ doc = "SAC OA Control Register" ] pub mod sac3oa {
# [ doc = "Reader of register SAC3OA" ] pub type R = crate :: R < u16 , super :: SAC3OA > ;
# [ doc = "Writer for register SAC3OA" ] pub type W = crate :: W < u16 , super :: SAC3OA > ;
# [ doc = "Register SAC3OA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC3OA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC OA Positive input source selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum PSEL_A { # [ doc = "0: External source selected" ] PSEL_0 = 0 , # [ doc = "1: 12-bit reference DAC source selected" ] PSEL_1 = 1 , # [ doc = "2: Pair OA source selected" ] PSEL_2 = 2 } impl From < PSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : PSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `PSEL`" ] pub type PSEL_R = crate :: R < u8 , PSEL_A > ; impl PSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , PSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( PSEL_A :: PSEL_0 ) , 1 => Val ( PSEL_A :: PSEL_1 ) , 2 => Val ( PSEL_A :: PSEL_2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `PSEL_0`" ] # [ inline ( always ) ] pub fn is_psel_0 ( & self ) -> bool { * self == PSEL_A :: PSEL_0 } # [ doc = "Checks if the value of the field is `PSEL_1`" ] # [ inline ( always ) ] pub fn is_psel_1 ( & self ) -> bool { * self == PSEL_A :: PSEL_1 } # [ doc = "Checks if the value of the field is `PSEL_2`" ] # [ inline ( always ) ] pub fn is_psel_2 ( & self ) -> bool { * self == PSEL_A :: PSEL_2 } }
# [ doc = "Write proxy for field `PSEL`" ] pub struct PSEL_W < 'a > { w : & 'a mut W , } impl < 'a > PSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "External source selected" ] # [ inline ( always ) ] pub fn psel_0 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_0 ) } # [ doc = "12-bit reference DAC source selected" ] # [ inline ( always ) ] pub fn psel_1 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_1 ) } # [ doc = "Pair OA source selected" ] # [ inline ( always ) ] pub fn psel_2 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_2 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "SAC Positive input MUX control.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PMUXEN_A { # [ doc = "0: All positive input sources are disconnected to OA positive port" ] PMUXEN_0 = 0 , # [ doc = "1: All positive input sources are connected to OA positive port" ] PMUXEN_1 = 1 } impl From < PMUXEN_A > for bool { # [ inline ( always ) ] fn from ( variant : PMUXEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `PMUXEN`" ] pub type PMUXEN_R = crate :: R < bool , PMUXEN_A > ; impl PMUXEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PMUXEN_A { match self . bits { false => PMUXEN_A :: PMUXEN_0 , true => PMUXEN_A :: PMUXEN_1 } } # [ doc = "Checks if the value of the field is `PMUXEN_0`" ] # [ inline ( always ) ] pub fn is_pmuxen_0 ( & self ) -> bool { * self == PMUXEN_A :: PMUXEN_0 } # [ doc = "Checks if the value of the field is `PMUXEN_1`" ] # [ inline ( always ) ] pub fn is_pmuxen_1 ( & self ) -> bool { * self == PMUXEN_A :: PMUXEN_1 } }
# [ doc = "Write proxy for field `PMUXEN`" ] pub struct PMUXEN_W < 'a > { w : & 'a mut W , } impl < 'a > PMUXEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PMUXEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "All positive input sources are disconnected to OA positive port" ] # [ inline ( always ) ] pub fn pmuxen_0 ( self ) -> & 'a mut W { self . variant ( PMUXEN_A :: PMUXEN_0 ) } # [ doc = "All positive input sources are connected to OA positive port" ] # [ inline ( always ) ] pub fn pmuxen_1 ( self ) -> & 'a mut W { self . variant ( PMUXEN_A :: PMUXEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "SAC OA Negative input source selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum NSEL_A { # [ doc = "0: External source selected" ] NSEL_0 = 0 , # [ doc = "1: PGA source selected" ] NSEL_1 = 1 , # [ doc = "2: Device Specific" ] NSEL_2 = 2 } impl From < NSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : NSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `NSEL`" ] pub type NSEL_R = crate :: R < u8 , NSEL_A > ; impl NSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , NSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( NSEL_A :: NSEL_0 ) , 1 => Val ( NSEL_A :: NSEL_1 ) , 2 => Val ( NSEL_A :: NSEL_2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NSEL_0`" ] # [ inline ( always ) ] pub fn is_nsel_0 ( & self ) -> bool { * self == NSEL_A :: NSEL_0 } # [ doc = "Checks if the value of the field is `NSEL_1`" ] # [ inline ( always ) ] pub fn is_nsel_1 ( & self ) -> bool { * self == NSEL_A :: NSEL_1 } # [ doc = "Checks if the value of the field is `NSEL_2`" ] # [ inline ( always ) ] pub fn is_nsel_2 ( & self ) -> bool { * self == NSEL_A :: NSEL_2 } }
# [ doc = "Write proxy for field `NSEL`" ] pub struct NSEL_W < 'a > { w : & 'a mut W , } impl < 'a > NSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "External source selected" ] # [ inline ( always ) ] pub fn nsel_0 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_0 ) } # [ doc = "PGA source selected" ] # [ inline ( always ) ] pub fn nsel_1 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_1 ) } # [ doc = "Device Specific" ] # [ inline ( always ) ] pub fn nsel_2 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_2 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "SAC Negative input MUX controL\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum NMUXEN_A { # [ doc = "0: All negative input sources are disconnected to OA negative port" ] NMUXEN_0 = 0 , # [ doc = "1: All negative input sources are connected to OA negative port" ] NMUXEN_1 = 1 } impl From < NMUXEN_A > for bool { # [ inline ( always ) ] fn from ( variant : NMUXEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `NMUXEN`" ] pub type NMUXEN_R = crate :: R < bool , NMUXEN_A > ; impl NMUXEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> NMUXEN_A { match self . bits { false => NMUXEN_A :: NMUXEN_0 , true => NMUXEN_A :: NMUXEN_1 } } # [ doc = "Checks if the value of the field is `NMUXEN_0`" ] # [ inline ( always ) ] pub fn is_nmuxen_0 ( & self ) -> bool { * self == NMUXEN_A :: NMUXEN_0 } # [ doc = "Checks if the value of the field is `NMUXEN_1`" ] # [ inline ( always ) ] pub fn is_nmuxen_1 ( & self ) -> bool { * self == NMUXEN_A :: NMUXEN_1 } }
# [ doc = "Write proxy for field `NMUXEN`" ] pub struct NMUXEN_W < 'a > { w : & 'a mut W , } impl < 'a > NMUXEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NMUXEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "All negative input sources are disconnected to OA negative port" ] # [ inline ( always ) ] pub fn nmuxen_0 ( self ) -> & 'a mut W { self . variant ( NMUXEN_A :: NMUXEN_0 ) } # [ doc = "All negative input sources are connected to OA negative port" ] # [ inline ( always ) ] pub fn nmuxen_1 ( self ) -> & 'a mut W { self . variant ( NMUXEN_A :: NMUXEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "SAC OA Enable selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OAEN_A { # [ doc = "0: SAC OA is disabled, then the SAC OA output high impedance" ] OAEN_0 = 0 , # [ doc = "1: SAC OA is enabled, normal mode" ] OAEN_1 = 1 } impl From < OAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : OAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OAEN`" ] pub type OAEN_R = crate :: R < bool , OAEN_A > ; impl OAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OAEN_A { match self . bits { false => OAEN_A :: OAEN_0 , true => OAEN_A :: OAEN_1 } } # [ doc = "Checks if the value of the field is `OAEN_0`" ] # [ inline ( always ) ] pub fn is_oaen_0 ( & self ) -> bool { * self == OAEN_A :: OAEN_0 } # [ doc = "Checks if the value of the field is `OAEN_1`" ] # [ inline ( always ) ] pub fn is_oaen_1 ( & self ) -> bool { * self == OAEN_A :: OAEN_1 } }
# [ doc = "Write proxy for field `OAEN`" ] pub struct OAEN_W < 'a > { w : & 'a mut W , } impl < 'a > OAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SAC OA is disabled, then the SAC OA output high impedance" ] # [ inline ( always ) ] pub fn oaen_0 ( self ) -> & 'a mut W { self . variant ( OAEN_A :: OAEN_0 ) } # [ doc = "SAC OA is enabled, normal mode" ] # [ inline ( always ) ] pub fn oaen_1 ( self ) -> & 'a mut W { self . variant ( OAEN_A :: OAEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "SAC OA power mode selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OAPM_A { # [ doc = "0: High speed and high power" ] OAPM_0 = 0 , # [ doc = "1: Llow speed and low power" ] OAPM_1 = 1 } impl From < OAPM_A > for bool { # [ inline ( always ) ] fn from ( variant : OAPM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OAPM`" ] pub type OAPM_R = crate :: R < bool , OAPM_A > ; impl OAPM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OAPM_A { match self . bits { false => OAPM_A :: OAPM_0 , true => OAPM_A :: OAPM_1 } } # [ doc = "Checks if the value of the field is `OAPM_0`" ] # [ inline ( always ) ] pub fn is_oapm_0 ( & self ) -> bool { * self == OAPM_A :: OAPM_0 } # [ doc = "Checks if the value of the field is `OAPM_1`" ] # [ inline ( always ) ] pub fn is_oapm_1 ( & self ) -> bool { * self == OAPM_A :: OAPM_1 } }
# [ doc = "Write proxy for field `OAPM`" ] pub struct OAPM_W < 'a > { w : & 'a mut W , } impl < 'a > OAPM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OAPM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "High speed and high power" ] # [ inline ( always ) ] pub fn oapm_0 ( self ) -> & 'a mut W { self . variant ( OAPM_A :: OAPM_0 ) } # [ doc = "Llow speed and low power" ] # [ inline ( always ) ] pub fn oapm_1 ( self ) -> & 'a mut W { self . variant ( OAPM_A :: OAPM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "SAC Enable selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SACEN_A { # [ doc = "0: SAC all modules are disabled, then the SAC output high impedance" ] SACEN_0 = 0 , # [ doc = "1: SAC all modules are enabled, normal mode" ] SACEN_1 = 1 } impl From < SACEN_A > for bool { # [ inline ( always ) ] fn from ( variant : SACEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SACEN`" ] pub type SACEN_R = crate :: R < bool , SACEN_A > ; impl SACEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SACEN_A { match self . bits { false => SACEN_A :: SACEN_0 , true => SACEN_A :: SACEN_1 } } # [ doc = "Checks if the value of the field is `SACEN_0`" ] # [ inline ( always ) ] pub fn is_sacen_0 ( & self ) -> bool { * self == SACEN_A :: SACEN_0 } # [ doc = "Checks if the value of the field is `SACEN_1`" ] # [ inline ( always ) ] pub fn is_sacen_1 ( & self ) -> bool { * self == SACEN_A :: SACEN_1 } }
# [ doc = "Write proxy for field `SACEN`" ] pub struct SACEN_W < 'a > { w : & 'a mut W , } impl < 'a > SACEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SACEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SAC all modules are disabled, then the SAC output high impedance" ] # [ inline ( always ) ] pub fn sacen_0 ( self ) -> & 'a mut W { self . variant ( SACEN_A :: SACEN_0 ) } # [ doc = "SAC all modules are enabled, normal mode" ] # [ inline ( always ) ] pub fn sacen_1 ( self ) -> & 'a mut W { self . variant ( SACEN_A :: SACEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - SAC OA Positive input source selection" ] # [ inline ( always ) ] pub fn psel ( & self ) -> PSEL_R { PSEL_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bit 3 - SAC Positive input MUX control." ] # [ inline ( always ) ] pub fn pmuxen ( & self ) -> PMUXEN_R { PMUXEN_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - SAC OA Negative input source selection" ] # [ inline ( always ) ] pub fn nsel ( & self ) -> NSEL_R { NSEL_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 7 - SAC Negative input MUX controL" ] # [ inline ( always ) ] pub fn nmuxen ( & self ) -> NMUXEN_R { NMUXEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - SAC OA Enable selection" ] # [ inline ( always ) ] pub fn oaen ( & self ) -> OAEN_R { OAEN_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - SAC OA power mode selection" ] # [ inline ( always ) ] pub fn oapm ( & self ) -> OAPM_R { OAPM_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - SAC Enable selection" ] # [ inline ( always ) ] pub fn sacen ( & self ) -> SACEN_R { SACEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:1 - SAC OA Positive input source selection" ] # [ inline ( always ) ] pub fn psel ( & mut self ) -> PSEL_W { PSEL_W { w : self } }
# [ doc = "Bit 3 - SAC Positive input MUX control." ] # [ inline ( always ) ] pub fn pmuxen ( & mut self ) -> PMUXEN_W { PMUXEN_W { w : self } }
# [ doc = "Bits 4:5 - SAC OA Negative input source selection" ] # [ inline ( always ) ] pub fn nsel ( & mut self ) -> NSEL_W { NSEL_W { w : self } }
# [ doc = "Bit 7 - SAC Negative input MUX controL" ] # [ inline ( always ) ] pub fn nmuxen ( & mut self ) -> NMUXEN_W { NMUXEN_W { w : self } }
# [ doc = "Bit 8 - SAC OA Enable selection" ] # [ inline ( always ) ] pub fn oaen ( & mut self ) -> OAEN_W { OAEN_W { w : self } }
# [ doc = "Bit 9 - SAC OA power mode selection" ] # [ inline ( always ) ] pub fn oapm ( & mut self ) -> OAPM_W { OAPM_W { w : self } }
# [ doc = "Bit 10 - SAC Enable selection" ] # [ inline ( always ) ] pub fn sacen ( & mut self ) -> SACEN_W { SACEN_W { w : self } }
}
}
# [ doc = "SAC PGA Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac3pga](sac3pga) module" ] pub type SAC3PGA = crate :: Reg < u16 , _SAC3PGA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC3PGA ;
# [ doc = "`read()` method returns [sac3pga::R](sac3pga::R) reader structure" ] impl crate :: Readable for SAC3PGA { }
# [ doc = "`write(|w| ..)` method takes [sac3pga::W](sac3pga::W) writer structure" ] impl crate :: Writable for SAC3PGA { }
# [ doc = "SAC PGA Control Register" ] pub mod sac3pga {
# [ doc = "Reader of register SAC3PGA" ] pub type R = crate :: R < u16 , super :: SAC3PGA > ;
# [ doc = "Writer for register SAC3PGA" ] pub type W = crate :: W < u16 , super :: SAC3PGA > ;
# [ doc = "Register SAC3PGA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC3PGA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC PGA Mode Selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum MSEL_A { # [ doc = "0: Inverting PGA mode (external pad IN- is selected)" ] MSEL_0 = 0 , # [ doc = "1: Buffer mode (floating is selected )" ] MSEL_1 = 1 , # [ doc = "2: Non-inverting mode" ] MSEL_2 = 2 , # [ doc = "3: Cascade OA Inverting mode" ] MSEL_3 = 3 } impl From < MSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : MSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `MSEL`" ] pub type MSEL_R = crate :: R < u8 , MSEL_A > ; impl MSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MSEL_A { match self . bits { 0 => MSEL_A :: MSEL_0 , 1 => MSEL_A :: MSEL_1 , 2 => MSEL_A :: MSEL_2 , 3 => MSEL_A :: MSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `MSEL_0`" ] # [ inline ( always ) ] pub fn is_msel_0 ( & self ) -> bool { * self == MSEL_A :: MSEL_0 } # [ doc = "Checks if the value of the field is `MSEL_1`" ] # [ inline ( always ) ] pub fn is_msel_1 ( & self ) -> bool { * self == MSEL_A :: MSEL_1 } # [ doc = "Checks if the value of the field is `MSEL_2`" ] # [ inline ( always ) ] pub fn is_msel_2 ( & self ) -> bool { * self == MSEL_A :: MSEL_2 } # [ doc = "Checks if the value of the field is `MSEL_3`" ] # [ inline ( always ) ] pub fn is_msel_3 ( & self ) -> bool { * self == MSEL_A :: MSEL_3 } }
# [ doc = "Write proxy for field `MSEL`" ] pub struct MSEL_W < 'a > { w : & 'a mut W , } impl < 'a > MSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Inverting PGA mode (external pad IN- is selected)" ] # [ inline ( always ) ] pub fn msel_0 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_0 ) } # [ doc = "Buffer mode (floating is selected )" ] # [ inline ( always ) ] pub fn msel_1 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_1 ) } # [ doc = "Non-inverting mode" ] # [ inline ( always ) ] pub fn msel_2 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_2 ) } # [ doc = "Cascade OA Inverting mode" ] # [ inline ( always ) ] pub fn msel_3 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `GAIN`" ] pub type GAIN_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `GAIN`" ] pub struct GAIN_W < 'a > { w : & 'a mut W , } impl < 'a > GAIN_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 4 ) ) | ( ( ( value as u16 ) & 0x07 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - SAC PGA Mode Selection" ] # [ inline ( always ) ] pub fn msel ( & self ) -> MSEL_R { MSEL_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 4:6 - SAC PGA Gain configuration" ] # [ inline ( always ) ] pub fn gain ( & self ) -> GAIN_R { GAIN_R :: new ( ( ( self . bits >> 4 ) & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - SAC PGA Mode Selection" ] # [ inline ( always ) ] pub fn msel ( & mut self ) -> MSEL_W { MSEL_W { w : self } }
# [ doc = "Bits 4:6 - SAC PGA Gain configuration" ] # [ inline ( always ) ] pub fn gain ( & mut self ) -> GAIN_W { GAIN_W { w : self } }
}
}
# [ doc = "SAC DAC Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac3dac](sac3dac) module" ] pub type SAC3DAC = crate :: Reg < u16 , _SAC3DAC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC3DAC ;
# [ doc = "`read()` method returns [sac3dac::R](sac3dac::R) reader structure" ] impl crate :: Readable for SAC3DAC { }
# [ doc = "`write(|w| ..)` method takes [sac3dac::W](sac3dac::W) writer structure" ] impl crate :: Writable for SAC3DAC { }
# [ doc = "SAC DAC Control Register" ] pub mod sac3dac {
# [ doc = "Reader of register SAC3DAC" ] pub type R = crate :: R < u16 , super :: SAC3DAC > ;
# [ doc = "Writer for register SAC3DAC" ] pub type W = crate :: W < u16 , super :: SAC3DAC > ;
# [ doc = "Register SAC3DAC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC3DAC { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC DAC enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACEN_A { # [ doc = "0: Disabled" ] DACEN_0 = 0 , # [ doc = "1: Enabled" ] DACEN_1 = 1 } impl From < DACEN_A > for bool { # [ inline ( always ) ] fn from ( variant : DACEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACEN`" ] pub type DACEN_R = crate :: R < bool , DACEN_A > ; impl DACEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACEN_A { match self . bits { false => DACEN_A :: DACEN_0 , true => DACEN_A :: DACEN_1 } } # [ doc = "Checks if the value of the field is `DACEN_0`" ] # [ inline ( always ) ] pub fn is_dacen_0 ( & self ) -> bool { * self == DACEN_A :: DACEN_0 } # [ doc = "Checks if the value of the field is `DACEN_1`" ] # [ inline ( always ) ] pub fn is_dacen_1 ( & self ) -> bool { * self == DACEN_A :: DACEN_1 } }
# [ doc = "Write proxy for field `DACEN`" ] pub struct DACEN_W < 'a > { w : & 'a mut W , } impl < 'a > DACEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn dacen_0 ( self ) -> & 'a mut W { self . variant ( DACEN_A :: DACEN_0 ) } # [ doc = "Enabled" ] # [ inline ( always ) ] pub fn dacen_1 ( self ) -> & 'a mut W { self . variant ( DACEN_A :: DACEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "SAC DAC interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACIE_A { # [ doc = "0: Disabled" ] DACIE_0 = 0 , # [ doc = "1: Enabled" ] DACIE_1 = 1 } impl From < DACIE_A > for bool { # [ inline ( always ) ] fn from ( variant : DACIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACIE`" ] pub type DACIE_R = crate :: R < bool , DACIE_A > ; impl DACIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACIE_A { match self . bits { false => DACIE_A :: DACIE_0 , true => DACIE_A :: DACIE_1 } } # [ doc = "Checks if the value of the field is `DACIE_0`" ] # [ inline ( always ) ] pub fn is_dacie_0 ( & self ) -> bool { * self == DACIE_A :: DACIE_0 } # [ doc = "Checks if the value of the field is `DACIE_1`" ] # [ inline ( always ) ] pub fn is_dacie_1 ( & self ) -> bool { * self == DACIE_A :: DACIE_1 } }
# [ doc = "Write proxy for field `DACIE`" ] pub struct DACIE_W < 'a > { w : & 'a mut W , } impl < 'a > DACIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn dacie_0 ( self ) -> & 'a mut W { self . variant ( DACIE_A :: DACIE_0 ) } # [ doc = "Enabled" ] # [ inline ( always ) ] pub fn dacie_1 ( self ) -> & 'a mut W { self . variant ( DACIE_A :: DACIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "SAC DAC DMA request enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACDMAE_A { # [ doc = "0: DMA request disabled" ] DACDMAE_0 = 0 , # [ doc = "1: DMA request enabled" ] DACDMAE_1 = 1 } impl From < DACDMAE_A > for bool { # [ inline ( always ) ] fn from ( variant : DACDMAE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACDMAE`" ] pub type DACDMAE_R = crate :: R < bool , DACDMAE_A > ; impl DACDMAE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACDMAE_A { match self . bits { false => DACDMAE_A :: DACDMAE_0 , true => DACDMAE_A :: DACDMAE_1 } } # [ doc = "Checks if the value of the field is `DACDMAE_0`" ] # [ inline ( always ) ] pub fn is_dacdmae_0 ( & self ) -> bool { * self == DACDMAE_A :: DACDMAE_0 } # [ doc = "Checks if the value of the field is `DACDMAE_1`" ] # [ inline ( always ) ] pub fn is_dacdmae_1 ( & self ) -> bool { * self == DACDMAE_A :: DACDMAE_1 } }
# [ doc = "Write proxy for field `DACDMAE`" ] pub struct DACDMAE_W < 'a > { w : & 'a mut W , } impl < 'a > DACDMAE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACDMAE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "DMA request disabled" ] # [ inline ( always ) ] pub fn dacdmae_0 ( self ) -> & 'a mut W { self . variant ( DACDMAE_A :: DACDMAE_0 ) } # [ doc = "DMA request enabled" ] # [ inline ( always ) ] pub fn dacdmae_1 ( self ) -> & 'a mut W { self . variant ( DACDMAE_A :: DACDMAE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "SAC DAC load select. Selects the load trigger for the DAC latch.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum DACLSEL_A { # [ doc = "0: DAC latch loads when DACDAT written" ] DACLSEL_0 = 0 , # [ doc = "2: Device specific 0. DAC always loads data from DACDAT at the positive edge of this signal" ] DACLSEL_2 = 2 , # [ doc = "3: Device specific 1. DAC always loads data from DACDAT at the positive edge of this signal" ] DACLSEL_3 = 3 } impl From < DACLSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : DACLSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `DACLSEL`" ] pub type DACLSEL_R = crate :: R < u8 , DACLSEL_A > ; impl DACLSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , DACLSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( DACLSEL_A :: DACLSEL_0 ) , 2 => Val ( DACLSEL_A :: DACLSEL_2 ) , 3 => Val ( DACLSEL_A :: DACLSEL_3 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DACLSEL_0`" ] # [ inline ( always ) ] pub fn is_daclsel_0 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_0 } # [ doc = "Checks if the value of the field is `DACLSEL_2`" ] # [ inline ( always ) ] pub fn is_daclsel_2 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_2 } # [ doc = "Checks if the value of the field is `DACLSEL_3`" ] # [ inline ( always ) ] pub fn is_daclsel_3 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_3 } }
# [ doc = "Write proxy for field `DACLSEL`" ] pub struct DACLSEL_W < 'a > { w : & 'a mut W , } impl < 'a > DACLSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACLSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "DAC latch loads when DACDAT written" ] # [ inline ( always ) ] pub fn daclsel_0 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_0 ) } # [ doc = "Device specific 0. DAC always loads data from DACDAT at the positive edge of this signal" ] # [ inline ( always ) ] pub fn daclsel_2 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_2 ) } # [ doc = "Device specific 1. DAC always loads data from DACDAT at the positive edge of this signal" ] # [ inline ( always ) ] pub fn daclsel_3 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "SAC DAC select reference voltage\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACSREF_A { # [ doc = "0: AVCC" ] DACSREF_0 = 0 , # [ doc = "1: Alternative reference" ] DACSREF_1 = 1 } impl From < DACSREF_A > for bool { # [ inline ( always ) ] fn from ( variant : DACSREF_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACSREF`" ] pub type DACSREF_R = crate :: R < bool , DACSREF_A > ; impl DACSREF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACSREF_A { match self . bits { false => DACSREF_A :: DACSREF_0 , true => DACSREF_A :: DACSREF_1 } } # [ doc = "Checks if the value of the field is `DACSREF_0`" ] # [ inline ( always ) ] pub fn is_dacsref_0 ( & self ) -> bool { * self == DACSREF_A :: DACSREF_0 } # [ doc = "Checks if the value of the field is `DACSREF_1`" ] # [ inline ( always ) ] pub fn is_dacsref_1 ( & self ) -> bool { * self == DACSREF_A :: DACSREF_1 } }
# [ doc = "Write proxy for field `DACSREF`" ] pub struct DACSREF_W < 'a > { w : & 'a mut W , } impl < 'a > DACSREF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACSREF_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "AVCC" ] # [ inline ( always ) ] pub fn dacsref_0 ( self ) -> & 'a mut W { self . variant ( DACSREF_A :: DACSREF_0 ) } # [ doc = "Alternative reference" ] # [ inline ( always ) ] pub fn dacsref_1 ( self ) -> & 'a mut W { self . variant ( DACSREF_A :: DACSREF_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - SAC DAC enable" ] # [ inline ( always ) ] pub fn dacen ( & self ) -> DACEN_R { DACEN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - SAC DAC interrupt enable" ] # [ inline ( always ) ] pub fn dacie ( & self ) -> DACIE_R { DACIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - SAC DAC DMA request enable" ] # [ inline ( always ) ] pub fn dacdmae ( & self ) -> DACDMAE_R { DACDMAE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:9 - SAC DAC load select. Selects the load trigger for the DAC latch." ] # [ inline ( always ) ] pub fn daclsel ( & self ) -> DACLSEL_R { DACLSEL_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 12 - SAC DAC select reference voltage" ] # [ inline ( always ) ] pub fn dacsref ( & self ) -> DACSREF_R { DACSREF_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - SAC DAC enable" ] # [ inline ( always ) ] pub fn dacen ( & mut self ) -> DACEN_W { DACEN_W { w : self } }
# [ doc = "Bit 1 - SAC DAC interrupt enable" ] # [ inline ( always ) ] pub fn dacie ( & mut self ) -> DACIE_W { DACIE_W { w : self } }
# [ doc = "Bit 2 - SAC DAC DMA request enable" ] # [ inline ( always ) ] pub fn dacdmae ( & mut self ) -> DACDMAE_W { DACDMAE_W { w : self } }
# [ doc = "Bits 8:9 - SAC DAC load select. Selects the load trigger for the DAC latch." ] # [ inline ( always ) ] pub fn daclsel ( & mut self ) -> DACLSEL_W { DACLSEL_W { w : self } }
# [ doc = "Bit 12 - SAC DAC select reference voltage" ] # [ inline ( always ) ] pub fn dacsref ( & mut self ) -> DACSREF_W { DACSREF_W { w : self } }
}
}
# [ doc = "SAC DAC Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac3dat](sac3dat) module" ] pub type SAC3DAT = crate :: Reg < u16 , _SAC3DAT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC3DAT ;
# [ doc = "`read()` method returns [sac3dat::R](sac3dat::R) reader structure" ] impl crate :: Readable for SAC3DAT { }
# [ doc = "`write(|w| ..)` method takes [sac3dat::W](sac3dat::W) writer structure" ] impl crate :: Writable for SAC3DAT { }
# [ doc = "SAC DAC Data Register" ] pub mod sac3dat {
# [ doc = "Reader of register SAC3DAT" ] pub type R = crate :: R < u16 , super :: SAC3DAT > ;
# [ doc = "Writer for register SAC3DAT" ] pub type W = crate :: W < u16 , super :: SAC3DAT > ;
# [ doc = "Register SAC3DAT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC3DAT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DACData`" ] pub type DACDATA_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `DACData`" ] pub struct DACDATA_W < 'a > { w : & 'a mut W , } impl < 'a > DACDATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0fff ) | ( ( value as u16 ) & 0x0fff ) ; self . w } }
impl R {
# [ doc = "Bits 0:11 - SAC DAC data in unsigned format." ] # [ inline ( always ) ] pub fn dacdata ( & self ) -> DACDATA_R { DACDATA_R :: new ( ( self . bits & 0x0fff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:11 - SAC DAC data in unsigned format." ] # [ inline ( always ) ] pub fn dacdata ( & mut self ) -> DACDATA_W { DACDATA_W { w : self } }
}
}
# [ doc = "SAC DAC Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac3dacsts](sac3dacsts) module" ] pub type SAC3DACSTS = crate :: Reg < u16 , _SAC3DACSTS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC3DACSTS ;
# [ doc = "`read()` method returns [sac3dacsts::R](sac3dacsts::R) reader structure" ] impl crate :: Readable for SAC3DACSTS { }
# [ doc = "`write(|w| ..)` method takes [sac3dacsts::W](sac3dacsts::W) writer structure" ] impl crate :: Writable for SAC3DACSTS { }
# [ doc = "SAC DAC Status Register" ] pub mod sac3dacsts {
# [ doc = "Reader of register SAC3DACSTS" ] pub type R = crate :: R < u16 , super :: SAC3DACSTS > ;
# [ doc = "Writer for register SAC3DACSTS" ] pub type W = crate :: W < u16 , super :: SAC3DACSTS > ;
# [ doc = "Register SAC3DACSTS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC3DACSTS { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DACIFG`" ] pub type DACIFG_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DACIFG`" ] pub struct DACIFG_W < 'a > { w : & 'a mut W , } impl < 'a > DACIFG_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - SAC DAC data update flag" ] # [ inline ( always ) ] pub fn dacifg ( & self ) -> DACIFG_R { DACIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - SAC DAC data update flag" ] # [ inline ( always ) ] pub fn dacifg ( & mut self ) -> DACIFG_W { DACIFG_W { w : self } }
}
}
# [ doc = "SAC Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac3iv](sac3iv) module" ] pub type SAC3IV = crate :: Reg < u16 , _SAC3IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC3IV ;
# [ doc = "`read()` method returns [sac3iv::R](sac3iv::R) reader structure" ] impl crate :: Readable for SAC3IV { }
# [ doc = "SAC Interrupt Vector Register" ] pub mod sac3iv {
# [ doc = "Reader of register SAC3IV" ] pub type R = crate :: R < u16 , super :: SAC3IV > ;
# [ doc = "SAC Interrupt Vector Register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum SACIV3_A { # [ doc = "0: No interrupt pending" ] SACIV_0 = 0 , # [ doc = "2: S&H completed interrupt flag (Highest priority)" ] SACIV_2 = 2 , # [ doc = "4: DAC channel update interrupt flag" ] SACIV_4 = 4 } impl From < SACIV3_A > for u16 { # [ inline ( always ) ] fn from ( variant : SACIV3_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `SACIV3`" ] pub type SACIV3_R = crate :: R < u16 , SACIV3_A > ; impl SACIV3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , SACIV3_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SACIV3_A :: SACIV_0 ) , 2 => Val ( SACIV3_A :: SACIV_2 ) , 4 => Val ( SACIV3_A :: SACIV_4 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `SACIV_0`" ] # [ inline ( always ) ] pub fn is_saciv_0 ( & self ) -> bool { * self == SACIV3_A :: SACIV_0 } # [ doc = "Checks if the value of the field is `SACIV_2`" ] # [ inline ( always ) ] pub fn is_saciv_2 ( & self ) -> bool { * self == SACIV3_A :: SACIV_2 } # [ doc = "Checks if the value of the field is `SACIV_4`" ] # [ inline ( always ) ] pub fn is_saciv_4 ( & self ) -> bool { * self == SACIV3_A :: SACIV_4 } }
impl R {
# [ doc = "Bits 0:15 - SAC Interrupt Vector Register" ] # [ inline ( always ) ] pub fn saciv3 ( & self ) -> SACIV3_R { SACIV3_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ no_mangle ] static mut DEVICE_PERIPHERALS : bool = false ; # [ doc = r"All the peripherals" ] # [ allow ( non_snake_case ) ] pub struct Peripherals { # [ doc = "P1" ] pub P1 : P1 , # [ doc = "P2" ] pub P2 : P2 , # [ doc = "P3" ] pub P3 : P3 , # [ doc = "P4" ] pub P4 : P4 , # [ doc = "P5" ] pub P5 : P5 , # [ doc = "P6" ] pub P6 : P6 , # [ doc = "TB0" ] pub TB0 : TB0 , # [ doc = "TB1" ] pub TB1 : TB1 , # [ doc = "TB2" ] pub TB2 : TB2 , # [ doc = "TB3" ] pub TB3 : TB3 , # [ doc = "MPY32" ] pub MPY32 : MPY32 , # [ doc = "E_USCI_A0" ] pub E_USCI_A0 : E_USCI_A0 , # [ doc = "E_USCI_B0" ] pub E_USCI_B0 : E_USCI_B0 , # [ doc = "E_USCI_A1" ] pub E_USCI_A1 : E_USCI_A1 , # [ doc = "E_USCI_B1" ] pub E_USCI_B1 : E_USCI_B1 , # [ doc = "BKMEM" ] pub BKMEM : BKMEM , # [ doc = "ICC" ] pub ICC : ICC , # [ doc = "ADC" ] pub ADC : ADC , # [ doc = "E_COMP0" ] pub E_COMP0 : E_COMP0 , # [ doc = "E_COMP1" ] pub E_COMP1 : E_COMP1 , # [ doc = "SAC0" ] pub SAC0 : SAC0 , # [ doc = "SAC1" ] pub SAC1 : SAC1 , # [ doc = "SAC2" ] pub SAC2 : SAC2 , # [ doc = "SAC3" ] pub SAC3 : SAC3 , } impl Peripherals { # [ doc = r"Returns all the peripherals *once*" ] # [ inline ] pub fn take ( ) -> Option < Self > { msp430 :: interrupt :: free ( | _ | { if unsafe { DEVICE_PERIPHERALS } { None } else { Some ( unsafe { Peripherals :: steal ( ) } ) } } ) } # [ doc = r"Unchecked version of `Peripherals::take`" ] # [ inline ] pub unsafe fn steal ( ) -> Self { DEVICE_PERIPHERALS = true ; Peripherals { P1 : P1 { _marker : PhantomData } , P2 : P2 { _marker : PhantomData } , P3 : P3 { _marker : PhantomData } , P4 : P4 { _marker : PhantomData } , P5 : P5 { _marker : PhantomData } , P6 : P6 { _marker : PhantomData } , TB0 : TB0 { _marker : PhantomData } , TB1 : TB1 { _marker : PhantomData } , TB2 : TB2 { _marker : PhantomData } , TB3 : TB3 { _marker : PhantomData } , MPY32 : MPY32 { _marker : PhantomData } , E_USCI_A0 : E_USCI_A0 { _marker : PhantomData } , E_USCI_B0 : E_USCI_B0 { _marker : PhantomData } , E_USCI_A1 : E_USCI_A1 { _marker : PhantomData } , E_USCI_B1 : E_USCI_B1 { _marker : PhantomData } , BKMEM : BKMEM { _marker : PhantomData } , ICC : ICC { _marker : PhantomData } , ADC : ADC { _marker : PhantomData } , E_COMP0 : E_COMP0 { _marker : PhantomData } , E_COMP1 : E_COMP1 { _marker : PhantomData } , SAC0 : SAC0 { _marker : PhantomData } , SAC1 : SAC1 { _marker : PhantomData } , SAC2 : SAC2 { _marker : PhantomData } , SAC3 : SAC3 { _marker : PhantomData } , } } }
