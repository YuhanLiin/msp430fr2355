# ! [ feature ( abi_msp430_interrupt ) ]
# ! [ doc = "Peripheral access API for MSP430FR2355 microcontrollers (generated using svd2rust v0.17.0)\n\nYou can find an overview of the API [here].\n\n[here]: https://docs.rs/svd2rust/0.17.0/svd2rust/#peripheral-api" ] # ! [ deny ( const_err ) ] # ! [ deny ( dead_code ) ] # ! [ deny ( improper_ctypes ) ] # ! [ deny ( legacy_directory_ownership ) ] # ! [ deny ( missing_docs ) ] # ! [ deny ( no_mangle_generic_items ) ] # ! [ deny ( non_shorthand_field_patterns ) ] # ! [ deny ( overflowing_literals ) ] # ! [ deny ( path_statements ) ] # ! [ deny ( patterns_in_fns_without_body ) ] # ! [ deny ( plugin_as_library ) ] # ! [ deny ( private_in_public ) ] # ! [ deny ( safe_extern_statics ) ] # ! [ deny ( unconditional_recursion ) ] # ! [ deny ( unions_with_drop_fields ) ] # ! [ deny ( unused_allocation ) ] # ! [ deny ( unused_comparisons ) ] # ! [ deny ( unused_parens ) ] # ! [ deny ( while_true ) ] # ! [ allow ( non_camel_case_types ) ] # ! [ allow ( non_snake_case ) ] # ! [ no_std ]
extern crate msp430 ; # [ cfg ( feature = "rt" ) ] extern crate msp430_rt ;
extern crate bare_metal ; extern crate vcell ; use core :: ops :: Deref ; use core :: marker :: PhantomData ;
# [ cfg ( feature = "rt" ) ] extern "msp430-interrupt" { fn PORT4 ( ) ; fn PORT3 ( ) ; fn PORT2 ( ) ; fn PORT1 ( ) ; fn SAC1_SAC3 ( ) ; fn SAC0_SAC2 ( ) ; fn ECOMP0_ECOMP1 ( ) ; fn ADC ( ) ; fn EUSCI_B1 ( ) ; fn EUSCI_B0 ( ) ; fn EUSCI_A1 ( ) ; fn EUSCI_A0 ( ) ; fn WDT ( ) ; fn RTC ( ) ; fn TIMER3_B1 ( ) ; fn TIMER3_B0 ( ) ; fn TIMER2_B1 ( ) ; fn TIMER2_B0 ( ) ; fn TIMER1_B1 ( ) ; fn TIMER1_B0 ( ) ; fn TIMER0_B1 ( ) ; fn TIMER0_B0 ( ) ; fn UNMI ( ) ; fn SYSNMI ( ) ; } # [ doc ( hidden ) ] pub union Vector { _handler : unsafe extern "msp430-interrupt" fn ( ) , _reserved : u16 , } # [ cfg ( feature = "rt" ) ] # [ doc ( hidden ) ] # [ link_section = ".vector_table.interrupts" ] # [ no_mangle ] # [ used ] pub static __INTERRUPTS : [ Vector ; 45 ] = [ Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _handler : PORT4 } , Vector { _handler : PORT3 } , Vector { _handler : PORT2 } , Vector { _handler : PORT1 } , Vector { _handler : SAC1_SAC3 } , Vector { _handler : SAC0_SAC2 } , Vector { _handler : ECOMP0_ECOMP1 } , Vector { _handler : ADC } , Vector { _handler : EUSCI_B1 } , Vector { _handler : EUSCI_B0 } , Vector { _handler : EUSCI_A1 } , Vector { _handler : EUSCI_A0 } , Vector { _handler : WDT } , Vector { _handler : RTC } , Vector { _handler : TIMER3_B1 } , Vector { _handler : TIMER3_B0 } , Vector { _handler : TIMER2_B1 } , Vector { _handler : TIMER2_B0 } , Vector { _handler : TIMER1_B1 } , Vector { _handler : TIMER1_B0 } , Vector { _handler : TIMER0_B1 } , Vector { _handler : TIMER0_B0 } , Vector { _handler : UNMI } , Vector { _handler : SYSNMI } , ] ;
# [ doc = r"Enumeration of all the interrupts" ] # [ derive ( Copy , Clone , Debug ) ] pub enum Interrupt { # [ doc = "21 - 0xFFCE" ] PORT4 , # [ doc = "22 - 0xFFD0" ] PORT3 , # [ doc = "23 - 0xFFD2" ] PORT2 , # [ doc = "24 - 0xFFD4" ] PORT1 , # [ doc = "25 - 0xFFD6" ] SAC1_SAC3 , # [ doc = "26 - 0xFFD8" ] SAC0_SAC2 , # [ doc = "27 - 0xFFDA" ] ECOMP0_ECOMP1 , # [ doc = "28 - 0xFFDC" ] ADC , # [ doc = "29 - 0xFFDE" ] EUSCI_B1 , # [ doc = "30 - 0xFFE0" ] EUSCI_B0 , # [ doc = "31 - 0xFFE2" ] EUSCI_A1 , # [ doc = "32 - 0xFFE4" ] EUSCI_A0 , # [ doc = "33 - 0xFFE6" ] WDT , # [ doc = "34 - 0xFFE8" ] RTC , # [ doc = "35 - 0xFFEA" ] TIMER3_B1 , # [ doc = "36 - 0xFFEC" ] TIMER3_B0 , # [ doc = "37 - 0xFFEE" ] TIMER2_B1 , # [ doc = "38 - 0xFFF0" ] TIMER2_B0 , # [ doc = "39 - 0xFFF2" ] TIMER1_B1 , # [ doc = "40 - 0xFFF4" ] TIMER1_B0 , # [ doc = "41 - 0xFFF6" ] TIMER0_B1 , # [ doc = "42 - 0xFFF8" ] TIMER0_B0 , # [ doc = "43 - 0xFFFA" ] UNMI , # [ doc = "44 - 0xFFFC" ] SYSNMI , } unsafe impl bare_metal :: Nr for Interrupt { # [ inline ] fn nr ( & self ) -> u8 { match * self { Interrupt :: PORT4 => 21 , Interrupt :: PORT3 => 22 , Interrupt :: PORT2 => 23 , Interrupt :: PORT1 => 24 , Interrupt :: SAC1_SAC3 => 25 , Interrupt :: SAC0_SAC2 => 26 , Interrupt :: ECOMP0_ECOMP1 => 27 , Interrupt :: ADC => 28 , Interrupt :: EUSCI_B1 => 29 , Interrupt :: EUSCI_B0 => 30 , Interrupt :: EUSCI_A1 => 31 , Interrupt :: EUSCI_A0 => 32 , Interrupt :: WDT => 33 , Interrupt :: RTC => 34 , Interrupt :: TIMER3_B1 => 35 , Interrupt :: TIMER3_B0 => 36 , Interrupt :: TIMER2_B1 => 37 , Interrupt :: TIMER2_B0 => 38 , Interrupt :: TIMER1_B1 => 39 , Interrupt :: TIMER1_B0 => 40 , Interrupt :: TIMER0_B1 => 41 , Interrupt :: TIMER0_B0 => 42 , Interrupt :: UNMI => 43 , Interrupt :: SYSNMI => 44 , } } }
# [ cfg ( feature = "rt" ) ] pub use msp430_rt :: interrupt ; # [ cfg ( feature = "rt" ) ] pub use self :: Interrupt as interrupt ;
# [ allow ( unused_imports ) ] use generic :: * ; # [ doc = r"Common register and bit access and modify traits" ] pub mod generic { use core :: marker ; # [ doc = "This trait shows that register has `read` method" ] # [ doc = "" ] # [ doc = "Registers marked with `Writable` can be also `modify`'ed" ] pub trait Readable { } # [ doc = "This trait shows that register has `write`, `write_with_zero` and `reset` method" ] # [ doc = "" ] # [ doc = "Registers marked with `Readable` can be also `modify`'ed" ] pub trait Writable { } # [ doc = "Reset value of the register" ] # [ doc = "" ] # [ doc = "This value is initial value for `write` method." ] # [ doc = "It can be also directly writed to register by `reset` method." ] pub trait ResetValue { # [ doc = "Register size" ] type Type ; # [ doc = "Reset value of the register" ] fn reset_value ( ) -> Self :: Type ; } # [ doc = "This structure provides volatile access to register" ] pub struct Reg < U , REG > { register : vcell :: VolatileCell < U > , _marker : marker :: PhantomData < REG > , } unsafe impl < U : Send , REG > Send for Reg < U , REG > { } impl < U , REG > Reg < U , REG > where Self : Readable , U : Copy { # [ doc = "Reads the contents of `Readable` register" ] # [ doc = "" ] # [ doc = "You can read the contents of a register in such way:" ] # [ doc = "```ignore" ] # [ doc = "let bits = periph.reg.read().bits();" ] # [ doc = "```" ] # [ doc = "or get the content of a particular field of a register." ] # [ doc = "```ignore" ] # [ doc = "let reader = periph.reg.read();" ] # [ doc = "let bits = reader.field1().bits();" ] # [ doc = "let flag = reader.field2().bit_is_set();" ] # [ doc = "```" ] # [ inline ( always ) ] pub fn read ( & self ) -> R < U , Self > { R { bits : self . register . get ( ) , _reg : marker :: PhantomData } } } impl < U , REG > Reg < U , REG > where Self : ResetValue < Type = U > + Writable , U : Copy , { # [ doc = "Writes the reset value to `Writable` register" ] # [ doc = "" ] # [ doc = "Resets the register to its initial state" ] # [ inline ( always ) ] pub fn reset ( & self ) { self . register . set ( Self :: reset_value ( ) ) } } impl < U , REG > Reg < U , REG > where Self : ResetValue < Type = U > + Writable , U : Copy { # [ doc = "Writes bits to `Writable` register" ] # [ doc = "" ] # [ doc = "You can write raw bits into a register:" ] # [ doc = "```ignore" ] # [ doc = "periph.reg.write(|w| unsafe { w.bits(rawbits) });" ] # [ doc = "```" ] # [ doc = "or write only the fields you need:" ] # [ doc = "```ignore" ] # [ doc = "periph.reg.write(|w| w" ] # [ doc = "    .field1().bits(newfield1bits)" ] # [ doc = "    .field2().set_bit()" ] # [ doc = "    .field3().variant(VARIANT)" ] # [ doc = ");" ] # [ doc = "```" ] # [ doc = "Other fields will have reset value." ] # [ inline ( always ) ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W < U , Self > ) -> & mut W < U , Self > { self . register . set ( f ( & mut W { bits : Self :: reset_value ( ) , _reg : marker :: PhantomData } ) . bits ) ; } } impl < U , REG > Reg < U , REG > where Self : Writable , U : Copy + Default { # [ doc = "Writes Zero to `Writable` register" ] # [ doc = "" ] # [ doc = "Similar to `write`, but unused bits will contain 0." ] # [ inline ( always ) ] pub fn write_with_zero < F > ( & self , f : F ) where F : FnOnce ( & mut W < U , Self > ) -> & mut W < U , Self > { self . register . set ( f ( & mut W { bits : U :: default ( ) , _reg : marker :: PhantomData } ) . bits ) ; } } impl < U , REG > Reg < U , REG > where Self : Readable + Writable , U : Copy , { # [ doc = "Modifies the contents of the register" ] # [ doc = "" ] # [ doc = "E.g. to do a read-modify-write sequence to change parts of a register:" ] # [ doc = "```ignore" ] # [ doc = "periph.reg.modify(|r, w| unsafe { w.bits(" ] # [ doc = "   r.bits() | 3" ] # [ doc = ") });" ] # [ doc = "```" ] # [ doc = "or" ] # [ doc = "```ignore" ] # [ doc = "periph.reg.modify(|_, w| w" ] # [ doc = "    .field1().bits(newfield1bits)" ] # [ doc = "    .field2().set_bit()" ] # [ doc = "    .field3().variant(VARIANT)" ] # [ doc = ");" ] # [ doc = "```" ] # [ doc = "Other fields will have value they had before call `modify`." ] # [ inline ( always ) ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R < U , Self > , & 'w mut W < U , Self > ) -> & 'w mut W < U , Self > { let bits = self . register . get ( ) ; self . register . set ( f ( & R { bits , _reg : marker :: PhantomData } , & mut W { bits , _reg : marker :: PhantomData } ) . bits ) ; } } # [ doc = "Register/field reader" ] # [ doc = "" ] # [ doc = "Result of the [`read`](Reg::read) method of a register." ] # [ doc = "Also it can be used in the [`modify`](Reg::read) method" ] pub struct R < U , T > { pub ( crate ) bits : U , _reg : marker :: PhantomData < T > , } impl < U , T > R < U , T > where U : Copy { # [ doc = "Create new instance of reader" ] # [ inline ( always ) ] pub ( crate ) fn new ( bits : U ) -> Self { Self { bits , _reg : marker :: PhantomData , } } # [ doc = "Read raw bits from register/field" ] # [ inline ( always ) ] pub fn bits ( & self ) -> U { self . bits } } impl < U , T , FI > PartialEq < FI > for R < U , T > where U : PartialEq , FI : Copy + Into < U > { # [ inline ( always ) ] fn eq ( & self , other : & FI ) -> bool { self . bits . eq ( & ( * other ) . into ( ) ) } } impl < FI > R < bool , FI > { # [ doc = "Value of the field as raw bits" ] # [ inline ( always ) ] pub fn bit ( & self ) -> bool { self . bits } # [ doc = "Returns `true` if the bit is clear (0)" ] # [ inline ( always ) ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = "Returns `true` if the bit is set (1)" ] # [ inline ( always ) ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = "Register writer" ] # [ doc = "" ] # [ doc = "Used as an argument to the closures in the [`write`](Reg::write) and [`modify`](Reg::modify) methods of the register" ] pub struct W < U , REG > { # [ doc = "Writable bits" ] pub ( crate ) bits : U , _reg : marker :: PhantomData < REG > , } impl < U , REG > W < U , REG > { # [ doc = "Writes raw bits to the register" ] # [ inline ( always ) ] pub unsafe fn bits ( & mut self , bits : U ) -> & mut Self { self . bits = bits ; self } } # [ doc = "Used if enumerated values cover not the whole range" ] # [ derive ( Clone , Copy , PartialEq ) ] pub enum Variant < U , T > { # [ doc = "Expected variant" ] Val ( T ) , # [ doc = "Raw bits" ] Res ( U ) , } }
# [ doc = "P1" ] pub struct P1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for P1 { } impl P1 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const p1 :: RegisterBlock { 0x0200 as * const _ } } impl Deref for P1 { type Target = p1 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * P1 :: ptr ( ) } } }
# [ doc = "P1" ] pub mod p1 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Port 1 Input" ] pub p1in : P1IN , _reserved1 : [ u8 ; 1usize ] , # [ doc = "0x02 - Port 1 Output" ] pub p1out : P1OUT , _reserved2 : [ u8 ; 1usize ] , # [ doc = "0x04 - Port 1 Direction" ] pub p1dir : P1DIR , _reserved3 : [ u8 ; 1usize ] , # [ doc = "0x06 - Port 1 Resistor Enable" ] pub p1ren : P1REN , _reserved4 : [ u8 ; 3usize ] , # [ doc = "0x0a - Port 1 Select 0" ] pub p1sel0 : P1SEL0 , _reserved5 : [ u8 ; 1usize ] , # [ doc = "0x0c - Port 1 Select 1" ] pub p1sel1 : P1SEL1 , _reserved6 : [ u8 ; 1usize ] , # [ doc = "0x0e - Port 1 Interrupt Vector Register" ] pub p1iv : P1IV , _reserved7 : [ u8 ; 6usize ] , # [ doc = "0x16 - Port 1 Complement Select" ] pub p1selc : P1SELC , _reserved8 : [ u8 ; 1usize ] , # [ doc = "0x18 - Port 1 Interrupt Edge Select" ] pub p1ies : P1IES , _reserved9 : [ u8 ; 1usize ] , # [ doc = "0x1a - Port 1 Interrupt Enable" ] pub p1ie : P1IE , _reserved10 : [ u8 ; 1usize ] , # [ doc = "0x1c - Port 1 Interrupt Flag" ] pub p1ifg : P1IFG , }
# [ doc = "Port 1 Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1in](p1in) module" ] pub type P1IN = crate :: Reg < u8 , _P1IN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1IN ;
# [ doc = "`read()` method returns [p1in::R](p1in::R) reader structure" ] impl crate :: Readable for P1IN { }
# [ doc = "`write(|w| ..)` method takes [p1in::W](p1in::W) writer structure" ] impl crate :: Writable for P1IN { }
# [ doc = "Port 1 Input" ] pub mod p1in {
# [ doc = "Reader of register P1IN" ] pub type R = crate :: R < u8 , super :: P1IN > ;
# [ doc = "Writer for register P1IN" ] pub type W = crate :: W < u8 , super :: P1IN > ;
# [ doc = "Register P1IN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P1IN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 1 Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1out](p1out) module" ] pub type P1OUT = crate :: Reg < u8 , _P1OUT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1OUT ;
# [ doc = "`read()` method returns [p1out::R](p1out::R) reader structure" ] impl crate :: Readable for P1OUT { }
# [ doc = "`write(|w| ..)` method takes [p1out::W](p1out::W) writer structure" ] impl crate :: Writable for P1OUT { }
# [ doc = "Port 1 Output" ] pub mod p1out {
# [ doc = "Reader of register P1OUT" ] pub type R = crate :: R < u8 , super :: P1OUT > ;
# [ doc = "Writer for register P1OUT" ] pub type W = crate :: W < u8 , super :: P1OUT > ;
# [ doc = "Register P1OUT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P1OUT { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 1 Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1dir](p1dir) module" ] pub type P1DIR = crate :: Reg < u8 , _P1DIR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1DIR ;
# [ doc = "`read()` method returns [p1dir::R](p1dir::R) reader structure" ] impl crate :: Readable for P1DIR { }
# [ doc = "`write(|w| ..)` method takes [p1dir::W](p1dir::W) writer structure" ] impl crate :: Writable for P1DIR { }
# [ doc = "Port 1 Direction" ] pub mod p1dir {
# [ doc = "Reader of register P1DIR" ] pub type R = crate :: R < u8 , super :: P1DIR > ;
# [ doc = "Writer for register P1DIR" ] pub type W = crate :: W < u8 , super :: P1DIR > ;
# [ doc = "Register P1DIR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P1DIR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 1 Resistor Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1ren](p1ren) module" ] pub type P1REN = crate :: Reg < u8 , _P1REN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1REN ;
# [ doc = "`read()` method returns [p1ren::R](p1ren::R) reader structure" ] impl crate :: Readable for P1REN { }
# [ doc = "`write(|w| ..)` method takes [p1ren::W](p1ren::W) writer structure" ] impl crate :: Writable for P1REN { }
# [ doc = "Port 1 Resistor Enable" ] pub mod p1ren {
# [ doc = "Reader of register P1REN" ] pub type R = crate :: R < u8 , super :: P1REN > ;
# [ doc = "Writer for register P1REN" ] pub type W = crate :: W < u8 , super :: P1REN > ;
# [ doc = "Register P1REN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P1REN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 1 Select 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1sel0](p1sel0) module" ] pub type P1SEL0 = crate :: Reg < u8 , _P1SEL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1SEL0 ;
# [ doc = "`read()` method returns [p1sel0::R](p1sel0::R) reader structure" ] impl crate :: Readable for P1SEL0 { }
# [ doc = "`write(|w| ..)` method takes [p1sel0::W](p1sel0::W) writer structure" ] impl crate :: Writable for P1SEL0 { }
# [ doc = "Port 1 Select 0" ] pub mod p1sel0 {
# [ doc = "Reader of register P1SEL0" ] pub type R = crate :: R < u8 , super :: P1SEL0 > ;
# [ doc = "Writer for register P1SEL0" ] pub type W = crate :: W < u8 , super :: P1SEL0 > ;
# [ doc = "Register P1SEL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P1SEL0 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 1 Select 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1sel1](p1sel1) module" ] pub type P1SEL1 = crate :: Reg < u8 , _P1SEL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1SEL1 ;
# [ doc = "`read()` method returns [p1sel1::R](p1sel1::R) reader structure" ] impl crate :: Readable for P1SEL1 { }
# [ doc = "`write(|w| ..)` method takes [p1sel1::W](p1sel1::W) writer structure" ] impl crate :: Writable for P1SEL1 { }
# [ doc = "Port 1 Select 1" ] pub mod p1sel1 {
# [ doc = "Reader of register P1SEL1" ] pub type R = crate :: R < u8 , super :: P1SEL1 > ;
# [ doc = "Writer for register P1SEL1" ] pub type W = crate :: W < u8 , super :: P1SEL1 > ;
# [ doc = "Register P1SEL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P1SEL1 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 1 Complement Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1selc](p1selc) module" ] pub type P1SELC = crate :: Reg < u8 , _P1SELC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1SELC ;
# [ doc = "`read()` method returns [p1selc::R](p1selc::R) reader structure" ] impl crate :: Readable for P1SELC { }
# [ doc = "`write(|w| ..)` method takes [p1selc::W](p1selc::W) writer structure" ] impl crate :: Writable for P1SELC { }
# [ doc = "Port 1 Complement Select" ] pub mod p1selc {
# [ doc = "Reader of register P1SELC" ] pub type R = crate :: R < u8 , super :: P1SELC > ;
# [ doc = "Writer for register P1SELC" ] pub type W = crate :: W < u8 , super :: P1SELC > ;
# [ doc = "Register P1SELC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P1SELC { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 1 Interrupt Edge Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1ies](p1ies) module" ] pub type P1IES = crate :: Reg < u8 , _P1IES > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1IES ;
# [ doc = "`read()` method returns [p1ies::R](p1ies::R) reader structure" ] impl crate :: Readable for P1IES { }
# [ doc = "`write(|w| ..)` method takes [p1ies::W](p1ies::W) writer structure" ] impl crate :: Writable for P1IES { }
# [ doc = "Port 1 Interrupt Edge Select" ] pub mod p1ies {
# [ doc = "Reader of register P1IES" ] pub type R = crate :: R < u8 , super :: P1IES > ;
# [ doc = "Writer for register P1IES" ] pub type W = crate :: W < u8 , super :: P1IES > ;
# [ doc = "Register P1IES `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P1IES { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 1 Interrupt Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1ie](p1ie) module" ] pub type P1IE = crate :: Reg < u8 , _P1IE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1IE ;
# [ doc = "`read()` method returns [p1ie::R](p1ie::R) reader structure" ] impl crate :: Readable for P1IE { }
# [ doc = "`write(|w| ..)` method takes [p1ie::W](p1ie::W) writer structure" ] impl crate :: Writable for P1IE { }
# [ doc = "Port 1 Interrupt Enable" ] pub mod p1ie {
# [ doc = "Reader of register P1IE" ] pub type R = crate :: R < u8 , super :: P1IE > ;
# [ doc = "Writer for register P1IE" ] pub type W = crate :: W < u8 , super :: P1IE > ;
# [ doc = "Register P1IE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P1IE { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 1 Interrupt Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1ifg](p1ifg) module" ] pub type P1IFG = crate :: Reg < u8 , _P1IFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1IFG ;
# [ doc = "`read()` method returns [p1ifg::R](p1ifg::R) reader structure" ] impl crate :: Readable for P1IFG { }
# [ doc = "`write(|w| ..)` method takes [p1ifg::W](p1ifg::W) writer structure" ] impl crate :: Writable for P1IFG { }
# [ doc = "Port 1 Interrupt Flag" ] pub mod p1ifg {
# [ doc = "Reader of register P1IFG" ] pub type R = crate :: R < u8 , super :: P1IFG > ;
# [ doc = "Writer for register P1IFG" ] pub type W = crate :: W < u8 , super :: P1IFG > ;
# [ doc = "Register P1IFG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P1IFG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 1 Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1iv](p1iv) module" ] pub type P1IV = crate :: Reg < u16 , _P1IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P1IV ;
# [ doc = "`read()` method returns [p1iv::R](p1iv::R) reader structure" ] impl crate :: Readable for P1IV { }
# [ doc = "Port 1 Interrupt Vector Register" ] pub mod p1iv {
# [ doc = "Reader of register P1IV" ] pub type R = crate :: R < u16 , super :: P1IV > ;
# [ doc = "Port 1 interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum P1IV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Port 1.0 interrupt; Interrupt Flag: P1IFG0; Interrupt Priority: Highest" ] P1IFG0 = 2 , # [ doc = "4: Interrupt Source: Port 1.1 interrupt; Interrupt Flag: P1IFG1" ] P1IFG1 = 4 , # [ doc = "6: Interrupt Source: Port 1.2 interrupt; Interrupt Flag: P1IFG2" ] P1IFG2 = 6 , # [ doc = "8: Interrupt Source: Port 1.3 interrupt; Interrupt Flag: P1IFG3" ] P1IFG3 = 8 , # [ doc = "10: Interrupt Source: Port 1.4 interrupt; Interrupt Flag: P1IFG4" ] P1IFG4 = 10 , # [ doc = "12: Interrupt Source: Port 1.5 interrupt; Interrupt Flag: P1IFG5" ] P1IFG5 = 12 , # [ doc = "14: Interrupt Source: Port 1.6 interrupt; Interrupt Flag: P1IFG6" ] P1IFG6 = 14 , # [ doc = "16: Interrupt Source: Port 1.7 interrupt; Interrupt Flag: P1IFG7; Interrupt Priority: Lowest" ] P1IFG7 = 16 } impl From < P1IV_A > for u8 { # [ inline ( always ) ] fn from ( variant : P1IV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `P1IV`" ] pub type P1IV_R = crate :: R < u8 , P1IV_A > ; impl P1IV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , P1IV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( P1IV_A :: NONE ) , 2 => Val ( P1IV_A :: P1IFG0 ) , 4 => Val ( P1IV_A :: P1IFG1 ) , 6 => Val ( P1IV_A :: P1IFG2 ) , 8 => Val ( P1IV_A :: P1IFG3 ) , 10 => Val ( P1IV_A :: P1IFG4 ) , 12 => Val ( P1IV_A :: P1IFG5 ) , 14 => Val ( P1IV_A :: P1IFG6 ) , 16 => Val ( P1IV_A :: P1IFG7 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == P1IV_A :: NONE } # [ doc = "Checks if the value of the field is `P1IFG0`" ] # [ inline ( always ) ] pub fn is_p1ifg0 ( & self ) -> bool { * self == P1IV_A :: P1IFG0 } # [ doc = "Checks if the value of the field is `P1IFG1`" ] # [ inline ( always ) ] pub fn is_p1ifg1 ( & self ) -> bool { * self == P1IV_A :: P1IFG1 } # [ doc = "Checks if the value of the field is `P1IFG2`" ] # [ inline ( always ) ] pub fn is_p1ifg2 ( & self ) -> bool { * self == P1IV_A :: P1IFG2 } # [ doc = "Checks if the value of the field is `P1IFG3`" ] # [ inline ( always ) ] pub fn is_p1ifg3 ( & self ) -> bool { * self == P1IV_A :: P1IFG3 } # [ doc = "Checks if the value of the field is `P1IFG4`" ] # [ inline ( always ) ] pub fn is_p1ifg4 ( & self ) -> bool { * self == P1IV_A :: P1IFG4 } # [ doc = "Checks if the value of the field is `P1IFG5`" ] # [ inline ( always ) ] pub fn is_p1ifg5 ( & self ) -> bool { * self == P1IV_A :: P1IFG5 } # [ doc = "Checks if the value of the field is `P1IFG6`" ] # [ inline ( always ) ] pub fn is_p1ifg6 ( & self ) -> bool { * self == P1IV_A :: P1IFG6 } # [ doc = "Checks if the value of the field is `P1IFG7`" ] # [ inline ( always ) ] pub fn is_p1ifg7 ( & self ) -> bool { * self == P1IV_A :: P1IFG7 } }
impl R {
# [ doc = "Bits 0:4 - Port 1 interrupt vector value" ] # [ inline ( always ) ] pub fn p1iv ( & self ) -> P1IV_R { P1IV_R :: new ( ( self . bits & 0x1f ) as u8 ) }
}
}
}
# [ doc = "P2" ] pub struct P2 { _marker : PhantomData < * const ( ) > } unsafe impl Send for P2 { } impl P2 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const p2 :: RegisterBlock { 0x0200 as * const _ } } impl Deref for P2 { type Target = p2 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * P2 :: ptr ( ) } } }
# [ doc = "P2" ] pub mod p2 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved0 : [ u8 ; 1usize ] , # [ doc = "0x01 - Port 2 Input" ] pub p2in : P2IN , _reserved1 : [ u8 ; 1usize ] , # [ doc = "0x03 - Port 2 Output" ] pub p2out : P2OUT , _reserved2 : [ u8 ; 1usize ] , # [ doc = "0x05 - Port 2 Direction" ] pub p2dir : P2DIR , _reserved3 : [ u8 ; 1usize ] , # [ doc = "0x07 - Port 2 Resistor Enable" ] pub p2ren : P2REN , _reserved4 : [ u8 ; 3usize ] , # [ doc = "0x0b - Port 2 Select 0" ] pub p2sel0 : P2SEL0 , _reserved5 : [ u8 ; 1usize ] , # [ doc = "0x0d - Port 2 Select 1" ] pub p2sel1 : P2SEL1 , _reserved6 : [ u8 ; 9usize ] , # [ doc = "0x17 - Port 2 Complement Select" ] pub p2selc : P2SELC , _reserved7 : [ u8 ; 1usize ] , # [ doc = "0x19 - Port 2 Interrupt Edge Select" ] pub p2ies : P2IES , _reserved8 : [ u8 ; 1usize ] , # [ doc = "0x1b - Port 2 Interrupt Enable" ] pub p2ie : P2IE , _reserved9 : [ u8 ; 1usize ] , # [ doc = "0x1d - Port 2 Interrupt Flag" ] pub p2ifg : P2IFG , # [ doc = "0x1e - Port 2 Interrupt Vector Register" ] pub p2iv : P2IV , }
# [ doc = "Port 2 Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2in](p2in) module" ] pub type P2IN = crate :: Reg < u8 , _P2IN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2IN ;
# [ doc = "`read()` method returns [p2in::R](p2in::R) reader structure" ] impl crate :: Readable for P2IN { }
# [ doc = "`write(|w| ..)` method takes [p2in::W](p2in::W) writer structure" ] impl crate :: Writable for P2IN { }
# [ doc = "Port 2 Input" ] pub mod p2in {
# [ doc = "Reader of register P2IN" ] pub type R = crate :: R < u8 , super :: P2IN > ;
# [ doc = "Writer for register P2IN" ] pub type W = crate :: W < u8 , super :: P2IN > ;
# [ doc = "Register P2IN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P2IN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 2 Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2out](p2out) module" ] pub type P2OUT = crate :: Reg < u8 , _P2OUT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2OUT ;
# [ doc = "`read()` method returns [p2out::R](p2out::R) reader structure" ] impl crate :: Readable for P2OUT { }
# [ doc = "`write(|w| ..)` method takes [p2out::W](p2out::W) writer structure" ] impl crate :: Writable for P2OUT { }
# [ doc = "Port 2 Output" ] pub mod p2out {
# [ doc = "Reader of register P2OUT" ] pub type R = crate :: R < u8 , super :: P2OUT > ;
# [ doc = "Writer for register P2OUT" ] pub type W = crate :: W < u8 , super :: P2OUT > ;
# [ doc = "Register P2OUT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P2OUT { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 2 Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2dir](p2dir) module" ] pub type P2DIR = crate :: Reg < u8 , _P2DIR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2DIR ;
# [ doc = "`read()` method returns [p2dir::R](p2dir::R) reader structure" ] impl crate :: Readable for P2DIR { }
# [ doc = "`write(|w| ..)` method takes [p2dir::W](p2dir::W) writer structure" ] impl crate :: Writable for P2DIR { }
# [ doc = "Port 2 Direction" ] pub mod p2dir {
# [ doc = "Reader of register P2DIR" ] pub type R = crate :: R < u8 , super :: P2DIR > ;
# [ doc = "Writer for register P2DIR" ] pub type W = crate :: W < u8 , super :: P2DIR > ;
# [ doc = "Register P2DIR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P2DIR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 2 Resistor Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2ren](p2ren) module" ] pub type P2REN = crate :: Reg < u8 , _P2REN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2REN ;
# [ doc = "`read()` method returns [p2ren::R](p2ren::R) reader structure" ] impl crate :: Readable for P2REN { }
# [ doc = "`write(|w| ..)` method takes [p2ren::W](p2ren::W) writer structure" ] impl crate :: Writable for P2REN { }
# [ doc = "Port 2 Resistor Enable" ] pub mod p2ren {
# [ doc = "Reader of register P2REN" ] pub type R = crate :: R < u8 , super :: P2REN > ;
# [ doc = "Writer for register P2REN" ] pub type W = crate :: W < u8 , super :: P2REN > ;
# [ doc = "Register P2REN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P2REN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 2 Select 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2sel0](p2sel0) module" ] pub type P2SEL0 = crate :: Reg < u8 , _P2SEL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2SEL0 ;
# [ doc = "`read()` method returns [p2sel0::R](p2sel0::R) reader structure" ] impl crate :: Readable for P2SEL0 { }
# [ doc = "`write(|w| ..)` method takes [p2sel0::W](p2sel0::W) writer structure" ] impl crate :: Writable for P2SEL0 { }
# [ doc = "Port 2 Select 0" ] pub mod p2sel0 {
# [ doc = "Reader of register P2SEL0" ] pub type R = crate :: R < u8 , super :: P2SEL0 > ;
# [ doc = "Writer for register P2SEL0" ] pub type W = crate :: W < u8 , super :: P2SEL0 > ;
# [ doc = "Register P2SEL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P2SEL0 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 2 Select 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2sel1](p2sel1) module" ] pub type P2SEL1 = crate :: Reg < u8 , _P2SEL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2SEL1 ;
# [ doc = "`read()` method returns [p2sel1::R](p2sel1::R) reader structure" ] impl crate :: Readable for P2SEL1 { }
# [ doc = "`write(|w| ..)` method takes [p2sel1::W](p2sel1::W) writer structure" ] impl crate :: Writable for P2SEL1 { }
# [ doc = "Port 2 Select 1" ] pub mod p2sel1 {
# [ doc = "Reader of register P2SEL1" ] pub type R = crate :: R < u8 , super :: P2SEL1 > ;
# [ doc = "Writer for register P2SEL1" ] pub type W = crate :: W < u8 , super :: P2SEL1 > ;
# [ doc = "Register P2SEL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P2SEL1 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 2 Complement Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2selc](p2selc) module" ] pub type P2SELC = crate :: Reg < u8 , _P2SELC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2SELC ;
# [ doc = "`read()` method returns [p2selc::R](p2selc::R) reader structure" ] impl crate :: Readable for P2SELC { }
# [ doc = "`write(|w| ..)` method takes [p2selc::W](p2selc::W) writer structure" ] impl crate :: Writable for P2SELC { }
# [ doc = "Port 2 Complement Select" ] pub mod p2selc {
# [ doc = "Reader of register P2SELC" ] pub type R = crate :: R < u8 , super :: P2SELC > ;
# [ doc = "Writer for register P2SELC" ] pub type W = crate :: W < u8 , super :: P2SELC > ;
# [ doc = "Register P2SELC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P2SELC { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 2 Interrupt Edge Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2ies](p2ies) module" ] pub type P2IES = crate :: Reg < u8 , _P2IES > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2IES ;
# [ doc = "`read()` method returns [p2ies::R](p2ies::R) reader structure" ] impl crate :: Readable for P2IES { }
# [ doc = "`write(|w| ..)` method takes [p2ies::W](p2ies::W) writer structure" ] impl crate :: Writable for P2IES { }
# [ doc = "Port 2 Interrupt Edge Select" ] pub mod p2ies {
# [ doc = "Reader of register P2IES" ] pub type R = crate :: R < u8 , super :: P2IES > ;
# [ doc = "Writer for register P2IES" ] pub type W = crate :: W < u8 , super :: P2IES > ;
# [ doc = "Register P2IES `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P2IES { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 2 Interrupt Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2ie](p2ie) module" ] pub type P2IE = crate :: Reg < u8 , _P2IE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2IE ;
# [ doc = "`read()` method returns [p2ie::R](p2ie::R) reader structure" ] impl crate :: Readable for P2IE { }
# [ doc = "`write(|w| ..)` method takes [p2ie::W](p2ie::W) writer structure" ] impl crate :: Writable for P2IE { }
# [ doc = "Port 2 Interrupt Enable" ] pub mod p2ie {
# [ doc = "Reader of register P2IE" ] pub type R = crate :: R < u8 , super :: P2IE > ;
# [ doc = "Writer for register P2IE" ] pub type W = crate :: W < u8 , super :: P2IE > ;
# [ doc = "Register P2IE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P2IE { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 2 Interrupt Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2ifg](p2ifg) module" ] pub type P2IFG = crate :: Reg < u8 , _P2IFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2IFG ;
# [ doc = "`read()` method returns [p2ifg::R](p2ifg::R) reader structure" ] impl crate :: Readable for P2IFG { }
# [ doc = "`write(|w| ..)` method takes [p2ifg::W](p2ifg::W) writer structure" ] impl crate :: Writable for P2IFG { }
# [ doc = "Port 2 Interrupt Flag" ] pub mod p2ifg {
# [ doc = "Reader of register P2IFG" ] pub type R = crate :: R < u8 , super :: P2IFG > ;
# [ doc = "Writer for register P2IFG" ] pub type W = crate :: W < u8 , super :: P2IFG > ;
# [ doc = "Register P2IFG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P2IFG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 2 Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2iv](p2iv) module" ] pub type P2IV = crate :: Reg < u16 , _P2IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P2IV ;
# [ doc = "`read()` method returns [p2iv::R](p2iv::R) reader structure" ] impl crate :: Readable for P2IV { }
# [ doc = "Port 2 Interrupt Vector Register" ] pub mod p2iv {
# [ doc = "Reader of register P2IV" ] pub type R = crate :: R < u16 , super :: P2IV > ;
# [ doc = "Port 2 interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum P2IV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Port 2.0 interrupt; Interrupt Flag: P2IFG0; Interrupt Priority: Highest" ] P2IFG0 = 2 , # [ doc = "4: Interrupt Source: Port 2.1 interrupt; Interrupt Flag: P2IFG1" ] P2IFG1 = 4 , # [ doc = "6: Interrupt Source: Port 2.2 interrupt; Interrupt Flag: P2IFG2" ] P2IFG2 = 6 , # [ doc = "8: Interrupt Source: Port 2.3 interrupt; Interrupt Flag: P2IFG3" ] P2IFG3 = 8 , # [ doc = "10: Interrupt Source: Port 2.4 interrupt; Interrupt Flag: P2IFG4" ] P2IFG4 = 10 , # [ doc = "12: Interrupt Source: Port 2.5 interrupt; Interrupt Flag: P2IFG5" ] P2IFG5 = 12 , # [ doc = "14: Interrupt Source: Port 2.6 interrupt; Interrupt Flag: P2IFG6" ] P2IFG6 = 14 , # [ doc = "16: Interrupt Source: Port 2.7 interrupt; Interrupt Flag: P2IFG7; Interrupt Priority: Lowest" ] P2IFG7 = 16 } impl From < P2IV_A > for u8 { # [ inline ( always ) ] fn from ( variant : P2IV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `P2IV`" ] pub type P2IV_R = crate :: R < u8 , P2IV_A > ; impl P2IV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , P2IV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( P2IV_A :: NONE ) , 2 => Val ( P2IV_A :: P2IFG0 ) , 4 => Val ( P2IV_A :: P2IFG1 ) , 6 => Val ( P2IV_A :: P2IFG2 ) , 8 => Val ( P2IV_A :: P2IFG3 ) , 10 => Val ( P2IV_A :: P2IFG4 ) , 12 => Val ( P2IV_A :: P2IFG5 ) , 14 => Val ( P2IV_A :: P2IFG6 ) , 16 => Val ( P2IV_A :: P2IFG7 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == P2IV_A :: NONE } # [ doc = "Checks if the value of the field is `P2IFG0`" ] # [ inline ( always ) ] pub fn is_p2ifg0 ( & self ) -> bool { * self == P2IV_A :: P2IFG0 } # [ doc = "Checks if the value of the field is `P2IFG1`" ] # [ inline ( always ) ] pub fn is_p2ifg1 ( & self ) -> bool { * self == P2IV_A :: P2IFG1 } # [ doc = "Checks if the value of the field is `P2IFG2`" ] # [ inline ( always ) ] pub fn is_p2ifg2 ( & self ) -> bool { * self == P2IV_A :: P2IFG2 } # [ doc = "Checks if the value of the field is `P2IFG3`" ] # [ inline ( always ) ] pub fn is_p2ifg3 ( & self ) -> bool { * self == P2IV_A :: P2IFG3 } # [ doc = "Checks if the value of the field is `P2IFG4`" ] # [ inline ( always ) ] pub fn is_p2ifg4 ( & self ) -> bool { * self == P2IV_A :: P2IFG4 } # [ doc = "Checks if the value of the field is `P2IFG5`" ] # [ inline ( always ) ] pub fn is_p2ifg5 ( & self ) -> bool { * self == P2IV_A :: P2IFG5 } # [ doc = "Checks if the value of the field is `P2IFG6`" ] # [ inline ( always ) ] pub fn is_p2ifg6 ( & self ) -> bool { * self == P2IV_A :: P2IFG6 } # [ doc = "Checks if the value of the field is `P2IFG7`" ] # [ inline ( always ) ] pub fn is_p2ifg7 ( & self ) -> bool { * self == P2IV_A :: P2IFG7 } }
impl R {
# [ doc = "Bits 0:4 - Port 2 interrupt vector value" ] # [ inline ( always ) ] pub fn p2iv ( & self ) -> P2IV_R { P2IV_R :: new ( ( self . bits & 0x1f ) as u8 ) }
}
}
}
# [ doc = "P3" ] pub struct P3 { _marker : PhantomData < * const ( ) > } unsafe impl Send for P3 { } impl P3 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const p3 :: RegisterBlock { 0x0220 as * const _ } } impl Deref for P3 { type Target = p3 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * P3 :: ptr ( ) } } }
# [ doc = "P3" ] pub mod p3 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Port 3 Input" ] pub p3in : P3IN , _reserved1 : [ u8 ; 1usize ] , # [ doc = "0x02 - Port 3 Output" ] pub p3out : P3OUT , _reserved2 : [ u8 ; 1usize ] , # [ doc = "0x04 - Port 3 Direction" ] pub p3dir : P3DIR , _reserved3 : [ u8 ; 1usize ] , # [ doc = "0x06 - Port 3 Resistor Enable" ] pub p3ren : P3REN , _reserved4 : [ u8 ; 3usize ] , # [ doc = "0x0a - Port 3 Select 0" ] pub p3sel0 : P3SEL0 , _reserved5 : [ u8 ; 1usize ] , # [ doc = "0x0c - Port 3 Select 1" ] pub p3sel1 : P3SEL1 , _reserved6 : [ u8 ; 1usize ] , # [ doc = "0x0e - Port 3 Interrupt Vector Register" ] pub p3iv : P3IV , _reserved7 : [ u8 ; 6usize ] , # [ doc = "0x16 - Port 3 Complement Select" ] pub p3selc : P3SELC , _reserved8 : [ u8 ; 1usize ] , # [ doc = "0x18 - Port 3 Interrupt Edge Select" ] pub p3ies : P3IES , _reserved9 : [ u8 ; 1usize ] , # [ doc = "0x1a - Port 3 Interrupt Enable" ] pub p3ie : P3IE , _reserved10 : [ u8 ; 1usize ] , # [ doc = "0x1c - Port 3 Interrupt Flag" ] pub p3ifg : P3IFG , }
# [ doc = "Port 3 Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3in](p3in) module" ] pub type P3IN = crate :: Reg < u8 , _P3IN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3IN ;
# [ doc = "`read()` method returns [p3in::R](p3in::R) reader structure" ] impl crate :: Readable for P3IN { }
# [ doc = "`write(|w| ..)` method takes [p3in::W](p3in::W) writer structure" ] impl crate :: Writable for P3IN { }
# [ doc = "Port 3 Input" ] pub mod p3in {
# [ doc = "Reader of register P3IN" ] pub type R = crate :: R < u8 , super :: P3IN > ;
# [ doc = "Writer for register P3IN" ] pub type W = crate :: W < u8 , super :: P3IN > ;
# [ doc = "Register P3IN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P3IN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 3 Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3out](p3out) module" ] pub type P3OUT = crate :: Reg < u8 , _P3OUT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3OUT ;
# [ doc = "`read()` method returns [p3out::R](p3out::R) reader structure" ] impl crate :: Readable for P3OUT { }
# [ doc = "`write(|w| ..)` method takes [p3out::W](p3out::W) writer structure" ] impl crate :: Writable for P3OUT { }
# [ doc = "Port 3 Output" ] pub mod p3out {
# [ doc = "Reader of register P3OUT" ] pub type R = crate :: R < u8 , super :: P3OUT > ;
# [ doc = "Writer for register P3OUT" ] pub type W = crate :: W < u8 , super :: P3OUT > ;
# [ doc = "Register P3OUT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P3OUT { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 3 Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3dir](p3dir) module" ] pub type P3DIR = crate :: Reg < u8 , _P3DIR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3DIR ;
# [ doc = "`read()` method returns [p3dir::R](p3dir::R) reader structure" ] impl crate :: Readable for P3DIR { }
# [ doc = "`write(|w| ..)` method takes [p3dir::W](p3dir::W) writer structure" ] impl crate :: Writable for P3DIR { }
# [ doc = "Port 3 Direction" ] pub mod p3dir {
# [ doc = "Reader of register P3DIR" ] pub type R = crate :: R < u8 , super :: P3DIR > ;
# [ doc = "Writer for register P3DIR" ] pub type W = crate :: W < u8 , super :: P3DIR > ;
# [ doc = "Register P3DIR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P3DIR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 3 Resistor Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3ren](p3ren) module" ] pub type P3REN = crate :: Reg < u8 , _P3REN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3REN ;
# [ doc = "`read()` method returns [p3ren::R](p3ren::R) reader structure" ] impl crate :: Readable for P3REN { }
# [ doc = "`write(|w| ..)` method takes [p3ren::W](p3ren::W) writer structure" ] impl crate :: Writable for P3REN { }
# [ doc = "Port 3 Resistor Enable" ] pub mod p3ren {
# [ doc = "Reader of register P3REN" ] pub type R = crate :: R < u8 , super :: P3REN > ;
# [ doc = "Writer for register P3REN" ] pub type W = crate :: W < u8 , super :: P3REN > ;
# [ doc = "Register P3REN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P3REN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 3 Select 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3sel0](p3sel0) module" ] pub type P3SEL0 = crate :: Reg < u8 , _P3SEL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3SEL0 ;
# [ doc = "`read()` method returns [p3sel0::R](p3sel0::R) reader structure" ] impl crate :: Readable for P3SEL0 { }
# [ doc = "`write(|w| ..)` method takes [p3sel0::W](p3sel0::W) writer structure" ] impl crate :: Writable for P3SEL0 { }
# [ doc = "Port 3 Select 0" ] pub mod p3sel0 {
# [ doc = "Reader of register P3SEL0" ] pub type R = crate :: R < u8 , super :: P3SEL0 > ;
# [ doc = "Writer for register P3SEL0" ] pub type W = crate :: W < u8 , super :: P3SEL0 > ;
# [ doc = "Register P3SEL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P3SEL0 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 3 Select 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3sel1](p3sel1) module" ] pub type P3SEL1 = crate :: Reg < u8 , _P3SEL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3SEL1 ;
# [ doc = "`read()` method returns [p3sel1::R](p3sel1::R) reader structure" ] impl crate :: Readable for P3SEL1 { }
# [ doc = "`write(|w| ..)` method takes [p3sel1::W](p3sel1::W) writer structure" ] impl crate :: Writable for P3SEL1 { }
# [ doc = "Port 3 Select 1" ] pub mod p3sel1 {
# [ doc = "Reader of register P3SEL1" ] pub type R = crate :: R < u8 , super :: P3SEL1 > ;
# [ doc = "Writer for register P3SEL1" ] pub type W = crate :: W < u8 , super :: P3SEL1 > ;
# [ doc = "Register P3SEL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P3SEL1 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 3 Complement Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3selc](p3selc) module" ] pub type P3SELC = crate :: Reg < u8 , _P3SELC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3SELC ;
# [ doc = "`read()` method returns [p3selc::R](p3selc::R) reader structure" ] impl crate :: Readable for P3SELC { }
# [ doc = "`write(|w| ..)` method takes [p3selc::W](p3selc::W) writer structure" ] impl crate :: Writable for P3SELC { }
# [ doc = "Port 3 Complement Select" ] pub mod p3selc {
# [ doc = "Reader of register P3SELC" ] pub type R = crate :: R < u8 , super :: P3SELC > ;
# [ doc = "Writer for register P3SELC" ] pub type W = crate :: W < u8 , super :: P3SELC > ;
# [ doc = "Register P3SELC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P3SELC { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 3 Interrupt Edge Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3ies](p3ies) module" ] pub type P3IES = crate :: Reg < u8 , _P3IES > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3IES ;
# [ doc = "`read()` method returns [p3ies::R](p3ies::R) reader structure" ] impl crate :: Readable for P3IES { }
# [ doc = "`write(|w| ..)` method takes [p3ies::W](p3ies::W) writer structure" ] impl crate :: Writable for P3IES { }
# [ doc = "Port 3 Interrupt Edge Select" ] pub mod p3ies {
# [ doc = "Reader of register P3IES" ] pub type R = crate :: R < u8 , super :: P3IES > ;
# [ doc = "Writer for register P3IES" ] pub type W = crate :: W < u8 , super :: P3IES > ;
# [ doc = "Register P3IES `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P3IES { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 3 Interrupt Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3ie](p3ie) module" ] pub type P3IE = crate :: Reg < u8 , _P3IE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3IE ;
# [ doc = "`read()` method returns [p3ie::R](p3ie::R) reader structure" ] impl crate :: Readable for P3IE { }
# [ doc = "`write(|w| ..)` method takes [p3ie::W](p3ie::W) writer structure" ] impl crate :: Writable for P3IE { }
# [ doc = "Port 3 Interrupt Enable" ] pub mod p3ie {
# [ doc = "Reader of register P3IE" ] pub type R = crate :: R < u8 , super :: P3IE > ;
# [ doc = "Writer for register P3IE" ] pub type W = crate :: W < u8 , super :: P3IE > ;
# [ doc = "Register P3IE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P3IE { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 3 Interrupt Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3ifg](p3ifg) module" ] pub type P3IFG = crate :: Reg < u8 , _P3IFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3IFG ;
# [ doc = "`read()` method returns [p3ifg::R](p3ifg::R) reader structure" ] impl crate :: Readable for P3IFG { }
# [ doc = "`write(|w| ..)` method takes [p3ifg::W](p3ifg::W) writer structure" ] impl crate :: Writable for P3IFG { }
# [ doc = "Port 3 Interrupt Flag" ] pub mod p3ifg {
# [ doc = "Reader of register P3IFG" ] pub type R = crate :: R < u8 , super :: P3IFG > ;
# [ doc = "Writer for register P3IFG" ] pub type W = crate :: W < u8 , super :: P3IFG > ;
# [ doc = "Register P3IFG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P3IFG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 3 Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3iv](p3iv) module" ] pub type P3IV = crate :: Reg < u16 , _P3IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P3IV ;
# [ doc = "`read()` method returns [p3iv::R](p3iv::R) reader structure" ] impl crate :: Readable for P3IV { }
# [ doc = "Port 3 Interrupt Vector Register" ] pub mod p3iv {
# [ doc = "Reader of register P3IV" ] pub type R = crate :: R < u16 , super :: P3IV > ;
# [ doc = "Port 3 interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum P3IV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Port 3.0 interrupt; Interrupt Flag: P3IFG0; Interrupt Priority: Highest" ] P3IFG0 = 2 , # [ doc = "4: Interrupt Source: Port 3.1 interrupt; Interrupt Flag: P3IFG1" ] P3IFG1 = 4 , # [ doc = "6: Interrupt Source: Port 3.2 interrupt; Interrupt Flag: P3IFG2" ] P3IFG2 = 6 , # [ doc = "8: Interrupt Source: Port 3.3 interrupt; Interrupt Flag: P3IFG3" ] P3IFG3 = 8 , # [ doc = "10: Interrupt Source: Port 3.4 interrupt; Interrupt Flag: P3IFG4" ] P3IFG4 = 10 , # [ doc = "12: Interrupt Source: Port 3.5 interrupt; Interrupt Flag: P3IFG5" ] P3IFG5 = 12 , # [ doc = "14: Interrupt Source: Port 3.6 interrupt; Interrupt Flag: P3IFG6" ] P3IFG6 = 14 , # [ doc = "16: Interrupt Source: Port 3.7 interrupt; Interrupt Flag: P3IFG7; Interrupt Priority: Lowest" ] P3IFG7 = 16 } impl From < P3IV_A > for u8 { # [ inline ( always ) ] fn from ( variant : P3IV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `P3IV`" ] pub type P3IV_R = crate :: R < u8 , P3IV_A > ; impl P3IV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , P3IV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( P3IV_A :: NONE ) , 2 => Val ( P3IV_A :: P3IFG0 ) , 4 => Val ( P3IV_A :: P3IFG1 ) , 6 => Val ( P3IV_A :: P3IFG2 ) , 8 => Val ( P3IV_A :: P3IFG3 ) , 10 => Val ( P3IV_A :: P3IFG4 ) , 12 => Val ( P3IV_A :: P3IFG5 ) , 14 => Val ( P3IV_A :: P3IFG6 ) , 16 => Val ( P3IV_A :: P3IFG7 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == P3IV_A :: NONE } # [ doc = "Checks if the value of the field is `P3IFG0`" ] # [ inline ( always ) ] pub fn is_p3ifg0 ( & self ) -> bool { * self == P3IV_A :: P3IFG0 } # [ doc = "Checks if the value of the field is `P3IFG1`" ] # [ inline ( always ) ] pub fn is_p3ifg1 ( & self ) -> bool { * self == P3IV_A :: P3IFG1 } # [ doc = "Checks if the value of the field is `P3IFG2`" ] # [ inline ( always ) ] pub fn is_p3ifg2 ( & self ) -> bool { * self == P3IV_A :: P3IFG2 } # [ doc = "Checks if the value of the field is `P3IFG3`" ] # [ inline ( always ) ] pub fn is_p3ifg3 ( & self ) -> bool { * self == P3IV_A :: P3IFG3 } # [ doc = "Checks if the value of the field is `P3IFG4`" ] # [ inline ( always ) ] pub fn is_p3ifg4 ( & self ) -> bool { * self == P3IV_A :: P3IFG4 } # [ doc = "Checks if the value of the field is `P3IFG5`" ] # [ inline ( always ) ] pub fn is_p3ifg5 ( & self ) -> bool { * self == P3IV_A :: P3IFG5 } # [ doc = "Checks if the value of the field is `P3IFG6`" ] # [ inline ( always ) ] pub fn is_p3ifg6 ( & self ) -> bool { * self == P3IV_A :: P3IFG6 } # [ doc = "Checks if the value of the field is `P3IFG7`" ] # [ inline ( always ) ] pub fn is_p3ifg7 ( & self ) -> bool { * self == P3IV_A :: P3IFG7 } }
impl R {
# [ doc = "Bits 0:4 - Port 3 interrupt vector value" ] # [ inline ( always ) ] pub fn p3iv ( & self ) -> P3IV_R { P3IV_R :: new ( ( self . bits & 0x1f ) as u8 ) }
}
}
}
# [ doc = "P4" ] pub struct P4 { _marker : PhantomData < * const ( ) > } unsafe impl Send for P4 { } impl P4 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const p4 :: RegisterBlock { 0x0220 as * const _ } } impl Deref for P4 { type Target = p4 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * P4 :: ptr ( ) } } }
# [ doc = "P4" ] pub mod p4 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved0 : [ u8 ; 1usize ] , # [ doc = "0x01 - Port 4 Input" ] pub p4in : P4IN , _reserved1 : [ u8 ; 1usize ] , # [ doc = "0x03 - Port 4 Output" ] pub p4out : P4OUT , _reserved2 : [ u8 ; 1usize ] , # [ doc = "0x05 - Port 4 Direction" ] pub p4dir : P4DIR , _reserved3 : [ u8 ; 1usize ] , # [ doc = "0x07 - Port 4 Resistor Enable" ] pub p4ren : P4REN , _reserved4 : [ u8 ; 3usize ] , # [ doc = "0x0b - Port 4 Select 0" ] pub p4sel0 : P4SEL0 , _reserved5 : [ u8 ; 1usize ] , # [ doc = "0x0d - Port 4 Select 1" ] pub p4sel1 : P4SEL1 , _reserved6 : [ u8 ; 9usize ] , # [ doc = "0x17 - Port 4 Complement Select" ] pub p4selc : P4SELC , _reserved7 : [ u8 ; 1usize ] , # [ doc = "0x19 - Port 4 Interrupt Edge Select" ] pub p4ies : P4IES , _reserved8 : [ u8 ; 1usize ] , # [ doc = "0x1b - Port 4 Interrupt Enable" ] pub p4ie : P4IE , _reserved9 : [ u8 ; 1usize ] , # [ doc = "0x1d - Port 4 Interrupt Flag" ] pub p4ifg : P4IFG , # [ doc = "0x1e - Port 4 Interrupt Vector Register" ] pub p4iv : P4IV , }
# [ doc = "Port 4 Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4in](p4in) module" ] pub type P4IN = crate :: Reg < u8 , _P4IN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4IN ;
# [ doc = "`read()` method returns [p4in::R](p4in::R) reader structure" ] impl crate :: Readable for P4IN { }
# [ doc = "`write(|w| ..)` method takes [p4in::W](p4in::W) writer structure" ] impl crate :: Writable for P4IN { }
# [ doc = "Port 4 Input" ] pub mod p4in {
# [ doc = "Reader of register P4IN" ] pub type R = crate :: R < u8 , super :: P4IN > ;
# [ doc = "Writer for register P4IN" ] pub type W = crate :: W < u8 , super :: P4IN > ;
# [ doc = "Register P4IN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P4IN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 4 Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4out](p4out) module" ] pub type P4OUT = crate :: Reg < u8 , _P4OUT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4OUT ;
# [ doc = "`read()` method returns [p4out::R](p4out::R) reader structure" ] impl crate :: Readable for P4OUT { }
# [ doc = "`write(|w| ..)` method takes [p4out::W](p4out::W) writer structure" ] impl crate :: Writable for P4OUT { }
# [ doc = "Port 4 Output" ] pub mod p4out {
# [ doc = "Reader of register P4OUT" ] pub type R = crate :: R < u8 , super :: P4OUT > ;
# [ doc = "Writer for register P4OUT" ] pub type W = crate :: W < u8 , super :: P4OUT > ;
# [ doc = "Register P4OUT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P4OUT { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 4 Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4dir](p4dir) module" ] pub type P4DIR = crate :: Reg < u8 , _P4DIR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4DIR ;
# [ doc = "`read()` method returns [p4dir::R](p4dir::R) reader structure" ] impl crate :: Readable for P4DIR { }
# [ doc = "`write(|w| ..)` method takes [p4dir::W](p4dir::W) writer structure" ] impl crate :: Writable for P4DIR { }
# [ doc = "Port 4 Direction" ] pub mod p4dir {
# [ doc = "Reader of register P4DIR" ] pub type R = crate :: R < u8 , super :: P4DIR > ;
# [ doc = "Writer for register P4DIR" ] pub type W = crate :: W < u8 , super :: P4DIR > ;
# [ doc = "Register P4DIR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P4DIR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 4 Resistor Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4ren](p4ren) module" ] pub type P4REN = crate :: Reg < u8 , _P4REN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4REN ;
# [ doc = "`read()` method returns [p4ren::R](p4ren::R) reader structure" ] impl crate :: Readable for P4REN { }
# [ doc = "`write(|w| ..)` method takes [p4ren::W](p4ren::W) writer structure" ] impl crate :: Writable for P4REN { }
# [ doc = "Port 4 Resistor Enable" ] pub mod p4ren {
# [ doc = "Reader of register P4REN" ] pub type R = crate :: R < u8 , super :: P4REN > ;
# [ doc = "Writer for register P4REN" ] pub type W = crate :: W < u8 , super :: P4REN > ;
# [ doc = "Register P4REN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P4REN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 4 Select 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4sel0](p4sel0) module" ] pub type P4SEL0 = crate :: Reg < u8 , _P4SEL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4SEL0 ;
# [ doc = "`read()` method returns [p4sel0::R](p4sel0::R) reader structure" ] impl crate :: Readable for P4SEL0 { }
# [ doc = "`write(|w| ..)` method takes [p4sel0::W](p4sel0::W) writer structure" ] impl crate :: Writable for P4SEL0 { }
# [ doc = "Port 4 Select 0" ] pub mod p4sel0 {
# [ doc = "Reader of register P4SEL0" ] pub type R = crate :: R < u8 , super :: P4SEL0 > ;
# [ doc = "Writer for register P4SEL0" ] pub type W = crate :: W < u8 , super :: P4SEL0 > ;
# [ doc = "Register P4SEL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P4SEL0 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 4 Select 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4sel1](p4sel1) module" ] pub type P4SEL1 = crate :: Reg < u8 , _P4SEL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4SEL1 ;
# [ doc = "`read()` method returns [p4sel1::R](p4sel1::R) reader structure" ] impl crate :: Readable for P4SEL1 { }
# [ doc = "`write(|w| ..)` method takes [p4sel1::W](p4sel1::W) writer structure" ] impl crate :: Writable for P4SEL1 { }
# [ doc = "Port 4 Select 1" ] pub mod p4sel1 {
# [ doc = "Reader of register P4SEL1" ] pub type R = crate :: R < u8 , super :: P4SEL1 > ;
# [ doc = "Writer for register P4SEL1" ] pub type W = crate :: W < u8 , super :: P4SEL1 > ;
# [ doc = "Register P4SEL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P4SEL1 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 4 Complement Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4selc](p4selc) module" ] pub type P4SELC = crate :: Reg < u8 , _P4SELC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4SELC ;
# [ doc = "`read()` method returns [p4selc::R](p4selc::R) reader structure" ] impl crate :: Readable for P4SELC { }
# [ doc = "`write(|w| ..)` method takes [p4selc::W](p4selc::W) writer structure" ] impl crate :: Writable for P4SELC { }
# [ doc = "Port 4 Complement Select" ] pub mod p4selc {
# [ doc = "Reader of register P4SELC" ] pub type R = crate :: R < u8 , super :: P4SELC > ;
# [ doc = "Writer for register P4SELC" ] pub type W = crate :: W < u8 , super :: P4SELC > ;
# [ doc = "Register P4SELC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P4SELC { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 4 Interrupt Edge Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4ies](p4ies) module" ] pub type P4IES = crate :: Reg < u8 , _P4IES > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4IES ;
# [ doc = "`read()` method returns [p4ies::R](p4ies::R) reader structure" ] impl crate :: Readable for P4IES { }
# [ doc = "`write(|w| ..)` method takes [p4ies::W](p4ies::W) writer structure" ] impl crate :: Writable for P4IES { }
# [ doc = "Port 4 Interrupt Edge Select" ] pub mod p4ies {
# [ doc = "Reader of register P4IES" ] pub type R = crate :: R < u8 , super :: P4IES > ;
# [ doc = "Writer for register P4IES" ] pub type W = crate :: W < u8 , super :: P4IES > ;
# [ doc = "Register P4IES `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P4IES { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 4 Interrupt Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4ie](p4ie) module" ] pub type P4IE = crate :: Reg < u8 , _P4IE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4IE ;
# [ doc = "`read()` method returns [p4ie::R](p4ie::R) reader structure" ] impl crate :: Readable for P4IE { }
# [ doc = "`write(|w| ..)` method takes [p4ie::W](p4ie::W) writer structure" ] impl crate :: Writable for P4IE { }
# [ doc = "Port 4 Interrupt Enable" ] pub mod p4ie {
# [ doc = "Reader of register P4IE" ] pub type R = crate :: R < u8 , super :: P4IE > ;
# [ doc = "Writer for register P4IE" ] pub type W = crate :: W < u8 , super :: P4IE > ;
# [ doc = "Register P4IE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P4IE { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 4 Interrupt Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4ifg](p4ifg) module" ] pub type P4IFG = crate :: Reg < u8 , _P4IFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4IFG ;
# [ doc = "`read()` method returns [p4ifg::R](p4ifg::R) reader structure" ] impl crate :: Readable for P4IFG { }
# [ doc = "`write(|w| ..)` method takes [p4ifg::W](p4ifg::W) writer structure" ] impl crate :: Writable for P4IFG { }
# [ doc = "Port 4 Interrupt Flag" ] pub mod p4ifg {
# [ doc = "Reader of register P4IFG" ] pub type R = crate :: R < u8 , super :: P4IFG > ;
# [ doc = "Writer for register P4IFG" ] pub type W = crate :: W < u8 , super :: P4IFG > ;
# [ doc = "Register P4IFG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P4IFG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 4 Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p4iv](p4iv) module" ] pub type P4IV = crate :: Reg < u16 , _P4IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P4IV ;
# [ doc = "`read()` method returns [p4iv::R](p4iv::R) reader structure" ] impl crate :: Readable for P4IV { }
# [ doc = "Port 4 Interrupt Vector Register" ] pub mod p4iv {
# [ doc = "Reader of register P4IV" ] pub type R = crate :: R < u16 , super :: P4IV > ;
# [ doc = "Port 4 interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum P4IV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Port 4.0 interrupt; Interrupt Flag: P4IFG0; Interrupt Priority: Highest" ] P4IFG0 = 2 , # [ doc = "4: Interrupt Source: Port 4.1 interrupt; Interrupt Flag: P4IFG1" ] P4IFG1 = 4 , # [ doc = "6: Interrupt Source: Port 4.2 interrupt; Interrupt Flag: P4IFG2" ] P4IFG2 = 6 , # [ doc = "8: Interrupt Source: Port 4.3 interrupt; Interrupt Flag: P4IFG3" ] P4IFG3 = 8 , # [ doc = "10: Interrupt Source: Port 4.4 interrupt; Interrupt Flag: P4IFG4" ] P4IFG4 = 10 , # [ doc = "12: Interrupt Source: Port 4.5 interrupt; Interrupt Flag: P4IFG5" ] P4IFG5 = 12 , # [ doc = "14: Interrupt Source: Port 4.6 interrupt; Interrupt Flag: P4IFG6" ] P4IFG6 = 14 , # [ doc = "16: Interrupt Source: Port 4.7 interrupt; Interrupt Flag: P4IFG7; Interrupt Priority: Lowest" ] P4IFG7 = 16 } impl From < P4IV_A > for u8 { # [ inline ( always ) ] fn from ( variant : P4IV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `P4IV`" ] pub type P4IV_R = crate :: R < u8 , P4IV_A > ; impl P4IV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , P4IV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( P4IV_A :: NONE ) , 2 => Val ( P4IV_A :: P4IFG0 ) , 4 => Val ( P4IV_A :: P4IFG1 ) , 6 => Val ( P4IV_A :: P4IFG2 ) , 8 => Val ( P4IV_A :: P4IFG3 ) , 10 => Val ( P4IV_A :: P4IFG4 ) , 12 => Val ( P4IV_A :: P4IFG5 ) , 14 => Val ( P4IV_A :: P4IFG6 ) , 16 => Val ( P4IV_A :: P4IFG7 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == P4IV_A :: NONE } # [ doc = "Checks if the value of the field is `P4IFG0`" ] # [ inline ( always ) ] pub fn is_p4ifg0 ( & self ) -> bool { * self == P4IV_A :: P4IFG0 } # [ doc = "Checks if the value of the field is `P4IFG1`" ] # [ inline ( always ) ] pub fn is_p4ifg1 ( & self ) -> bool { * self == P4IV_A :: P4IFG1 } # [ doc = "Checks if the value of the field is `P4IFG2`" ] # [ inline ( always ) ] pub fn is_p4ifg2 ( & self ) -> bool { * self == P4IV_A :: P4IFG2 } # [ doc = "Checks if the value of the field is `P4IFG3`" ] # [ inline ( always ) ] pub fn is_p4ifg3 ( & self ) -> bool { * self == P4IV_A :: P4IFG3 } # [ doc = "Checks if the value of the field is `P4IFG4`" ] # [ inline ( always ) ] pub fn is_p4ifg4 ( & self ) -> bool { * self == P4IV_A :: P4IFG4 } # [ doc = "Checks if the value of the field is `P4IFG5`" ] # [ inline ( always ) ] pub fn is_p4ifg5 ( & self ) -> bool { * self == P4IV_A :: P4IFG5 } # [ doc = "Checks if the value of the field is `P4IFG6`" ] # [ inline ( always ) ] pub fn is_p4ifg6 ( & self ) -> bool { * self == P4IV_A :: P4IFG6 } # [ doc = "Checks if the value of the field is `P4IFG7`" ] # [ inline ( always ) ] pub fn is_p4ifg7 ( & self ) -> bool { * self == P4IV_A :: P4IFG7 } }
impl R {
# [ doc = "Bits 0:4 - Port 4 interrupt vector value" ] # [ inline ( always ) ] pub fn p4iv ( & self ) -> P4IV_R { P4IV_R :: new ( ( self . bits & 0x1f ) as u8 ) }
}
}
}
# [ doc = "P5" ] pub struct P5 { _marker : PhantomData < * const ( ) > } unsafe impl Send for P5 { } impl P5 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const p5 :: RegisterBlock { 0x0240 as * const _ } } impl Deref for P5 { type Target = p5 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * P5 :: ptr ( ) } } }
# [ doc = "P5" ] pub mod p5 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Port 5 Input" ] pub p5in : P5IN , _reserved1 : [ u8 ; 1usize ] , # [ doc = "0x02 - Port 5 Output" ] pub p5out : P5OUT , _reserved2 : [ u8 ; 1usize ] , # [ doc = "0x04 - Port 5 Direction" ] pub p5dir : P5DIR , _reserved3 : [ u8 ; 1usize ] , # [ doc = "0x06 - Port 5 Resistor Enable" ] pub p5ren : P5REN , _reserved4 : [ u8 ; 3usize ] , # [ doc = "0x0a - Port 5 Select 0" ] pub p5sel0 : P5SEL0 , _reserved5 : [ u8 ; 1usize ] , # [ doc = "0x0c - Port 5 Select 1" ] pub p5sel1 : P5SEL1 , _reserved6 : [ u8 ; 9usize ] , # [ doc = "0x16 - Port 5 Complement Select" ] pub p5selc : P5SELC , }
# [ doc = "Port 5 Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p5in](p5in) module" ] pub type P5IN = crate :: Reg < u8 , _P5IN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P5IN ;
# [ doc = "`read()` method returns [p5in::R](p5in::R) reader structure" ] impl crate :: Readable for P5IN { }
# [ doc = "`write(|w| ..)` method takes [p5in::W](p5in::W) writer structure" ] impl crate :: Writable for P5IN { }
# [ doc = "Port 5 Input" ] pub mod p5in {
# [ doc = "Reader of register P5IN" ] pub type R = crate :: R < u8 , super :: P5IN > ;
# [ doc = "Writer for register P5IN" ] pub type W = crate :: W < u8 , super :: P5IN > ;
# [ doc = "Register P5IN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P5IN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 5 Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p5out](p5out) module" ] pub type P5OUT = crate :: Reg < u8 , _P5OUT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P5OUT ;
# [ doc = "`read()` method returns [p5out::R](p5out::R) reader structure" ] impl crate :: Readable for P5OUT { }
# [ doc = "`write(|w| ..)` method takes [p5out::W](p5out::W) writer structure" ] impl crate :: Writable for P5OUT { }
# [ doc = "Port 5 Output" ] pub mod p5out {
# [ doc = "Reader of register P5OUT" ] pub type R = crate :: R < u8 , super :: P5OUT > ;
# [ doc = "Writer for register P5OUT" ] pub type W = crate :: W < u8 , super :: P5OUT > ;
# [ doc = "Register P5OUT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P5OUT { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 5 Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p5dir](p5dir) module" ] pub type P5DIR = crate :: Reg < u8 , _P5DIR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P5DIR ;
# [ doc = "`read()` method returns [p5dir::R](p5dir::R) reader structure" ] impl crate :: Readable for P5DIR { }
# [ doc = "`write(|w| ..)` method takes [p5dir::W](p5dir::W) writer structure" ] impl crate :: Writable for P5DIR { }
# [ doc = "Port 5 Direction" ] pub mod p5dir {
# [ doc = "Reader of register P5DIR" ] pub type R = crate :: R < u8 , super :: P5DIR > ;
# [ doc = "Writer for register P5DIR" ] pub type W = crate :: W < u8 , super :: P5DIR > ;
# [ doc = "Register P5DIR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P5DIR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 5 Resistor Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p5ren](p5ren) module" ] pub type P5REN = crate :: Reg < u8 , _P5REN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P5REN ;
# [ doc = "`read()` method returns [p5ren::R](p5ren::R) reader structure" ] impl crate :: Readable for P5REN { }
# [ doc = "`write(|w| ..)` method takes [p5ren::W](p5ren::W) writer structure" ] impl crate :: Writable for P5REN { }
# [ doc = "Port 5 Resistor Enable" ] pub mod p5ren {
# [ doc = "Reader of register P5REN" ] pub type R = crate :: R < u8 , super :: P5REN > ;
# [ doc = "Writer for register P5REN" ] pub type W = crate :: W < u8 , super :: P5REN > ;
# [ doc = "Register P5REN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P5REN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 5 Select 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p5sel0](p5sel0) module" ] pub type P5SEL0 = crate :: Reg < u8 , _P5SEL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P5SEL0 ;
# [ doc = "`read()` method returns [p5sel0::R](p5sel0::R) reader structure" ] impl crate :: Readable for P5SEL0 { }
# [ doc = "`write(|w| ..)` method takes [p5sel0::W](p5sel0::W) writer structure" ] impl crate :: Writable for P5SEL0 { }
# [ doc = "Port 5 Select 0" ] pub mod p5sel0 {
# [ doc = "Reader of register P5SEL0" ] pub type R = crate :: R < u8 , super :: P5SEL0 > ;
# [ doc = "Writer for register P5SEL0" ] pub type W = crate :: W < u8 , super :: P5SEL0 > ;
# [ doc = "Register P5SEL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P5SEL0 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 5 Select 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p5sel1](p5sel1) module" ] pub type P5SEL1 = crate :: Reg < u8 , _P5SEL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P5SEL1 ;
# [ doc = "`read()` method returns [p5sel1::R](p5sel1::R) reader structure" ] impl crate :: Readable for P5SEL1 { }
# [ doc = "`write(|w| ..)` method takes [p5sel1::W](p5sel1::W) writer structure" ] impl crate :: Writable for P5SEL1 { }
# [ doc = "Port 5 Select 1" ] pub mod p5sel1 {
# [ doc = "Reader of register P5SEL1" ] pub type R = crate :: R < u8 , super :: P5SEL1 > ;
# [ doc = "Writer for register P5SEL1" ] pub type W = crate :: W < u8 , super :: P5SEL1 > ;
# [ doc = "Register P5SEL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P5SEL1 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 5 Complement Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p5selc](p5selc) module" ] pub type P5SELC = crate :: Reg < u8 , _P5SELC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P5SELC ;
# [ doc = "`read()` method returns [p5selc::R](p5selc::R) reader structure" ] impl crate :: Readable for P5SELC { }
# [ doc = "`write(|w| ..)` method takes [p5selc::W](p5selc::W) writer structure" ] impl crate :: Writable for P5SELC { }
# [ doc = "Port 5 Complement Select" ] pub mod p5selc {
# [ doc = "Reader of register P5SELC" ] pub type R = crate :: R < u8 , super :: P5SELC > ;
# [ doc = "Writer for register P5SELC" ] pub type W = crate :: W < u8 , super :: P5SELC > ;
# [ doc = "Register P5SELC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P5SELC { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
}
# [ doc = "P6" ] pub struct P6 { _marker : PhantomData < * const ( ) > } unsafe impl Send for P6 { } impl P6 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const p6 :: RegisterBlock { 0x0240 as * const _ } } impl Deref for P6 { type Target = p6 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * P6 :: ptr ( ) } } }
# [ doc = "P6" ] pub mod p6 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved0 : [ u8 ; 1usize ] , # [ doc = "0x01 - Port 6 Input" ] pub p6in : P6IN , _reserved1 : [ u8 ; 1usize ] , # [ doc = "0x03 - Port 6 Output" ] pub p6out : P6OUT , _reserved2 : [ u8 ; 1usize ] , # [ doc = "0x05 - Port 6 Direction" ] pub p6dir : P6DIR , _reserved3 : [ u8 ; 1usize ] , # [ doc = "0x07 - Port 6 Resistor Enable" ] pub p6ren : P6REN , _reserved4 : [ u8 ; 3usize ] , # [ doc = "0x0b - Port 6 Select 0" ] pub p6sel0 : P6SEL0 , _reserved5 : [ u8 ; 1usize ] , # [ doc = "0x0d - Port 6 Select 1" ] pub p6sel1 : P6SEL1 , _reserved6 : [ u8 ; 9usize ] , # [ doc = "0x17 - Port 6 Complement Select" ] pub p6selc : P6SELC , }
# [ doc = "Port 6 Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p6in](p6in) module" ] pub type P6IN = crate :: Reg < u8 , _P6IN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P6IN ;
# [ doc = "`read()` method returns [p6in::R](p6in::R) reader structure" ] impl crate :: Readable for P6IN { }
# [ doc = "`write(|w| ..)` method takes [p6in::W](p6in::W) writer structure" ] impl crate :: Writable for P6IN { }
# [ doc = "Port 6 Input" ] pub mod p6in {
# [ doc = "Reader of register P6IN" ] pub type R = crate :: R < u8 , super :: P6IN > ;
# [ doc = "Writer for register P6IN" ] pub type W = crate :: W < u8 , super :: P6IN > ;
# [ doc = "Register P6IN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P6IN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 6 Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p6out](p6out) module" ] pub type P6OUT = crate :: Reg < u8 , _P6OUT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P6OUT ;
# [ doc = "`read()` method returns [p6out::R](p6out::R) reader structure" ] impl crate :: Readable for P6OUT { }
# [ doc = "`write(|w| ..)` method takes [p6out::W](p6out::W) writer structure" ] impl crate :: Writable for P6OUT { }
# [ doc = "Port 6 Output" ] pub mod p6out {
# [ doc = "Reader of register P6OUT" ] pub type R = crate :: R < u8 , super :: P6OUT > ;
# [ doc = "Writer for register P6OUT" ] pub type W = crate :: W < u8 , super :: P6OUT > ;
# [ doc = "Register P6OUT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P6OUT { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 6 Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p6dir](p6dir) module" ] pub type P6DIR = crate :: Reg < u8 , _P6DIR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P6DIR ;
# [ doc = "`read()` method returns [p6dir::R](p6dir::R) reader structure" ] impl crate :: Readable for P6DIR { }
# [ doc = "`write(|w| ..)` method takes [p6dir::W](p6dir::W) writer structure" ] impl crate :: Writable for P6DIR { }
# [ doc = "Port 6 Direction" ] pub mod p6dir {
# [ doc = "Reader of register P6DIR" ] pub type R = crate :: R < u8 , super :: P6DIR > ;
# [ doc = "Writer for register P6DIR" ] pub type W = crate :: W < u8 , super :: P6DIR > ;
# [ doc = "Register P6DIR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P6DIR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 6 Resistor Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p6ren](p6ren) module" ] pub type P6REN = crate :: Reg < u8 , _P6REN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P6REN ;
# [ doc = "`read()` method returns [p6ren::R](p6ren::R) reader structure" ] impl crate :: Readable for P6REN { }
# [ doc = "`write(|w| ..)` method takes [p6ren::W](p6ren::W) writer structure" ] impl crate :: Writable for P6REN { }
# [ doc = "Port 6 Resistor Enable" ] pub mod p6ren {
# [ doc = "Reader of register P6REN" ] pub type R = crate :: R < u8 , super :: P6REN > ;
# [ doc = "Writer for register P6REN" ] pub type W = crate :: W < u8 , super :: P6REN > ;
# [ doc = "Register P6REN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P6REN { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 6 Select 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p6sel0](p6sel0) module" ] pub type P6SEL0 = crate :: Reg < u8 , _P6SEL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P6SEL0 ;
# [ doc = "`read()` method returns [p6sel0::R](p6sel0::R) reader structure" ] impl crate :: Readable for P6SEL0 { }
# [ doc = "`write(|w| ..)` method takes [p6sel0::W](p6sel0::W) writer structure" ] impl crate :: Writable for P6SEL0 { }
# [ doc = "Port 6 Select 0" ] pub mod p6sel0 {
# [ doc = "Reader of register P6SEL0" ] pub type R = crate :: R < u8 , super :: P6SEL0 > ;
# [ doc = "Writer for register P6SEL0" ] pub type W = crate :: W < u8 , super :: P6SEL0 > ;
# [ doc = "Register P6SEL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P6SEL0 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 6 Select 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p6sel1](p6sel1) module" ] pub type P6SEL1 = crate :: Reg < u8 , _P6SEL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P6SEL1 ;
# [ doc = "`read()` method returns [p6sel1::R](p6sel1::R) reader structure" ] impl crate :: Readable for P6SEL1 { }
# [ doc = "`write(|w| ..)` method takes [p6sel1::W](p6sel1::W) writer structure" ] impl crate :: Writable for P6SEL1 { }
# [ doc = "Port 6 Select 1" ] pub mod p6sel1 {
# [ doc = "Reader of register P6SEL1" ] pub type R = crate :: R < u8 , super :: P6SEL1 > ;
# [ doc = "Writer for register P6SEL1" ] pub type W = crate :: W < u8 , super :: P6SEL1 > ;
# [ doc = "Register P6SEL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P6SEL1 { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Port 6 Complement Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p6selc](p6selc) module" ] pub type P6SELC = crate :: Reg < u8 , _P6SELC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _P6SELC ;
# [ doc = "`read()` method returns [p6selc::R](p6selc::R) reader structure" ] impl crate :: Readable for P6SELC { }
# [ doc = "`write(|w| ..)` method takes [p6selc::W](p6selc::W) writer structure" ] impl crate :: Writable for P6SELC { }
# [ doc = "Port 6 Complement Select" ] pub mod p6selc {
# [ doc = "Reader of register P6SELC" ] pub type R = crate :: R < u8 , super :: P6SELC > ;
# [ doc = "Writer for register P6SELC" ] pub type W = crate :: W < u8 , super :: P6SELC > ;
# [ doc = "Register P6SELC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: P6SELC { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
}
# [ doc = "SFR" ] pub struct SFR { _marker : PhantomData < * const ( ) > } unsafe impl Send for SFR { } impl SFR { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const sfr :: RegisterBlock { 0x0100 as * const _ } } impl Deref for SFR { type Target = sfr :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * SFR :: ptr ( ) } } }
# [ doc = "SFR" ] pub mod sfr {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Interrupt Enable" ] pub sfrie1 : SFRIE1 , # [ doc = "0x02 - Interrupt Flag" ] pub sfrifg1 : SFRIFG1 , # [ doc = "0x04 - Reset Pin Control" ] pub sfrrpcr : SFRRPCR , }
# [ doc = "Interrupt Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sfrie1](sfrie1) module" ] pub type SFRIE1 = crate :: Reg < u16 , _SFRIE1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SFRIE1 ;
# [ doc = "`read()` method returns [sfrie1::R](sfrie1::R) reader structure" ] impl crate :: Readable for SFRIE1 { }
# [ doc = "`write(|w| ..)` method takes [sfrie1::W](sfrie1::W) writer structure" ] impl crate :: Writable for SFRIE1 { }
# [ doc = "Interrupt Enable" ] pub mod sfrie1 {
# [ doc = "Reader of register SFRIE1" ] pub type R = crate :: R < u16 , super :: SFRIE1 > ;
# [ doc = "Writer for register SFRIE1" ] pub type W = crate :: W < u16 , super :: SFRIE1 > ;
# [ doc = "Register SFRIE1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SFRIE1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Watchdog timer interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WDTIE_A { # [ doc = "0: Interrupts disabled" ] DISABLE = 0 , # [ doc = "1: Interrupts enabled" ] ENABLE = 1 } impl From < WDTIE_A > for bool { # [ inline ( always ) ] fn from ( variant : WDTIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `WDTIE`" ] pub type WDTIE_R = crate :: R < bool , WDTIE_A > ; impl WDTIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> WDTIE_A { match self . bits { false => WDTIE_A :: DISABLE , true => WDTIE_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == WDTIE_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == WDTIE_A :: ENABLE } }
# [ doc = "Write proxy for field `WDTIE`" ] pub struct WDTIE_W < 'a > { w : & 'a mut W , } impl < 'a > WDTIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : WDTIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupts disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( WDTIE_A :: DISABLE ) } # [ doc = "Interrupts enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( WDTIE_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Oscillator fault interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OFIE_A { # [ doc = "0: Interrupts disabled" ] DISABLE = 0 , # [ doc = "1: Interrupts enabled" ] ENABLE = 1 } impl From < OFIE_A > for bool { # [ inline ( always ) ] fn from ( variant : OFIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OFIE`" ] pub type OFIE_R = crate :: R < bool , OFIE_A > ; impl OFIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OFIE_A { match self . bits { false => OFIE_A :: DISABLE , true => OFIE_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == OFIE_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == OFIE_A :: ENABLE } }
# [ doc = "Write proxy for field `OFIE`" ] pub struct OFIE_W < 'a > { w : & 'a mut W , } impl < 'a > OFIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OFIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupts disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( OFIE_A :: DISABLE ) } # [ doc = "Interrupts enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( OFIE_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Vacant memory access interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum VMAIE_A { # [ doc = "0: Interrupts disabled" ] DISABLE = 0 , # [ doc = "1: Interrupts enabled" ] ENABLE = 1 } impl From < VMAIE_A > for bool { # [ inline ( always ) ] fn from ( variant : VMAIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `VMAIE`" ] pub type VMAIE_R = crate :: R < bool , VMAIE_A > ; impl VMAIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> VMAIE_A { match self . bits { false => VMAIE_A :: DISABLE , true => VMAIE_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == VMAIE_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == VMAIE_A :: ENABLE } }
# [ doc = "Write proxy for field `VMAIE`" ] pub struct VMAIE_W < 'a > { w : & 'a mut W , } impl < 'a > VMAIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : VMAIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupts disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( VMAIE_A :: DISABLE ) } # [ doc = "Interrupts enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( VMAIE_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "NMI pin interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum NMIIE_A { # [ doc = "0: Interrupts disabled" ] DISABLE = 0 , # [ doc = "1: Interrupts enabled" ] ENABLE = 1 } impl From < NMIIE_A > for bool { # [ inline ( always ) ] fn from ( variant : NMIIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `NMIIE`" ] pub type NMIIE_R = crate :: R < bool , NMIIE_A > ; impl NMIIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> NMIIE_A { match self . bits { false => NMIIE_A :: DISABLE , true => NMIIE_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == NMIIE_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == NMIIE_A :: ENABLE } }
# [ doc = "Write proxy for field `NMIIE`" ] pub struct NMIIE_W < 'a > { w : & 'a mut W , } impl < 'a > NMIIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NMIIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupts disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( NMIIE_A :: DISABLE ) } # [ doc = "Interrupts enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( NMIIE_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "JTAG mailbox input interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum JMBINIE_A { # [ doc = "0: Interrupts disabled" ] DISABLE = 0 , # [ doc = "1: Interrupts enabled" ] ENABLE = 1 } impl From < JMBINIE_A > for bool { # [ inline ( always ) ] fn from ( variant : JMBINIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `JMBINIE`" ] pub type JMBINIE_R = crate :: R < bool , JMBINIE_A > ; impl JMBINIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> JMBINIE_A { match self . bits { false => JMBINIE_A :: DISABLE , true => JMBINIE_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == JMBINIE_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == JMBINIE_A :: ENABLE } }
# [ doc = "Write proxy for field `JMBINIE`" ] pub struct JMBINIE_W < 'a > { w : & 'a mut W , } impl < 'a > JMBINIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : JMBINIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupts disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( JMBINIE_A :: DISABLE ) } # [ doc = "Interrupts enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( JMBINIE_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "JTAG mailbox output interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum JMBOUTIE_A { # [ doc = "0: Interrupts disabled" ] DISABLE = 0 , # [ doc = "1: Interrupts enabled" ] ENABLE = 1 } impl From < JMBOUTIE_A > for bool { # [ inline ( always ) ] fn from ( variant : JMBOUTIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `JMBOUTIE`" ] pub type JMBOUTIE_R = crate :: R < bool , JMBOUTIE_A > ; impl JMBOUTIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> JMBOUTIE_A { match self . bits { false => JMBOUTIE_A :: DISABLE , true => JMBOUTIE_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == JMBOUTIE_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == JMBOUTIE_A :: ENABLE } }
# [ doc = "Write proxy for field `JMBOUTIE`" ] pub struct JMBOUTIE_W < 'a > { w : & 'a mut W , } impl < 'a > JMBOUTIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : JMBOUTIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupts disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( JMBOUTIE_A :: DISABLE ) } # [ doc = "Interrupts enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( JMBOUTIE_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Watchdog timer interrupt enable" ] # [ inline ( always ) ] pub fn wdtie ( & self ) -> WDTIE_R { WDTIE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Oscillator fault interrupt enable" ] # [ inline ( always ) ] pub fn ofie ( & self ) -> OFIE_R { OFIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Vacant memory access interrupt enable" ] # [ inline ( always ) ] pub fn vmaie ( & self ) -> VMAIE_R { VMAIE_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - NMI pin interrupt enable" ] # [ inline ( always ) ] pub fn nmiie ( & self ) -> NMIIE_R { NMIIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - JTAG mailbox input interrupt enable" ] # [ inline ( always ) ] pub fn jmbinie ( & self ) -> JMBINIE_R { JMBINIE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - JTAG mailbox output interrupt enable" ] # [ inline ( always ) ] pub fn jmboutie ( & self ) -> JMBOUTIE_R { JMBOUTIE_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Watchdog timer interrupt enable" ] # [ inline ( always ) ] pub fn wdtie ( & mut self ) -> WDTIE_W { WDTIE_W { w : self } }
# [ doc = "Bit 1 - Oscillator fault interrupt enable" ] # [ inline ( always ) ] pub fn ofie ( & mut self ) -> OFIE_W { OFIE_W { w : self } }
# [ doc = "Bit 3 - Vacant memory access interrupt enable" ] # [ inline ( always ) ] pub fn vmaie ( & mut self ) -> VMAIE_W { VMAIE_W { w : self } }
# [ doc = "Bit 4 - NMI pin interrupt enable" ] # [ inline ( always ) ] pub fn nmiie ( & mut self ) -> NMIIE_W { NMIIE_W { w : self } }
# [ doc = "Bit 6 - JTAG mailbox input interrupt enable" ] # [ inline ( always ) ] pub fn jmbinie ( & mut self ) -> JMBINIE_W { JMBINIE_W { w : self } }
# [ doc = "Bit 7 - JTAG mailbox output interrupt enable" ] # [ inline ( always ) ] pub fn jmboutie ( & mut self ) -> JMBOUTIE_W { JMBOUTIE_W { w : self } }
}
}
# [ doc = "Interrupt Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sfrifg1](sfrifg1) module" ] pub type SFRIFG1 = crate :: Reg < u16 , _SFRIFG1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SFRIFG1 ;
# [ doc = "`read()` method returns [sfrifg1::R](sfrifg1::R) reader structure" ] impl crate :: Readable for SFRIFG1 { }
# [ doc = "`write(|w| ..)` method takes [sfrifg1::W](sfrifg1::W) writer structure" ] impl crate :: Writable for SFRIFG1 { }
# [ doc = "Interrupt Flag" ] pub mod sfrifg1 {
# [ doc = "Reader of register SFRIFG1" ] pub type R = crate :: R < u16 , super :: SFRIFG1 > ;
# [ doc = "Writer for register SFRIFG1" ] pub type W = crate :: W < u16 , super :: SFRIFG1 > ;
# [ doc = "Register SFRIFG1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SFRIFG1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Oscillator fault interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OFIFG_A { # [ doc = "0: No interrupt pending" ] OFIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] OFIFG_1 = 1 } impl From < OFIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : OFIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OFIFG`" ] pub type OFIFG_R = crate :: R < bool , OFIFG_A > ; impl OFIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OFIFG_A { match self . bits { false => OFIFG_A :: OFIFG_0 , true => OFIFG_A :: OFIFG_1 } } # [ doc = "Checks if the value of the field is `OFIFG_0`" ] # [ inline ( always ) ] pub fn is_ofifg_0 ( & self ) -> bool { * self == OFIFG_A :: OFIFG_0 } # [ doc = "Checks if the value of the field is `OFIFG_1`" ] # [ inline ( always ) ] pub fn is_ofifg_1 ( & self ) -> bool { * self == OFIFG_A :: OFIFG_1 } }
# [ doc = "Write proxy for field `OFIFG`" ] pub struct OFIFG_W < 'a > { w : & 'a mut W , } impl < 'a > OFIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OFIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ofifg_0 ( self ) -> & 'a mut W { self . variant ( OFIFG_A :: OFIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ofifg_1 ( self ) -> & 'a mut W { self . variant ( OFIFG_A :: OFIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Vacant memory access interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum VMAIFG_A { # [ doc = "0: No interrupt pending" ] VMAIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] VMAIFG_1 = 1 } impl From < VMAIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : VMAIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `VMAIFG`" ] pub type VMAIFG_R = crate :: R < bool , VMAIFG_A > ; impl VMAIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> VMAIFG_A { match self . bits { false => VMAIFG_A :: VMAIFG_0 , true => VMAIFG_A :: VMAIFG_1 } } # [ doc = "Checks if the value of the field is `VMAIFG_0`" ] # [ inline ( always ) ] pub fn is_vmaifg_0 ( & self ) -> bool { * self == VMAIFG_A :: VMAIFG_0 } # [ doc = "Checks if the value of the field is `VMAIFG_1`" ] # [ inline ( always ) ] pub fn is_vmaifg_1 ( & self ) -> bool { * self == VMAIFG_A :: VMAIFG_1 } }
# [ doc = "Write proxy for field `VMAIFG`" ] pub struct VMAIFG_W < 'a > { w : & 'a mut W , } impl < 'a > VMAIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : VMAIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn vmaifg_0 ( self ) -> & 'a mut W { self . variant ( VMAIFG_A :: VMAIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn vmaifg_1 ( self ) -> & 'a mut W { self . variant ( VMAIFG_A :: VMAIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "NMI pin interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum NMIIFG_A { # [ doc = "0: No interrupt pending" ] NMIIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] NMIIFG_1 = 1 } impl From < NMIIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : NMIIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `NMIIFG`" ] pub type NMIIFG_R = crate :: R < bool , NMIIFG_A > ; impl NMIIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> NMIIFG_A { match self . bits { false => NMIIFG_A :: NMIIFG_0 , true => NMIIFG_A :: NMIIFG_1 } } # [ doc = "Checks if the value of the field is `NMIIFG_0`" ] # [ inline ( always ) ] pub fn is_nmiifg_0 ( & self ) -> bool { * self == NMIIFG_A :: NMIIFG_0 } # [ doc = "Checks if the value of the field is `NMIIFG_1`" ] # [ inline ( always ) ] pub fn is_nmiifg_1 ( & self ) -> bool { * self == NMIIFG_A :: NMIIFG_1 } }
# [ doc = "Write proxy for field `NMIIFG`" ] pub struct NMIIFG_W < 'a > { w : & 'a mut W , } impl < 'a > NMIIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NMIIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn nmiifg_0 ( self ) -> & 'a mut W { self . variant ( NMIIFG_A :: NMIIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn nmiifg_1 ( self ) -> & 'a mut W { self . variant ( NMIIFG_A :: NMIIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Watchdog timer interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WDTIFG_A { # [ doc = "0: No interrupt pending" ] WDTIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] WDTIFG_1 = 1 } impl From < WDTIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : WDTIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `WDTIFG`" ] pub type WDTIFG_R = crate :: R < bool , WDTIFG_A > ; impl WDTIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> WDTIFG_A { match self . bits { false => WDTIFG_A :: WDTIFG_0 , true => WDTIFG_A :: WDTIFG_1 } } # [ doc = "Checks if the value of the field is `WDTIFG_0`" ] # [ inline ( always ) ] pub fn is_wdtifg_0 ( & self ) -> bool { * self == WDTIFG_A :: WDTIFG_0 } # [ doc = "Checks if the value of the field is `WDTIFG_1`" ] # [ inline ( always ) ] pub fn is_wdtifg_1 ( & self ) -> bool { * self == WDTIFG_A :: WDTIFG_1 } }
# [ doc = "Write proxy for field `WDTIFG`" ] pub struct WDTIFG_W < 'a > { w : & 'a mut W , } impl < 'a > WDTIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : WDTIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn wdtifg_0 ( self ) -> & 'a mut W { self . variant ( WDTIFG_A :: WDTIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn wdtifg_1 ( self ) -> & 'a mut W { self . variant ( WDTIFG_A :: WDTIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "JTAG mailbox input interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum JMBINIFG_A { # [ doc = "0: No interrupt pending. When in 16-bit mode (JMBMODE = 0), this bit is cleared automatically when JMBI0 is read by the CPU. When in 32-bit mode (JMBMODE = 1), this bit is cleared automatically when both JMBI0 and JMBI1 have been read by the CPU. This bit is also cleared when the associated vector in SYSUNIV has been read" ] JMBINIFG_0 = 0 , # [ doc = "1: Interrupt pending. A message is waiting in the JMBIN registers. In 16-bit mode (JMBMODE = 0) when JMBI0 has been written by the JTAG module. In 32-bit mode (JMBMODE = 1) when JMBI0 and JMBI1 have been written by the JTAG module." ] JMBINIFG_1 = 1 } impl From < JMBINIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : JMBINIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `JMBINIFG`" ] pub type JMBINIFG_R = crate :: R < bool , JMBINIFG_A > ; impl JMBINIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> JMBINIFG_A { match self . bits { false => JMBINIFG_A :: JMBINIFG_0 , true => JMBINIFG_A :: JMBINIFG_1 } } # [ doc = "Checks if the value of the field is `JMBINIFG_0`" ] # [ inline ( always ) ] pub fn is_jmbinifg_0 ( & self ) -> bool { * self == JMBINIFG_A :: JMBINIFG_0 } # [ doc = "Checks if the value of the field is `JMBINIFG_1`" ] # [ inline ( always ) ] pub fn is_jmbinifg_1 ( & self ) -> bool { * self == JMBINIFG_A :: JMBINIFG_1 } }
# [ doc = "Write proxy for field `JMBINIFG`" ] pub struct JMBINIFG_W < 'a > { w : & 'a mut W , } impl < 'a > JMBINIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : JMBINIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending. When in 16-bit mode (JMBMODE = 0), this bit is cleared automatically when JMBI0 is read by the CPU. When in 32-bit mode (JMBMODE = 1), this bit is cleared automatically when both JMBI0 and JMBI1 have been read by the CPU. This bit is also cleared when the associated vector in SYSUNIV has been read" ] # [ inline ( always ) ] pub fn jmbinifg_0 ( self ) -> & 'a mut W { self . variant ( JMBINIFG_A :: JMBINIFG_0 ) } # [ doc = "Interrupt pending. A message is waiting in the JMBIN registers. In 16-bit mode (JMBMODE = 0) when JMBI0 has been written by the JTAG module. In 32-bit mode (JMBMODE = 1) when JMBI0 and JMBI1 have been written by the JTAG module." ] # [ inline ( always ) ] pub fn jmbinifg_1 ( self ) -> & 'a mut W { self . variant ( JMBINIFG_A :: JMBINIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "JTAG mailbox output interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum JMBOUTIFG_A { # [ doc = "0: No interrupt pending. When in 16-bit mode (JMBMODE = 0), this bit is cleared automatically when JMBO0 has been written with a new message to the JTAG module by the CPU. When in 32-bit mode (JMBMODE = 1), this bit is cleared automatically when both JMBO0 and JMBO1 have been written with new messages to the JTAG module by the CPU. This bit is also cleared when the associated vector in SYSUNIV has been read." ] JMBOUTIFG_0 = 0 , # [ doc = "1: Interrupt pending. JMBO registers are ready for new messages. In 16-bit mode (JMBMODE = 0), JMBO0 has been received by the JTAG module and is ready for a new message from the CPU. In 32-bit mode (JMBMODE = 1), JMBO0 and JMBO1 have been received by the JTAG module and are ready for new messages from the CPU." ] JMBOUTIFG_1 = 1 } impl From < JMBOUTIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : JMBOUTIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `JMBOUTIFG`" ] pub type JMBOUTIFG_R = crate :: R < bool , JMBOUTIFG_A > ; impl JMBOUTIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> JMBOUTIFG_A { match self . bits { false => JMBOUTIFG_A :: JMBOUTIFG_0 , true => JMBOUTIFG_A :: JMBOUTIFG_1 } } # [ doc = "Checks if the value of the field is `JMBOUTIFG_0`" ] # [ inline ( always ) ] pub fn is_jmboutifg_0 ( & self ) -> bool { * self == JMBOUTIFG_A :: JMBOUTIFG_0 } # [ doc = "Checks if the value of the field is `JMBOUTIFG_1`" ] # [ inline ( always ) ] pub fn is_jmboutifg_1 ( & self ) -> bool { * self == JMBOUTIFG_A :: JMBOUTIFG_1 } }
# [ doc = "Write proxy for field `JMBOUTIFG`" ] pub struct JMBOUTIFG_W < 'a > { w : & 'a mut W , } impl < 'a > JMBOUTIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : JMBOUTIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending. When in 16-bit mode (JMBMODE = 0), this bit is cleared automatically when JMBO0 has been written with a new message to the JTAG module by the CPU. When in 32-bit mode (JMBMODE = 1), this bit is cleared automatically when both JMBO0 and JMBO1 have been written with new messages to the JTAG module by the CPU. This bit is also cleared when the associated vector in SYSUNIV has been read." ] # [ inline ( always ) ] pub fn jmboutifg_0 ( self ) -> & 'a mut W { self . variant ( JMBOUTIFG_A :: JMBOUTIFG_0 ) } # [ doc = "Interrupt pending. JMBO registers are ready for new messages. In 16-bit mode (JMBMODE = 0), JMBO0 has been received by the JTAG module and is ready for a new message from the CPU. In 32-bit mode (JMBMODE = 1), JMBO0 and JMBO1 have been received by the JTAG module and are ready for new messages from the CPU." ] # [ inline ( always ) ] pub fn jmboutifg_1 ( self ) -> & 'a mut W { self . variant ( JMBOUTIFG_A :: JMBOUTIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 1 - Oscillator fault interrupt flag" ] # [ inline ( always ) ] pub fn ofifg ( & self ) -> OFIFG_R { OFIFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Vacant memory access interrupt flag" ] # [ inline ( always ) ] pub fn vmaifg ( & self ) -> VMAIFG_R { VMAIFG_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - NMI pin interrupt flag" ] # [ inline ( always ) ] pub fn nmiifg ( & self ) -> NMIIFG_R { NMIIFG_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 0 - Watchdog timer interrupt flag" ] # [ inline ( always ) ] pub fn wdtifg ( & self ) -> WDTIFG_R { WDTIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - JTAG mailbox input interrupt flag" ] # [ inline ( always ) ] pub fn jmbinifg ( & self ) -> JMBINIFG_R { JMBINIFG_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - JTAG mailbox output interrupt flag" ] # [ inline ( always ) ] pub fn jmboutifg ( & self ) -> JMBOUTIFG_R { JMBOUTIFG_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 1 - Oscillator fault interrupt flag" ] # [ inline ( always ) ] pub fn ofifg ( & mut self ) -> OFIFG_W { OFIFG_W { w : self } }
# [ doc = "Bit 3 - Vacant memory access interrupt flag" ] # [ inline ( always ) ] pub fn vmaifg ( & mut self ) -> VMAIFG_W { VMAIFG_W { w : self } }
# [ doc = "Bit 4 - NMI pin interrupt flag" ] # [ inline ( always ) ] pub fn nmiifg ( & mut self ) -> NMIIFG_W { NMIIFG_W { w : self } }
# [ doc = "Bit 0 - Watchdog timer interrupt flag" ] # [ inline ( always ) ] pub fn wdtifg ( & mut self ) -> WDTIFG_W { WDTIFG_W { w : self } }
# [ doc = "Bit 6 - JTAG mailbox input interrupt flag" ] # [ inline ( always ) ] pub fn jmbinifg ( & mut self ) -> JMBINIFG_W { JMBINIFG_W { w : self } }
# [ doc = "Bit 7 - JTAG mailbox output interrupt flag" ] # [ inline ( always ) ] pub fn jmboutifg ( & mut self ) -> JMBOUTIFG_W { JMBOUTIFG_W { w : self } }
}
}
# [ doc = "Reset Pin Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sfrrpcr](sfrrpcr) module" ] pub type SFRRPCR = crate :: Reg < u16 , _SFRRPCR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SFRRPCR ;
# [ doc = "`read()` method returns [sfrrpcr::R](sfrrpcr::R) reader structure" ] impl crate :: Readable for SFRRPCR { }
# [ doc = "`write(|w| ..)` method takes [sfrrpcr::W](sfrrpcr::W) writer structure" ] impl crate :: Writable for SFRRPCR { }
# [ doc = "Reset Pin Control" ] pub mod sfrrpcr {
# [ doc = "Reader of register SFRRPCR" ] pub type R = crate :: R < u16 , super :: SFRRPCR > ;
# [ doc = "Writer for register SFRRPCR" ] pub type W = crate :: W < u16 , super :: SFRRPCR > ;
# [ doc = "Register SFRRPCR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SFRRPCR { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "NMI select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SYSNMI_A { # [ doc = "0: Reset function" ] RESET = 0 , # [ doc = "1: NMI function" ] NMI = 1 } impl From < SYSNMI_A > for bool { # [ inline ( always ) ] fn from ( variant : SYSNMI_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SYSNMI`" ] pub type SYSNMI_R = crate :: R < bool , SYSNMI_A > ; impl SYSNMI_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SYSNMI_A { match self . bits { false => SYSNMI_A :: RESET , true => SYSNMI_A :: NMI } } # [ doc = "Checks if the value of the field is `RESET`" ] # [ inline ( always ) ] pub fn is_reset ( & self ) -> bool { * self == SYSNMI_A :: RESET } # [ doc = "Checks if the value of the field is `NMI`" ] # [ inline ( always ) ] pub fn is_nmi ( & self ) -> bool { * self == SYSNMI_A :: NMI } }
# [ doc = "Write proxy for field `SYSNMI`" ] pub struct SYSNMI_W < 'a > { w : & 'a mut W , } impl < 'a > SYSNMI_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SYSNMI_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Reset function" ] # [ inline ( always ) ] pub fn reset ( self ) -> & 'a mut W { self . variant ( SYSNMI_A :: RESET ) } # [ doc = "NMI function" ] # [ inline ( always ) ] pub fn nmi ( self ) -> & 'a mut W { self . variant ( SYSNMI_A :: NMI ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "NMI edge select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SYSNMIIES_A { # [ doc = "0: NMI on rising edge" ] RISING = 0 , # [ doc = "1: NMI on falling edge" ] FALLING = 1 } impl From < SYSNMIIES_A > for bool { # [ inline ( always ) ] fn from ( variant : SYSNMIIES_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SYSNMIIES`" ] pub type SYSNMIIES_R = crate :: R < bool , SYSNMIIES_A > ; impl SYSNMIIES_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SYSNMIIES_A { match self . bits { false => SYSNMIIES_A :: RISING , true => SYSNMIIES_A :: FALLING } } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == SYSNMIIES_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == SYSNMIIES_A :: FALLING } }
# [ doc = "Write proxy for field `SYSNMIIES`" ] pub struct SYSNMIIES_W < 'a > { w : & 'a mut W , } impl < 'a > SYSNMIIES_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SYSNMIIES_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "NMI on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( SYSNMIIES_A :: RISING ) } # [ doc = "NMI on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( SYSNMIIES_A :: FALLING ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reset resistor pin pullup or pulldown\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SYSRSTUP_A { # [ doc = "0: Pulldown is selected" ] PULLDOWN = 0 , # [ doc = "1: Pullup is selected" ] PULLUP = 1 } impl From < SYSRSTUP_A > for bool { # [ inline ( always ) ] fn from ( variant : SYSRSTUP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SYSRSTUP`" ] pub type SYSRSTUP_R = crate :: R < bool , SYSRSTUP_A > ; impl SYSRSTUP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SYSRSTUP_A { match self . bits { false => SYSRSTUP_A :: PULLDOWN , true => SYSRSTUP_A :: PULLUP } } # [ doc = "Checks if the value of the field is `PULLDOWN`" ] # [ inline ( always ) ] pub fn is_pulldown ( & self ) -> bool { * self == SYSRSTUP_A :: PULLDOWN } # [ doc = "Checks if the value of the field is `PULLUP`" ] # [ inline ( always ) ] pub fn is_pullup ( & self ) -> bool { * self == SYSRSTUP_A :: PULLUP } }
# [ doc = "Write proxy for field `SYSRSTUP`" ] pub struct SYSRSTUP_W < 'a > { w : & 'a mut W , } impl < 'a > SYSRSTUP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SYSRSTUP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Pulldown is selected" ] # [ inline ( always ) ] pub fn pulldown ( self ) -> & 'a mut W { self . variant ( SYSRSTUP_A :: PULLDOWN ) } # [ doc = "Pullup is selected" ] # [ inline ( always ) ] pub fn pullup ( self ) -> & 'a mut W { self . variant ( SYSRSTUP_A :: PULLUP ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reset pin resistor enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SYSRSTRE_A { # [ doc = "0: Pullup or pulldown resistor at the RST/NMI pin is disabled" ] DISABLE = 0 , # [ doc = "1: Pullup or pulldown resistor at the RST/NMI pin is enabled" ] ENABLE = 1 } impl From < SYSRSTRE_A > for bool { # [ inline ( always ) ] fn from ( variant : SYSRSTRE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SYSRSTRE`" ] pub type SYSRSTRE_R = crate :: R < bool , SYSRSTRE_A > ; impl SYSRSTRE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SYSRSTRE_A { match self . bits { false => SYSRSTRE_A :: DISABLE , true => SYSRSTRE_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == SYSRSTRE_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == SYSRSTRE_A :: ENABLE } }
# [ doc = "Write proxy for field `SYSRSTRE`" ] pub struct SYSRSTRE_W < 'a > { w : & 'a mut W , } impl < 'a > SYSRSTRE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SYSRSTRE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Pullup or pulldown resistor at the RST/NMI pin is disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( SYSRSTRE_A :: DISABLE ) } # [ doc = "Pullup or pulldown resistor at the RST/NMI pin is enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( SYSRSTRE_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - NMI select" ] # [ inline ( always ) ] pub fn sysnmi ( & self ) -> SYSNMI_R { SYSNMI_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - NMI edge select" ] # [ inline ( always ) ] pub fn sysnmiies ( & self ) -> SYSNMIIES_R { SYSNMIIES_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Reset resistor pin pullup or pulldown" ] # [ inline ( always ) ] pub fn sysrstup ( & self ) -> SYSRSTUP_R { SYSRSTUP_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Reset pin resistor enable" ] # [ inline ( always ) ] pub fn sysrstre ( & self ) -> SYSRSTRE_R { SYSRSTRE_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - NMI select" ] # [ inline ( always ) ] pub fn sysnmi ( & mut self ) -> SYSNMI_W { SYSNMI_W { w : self } }
# [ doc = "Bit 1 - NMI edge select" ] # [ inline ( always ) ] pub fn sysnmiies ( & mut self ) -> SYSNMIIES_W { SYSNMIIES_W { w : self } }
# [ doc = "Bit 2 - Reset resistor pin pullup or pulldown" ] # [ inline ( always ) ] pub fn sysrstup ( & mut self ) -> SYSRSTUP_W { SYSRSTUP_W { w : self } }
# [ doc = "Bit 3 - Reset pin resistor enable" ] # [ inline ( always ) ] pub fn sysrstre ( & mut self ) -> SYSRSTRE_W { SYSRSTRE_W { w : self } }
}
}
}
# [ doc = "PMM" ] pub struct PMM { _marker : PhantomData < * const ( ) > } unsafe impl Send for PMM { } impl PMM { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const pmm :: RegisterBlock { 0x0120 as * const _ } } impl Deref for PMM { type Target = pmm :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * PMM :: ptr ( ) } } }
# [ doc = "PMM" ] pub mod pmm {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Power Management Module control register 0" ] pub pmmctl0 : PMMCTL0 , _reserved1 : [ u8 ; 2usize ] , # [ doc = "0x04 - Power Management Module Control Register 2" ] pub pmmctl2 : PMMCTL2 , _reserved2 : [ u8 ; 4usize ] , # [ doc = "0x0a - PMM interrupt flag register" ] pub pmmifg : PMMIFG , _reserved3 : [ u8 ; 4usize ] , # [ doc = "0x10 - Power mode 5 control register 0" ] pub pm5ctl0 : PM5CTL0 , }
# [ doc = "Power Management Module control register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pmmctl0](pmmctl0) module" ] pub type PMMCTL0 = crate :: Reg < u16 , _PMMCTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PMMCTL0 ;
# [ doc = "`read()` method returns [pmmctl0::R](pmmctl0::R) reader structure" ] impl crate :: Readable for PMMCTL0 { }
# [ doc = "`write(|w| ..)` method takes [pmmctl0::W](pmmctl0::W) writer structure" ] impl crate :: Writable for PMMCTL0 { }
# [ doc = "Power Management Module control register 0" ] pub mod pmmctl0 {
# [ doc = "Reader of register PMMCTL0" ] pub type R = crate :: R < u16 , super :: PMMCTL0 > ;
# [ doc = "Writer for register PMMCTL0" ] pub type W = crate :: W < u16 , super :: PMMCTL0 > ;
# [ doc = "Register PMMCTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: PMMCTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reflow pre-conditioning. Prepares device for reflow soldering. Write as 0 during normal operation.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum REFLOW_A { # [ doc = "0: Normal operation" ] REFLOW_0 = 0 , # [ doc = "1: Enable reflow pre-conditioning" ] REFLOW_1 = 1 } impl From < REFLOW_A > for bool { # [ inline ( always ) ] fn from ( variant : REFLOW_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `REFLOW`" ] pub type REFLOW_R = crate :: R < bool , REFLOW_A > ; impl REFLOW_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> REFLOW_A { match self . bits { false => REFLOW_A :: REFLOW_0 , true => REFLOW_A :: REFLOW_1 } } # [ doc = "Checks if the value of the field is `REFLOW_0`" ] # [ inline ( always ) ] pub fn is_reflow_0 ( & self ) -> bool { * self == REFLOW_A :: REFLOW_0 } # [ doc = "Checks if the value of the field is `REFLOW_1`" ] # [ inline ( always ) ] pub fn is_reflow_1 ( & self ) -> bool { * self == REFLOW_A :: REFLOW_1 } }
# [ doc = "Write proxy for field `REFLOW`" ] pub struct REFLOW_W < 'a > { w : & 'a mut W , } impl < 'a > REFLOW_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : REFLOW_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Normal operation" ] # [ inline ( always ) ] pub fn reflow_0 ( self ) -> & 'a mut W { self . variant ( REFLOW_A :: REFLOW_0 ) } # [ doc = "Enable reflow pre-conditioning" ] # [ inline ( always ) ] pub fn reflow_1 ( self ) -> & 'a mut W { self . variant ( REFLOW_A :: REFLOW_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Software brownout reset.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PMMSWBOR_A { # [ doc = "0: Normal operation" ] PMMSWBOR_0 = 0 , # [ doc = "1: Set to 1 to trigger a BOR" ] PMMSWBOR_1 = 1 } impl From < PMMSWBOR_A > for bool { # [ inline ( always ) ] fn from ( variant : PMMSWBOR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `PMMSWBOR`" ] pub type PMMSWBOR_R = crate :: R < bool , PMMSWBOR_A > ; impl PMMSWBOR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PMMSWBOR_A { match self . bits { false => PMMSWBOR_A :: PMMSWBOR_0 , true => PMMSWBOR_A :: PMMSWBOR_1 } } # [ doc = "Checks if the value of the field is `PMMSWBOR_0`" ] # [ inline ( always ) ] pub fn is_pmmswbor_0 ( & self ) -> bool { * self == PMMSWBOR_A :: PMMSWBOR_0 } # [ doc = "Checks if the value of the field is `PMMSWBOR_1`" ] # [ inline ( always ) ] pub fn is_pmmswbor_1 ( & self ) -> bool { * self == PMMSWBOR_A :: PMMSWBOR_1 } }
# [ doc = "Write proxy for field `PMMSWBOR`" ] pub struct PMMSWBOR_W < 'a > { w : & 'a mut W , } impl < 'a > PMMSWBOR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PMMSWBOR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Normal operation" ] # [ inline ( always ) ] pub fn pmmswbor_0 ( self ) -> & 'a mut W { self . variant ( PMMSWBOR_A :: PMMSWBOR_0 ) } # [ doc = "Set to 1 to trigger a BOR" ] # [ inline ( always ) ] pub fn pmmswbor_1 ( self ) -> & 'a mut W { self . variant ( PMMSWBOR_A :: PMMSWBOR_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Software POR.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PMMSWPOR_A { # [ doc = "0: Normal operation" ] PMMSWPOR_0 = 0 , # [ doc = "1: Set to 1 to trigger a POR" ] PMMSWPOR_1 = 1 } impl From < PMMSWPOR_A > for bool { # [ inline ( always ) ] fn from ( variant : PMMSWPOR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `PMMSWPOR`" ] pub type PMMSWPOR_R = crate :: R < bool , PMMSWPOR_A > ; impl PMMSWPOR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PMMSWPOR_A { match self . bits { false => PMMSWPOR_A :: PMMSWPOR_0 , true => PMMSWPOR_A :: PMMSWPOR_1 } } # [ doc = "Checks if the value of the field is `PMMSWPOR_0`" ] # [ inline ( always ) ] pub fn is_pmmswpor_0 ( & self ) -> bool { * self == PMMSWPOR_A :: PMMSWPOR_0 } # [ doc = "Checks if the value of the field is `PMMSWPOR_1`" ] # [ inline ( always ) ] pub fn is_pmmswpor_1 ( & self ) -> bool { * self == PMMSWPOR_A :: PMMSWPOR_1 } }
# [ doc = "Write proxy for field `PMMSWPOR`" ] pub struct PMMSWPOR_W < 'a > { w : & 'a mut W , } impl < 'a > PMMSWPOR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PMMSWPOR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Normal operation" ] # [ inline ( always ) ] pub fn pmmswpor_0 ( self ) -> & 'a mut W { self . variant ( PMMSWPOR_A :: PMMSWPOR_0 ) } # [ doc = "Set to 1 to trigger a POR" ] # [ inline ( always ) ] pub fn pmmswpor_1 ( self ) -> & 'a mut W { self . variant ( PMMSWPOR_A :: PMMSWPOR_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Regulator off\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PMMREGOFF_A { # [ doc = "0: Regulator remains on when going into LPM3 or LPM4" ] PMMREGOFF_0 = 0 , # [ doc = "1: Regulator is turned off when going to LPM3 or LPM4. System enters LPM3.5 or LPM4.5, respectively." ] PMMREGOFF_1 = 1 } impl From < PMMREGOFF_A > for bool { # [ inline ( always ) ] fn from ( variant : PMMREGOFF_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `PMMREGOFF`" ] pub type PMMREGOFF_R = crate :: R < bool , PMMREGOFF_A > ; impl PMMREGOFF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PMMREGOFF_A { match self . bits { false => PMMREGOFF_A :: PMMREGOFF_0 , true => PMMREGOFF_A :: PMMREGOFF_1 } } # [ doc = "Checks if the value of the field is `PMMREGOFF_0`" ] # [ inline ( always ) ] pub fn is_pmmregoff_0 ( & self ) -> bool { * self == PMMREGOFF_A :: PMMREGOFF_0 } # [ doc = "Checks if the value of the field is `PMMREGOFF_1`" ] # [ inline ( always ) ] pub fn is_pmmregoff_1 ( & self ) -> bool { * self == PMMREGOFF_A :: PMMREGOFF_1 } }
# [ doc = "Write proxy for field `PMMREGOFF`" ] pub struct PMMREGOFF_W < 'a > { w : & 'a mut W , } impl < 'a > PMMREGOFF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PMMREGOFF_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Regulator remains on when going into LPM3 or LPM4" ] # [ inline ( always ) ] pub fn pmmregoff_0 ( self ) -> & 'a mut W { self . variant ( PMMREGOFF_A :: PMMREGOFF_0 ) } # [ doc = "Regulator is turned off when going to LPM3 or LPM4. System enters LPM3.5 or LPM4.5, respectively." ] # [ inline ( always ) ] pub fn pmmregoff_1 ( self ) -> & 'a mut W { self . variant ( PMMREGOFF_A :: PMMREGOFF_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "High-side SVS enable.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SVSHE_A { # [ doc = "0: High-side SVS (SVSH) is disabled in LPM2, LPM3, LPM4, LPM3.5, and LPM4.5. SVSH is always enabled in active mode, LPM0, and LPM1." ] SVSHE_0 = 0 , # [ doc = "1: SVSH is always enabled." ] SVSHE_1 = 1 } impl From < SVSHE_A > for bool { # [ inline ( always ) ] fn from ( variant : SVSHE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SVSHE`" ] pub type SVSHE_R = crate :: R < bool , SVSHE_A > ; impl SVSHE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SVSHE_A { match self . bits { false => SVSHE_A :: SVSHE_0 , true => SVSHE_A :: SVSHE_1 } } # [ doc = "Checks if the value of the field is `SVSHE_0`" ] # [ inline ( always ) ] pub fn is_svshe_0 ( & self ) -> bool { * self == SVSHE_A :: SVSHE_0 } # [ doc = "Checks if the value of the field is `SVSHE_1`" ] # [ inline ( always ) ] pub fn is_svshe_1 ( & self ) -> bool { * self == SVSHE_A :: SVSHE_1 } }
# [ doc = "Write proxy for field `SVSHE`" ] pub struct SVSHE_W < 'a > { w : & 'a mut W , } impl < 'a > SVSHE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SVSHE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "High-side SVS (SVSH) is disabled in LPM2, LPM3, LPM4, LPM3.5, and LPM4.5. SVSH is always enabled in active mode, LPM0, and LPM1." ] # [ inline ( always ) ] pub fn svshe_0 ( self ) -> & 'a mut W { self . variant ( SVSHE_A :: SVSHE_0 ) } # [ doc = "SVSH is always enabled." ] # [ inline ( always ) ] pub fn svshe_1 ( self ) -> & 'a mut W { self . variant ( SVSHE_A :: SVSHE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `PMMPW`" ] pub type PMMPW_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `PMMPW`" ] pub struct PMMPW_W < 'a > { w : & 'a mut W , } impl < 'a > PMMPW_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 8 ) ) | ( ( ( value as u16 ) & 0xff ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Reflow pre-conditioning. Prepares device for reflow soldering. Write as 0 during normal operation." ] # [ inline ( always ) ] pub fn reflow ( & self ) -> REFLOW_R { REFLOW_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Software brownout reset." ] # [ inline ( always ) ] pub fn pmmswbor ( & self ) -> PMMSWBOR_R { PMMSWBOR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Software POR." ] # [ inline ( always ) ] pub fn pmmswpor ( & self ) -> PMMSWPOR_R { PMMSWPOR_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Regulator off" ] # [ inline ( always ) ] pub fn pmmregoff ( & self ) -> PMMREGOFF_R { PMMREGOFF_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - High-side SVS enable." ] # [ inline ( always ) ] pub fn svshe ( & self ) -> SVSHE_R { SVSHE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:15 - PMM password." ] # [ inline ( always ) ] pub fn pmmpw ( & self ) -> PMMPW_R { PMMPW_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Reflow pre-conditioning. Prepares device for reflow soldering. Write as 0 during normal operation." ] # [ inline ( always ) ] pub fn reflow ( & mut self ) -> REFLOW_W { REFLOW_W { w : self } }
# [ doc = "Bit 2 - Software brownout reset." ] # [ inline ( always ) ] pub fn pmmswbor ( & mut self ) -> PMMSWBOR_W { PMMSWBOR_W { w : self } }
# [ doc = "Bit 3 - Software POR." ] # [ inline ( always ) ] pub fn pmmswpor ( & mut self ) -> PMMSWPOR_W { PMMSWPOR_W { w : self } }
# [ doc = "Bit 4 - Regulator off" ] # [ inline ( always ) ] pub fn pmmregoff ( & mut self ) -> PMMREGOFF_W { PMMREGOFF_W { w : self } }
# [ doc = "Bit 6 - High-side SVS enable." ] # [ inline ( always ) ] pub fn svshe ( & mut self ) -> SVSHE_W { SVSHE_W { w : self } }
# [ doc = "Bits 8:15 - PMM password." ] # [ inline ( always ) ] pub fn pmmpw ( & mut self ) -> PMMPW_W { PMMPW_W { w : self } }
}
}
# [ doc = "Power Management Module Control Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pmmctl2](pmmctl2) module" ] pub type PMMCTL2 = crate :: Reg < u16 , _PMMCTL2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PMMCTL2 ;
# [ doc = "`read()` method returns [pmmctl2::R](pmmctl2::R) reader structure" ] impl crate :: Readable for PMMCTL2 { }
# [ doc = "`write(|w| ..)` method takes [pmmctl2::W](pmmctl2::W) writer structure" ] impl crate :: Writable for PMMCTL2 { }
# [ doc = "Power Management Module Control Register 2" ] pub mod pmmctl2 {
# [ doc = "Reader of register PMMCTL2" ] pub type R = crate :: R < u16 , super :: PMMCTL2 > ;
# [ doc = "Writer for register PMMCTL2" ] pub type W = crate :: W < u16 , super :: PMMCTL2 > ;
# [ doc = "Register PMMCTL2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: PMMCTL2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Internal reference enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INTREFEN_A { # [ doc = "0: Disable internal reference" ] INTREFEN_0 = 0 , # [ doc = "1: Enable internal reference" ] INTREFEN_1 = 1 } impl From < INTREFEN_A > for bool { # [ inline ( always ) ] fn from ( variant : INTREFEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `INTREFEN`" ] pub type INTREFEN_R = crate :: R < bool , INTREFEN_A > ; impl INTREFEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> INTREFEN_A { match self . bits { false => INTREFEN_A :: INTREFEN_0 , true => INTREFEN_A :: INTREFEN_1 } } # [ doc = "Checks if the value of the field is `INTREFEN_0`" ] # [ inline ( always ) ] pub fn is_intrefen_0 ( & self ) -> bool { * self == INTREFEN_A :: INTREFEN_0 } # [ doc = "Checks if the value of the field is `INTREFEN_1`" ] # [ inline ( always ) ] pub fn is_intrefen_1 ( & self ) -> bool { * self == INTREFEN_A :: INTREFEN_1 } }
# [ doc = "Write proxy for field `INTREFEN`" ] pub struct INTREFEN_W < 'a > { w : & 'a mut W , } impl < 'a > INTREFEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : INTREFEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disable internal reference" ] # [ inline ( always ) ] pub fn intrefen_0 ( self ) -> & 'a mut W { self . variant ( INTREFEN_A :: INTREFEN_0 ) } # [ doc = "Enable internal reference" ] # [ inline ( always ) ] pub fn intrefen_1 ( self ) -> & 'a mut W { self . variant ( INTREFEN_A :: INTREFEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "External reference output enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EXTREFEN_A { # [ doc = "0: Disable external reference output" ] EXTREFEN_0 = 0 , # [ doc = "1: Enable internal reference output" ] EXTREFEN_1 = 1 } impl From < EXTREFEN_A > for bool { # [ inline ( always ) ] fn from ( variant : EXTREFEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `EXTREFEN`" ] pub type EXTREFEN_R = crate :: R < bool , EXTREFEN_A > ; impl EXTREFEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> EXTREFEN_A { match self . bits { false => EXTREFEN_A :: EXTREFEN_0 , true => EXTREFEN_A :: EXTREFEN_1 } } # [ doc = "Checks if the value of the field is `EXTREFEN_0`" ] # [ inline ( always ) ] pub fn is_extrefen_0 ( & self ) -> bool { * self == EXTREFEN_A :: EXTREFEN_0 } # [ doc = "Checks if the value of the field is `EXTREFEN_1`" ] # [ inline ( always ) ] pub fn is_extrefen_1 ( & self ) -> bool { * self == EXTREFEN_A :: EXTREFEN_1 } }
# [ doc = "Write proxy for field `EXTREFEN`" ] pub struct EXTREFEN_W < 'a > { w : & 'a mut W , } impl < 'a > EXTREFEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : EXTREFEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disable external reference output" ] # [ inline ( always ) ] pub fn extrefen_0 ( self ) -> & 'a mut W { self . variant ( EXTREFEN_A :: EXTREFEN_0 ) } # [ doc = "Enable internal reference output" ] # [ inline ( always ) ] pub fn extrefen_1 ( self ) -> & 'a mut W { self . variant ( EXTREFEN_A :: EXTREFEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `PWRMODE`" ] pub type PWRMODE_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `PWRMODE`" ] pub struct PWRMODE_W < 'a > { w : & 'a mut W , } impl < 'a > PWRMODE_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
# [ doc = "Temperature sensor enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TSENSOREN_A { # [ doc = "0: Disable temperature sensor" ] TSENSOREN_0 = 0 , # [ doc = "1: Enable temperature sensor" ] TSENSOREN_1 = 1 } impl From < TSENSOREN_A > for bool { # [ inline ( always ) ] fn from ( variant : TSENSOREN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `TSENSOREN`" ] pub type TSENSOREN_R = crate :: R < bool , TSENSOREN_A > ; impl TSENSOREN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TSENSOREN_A { match self . bits { false => TSENSOREN_A :: TSENSOREN_0 , true => TSENSOREN_A :: TSENSOREN_1 } } # [ doc = "Checks if the value of the field is `TSENSOREN_0`" ] # [ inline ( always ) ] pub fn is_tsensoren_0 ( & self ) -> bool { * self == TSENSOREN_A :: TSENSOREN_0 } # [ doc = "Checks if the value of the field is `TSENSOREN_1`" ] # [ inline ( always ) ] pub fn is_tsensoren_1 ( & self ) -> bool { * self == TSENSOREN_A :: TSENSOREN_1 } }
# [ doc = "Write proxy for field `TSENSOREN`" ] pub struct TSENSOREN_W < 'a > { w : & 'a mut W , } impl < 'a > TSENSOREN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TSENSOREN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disable temperature sensor" ] # [ inline ( always ) ] pub fn tsensoren_0 ( self ) -> & 'a mut W { self . variant ( TSENSOREN_A :: TSENSOREN_0 ) } # [ doc = "Enable temperature sensor" ] # [ inline ( always ) ] pub fn tsensoren_1 ( self ) -> & 'a mut W { self . variant ( TSENSOREN_A :: TSENSOREN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reference generator active. Read only.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum REFGENACT_A { # [ doc = "0: Reference generator not active" ] REFGENACT_0 = 0 , # [ doc = "1: Reference generator active" ] REFGENACT_1 = 1 } impl From < REFGENACT_A > for bool { # [ inline ( always ) ] fn from ( variant : REFGENACT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `REFGENACT`" ] pub type REFGENACT_R = crate :: R < bool , REFGENACT_A > ; impl REFGENACT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> REFGENACT_A { match self . bits { false => REFGENACT_A :: REFGENACT_0 , true => REFGENACT_A :: REFGENACT_1 } } # [ doc = "Checks if the value of the field is `REFGENACT_0`" ] # [ inline ( always ) ] pub fn is_refgenact_0 ( & self ) -> bool { * self == REFGENACT_A :: REFGENACT_0 } # [ doc = "Checks if the value of the field is `REFGENACT_1`" ] # [ inline ( always ) ] pub fn is_refgenact_1 ( & self ) -> bool { * self == REFGENACT_A :: REFGENACT_1 } }
# [ doc = "Reference bandgap active. Ready only.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum REFBGACT_A { # [ doc = "0: Reference bandgap buffer not active" ] REFBGACT_0 = 0 , # [ doc = "1: Reference bandgap buffer active" ] REFBGACT_1 = 1 } impl From < REFBGACT_A > for bool { # [ inline ( always ) ] fn from ( variant : REFBGACT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `REFBGACT`" ] pub type REFBGACT_R = crate :: R < bool , REFBGACT_A > ; impl REFBGACT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> REFBGACT_A { match self . bits { false => REFBGACT_A :: REFBGACT_0 , true => REFBGACT_A :: REFBGACT_1 } } # [ doc = "Checks if the value of the field is `REFBGACT_0`" ] # [ inline ( always ) ] pub fn is_refbgact_0 ( & self ) -> bool { * self == REFBGACT_A :: REFBGACT_0 } # [ doc = "Checks if the value of the field is `REFBGACT_1`" ] # [ inline ( always ) ] pub fn is_refbgact_1 ( & self ) -> bool { * self == REFBGACT_A :: REFBGACT_1 } }
# [ doc = "Bandgap mode. Ready only.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BGMODE_A { # [ doc = "0: Static mode (higher precision)" ] BGMODE_0 = 0 , # [ doc = "1: Sampled mode (lower power consumption)" ] BGMODE_1 = 1 } impl From < BGMODE_A > for bool { # [ inline ( always ) ] fn from ( variant : BGMODE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `BGMODE`" ] pub type BGMODE_R = crate :: R < bool , BGMODE_A > ; impl BGMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> BGMODE_A { match self . bits { false => BGMODE_A :: BGMODE_0 , true => BGMODE_A :: BGMODE_1 } } # [ doc = "Checks if the value of the field is `BGMODE_0`" ] # [ inline ( always ) ] pub fn is_bgmode_0 ( & self ) -> bool { * self == BGMODE_A :: BGMODE_0 } # [ doc = "Checks if the value of the field is `BGMODE_1`" ] # [ inline ( always ) ] pub fn is_bgmode_1 ( & self ) -> bool { * self == BGMODE_A :: BGMODE_1 } }
# [ doc = "Write proxy for field `BGMODE`" ] pub struct BGMODE_W < 'a > { w : & 'a mut W , } impl < 'a > BGMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : BGMODE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Static mode (higher precision)" ] # [ inline ( always ) ] pub fn bgmode_0 ( self ) -> & 'a mut W { self . variant ( BGMODE_A :: BGMODE_0 ) } # [ doc = "Sampled mode (lower power consumption)" ] # [ inline ( always ) ] pub fn bgmode_1 ( self ) -> & 'a mut W { self . variant ( BGMODE_A :: BGMODE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Variable reference voltage ready status.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum REFGENRDY_A { # [ doc = "0: Reference voltage output is not ready to be used." ] REFGENRDY_0 = 0 , # [ doc = "1: Reference voltage output is ready to be used" ] REFGENRDY_1 = 1 } impl From < REFGENRDY_A > for bool { # [ inline ( always ) ] fn from ( variant : REFGENRDY_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `REFGENRDY`" ] pub type REFGENRDY_R = crate :: R < bool , REFGENRDY_A > ; impl REFGENRDY_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> REFGENRDY_A { match self . bits { false => REFGENRDY_A :: REFGENRDY_0 , true => REFGENRDY_A :: REFGENRDY_1 } } # [ doc = "Checks if the value of the field is `REFGENRDY_0`" ] # [ inline ( always ) ] pub fn is_refgenrdy_0 ( & self ) -> bool { * self == REFGENRDY_A :: REFGENRDY_0 } # [ doc = "Checks if the value of the field is `REFGENRDY_1`" ] # [ inline ( always ) ] pub fn is_refgenrdy_1 ( & self ) -> bool { * self == REFGENRDY_A :: REFGENRDY_1 } }
# [ doc = "Write proxy for field `REFGENRDY`" ] pub struct REFGENRDY_W < 'a > { w : & 'a mut W , } impl < 'a > REFGENRDY_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : REFGENRDY_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Reference voltage output is not ready to be used." ] # [ inline ( always ) ] pub fn refgenrdy_0 ( self ) -> & 'a mut W { self . variant ( REFGENRDY_A :: REFGENRDY_0 ) } # [ doc = "Reference voltage output is ready to be used" ] # [ inline ( always ) ] pub fn refgenrdy_1 ( self ) -> & 'a mut W { self . variant ( REFGENRDY_A :: REFGENRDY_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Buffered bandgap voltage ready status.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum REFBGRDY_A { # [ doc = "0: Buffered bandgap voltage is not ready to be used" ] REFBGRDY_0 = 0 , # [ doc = "1: Buffered bandgap voltage is ready to be used" ] REFBGRDY_1 = 1 } impl From < REFBGRDY_A > for bool { # [ inline ( always ) ] fn from ( variant : REFBGRDY_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `REFBGRDY`" ] pub type REFBGRDY_R = crate :: R < bool , REFBGRDY_A > ; impl REFBGRDY_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> REFBGRDY_A { match self . bits { false => REFBGRDY_A :: REFBGRDY_0 , true => REFBGRDY_A :: REFBGRDY_1 } } # [ doc = "Checks if the value of the field is `REFBGRDY_0`" ] # [ inline ( always ) ] pub fn is_refbgrdy_0 ( & self ) -> bool { * self == REFBGRDY_A :: REFBGRDY_0 } # [ doc = "Checks if the value of the field is `REFBGRDY_1`" ] # [ inline ( always ) ] pub fn is_refbgrdy_1 ( & self ) -> bool { * self == REFBGRDY_A :: REFBGRDY_1 } }
# [ doc = "Write proxy for field `REFBGRDY`" ] pub struct REFBGRDY_W < 'a > { w : & 'a mut W , } impl < 'a > REFBGRDY_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : REFBGRDY_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Buffered bandgap voltage is not ready to be used" ] # [ inline ( always ) ] pub fn refbgrdy_0 ( self ) -> & 'a mut W { self . variant ( REFBGRDY_A :: REFBGRDY_0 ) } # [ doc = "Buffered bandgap voltage is ready to be used" ] # [ inline ( always ) ] pub fn refbgrdy_1 ( self ) -> & 'a mut W { self . variant ( REFBGRDY_A :: REFBGRDY_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reference voltage level select. Can be modified only when REFGENBUSY = 0.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum REFVSEL_A { # [ doc = "0: 00b = 1.5V" ] REFVSEL_0 = 0 , # [ doc = "1: 01b = 2.0V" ] REFVSEL_1 = 1 , # [ doc = "2: 10b = 2.5V" ] REFVSEL_2 = 2 , # [ doc = "3: 11b = Reserved" ] REFVSEL_3 = 3 } impl From < REFVSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : REFVSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `REFVSEL`" ] pub type REFVSEL_R = crate :: R < u8 , REFVSEL_A > ; impl REFVSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> REFVSEL_A { match self . bits { 0 => REFVSEL_A :: REFVSEL_0 , 1 => REFVSEL_A :: REFVSEL_1 , 2 => REFVSEL_A :: REFVSEL_2 , 3 => REFVSEL_A :: REFVSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `REFVSEL_0`" ] # [ inline ( always ) ] pub fn is_refvsel_0 ( & self ) -> bool { * self == REFVSEL_A :: REFVSEL_0 } # [ doc = "Checks if the value of the field is `REFVSEL_1`" ] # [ inline ( always ) ] pub fn is_refvsel_1 ( & self ) -> bool { * self == REFVSEL_A :: REFVSEL_1 } # [ doc = "Checks if the value of the field is `REFVSEL_2`" ] # [ inline ( always ) ] pub fn is_refvsel_2 ( & self ) -> bool { * self == REFVSEL_A :: REFVSEL_2 } # [ doc = "Checks if the value of the field is `REFVSEL_3`" ] # [ inline ( always ) ] pub fn is_refvsel_3 ( & self ) -> bool { * self == REFVSEL_A :: REFVSEL_3 } }
# [ doc = "Write proxy for field `REFVSEL`" ] pub struct REFVSEL_W < 'a > { w : & 'a mut W , } impl < 'a > REFVSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : REFVSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "00b = 1.5V" ] # [ inline ( always ) ] pub fn refvsel_0 ( self ) -> & 'a mut W { self . variant ( REFVSEL_A :: REFVSEL_0 ) } # [ doc = "01b = 2.0V" ] # [ inline ( always ) ] pub fn refvsel_1 ( self ) -> & 'a mut W { self . variant ( REFVSEL_A :: REFVSEL_1 ) } # [ doc = "10b = 2.5V" ] # [ inline ( always ) ] pub fn refvsel_2 ( self ) -> & 'a mut W { self . variant ( REFVSEL_A :: REFVSEL_2 ) } # [ doc = "11b = Reserved" ] # [ inline ( always ) ] pub fn refvsel_3 ( self ) -> & 'a mut W { self . variant ( REFVSEL_A :: REFVSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Reference generator one-time trigger. If written with a 1, the generation of the variable reference voltage is started. When the reference voltage request is set, this bit is cleared by hardware.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum REFGEN_A { # [ doc = "0: No trigger" ] REFGEN_0 = 0 , # [ doc = "1: Generation of the reference voltage is started by writing 1 or by a hardware trigger" ] REFGEN_1 = 1 } impl From < REFGEN_A > for bool { # [ inline ( always ) ] fn from ( variant : REFGEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `REFGEN`" ] pub type REFGEN_R = crate :: R < bool , REFGEN_A > ; impl REFGEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> REFGEN_A { match self . bits { false => REFGEN_A :: REFGEN_0 , true => REFGEN_A :: REFGEN_1 } } # [ doc = "Checks if the value of the field is `REFGEN_0`" ] # [ inline ( always ) ] pub fn is_refgen_0 ( & self ) -> bool { * self == REFGEN_A :: REFGEN_0 } # [ doc = "Checks if the value of the field is `REFGEN_1`" ] # [ inline ( always ) ] pub fn is_refgen_1 ( & self ) -> bool { * self == REFGEN_A :: REFGEN_1 } }
# [ doc = "Write proxy for field `REFGEN`" ] pub struct REFGEN_W < 'a > { w : & 'a mut W , } impl < 'a > REFGEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : REFGEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No trigger" ] # [ inline ( always ) ] pub fn refgen_0 ( self ) -> & 'a mut W { self . variant ( REFGEN_A :: REFGEN_0 ) } # [ doc = "Generation of the reference voltage is started by writing 1 or by a hardware trigger" ] # [ inline ( always ) ] pub fn refgen_1 ( self ) -> & 'a mut W { self . variant ( REFGEN_A :: REFGEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Bandgap and bandgap buffer one-time trigger. If written with a 1, the generation of the buffered bandgap voltage is started. When the bandgap buffer voltage request is set, this bit is cleared by hardware.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum REFBGEN_A { # [ doc = "0: No trigger" ] REFBG_0 = 0 , # [ doc = "1: Generation of the bandgap voltage is started by writing 1 or by a hardware trigger" ] REFBG_1 = 1 } impl From < REFBGEN_A > for bool { # [ inline ( always ) ] fn from ( variant : REFBGEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `REFBGEN`" ] pub type REFBGEN_R = crate :: R < bool , REFBGEN_A > ; impl REFBGEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> REFBGEN_A { match self . bits { false => REFBGEN_A :: REFBG_0 , true => REFBGEN_A :: REFBG_1 } } # [ doc = "Checks if the value of the field is `REFBG_0`" ] # [ inline ( always ) ] pub fn is_refbg_0 ( & self ) -> bool { * self == REFBGEN_A :: REFBG_0 } # [ doc = "Checks if the value of the field is `REFBG_1`" ] # [ inline ( always ) ] pub fn is_refbg_1 ( & self ) -> bool { * self == REFBGEN_A :: REFBG_1 } }
# [ doc = "Write proxy for field `REFBGEN`" ] pub struct REFBGEN_W < 'a > { w : & 'a mut W , } impl < 'a > REFBGEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : REFBGEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No trigger" ] # [ inline ( always ) ] pub fn refbg_0 ( self ) -> & 'a mut W { self . variant ( REFBGEN_A :: REFBG_0 ) } # [ doc = "Generation of the bandgap voltage is started by writing 1 or by a hardware trigger" ] # [ inline ( always ) ] pub fn refbg_1 ( self ) -> & 'a mut W { self . variant ( REFBGEN_A :: REFBG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Internal reference enable" ] # [ inline ( always ) ] pub fn intrefen ( & self ) -> INTREFEN_R { INTREFEN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - External reference output enable" ] # [ inline ( always ) ] pub fn extrefen ( & self ) -> EXTREFEN_R { EXTREFEN_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 14:15 - Power Mode Selection. The two bits are used to select the power supply in multi power supply systems. A single power supply system is not affected by the bits. Reserved for future use." ] # [ inline ( always ) ] pub fn pwrmode ( & self ) -> PWRMODE_R { PWRMODE_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 3 - Temperature sensor enable" ] # [ inline ( always ) ] pub fn tsensoren ( & self ) -> TSENSOREN_R { TSENSOREN_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Reference generator active. Read only." ] # [ inline ( always ) ] pub fn refgenact ( & self ) -> REFGENACT_R { REFGENACT_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Reference bandgap active. Ready only." ] # [ inline ( always ) ] pub fn refbgact ( & self ) -> REFBGACT_R { REFBGACT_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Bandgap mode. Ready only." ] # [ inline ( always ) ] pub fn bgmode ( & self ) -> BGMODE_R { BGMODE_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Variable reference voltage ready status." ] # [ inline ( always ) ] pub fn refgenrdy ( & self ) -> REFGENRDY_R { REFGENRDY_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Buffered bandgap voltage ready status." ] # [ inline ( always ) ] pub fn refbgrdy ( & self ) -> REFBGRDY_R { REFBGRDY_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - Reference voltage level select. Can be modified only when REFGENBUSY = 0." ] # [ inline ( always ) ] pub fn refvsel ( & self ) -> REFVSEL_R { REFVSEL_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 6 - Reference generator one-time trigger. If written with a 1, the generation of the variable reference voltage is started. When the reference voltage request is set, this bit is cleared by hardware." ] # [ inline ( always ) ] pub fn refgen ( & self ) -> REFGEN_R { REFGEN_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Bandgap and bandgap buffer one-time trigger. If written with a 1, the generation of the buffered bandgap voltage is started. When the bandgap buffer voltage request is set, this bit is cleared by hardware." ] # [ inline ( always ) ] pub fn refbgen ( & self ) -> REFBGEN_R { REFBGEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Internal reference enable" ] # [ inline ( always ) ] pub fn intrefen ( & mut self ) -> INTREFEN_W { INTREFEN_W { w : self } }
# [ doc = "Bit 1 - External reference output enable" ] # [ inline ( always ) ] pub fn extrefen ( & mut self ) -> EXTREFEN_W { EXTREFEN_W { w : self } }
# [ doc = "Bits 14:15 - Power Mode Selection. The two bits are used to select the power supply in multi power supply systems. A single power supply system is not affected by the bits. Reserved for future use." ] # [ inline ( always ) ] pub fn pwrmode ( & mut self ) -> PWRMODE_W { PWRMODE_W { w : self } }
# [ doc = "Bit 3 - Temperature sensor enable" ] # [ inline ( always ) ] pub fn tsensoren ( & mut self ) -> TSENSOREN_W { TSENSOREN_W { w : self } }
# [ doc = "Bit 11 - Bandgap mode. Ready only." ] # [ inline ( always ) ] pub fn bgmode ( & mut self ) -> BGMODE_W { BGMODE_W { w : self } }
# [ doc = "Bit 12 - Variable reference voltage ready status." ] # [ inline ( always ) ] pub fn refgenrdy ( & mut self ) -> REFGENRDY_W { REFGENRDY_W { w : self } }
# [ doc = "Bit 13 - Buffered bandgap voltage ready status." ] # [ inline ( always ) ] pub fn refbgrdy ( & mut self ) -> REFBGRDY_W { REFBGRDY_W { w : self } }
# [ doc = "Bits 4:5 - Reference voltage level select. Can be modified only when REFGENBUSY = 0." ] # [ inline ( always ) ] pub fn refvsel ( & mut self ) -> REFVSEL_W { REFVSEL_W { w : self } }
# [ doc = "Bit 6 - Reference generator one-time trigger. If written with a 1, the generation of the variable reference voltage is started. When the reference voltage request is set, this bit is cleared by hardware." ] # [ inline ( always ) ] pub fn refgen ( & mut self ) -> REFGEN_W { REFGEN_W { w : self } }
# [ doc = "Bit 7 - Bandgap and bandgap buffer one-time trigger. If written with a 1, the generation of the buffered bandgap voltage is started. When the bandgap buffer voltage request is set, this bit is cleared by hardware." ] # [ inline ( always ) ] pub fn refbgen ( & mut self ) -> REFBGEN_W { REFBGEN_W { w : self } }
}
}
# [ doc = "PMM interrupt flag register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pmmifg](pmmifg) module" ] pub type PMMIFG = crate :: Reg < u16 , _PMMIFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PMMIFG ;
# [ doc = "`read()` method returns [pmmifg::R](pmmifg::R) reader structure" ] impl crate :: Readable for PMMIFG { }
# [ doc = "`write(|w| ..)` method takes [pmmifg::W](pmmifg::W) writer structure" ] impl crate :: Writable for PMMIFG { }
# [ doc = "PMM interrupt flag register" ] pub mod pmmifg {
# [ doc = "Reader of register PMMIFG" ] pub type R = crate :: R < u16 , super :: PMMIFG > ;
# [ doc = "Writer for register PMMIFG" ] pub type W = crate :: W < u16 , super :: PMMIFG > ;
# [ doc = "Register PMMIFG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: PMMIFG { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "PMM software brownout reset interrupt flag.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PMMBORIFG_A { # [ doc = "0: Reset not due to PMMSWBOR" ] PMMBORIFG_0 = 0 , # [ doc = "1: Reset due to PMMSWBOR" ] PMMBORIFG_1 = 1 } impl From < PMMBORIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : PMMBORIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `PMMBORIFG`" ] pub type PMMBORIFG_R = crate :: R < bool , PMMBORIFG_A > ; impl PMMBORIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PMMBORIFG_A { match self . bits { false => PMMBORIFG_A :: PMMBORIFG_0 , true => PMMBORIFG_A :: PMMBORIFG_1 } } # [ doc = "Checks if the value of the field is `PMMBORIFG_0`" ] # [ inline ( always ) ] pub fn is_pmmborifg_0 ( & self ) -> bool { * self == PMMBORIFG_A :: PMMBORIFG_0 } # [ doc = "Checks if the value of the field is `PMMBORIFG_1`" ] # [ inline ( always ) ] pub fn is_pmmborifg_1 ( & self ) -> bool { * self == PMMBORIFG_A :: PMMBORIFG_1 } }
# [ doc = "Write proxy for field `PMMBORIFG`" ] pub struct PMMBORIFG_W < 'a > { w : & 'a mut W , } impl < 'a > PMMBORIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PMMBORIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Reset not due to PMMSWBOR" ] # [ inline ( always ) ] pub fn pmmborifg_0 ( self ) -> & 'a mut W { self . variant ( PMMBORIFG_A :: PMMBORIFG_0 ) } # [ doc = "Reset due to PMMSWBOR" ] # [ inline ( always ) ] pub fn pmmborifg_1 ( self ) -> & 'a mut W { self . variant ( PMMBORIFG_A :: PMMBORIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "PMM reset pin interrupt flag.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PMMRSTIFG_A { # [ doc = "0: Reset not due to reset pin" ] PMMBORIFG_0 = 0 , # [ doc = "1: Reset due to reset pin" ] PMMBORIFG_1 = 1 } impl From < PMMRSTIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : PMMRSTIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `PMMRSTIFG`" ] pub type PMMRSTIFG_R = crate :: R < bool , PMMRSTIFG_A > ; impl PMMRSTIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PMMRSTIFG_A { match self . bits { false => PMMRSTIFG_A :: PMMBORIFG_0 , true => PMMRSTIFG_A :: PMMBORIFG_1 } } # [ doc = "Checks if the value of the field is `PMMBORIFG_0`" ] # [ inline ( always ) ] pub fn is_pmmborifg_0 ( & self ) -> bool { * self == PMMRSTIFG_A :: PMMBORIFG_0 } # [ doc = "Checks if the value of the field is `PMMBORIFG_1`" ] # [ inline ( always ) ] pub fn is_pmmborifg_1 ( & self ) -> bool { * self == PMMRSTIFG_A :: PMMBORIFG_1 } }
# [ doc = "Write proxy for field `PMMRSTIFG`" ] pub struct PMMRSTIFG_W < 'a > { w : & 'a mut W , } impl < 'a > PMMRSTIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PMMRSTIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Reset not due to reset pin" ] # [ inline ( always ) ] pub fn pmmborifg_0 ( self ) -> & 'a mut W { self . variant ( PMMRSTIFG_A :: PMMBORIFG_0 ) } # [ doc = "Reset due to reset pin" ] # [ inline ( always ) ] pub fn pmmborifg_1 ( self ) -> & 'a mut W { self . variant ( PMMRSTIFG_A :: PMMBORIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "PMM software POR interrupt flag.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PMMPORIFG_A { # [ doc = "0: Reset not due to PMMSWPOR" ] PMMBORIFG_0 = 0 , # [ doc = "1: Reset due to PMMSWPOR" ] PMMBORIFG_1 = 1 } impl From < PMMPORIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : PMMPORIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `PMMPORIFG`" ] pub type PMMPORIFG_R = crate :: R < bool , PMMPORIFG_A > ; impl PMMPORIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PMMPORIFG_A { match self . bits { false => PMMPORIFG_A :: PMMBORIFG_0 , true => PMMPORIFG_A :: PMMBORIFG_1 } } # [ doc = "Checks if the value of the field is `PMMBORIFG_0`" ] # [ inline ( always ) ] pub fn is_pmmborifg_0 ( & self ) -> bool { * self == PMMPORIFG_A :: PMMBORIFG_0 } # [ doc = "Checks if the value of the field is `PMMBORIFG_1`" ] # [ inline ( always ) ] pub fn is_pmmborifg_1 ( & self ) -> bool { * self == PMMPORIFG_A :: PMMBORIFG_1 } }
# [ doc = "Write proxy for field `PMMPORIFG`" ] pub struct PMMPORIFG_W < 'a > { w : & 'a mut W , } impl < 'a > PMMPORIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PMMPORIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Reset not due to PMMSWPOR" ] # [ inline ( always ) ] pub fn pmmborifg_0 ( self ) -> & 'a mut W { self . variant ( PMMPORIFG_A :: PMMBORIFG_0 ) } # [ doc = "Reset due to PMMSWPOR" ] # [ inline ( always ) ] pub fn pmmborifg_1 ( self ) -> & 'a mut W { self . variant ( PMMPORIFG_A :: PMMBORIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `SPWRIFG`" ] pub type SPWRIFG_R = crate :: R < bool , bool > ;
# [ doc = "High-side SVS interrupt flag.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SVSHIFG_A { # [ doc = "0: Reset not due to SVSH" ] SVSHIFG_0 = 0 , # [ doc = "1: Reset due to SVSH" ] SVSHIFG_1 = 1 } impl From < SVSHIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : SVSHIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SVSHIFG`" ] pub type SVSHIFG_R = crate :: R < bool , SVSHIFG_A > ; impl SVSHIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SVSHIFG_A { match self . bits { false => SVSHIFG_A :: SVSHIFG_0 , true => SVSHIFG_A :: SVSHIFG_1 } } # [ doc = "Checks if the value of the field is `SVSHIFG_0`" ] # [ inline ( always ) ] pub fn is_svshifg_0 ( & self ) -> bool { * self == SVSHIFG_A :: SVSHIFG_0 } # [ doc = "Checks if the value of the field is `SVSHIFG_1`" ] # [ inline ( always ) ] pub fn is_svshifg_1 ( & self ) -> bool { * self == SVSHIFG_A :: SVSHIFG_1 } }
# [ doc = "Write proxy for field `SVSHIFG`" ] pub struct SVSHIFG_W < 'a > { w : & 'a mut W , } impl < 'a > SVSHIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SVSHIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Reset not due to SVSH" ] # [ inline ( always ) ] pub fn svshifg_0 ( self ) -> & 'a mut W { self . variant ( SVSHIFG_A :: SVSHIFG_0 ) } # [ doc = "Reset due to SVSH" ] # [ inline ( always ) ] pub fn svshifg_1 ( self ) -> & 'a mut W { self . variant ( SVSHIFG_A :: SVSHIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "LPMx.5 flag.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PMMLPM5IFG_A { # [ doc = "0: Reset not due to wake-up from LPMx.5" ] PMMLPM5IFG_0 = 0 , # [ doc = "1: Reset due to wake-up from LPMx.5" ] PMMLPM5IFG_1 = 1 } impl From < PMMLPM5IFG_A > for bool { # [ inline ( always ) ] fn from ( variant : PMMLPM5IFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `PMMLPM5IFG`" ] pub type PMMLPM5IFG_R = crate :: R < bool , PMMLPM5IFG_A > ; impl PMMLPM5IFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PMMLPM5IFG_A { match self . bits { false => PMMLPM5IFG_A :: PMMLPM5IFG_0 , true => PMMLPM5IFG_A :: PMMLPM5IFG_1 } } # [ doc = "Checks if the value of the field is `PMMLPM5IFG_0`" ] # [ inline ( always ) ] pub fn is_pmmlpm5ifg_0 ( & self ) -> bool { * self == PMMLPM5IFG_A :: PMMLPM5IFG_0 } # [ doc = "Checks if the value of the field is `PMMLPM5IFG_1`" ] # [ inline ( always ) ] pub fn is_pmmlpm5ifg_1 ( & self ) -> bool { * self == PMMLPM5IFG_A :: PMMLPM5IFG_1 } }
# [ doc = "Write proxy for field `PMMLPM5IFG`" ] pub struct PMMLPM5IFG_W < 'a > { w : & 'a mut W , } impl < 'a > PMMLPM5IFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PMMLPM5IFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Reset not due to wake-up from LPMx.5" ] # [ inline ( always ) ] pub fn pmmlpm5ifg_0 ( self ) -> & 'a mut W { self . variant ( PMMLPM5IFG_A :: PMMLPM5IFG_0 ) } # [ doc = "Reset due to wake-up from LPMx.5" ] # [ inline ( always ) ] pub fn pmmlpm5ifg_1 ( self ) -> & 'a mut W { self . variant ( PMMLPM5IFG_A :: PMMLPM5IFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `PMMSPSIFG`" ] pub type PMMSPSIFG_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `PPWRIFG`" ] pub type PPWRIFG_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 8 - PMM software brownout reset interrupt flag." ] # [ inline ( always ) ] pub fn pmmborifg ( & self ) -> PMMBORIFG_R { PMMBORIFG_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - PMM reset pin interrupt flag." ] # [ inline ( always ) ] pub fn pmmrstifg ( & self ) -> PMMRSTIFG_R { PMMRSTIFG_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - PMM software POR interrupt flag." ] # [ inline ( always ) ] pub fn pmmporifg ( & self ) -> PMMPORIFG_R { PMMPORIFG_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Secondary Power interrupt flag. This bit only works in multi power supply systems. When the secondary power is ready to use, this bit is set., In single power supply systems, this bit does not work." ] # [ inline ( always ) ] pub fn spwrifg ( & self ) -> SPWRIFG_R { SPWRIFG_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - High-side SVS interrupt flag." ] # [ inline ( always ) ] pub fn svshifg ( & self ) -> SVSHIFG_R { SVSHIFG_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - LPMx.5 flag." ] # [ inline ( always ) ] pub fn pmmlpm5ifg ( & self ) -> PMMLPM5IFG_R { PMMLPM5IFG_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 0 - PMM secondary power supply interrupt flag. Reserved for future multi power supply systems." ] # [ inline ( always ) ] pub fn pmmspsifg ( & self ) -> PMMSPSIFG_R { PMMSPSIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Primary Power interrupt flag. This bit only works in multi power supply systems. When the primary power is ready to use, this bit is set. In single power supply systems, this bit does not work" ] # [ inline ( always ) ] pub fn ppwrifg ( & self ) -> PPWRIFG_R { PPWRIFG_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 8 - PMM software brownout reset interrupt flag." ] # [ inline ( always ) ] pub fn pmmborifg ( & mut self ) -> PMMBORIFG_W { PMMBORIFG_W { w : self } }
# [ doc = "Bit 9 - PMM reset pin interrupt flag." ] # [ inline ( always ) ] pub fn pmmrstifg ( & mut self ) -> PMMRSTIFG_W { PMMRSTIFG_W { w : self } }
# [ doc = "Bit 10 - PMM software POR interrupt flag." ] # [ inline ( always ) ] pub fn pmmporifg ( & mut self ) -> PMMPORIFG_W { PMMPORIFG_W { w : self } }
# [ doc = "Bit 13 - High-side SVS interrupt flag." ] # [ inline ( always ) ] pub fn svshifg ( & mut self ) -> SVSHIFG_W { SVSHIFG_W { w : self } }
# [ doc = "Bit 15 - LPMx.5 flag." ] # [ inline ( always ) ] pub fn pmmlpm5ifg ( & mut self ) -> PMMLPM5IFG_W { PMMLPM5IFG_W { w : self } }
}
}
# [ doc = "Power mode 5 control register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pm5ctl0](pm5ctl0) module" ] pub type PM5CTL0 = crate :: Reg < u16 , _PM5CTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PM5CTL0 ;
# [ doc = "`read()` method returns [pm5ctl0::R](pm5ctl0::R) reader structure" ] impl crate :: Readable for PM5CTL0 { }
# [ doc = "`write(|w| ..)` method takes [pm5ctl0::W](pm5ctl0::W) writer structure" ] impl crate :: Writable for PM5CTL0 { }
# [ doc = "Power mode 5 control register 0" ] pub mod pm5ctl0 {
# [ doc = "Reader of register PM5CTL0" ] pub type R = crate :: R < u16 , super :: PM5CTL0 > ;
# [ doc = "Writer for register PM5CTL0" ] pub type W = crate :: W < u16 , super :: PM5CTL0 > ;
# [ doc = "Register PM5CTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: PM5CTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "LPMx.5 Lock Bit\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum LOCKLPM5_A { # [ doc = "0: LPMx.5 configuration is not locked and defaults to its reset condition." ] LOCKLPM5_0 = 0 , # [ doc = "1: LPMx.5 configuration remains locked. Pin state is held during LPMx.5 entry and exit." ] LOCKLPM5_1 = 1 } impl From < LOCKLPM5_A > for bool { # [ inline ( always ) ] fn from ( variant : LOCKLPM5_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `LOCKLPM5`" ] pub type LOCKLPM5_R = crate :: R < bool , LOCKLPM5_A > ; impl LOCKLPM5_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> LOCKLPM5_A { match self . bits { false => LOCKLPM5_A :: LOCKLPM5_0 , true => LOCKLPM5_A :: LOCKLPM5_1 } } # [ doc = "Checks if the value of the field is `LOCKLPM5_0`" ] # [ inline ( always ) ] pub fn is_locklpm5_0 ( & self ) -> bool { * self == LOCKLPM5_A :: LOCKLPM5_0 } # [ doc = "Checks if the value of the field is `LOCKLPM5_1`" ] # [ inline ( always ) ] pub fn is_locklpm5_1 ( & self ) -> bool { * self == LOCKLPM5_A :: LOCKLPM5_1 } }
# [ doc = "Write proxy for field `LOCKLPM5`" ] pub struct LOCKLPM5_W < 'a > { w : & 'a mut W , } impl < 'a > LOCKLPM5_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : LOCKLPM5_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "LPMx.5 configuration is not locked and defaults to its reset condition." ] # [ inline ( always ) ] pub fn locklpm5_0 ( self ) -> & 'a mut W { self . variant ( LOCKLPM5_A :: LOCKLPM5_0 ) } # [ doc = "LPMx.5 configuration remains locked. Pin state is held during LPMx.5 entry and exit." ] # [ inline ( always ) ] pub fn locklpm5_1 ( self ) -> & 'a mut W { self . variant ( LOCKLPM5_A :: LOCKLPM5_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Reports or sets the LPM3.5 switch connection upon the switch mode set by LPM5SM. When this bit is set, the VLPM3.5 domain can accept full-speed read and write operation by CPU MCLK. If the switch is disconnected, all peripherals within this domain can only accept the operation no more than 40 kHz. In automatic mode (LPM5SM = 0), this bit represents the switch connection between Vcore and VLPM3.5. Any write to this bit has no effect. In manual mode (LPM5SM = 1), this bit can be fully read and written by software. When this bit is set, the switch connection between Vcore and VLPM3.5 is connected. Otherwise, the switch is disconnected.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum LPM5SW_A { # [ doc = "0: LPMx.5 switch disconnected" ] LPM5SW_0 = 0 , # [ doc = "1: LPMx.5 switch connected" ] LPM5SW_1 = 1 } impl From < LPM5SW_A > for bool { # [ inline ( always ) ] fn from ( variant : LPM5SW_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `LPM5SW`" ] pub type LPM5SW_R = crate :: R < bool , LPM5SW_A > ; impl LPM5SW_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> LPM5SW_A { match self . bits { false => LPM5SW_A :: LPM5SW_0 , true => LPM5SW_A :: LPM5SW_1 } } # [ doc = "Checks if the value of the field is `LPM5SW_0`" ] # [ inline ( always ) ] pub fn is_lpm5sw_0 ( & self ) -> bool { * self == LPM5SW_A :: LPM5SW_0 } # [ doc = "Checks if the value of the field is `LPM5SW_1`" ] # [ inline ( always ) ] pub fn is_lpm5sw_1 ( & self ) -> bool { * self == LPM5SW_A :: LPM5SW_1 } }
# [ doc = "Write proxy for field `LPM5SW`" ] pub struct LPM5SW_W < 'a > { w : & 'a mut W , } impl < 'a > LPM5SW_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : LPM5SW_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "LPMx.5 switch disconnected" ] # [ inline ( always ) ] pub fn lpm5sw_0 ( self ) -> & 'a mut W { self . variant ( LPM5SW_A :: LPM5SW_0 ) } # [ doc = "LPMx.5 switch connected" ] # [ inline ( always ) ] pub fn lpm5sw_1 ( self ) -> & 'a mut W { self . variant ( LPM5SW_A :: LPM5SW_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Specifies the operation mode of the LPM3.5 switch.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum LPM5SM_A { # [ doc = "0: Automatic mode for LPM3.5 switch that the switch is fully handled by the circuitry during mode switch." ] LPM5SM_0 = 0 , # [ doc = "1: Manual mode for LPM3.5 switch that the switch is specified by LPM5SW bit setting in software." ] LPM5SM_1 = 1 } impl From < LPM5SM_A > for bool { # [ inline ( always ) ] fn from ( variant : LPM5SM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `LPM5SM`" ] pub type LPM5SM_R = crate :: R < bool , LPM5SM_A > ; impl LPM5SM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> LPM5SM_A { match self . bits { false => LPM5SM_A :: LPM5SM_0 , true => LPM5SM_A :: LPM5SM_1 } } # [ doc = "Checks if the value of the field is `LPM5SM_0`" ] # [ inline ( always ) ] pub fn is_lpm5sm_0 ( & self ) -> bool { * self == LPM5SM_A :: LPM5SM_0 } # [ doc = "Checks if the value of the field is `LPM5SM_1`" ] # [ inline ( always ) ] pub fn is_lpm5sm_1 ( & self ) -> bool { * self == LPM5SM_A :: LPM5SM_1 } }
# [ doc = "Write proxy for field `LPM5SM`" ] pub struct LPM5SM_W < 'a > { w : & 'a mut W , } impl < 'a > LPM5SM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : LPM5SM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Automatic mode for LPM3.5 switch that the switch is fully handled by the circuitry during mode switch." ] # [ inline ( always ) ] pub fn lpm5sm_0 ( self ) -> & 'a mut W { self . variant ( LPM5SM_A :: LPM5SM_0 ) } # [ doc = "Manual mode for LPM3.5 switch that the switch is specified by LPM5SW bit setting in software." ] # [ inline ( always ) ] pub fn lpm5sm_1 ( self ) -> & 'a mut W { self . variant ( LPM5SM_A :: LPM5SM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - LPMx.5 Lock Bit" ] # [ inline ( always ) ] pub fn locklpm5 ( & self ) -> LOCKLPM5_R { LOCKLPM5_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Reports or sets the LPM3.5 switch connection upon the switch mode set by LPM5SM. When this bit is set, the VLPM3.5 domain can accept full-speed read and write operation by CPU MCLK. If the switch is disconnected, all peripherals within this domain can only accept the operation no more than 40 kHz. In automatic mode (LPM5SM = 0), this bit represents the switch connection between Vcore and VLPM3.5. Any write to this bit has no effect. In manual mode (LPM5SM = 1), this bit can be fully read and written by software. When this bit is set, the switch connection between Vcore and VLPM3.5 is connected. Otherwise, the switch is disconnected." ] # [ inline ( always ) ] pub fn lpm5sw ( & self ) -> LPM5SW_R { LPM5SW_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Specifies the operation mode of the LPM3.5 switch." ] # [ inline ( always ) ] pub fn lpm5sm ( & self ) -> LPM5SM_R { LPM5SM_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - LPMx.5 Lock Bit" ] # [ inline ( always ) ] pub fn locklpm5 ( & mut self ) -> LOCKLPM5_W { LOCKLPM5_W { w : self } }
# [ doc = "Bit 4 - Reports or sets the LPM3.5 switch connection upon the switch mode set by LPM5SM. When this bit is set, the VLPM3.5 domain can accept full-speed read and write operation by CPU MCLK. If the switch is disconnected, all peripherals within this domain can only accept the operation no more than 40 kHz. In automatic mode (LPM5SM = 0), this bit represents the switch connection between Vcore and VLPM3.5. Any write to this bit has no effect. In manual mode (LPM5SM = 1), this bit can be fully read and written by software. When this bit is set, the switch connection between Vcore and VLPM3.5 is connected. Otherwise, the switch is disconnected." ] # [ inline ( always ) ] pub fn lpm5sw ( & mut self ) -> LPM5SW_W { LPM5SW_W { w : self } }
# [ doc = "Bit 5 - Specifies the operation mode of the LPM3.5 switch." ] # [ inline ( always ) ] pub fn lpm5sm ( & mut self ) -> LPM5SM_W { LPM5SM_W { w : self } }
}
}
}
# [ doc = "SYS" ] pub struct SYS { _marker : PhantomData < * const ( ) > } unsafe impl Send for SYS { } impl SYS { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const sys :: RegisterBlock { 0x0140 as * const _ } } impl Deref for SYS { type Target = sys :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * SYS :: ptr ( ) } } }
# [ doc = "SYS" ] pub mod sys {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - System Control" ] pub sysctl : SYSCTL , # [ doc = "0x02 - Bootstrap Loader Configuration Register" ] pub sysbslc : SYSBSLC , _reserved2 : [ u8 ; 2usize ] , # [ doc = "0x06 - JTAG Mailbox Control" ] pub sysjmbc : SYSJMBC , # [ doc = "0x08 - JTAG Mailbox Input" ] pub sysjmbi0 : SYSJMBI0 , # [ doc = "0x0a - JTAG Mailbox Input 1 Register" ] pub sysjmbi1 : SYSJMBI1 , # [ doc = "0x0c - JTAG Mailbox Output" ] pub sysjmbo0 : SYSJMBO0 , # [ doc = "0x0e - JTAG Mailbox Output 1 Register" ] pub sysjmbo1 : SYSJMBO1 , _reserved7 : [ u8 ; 10usize ] , # [ doc = "0x1a - User NMI Vector Generator" ] pub sysuniv : SYSUNIV , # [ doc = "0x1c - System NMI Vector Generator" ] pub syssniv : SYSSNIV , # [ doc = "0x1e - Reset Vector Generator" ] pub sysrstiv : SYSRSTIV , # [ doc = "0x20 - System Configuration Register 0" ] pub syscfg0 : SYSCFG0 , # [ doc = "0x22 - System Configuration Register 1" ] pub syscfg1 : SYSCFG1 , # [ doc = "0x24 - System Configuration Register 2" ] pub syscfg2 : SYSCFG2 , # [ doc = "0x26 - System Configuration Register 3" ] pub syscfg3 : SYSCFG3 , }
# [ doc = "System Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sysctl](sysctl) module" ] pub type SYSCTL = crate :: Reg < u16 , _SYSCTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYSCTL ;
# [ doc = "`read()` method returns [sysctl::R](sysctl::R) reader structure" ] impl crate :: Readable for SYSCTL { }
# [ doc = "`write(|w| ..)` method takes [sysctl::W](sysctl::W) writer structure" ] impl crate :: Writable for SYSCTL { }
# [ doc = "System Control" ] pub mod sysctl {
# [ doc = "Reader of register SYSCTL" ] pub type R = crate :: R < u16 , super :: SYSCTL > ;
# [ doc = "Writer for register SYSCTL" ] pub type W = crate :: W < u16 , super :: SYSCTL > ;
# [ doc = "Register SYSCTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SYSCTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "RAM-based interrupt vectors\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SYSRIVECT_A { # [ doc = "0: Interrupt vectors generated with end address TOP of lower 64K FRAM FFFFh" ] FRAM = 0 , # [ doc = "1: Interrupt vectors generated with end address TOP of RAM, when RAM available" ] RAM = 1 } impl From < SYSRIVECT_A > for bool { # [ inline ( always ) ] fn from ( variant : SYSRIVECT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SYSRIVECT`" ] pub type SYSRIVECT_R = crate :: R < bool , SYSRIVECT_A > ; impl SYSRIVECT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SYSRIVECT_A { match self . bits { false => SYSRIVECT_A :: FRAM , true => SYSRIVECT_A :: RAM } } # [ doc = "Checks if the value of the field is `FRAM`" ] # [ inline ( always ) ] pub fn is_fram ( & self ) -> bool { * self == SYSRIVECT_A :: FRAM } # [ doc = "Checks if the value of the field is `RAM`" ] # [ inline ( always ) ] pub fn is_ram ( & self ) -> bool { * self == SYSRIVECT_A :: RAM } }
# [ doc = "Write proxy for field `SYSRIVECT`" ] pub struct SYSRIVECT_W < 'a > { w : & 'a mut W , } impl < 'a > SYSRIVECT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SYSRIVECT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt vectors generated with end address TOP of lower 64K FRAM FFFFh" ] # [ inline ( always ) ] pub fn fram ( self ) -> & 'a mut W { self . variant ( SYSRIVECT_A :: FRAM ) } # [ doc = "Interrupt vectors generated with end address TOP of RAM, when RAM available" ] # [ inline ( always ) ] pub fn ram ( self ) -> & 'a mut W { self . variant ( SYSRIVECT_A :: RAM ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "PMM access protect\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SYSPMMPE_A { # [ doc = "0: Access from anywhere in memory" ] SYSPMMPE_0 = 0 , # [ doc = "1: Access only from the BSL segments" ] SYSPMMPE_1 = 1 } impl From < SYSPMMPE_A > for bool { # [ inline ( always ) ] fn from ( variant : SYSPMMPE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SYSPMMPE`" ] pub type SYSPMMPE_R = crate :: R < bool , SYSPMMPE_A > ; impl SYSPMMPE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SYSPMMPE_A { match self . bits { false => SYSPMMPE_A :: SYSPMMPE_0 , true => SYSPMMPE_A :: SYSPMMPE_1 } } # [ doc = "Checks if the value of the field is `SYSPMMPE_0`" ] # [ inline ( always ) ] pub fn is_syspmmpe_0 ( & self ) -> bool { * self == SYSPMMPE_A :: SYSPMMPE_0 } # [ doc = "Checks if the value of the field is `SYSPMMPE_1`" ] # [ inline ( always ) ] pub fn is_syspmmpe_1 ( & self ) -> bool { * self == SYSPMMPE_A :: SYSPMMPE_1 } }
# [ doc = "Write proxy for field `SYSPMMPE`" ] pub struct SYSPMMPE_W < 'a > { w : & 'a mut W , } impl < 'a > SYSPMMPE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SYSPMMPE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Access from anywhere in memory" ] # [ inline ( always ) ] pub fn syspmmpe_0 ( self ) -> & 'a mut W { self . variant ( SYSPMMPE_A :: SYSPMMPE_0 ) } # [ doc = "Access only from the BSL segments" ] # [ inline ( always ) ] pub fn syspmmpe_1 ( self ) -> & 'a mut W { self . variant ( SYSPMMPE_A :: SYSPMMPE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "BSL entry indication\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SYSBSLIND_A { # [ doc = "0: No BSL entry sequence detected" ] SYSBSLIND_0 = 0 , # [ doc = "1: BSL entry sequence detected" ] SYSBSLIND_1 = 1 } impl From < SYSBSLIND_A > for bool { # [ inline ( always ) ] fn from ( variant : SYSBSLIND_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SYSBSLIND`" ] pub type SYSBSLIND_R = crate :: R < bool , SYSBSLIND_A > ; impl SYSBSLIND_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SYSBSLIND_A { match self . bits { false => SYSBSLIND_A :: SYSBSLIND_0 , true => SYSBSLIND_A :: SYSBSLIND_1 } } # [ doc = "Checks if the value of the field is `SYSBSLIND_0`" ] # [ inline ( always ) ] pub fn is_sysbslind_0 ( & self ) -> bool { * self == SYSBSLIND_A :: SYSBSLIND_0 } # [ doc = "Checks if the value of the field is `SYSBSLIND_1`" ] # [ inline ( always ) ] pub fn is_sysbslind_1 ( & self ) -> bool { * self == SYSBSLIND_A :: SYSBSLIND_1 } }
# [ doc = "Dedicated JTAG pins enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SYSJTAGPIN_A { # [ doc = "0: Shared JTAG pins (JTAG mode selectable using SBW sequence)" ] SHARED = 0 , # [ doc = "1: Dedicated JTAG pins (explicit 4-wire JTAG mode selection)" ] DEDICATED = 1 } impl From < SYSJTAGPIN_A > for bool { # [ inline ( always ) ] fn from ( variant : SYSJTAGPIN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SYSJTAGPIN`" ] pub type SYSJTAGPIN_R = crate :: R < bool , SYSJTAGPIN_A > ; impl SYSJTAGPIN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SYSJTAGPIN_A { match self . bits { false => SYSJTAGPIN_A :: SHARED , true => SYSJTAGPIN_A :: DEDICATED } } # [ doc = "Checks if the value of the field is `SHARED`" ] # [ inline ( always ) ] pub fn is_shared ( & self ) -> bool { * self == SYSJTAGPIN_A :: SHARED } # [ doc = "Checks if the value of the field is `DEDICATED`" ] # [ inline ( always ) ] pub fn is_dedicated ( & self ) -> bool { * self == SYSJTAGPIN_A :: DEDICATED } }
# [ doc = "Write proxy for field `SYSJTAGPIN`" ] pub struct SYSJTAGPIN_W < 'a > { w : & 'a mut W , } impl < 'a > SYSJTAGPIN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SYSJTAGPIN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Shared JTAG pins (JTAG mode selectable using SBW sequence)" ] # [ inline ( always ) ] pub fn shared ( self ) -> & 'a mut W { self . variant ( SYSJTAGPIN_A :: SHARED ) } # [ doc = "Dedicated JTAG pins (explicit 4-wire JTAG mode selection)" ] # [ inline ( always ) ] pub fn dedicated ( self ) -> & 'a mut W { self . variant ( SYSJTAGPIN_A :: DEDICATED ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - RAM-based interrupt vectors" ] # [ inline ( always ) ] pub fn sysrivect ( & self ) -> SYSRIVECT_R { SYSRIVECT_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - PMM access protect" ] # [ inline ( always ) ] pub fn syspmmpe ( & self ) -> SYSPMMPE_R { SYSPMMPE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - BSL entry indication" ] # [ inline ( always ) ] pub fn sysbslind ( & self ) -> SYSBSLIND_R { SYSBSLIND_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Dedicated JTAG pins enable" ] # [ inline ( always ) ] pub fn sysjtagpin ( & self ) -> SYSJTAGPIN_R { SYSJTAGPIN_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - RAM-based interrupt vectors" ] # [ inline ( always ) ] pub fn sysrivect ( & mut self ) -> SYSRIVECT_W { SYSRIVECT_W { w : self } }
# [ doc = "Bit 2 - PMM access protect" ] # [ inline ( always ) ] pub fn syspmmpe ( & mut self ) -> SYSPMMPE_W { SYSPMMPE_W { w : self } }
# [ doc = "Bit 5 - Dedicated JTAG pins enable" ] # [ inline ( always ) ] pub fn sysjtagpin ( & mut self ) -> SYSJTAGPIN_W { SYSJTAGPIN_W { w : self } }
}
}
# [ doc = "Bootstrap Loader Configuration Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sysbslc](sysbslc) module" ] pub type SYSBSLC = crate :: Reg < u16 , _SYSBSLC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYSBSLC ;
# [ doc = "`read()` method returns [sysbslc::R](sysbslc::R) reader structure" ] impl crate :: Readable for SYSBSLC { }
# [ doc = "`write(|w| ..)` method takes [sysbslc::W](sysbslc::W) writer structure" ] impl crate :: Writable for SYSBSLC { }
# [ doc = "Bootstrap Loader Configuration Register" ] pub mod sysbslc {
# [ doc = "Reader of register SYSBSLC" ] pub type R = crate :: R < u16 , super :: SYSBSLC > ;
# [ doc = "Writer for register SYSBSLC" ] pub type W = crate :: W < u16 , super :: SYSBSLC > ;
# [ doc = "Register SYSBSLC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SYSBSLC { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "RAM assigned to BSL\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SYSBSLR_A { # [ doc = "0: No RAM assigned to BSL area" ] SYSBSLR_0 = 0 , # [ doc = "1: Lowest 16 bytes of RAM assigned to BSL" ] SYSBSLR_1 = 1 } impl From < SYSBSLR_A > for bool { # [ inline ( always ) ] fn from ( variant : SYSBSLR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SYSBSLR`" ] pub type SYSBSLR_R = crate :: R < bool , SYSBSLR_A > ; impl SYSBSLR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SYSBSLR_A { match self . bits { false => SYSBSLR_A :: SYSBSLR_0 , true => SYSBSLR_A :: SYSBSLR_1 } } # [ doc = "Checks if the value of the field is `SYSBSLR_0`" ] # [ inline ( always ) ] pub fn is_sysbslr_0 ( & self ) -> bool { * self == SYSBSLR_A :: SYSBSLR_0 } # [ doc = "Checks if the value of the field is `SYSBSLR_1`" ] # [ inline ( always ) ] pub fn is_sysbslr_1 ( & self ) -> bool { * self == SYSBSLR_A :: SYSBSLR_1 } }
# [ doc = "Write proxy for field `SYSBSLR`" ] pub struct SYSBSLR_W < 'a > { w : & 'a mut W , } impl < 'a > SYSBSLR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SYSBSLR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No RAM assigned to BSL area" ] # [ inline ( always ) ] pub fn sysbslr_0 ( self ) -> & 'a mut W { self . variant ( SYSBSLR_A :: SYSBSLR_0 ) } # [ doc = "Lowest 16 bytes of RAM assigned to BSL" ] # [ inline ( always ) ] pub fn sysbslr_1 ( self ) -> & 'a mut W { self . variant ( SYSBSLR_A :: SYSBSLR_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Bootstrap loader memory disable for the size covered in SYSBSLSIZE\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SYSBSLOFF_A { # [ doc = "0: BSL memory is addressed when this area is read." ] SYSBSLOFF_0 = 0 , # [ doc = "1: BSL memory behaves like vacant memory. Reads cause 3FFFh to be read. Fetches cause JMP $ to be executed." ] SYSBSLOFF_1 = 1 } impl From < SYSBSLOFF_A > for bool { # [ inline ( always ) ] fn from ( variant : SYSBSLOFF_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SYSBSLOFF`" ] pub type SYSBSLOFF_R = crate :: R < bool , SYSBSLOFF_A > ; impl SYSBSLOFF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SYSBSLOFF_A { match self . bits { false => SYSBSLOFF_A :: SYSBSLOFF_0 , true => SYSBSLOFF_A :: SYSBSLOFF_1 } } # [ doc = "Checks if the value of the field is `SYSBSLOFF_0`" ] # [ inline ( always ) ] pub fn is_sysbsloff_0 ( & self ) -> bool { * self == SYSBSLOFF_A :: SYSBSLOFF_0 } # [ doc = "Checks if the value of the field is `SYSBSLOFF_1`" ] # [ inline ( always ) ] pub fn is_sysbsloff_1 ( & self ) -> bool { * self == SYSBSLOFF_A :: SYSBSLOFF_1 } }
# [ doc = "Write proxy for field `SYSBSLOFF`" ] pub struct SYSBSLOFF_W < 'a > { w : & 'a mut W , } impl < 'a > SYSBSLOFF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SYSBSLOFF_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "BSL memory is addressed when this area is read." ] # [ inline ( always ) ] pub fn sysbsloff_0 ( self ) -> & 'a mut W { self . variant ( SYSBSLOFF_A :: SYSBSLOFF_0 ) } # [ doc = "BSL memory behaves like vacant memory. Reads cause 3FFFh to be read. Fetches cause JMP $ to be executed." ] # [ inline ( always ) ] pub fn sysbsloff_1 ( self ) -> & 'a mut W { self . variant ( SYSBSLOFF_A :: SYSBSLOFF_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Bootstrap loader memory protection enable for the size covered in SYSBSLSIZE. By default, this bit is cleared by hardware with a BOR event (as indicated above); however, the boot code that checks for an available BSL may set this bit in software to protect the BSL. Because devices normally come with a TI BSL preprogrammed and protected, the boot code sets this bit.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SYSBSLPE_A { # [ doc = "0: Area not protected. Read, program, and erase of BSL memory is possible." ] SYSBSLPE_0 = 0 , # [ doc = "1: Area protected" ] SYSBSLPE_1 = 1 } impl From < SYSBSLPE_A > for bool { # [ inline ( always ) ] fn from ( variant : SYSBSLPE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SYSBSLPE`" ] pub type SYSBSLPE_R = crate :: R < bool , SYSBSLPE_A > ; impl SYSBSLPE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SYSBSLPE_A { match self . bits { false => SYSBSLPE_A :: SYSBSLPE_0 , true => SYSBSLPE_A :: SYSBSLPE_1 } } # [ doc = "Checks if the value of the field is `SYSBSLPE_0`" ] # [ inline ( always ) ] pub fn is_sysbslpe_0 ( & self ) -> bool { * self == SYSBSLPE_A :: SYSBSLPE_0 } # [ doc = "Checks if the value of the field is `SYSBSLPE_1`" ] # [ inline ( always ) ] pub fn is_sysbslpe_1 ( & self ) -> bool { * self == SYSBSLPE_A :: SYSBSLPE_1 } }
# [ doc = "Write proxy for field `SYSBSLPE`" ] pub struct SYSBSLPE_W < 'a > { w : & 'a mut W , } impl < 'a > SYSBSLPE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SYSBSLPE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Area not protected. Read, program, and erase of BSL memory is possible." ] # [ inline ( always ) ] pub fn sysbslpe_0 ( self ) -> & 'a mut W { self . variant ( SYSBSLPE_A :: SYSBSLPE_0 ) } # [ doc = "Area protected" ] # [ inline ( always ) ] pub fn sysbslpe_1 ( self ) -> & 'a mut W { self . variant ( SYSBSLPE_A :: SYSBSLPE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 2 - RAM assigned to BSL" ] # [ inline ( always ) ] pub fn sysbslr ( & self ) -> SYSBSLR_R { SYSBSLR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Bootstrap loader memory disable for the size covered in SYSBSLSIZE" ] # [ inline ( always ) ] pub fn sysbsloff ( & self ) -> SYSBSLOFF_R { SYSBSLOFF_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Bootstrap loader memory protection enable for the size covered in SYSBSLSIZE. By default, this bit is cleared by hardware with a BOR event (as indicated above); however, the boot code that checks for an available BSL may set this bit in software to protect the BSL. Because devices normally come with a TI BSL preprogrammed and protected, the boot code sets this bit." ] # [ inline ( always ) ] pub fn sysbslpe ( & self ) -> SYSBSLPE_R { SYSBSLPE_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 2 - RAM assigned to BSL" ] # [ inline ( always ) ] pub fn sysbslr ( & mut self ) -> SYSBSLR_W { SYSBSLR_W { w : self } }
# [ doc = "Bit 14 - Bootstrap loader memory disable for the size covered in SYSBSLSIZE" ] # [ inline ( always ) ] pub fn sysbsloff ( & mut self ) -> SYSBSLOFF_W { SYSBSLOFF_W { w : self } }
# [ doc = "Bit 15 - Bootstrap loader memory protection enable for the size covered in SYSBSLSIZE. By default, this bit is cleared by hardware with a BOR event (as indicated above); however, the boot code that checks for an available BSL may set this bit in software to protect the BSL. Because devices normally come with a TI BSL preprogrammed and protected, the boot code sets this bit." ] # [ inline ( always ) ] pub fn sysbslpe ( & mut self ) -> SYSBSLPE_W { SYSBSLPE_W { w : self } }
}
}
# [ doc = "JTAG Mailbox Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sysjmbc](sysjmbc) module" ] pub type SYSJMBC = crate :: Reg < u16 , _SYSJMBC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYSJMBC ;
# [ doc = "`read()` method returns [sysjmbc::R](sysjmbc::R) reader structure" ] impl crate :: Readable for SYSJMBC { }
# [ doc = "`write(|w| ..)` method takes [sysjmbc::W](sysjmbc::W) writer structure" ] impl crate :: Writable for SYSJMBC { }
# [ doc = "JTAG Mailbox Control" ] pub mod sysjmbc {
# [ doc = "Reader of register SYSJMBC" ] pub type R = crate :: R < u16 , super :: SYSJMBC > ;
# [ doc = "Writer for register SYSJMBC" ] pub type W = crate :: W < u16 , super :: SYSJMBC > ;
# [ doc = "Register SYSJMBC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SYSJMBC { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Incoming JTAG Mailbox 0 flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum JMBIN0FG_A { # [ doc = "0: JMBI0 has no new data" ] JMBIN0FG_0 = 0 , # [ doc = "1: JMBI0 has new data available" ] JMBIN0FG_1 = 1 } impl From < JMBIN0FG_A > for bool { # [ inline ( always ) ] fn from ( variant : JMBIN0FG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `JMBIN0FG`" ] pub type JMBIN0FG_R = crate :: R < bool , JMBIN0FG_A > ; impl JMBIN0FG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> JMBIN0FG_A { match self . bits { false => JMBIN0FG_A :: JMBIN0FG_0 , true => JMBIN0FG_A :: JMBIN0FG_1 } } # [ doc = "Checks if the value of the field is `JMBIN0FG_0`" ] # [ inline ( always ) ] pub fn is_jmbin0fg_0 ( & self ) -> bool { * self == JMBIN0FG_A :: JMBIN0FG_0 } # [ doc = "Checks if the value of the field is `JMBIN0FG_1`" ] # [ inline ( always ) ] pub fn is_jmbin0fg_1 ( & self ) -> bool { * self == JMBIN0FG_A :: JMBIN0FG_1 } }
# [ doc = "Write proxy for field `JMBIN0FG`" ] pub struct JMBIN0FG_W < 'a > { w : & 'a mut W , } impl < 'a > JMBIN0FG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : JMBIN0FG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "JMBI0 has no new data" ] # [ inline ( always ) ] pub fn jmbin0fg_0 ( self ) -> & 'a mut W { self . variant ( JMBIN0FG_A :: JMBIN0FG_0 ) } # [ doc = "JMBI0 has new data available" ] # [ inline ( always ) ] pub fn jmbin0fg_1 ( self ) -> & 'a mut W { self . variant ( JMBIN0FG_A :: JMBIN0FG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Incoming JTAG Mailbox 1 flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum JMBIN1FG_A { # [ doc = "0: JMBI1 has no new data" ] JMBIN1FG_0 = 0 , # [ doc = "1: JMBI1 has new data available" ] JMBIN1FG_1 = 1 } impl From < JMBIN1FG_A > for bool { # [ inline ( always ) ] fn from ( variant : JMBIN1FG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `JMBIN1FG`" ] pub type JMBIN1FG_R = crate :: R < bool , JMBIN1FG_A > ; impl JMBIN1FG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> JMBIN1FG_A { match self . bits { false => JMBIN1FG_A :: JMBIN1FG_0 , true => JMBIN1FG_A :: JMBIN1FG_1 } } # [ doc = "Checks if the value of the field is `JMBIN1FG_0`" ] # [ inline ( always ) ] pub fn is_jmbin1fg_0 ( & self ) -> bool { * self == JMBIN1FG_A :: JMBIN1FG_0 } # [ doc = "Checks if the value of the field is `JMBIN1FG_1`" ] # [ inline ( always ) ] pub fn is_jmbin1fg_1 ( & self ) -> bool { * self == JMBIN1FG_A :: JMBIN1FG_1 } }
# [ doc = "Write proxy for field `JMBIN1FG`" ] pub struct JMBIN1FG_W < 'a > { w : & 'a mut W , } impl < 'a > JMBIN1FG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : JMBIN1FG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "JMBI1 has no new data" ] # [ inline ( always ) ] pub fn jmbin1fg_0 ( self ) -> & 'a mut W { self . variant ( JMBIN1FG_A :: JMBIN1FG_0 ) } # [ doc = "JMBI1 has new data available" ] # [ inline ( always ) ] pub fn jmbin1fg_1 ( self ) -> & 'a mut W { self . variant ( JMBIN1FG_A :: JMBIN1FG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Outgoing JTAG Mailbox 0 flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum JMBOUT0FG_A { # [ doc = "0: JMBO0 is not ready to receive new data" ] JMBOUT0FG_0 = 0 , # [ doc = "1: JMBO0 is ready to receive new data" ] JMBOUT0FG_1 = 1 } impl From < JMBOUT0FG_A > for bool { # [ inline ( always ) ] fn from ( variant : JMBOUT0FG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `JMBOUT0FG`" ] pub type JMBOUT0FG_R = crate :: R < bool , JMBOUT0FG_A > ; impl JMBOUT0FG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> JMBOUT0FG_A { match self . bits { false => JMBOUT0FG_A :: JMBOUT0FG_0 , true => JMBOUT0FG_A :: JMBOUT0FG_1 } } # [ doc = "Checks if the value of the field is `JMBOUT0FG_0`" ] # [ inline ( always ) ] pub fn is_jmbout0fg_0 ( & self ) -> bool { * self == JMBOUT0FG_A :: JMBOUT0FG_0 } # [ doc = "Checks if the value of the field is `JMBOUT0FG_1`" ] # [ inline ( always ) ] pub fn is_jmbout0fg_1 ( & self ) -> bool { * self == JMBOUT0FG_A :: JMBOUT0FG_1 } }
# [ doc = "Outgoing JTAG Mailbox 1 flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum JMBOUT1FG_A { # [ doc = "0: JMBO1 is not ready to receive new data" ] JMBOUT1FG_0 = 0 , # [ doc = "1: JMBO1 is ready to receive new data" ] JMBOUT1FG_1 = 1 } impl From < JMBOUT1FG_A > for bool { # [ inline ( always ) ] fn from ( variant : JMBOUT1FG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `JMBOUT1FG`" ] pub type JMBOUT1FG_R = crate :: R < bool , JMBOUT1FG_A > ; impl JMBOUT1FG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> JMBOUT1FG_A { match self . bits { false => JMBOUT1FG_A :: JMBOUT1FG_0 , true => JMBOUT1FG_A :: JMBOUT1FG_1 } } # [ doc = "Checks if the value of the field is `JMBOUT1FG_0`" ] # [ inline ( always ) ] pub fn is_jmbout1fg_0 ( & self ) -> bool { * self == JMBOUT1FG_A :: JMBOUT1FG_0 } # [ doc = "Checks if the value of the field is `JMBOUT1FG_1`" ] # [ inline ( always ) ] pub fn is_jmbout1fg_1 ( & self ) -> bool { * self == JMBOUT1FG_A :: JMBOUT1FG_1 } }
# [ doc = "Operation mode of JMB\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum JMBMODE_A { # [ doc = "0: 16-bit transfers using JMBO0 and JMBI0 only" ] _16BIT = 0 , # [ doc = "1: 32-bit transfers using JMBO0 with JMBO1 and JMBI0 with JMBI1" ] _32BIT = 1 } impl From < JMBMODE_A > for bool { # [ inline ( always ) ] fn from ( variant : JMBMODE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `JMBMODE`" ] pub type JMBMODE_R = crate :: R < bool , JMBMODE_A > ; impl JMBMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> JMBMODE_A { match self . bits { false => JMBMODE_A :: _16BIT , true => JMBMODE_A :: _32BIT } } # [ doc = "Checks if the value of the field is `_16BIT`" ] # [ inline ( always ) ] pub fn is_16bit ( & self ) -> bool { * self == JMBMODE_A :: _16BIT } # [ doc = "Checks if the value of the field is `_32BIT`" ] # [ inline ( always ) ] pub fn is_32bit ( & self ) -> bool { * self == JMBMODE_A :: _32BIT } }
# [ doc = "Write proxy for field `JMBMODE`" ] pub struct JMBMODE_W < 'a > { w : & 'a mut W , } impl < 'a > JMBMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : JMBMODE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "16-bit transfers using JMBO0 and JMBI0 only" ] # [ inline ( always ) ] pub fn _16bit ( self ) -> & 'a mut W { self . variant ( JMBMODE_A :: _16BIT ) } # [ doc = "32-bit transfers using JMBO0 with JMBO1 and JMBI0 with JMBI1" ] # [ inline ( always ) ] pub fn _32bit ( self ) -> & 'a mut W { self . variant ( JMBMODE_A :: _32BIT ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Incoming JTAG Mailbox 0 flag auto-clear disable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum JMBCLR0OFF_A { # [ doc = "0: JMBIN0FG cleared on read of JMB0IN register" ] JMBCLR0OFF_0 = 0 , # [ doc = "1: JMBIN0FG cleared by software" ] JMBCLR0OFF_1 = 1 } impl From < JMBCLR0OFF_A > for bool { # [ inline ( always ) ] fn from ( variant : JMBCLR0OFF_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `JMBCLR0OFF`" ] pub type JMBCLR0OFF_R = crate :: R < bool , JMBCLR0OFF_A > ; impl JMBCLR0OFF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> JMBCLR0OFF_A { match self . bits { false => JMBCLR0OFF_A :: JMBCLR0OFF_0 , true => JMBCLR0OFF_A :: JMBCLR0OFF_1 } } # [ doc = "Checks if the value of the field is `JMBCLR0OFF_0`" ] # [ inline ( always ) ] pub fn is_jmbclr0off_0 ( & self ) -> bool { * self == JMBCLR0OFF_A :: JMBCLR0OFF_0 } # [ doc = "Checks if the value of the field is `JMBCLR0OFF_1`" ] # [ inline ( always ) ] pub fn is_jmbclr0off_1 ( & self ) -> bool { * self == JMBCLR0OFF_A :: JMBCLR0OFF_1 } }
# [ doc = "Write proxy for field `JMBCLR0OFF`" ] pub struct JMBCLR0OFF_W < 'a > { w : & 'a mut W , } impl < 'a > JMBCLR0OFF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : JMBCLR0OFF_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "JMBIN0FG cleared on read of JMB0IN register" ] # [ inline ( always ) ] pub fn jmbclr0off_0 ( self ) -> & 'a mut W { self . variant ( JMBCLR0OFF_A :: JMBCLR0OFF_0 ) } # [ doc = "JMBIN0FG cleared by software" ] # [ inline ( always ) ] pub fn jmbclr0off_1 ( self ) -> & 'a mut W { self . variant ( JMBCLR0OFF_A :: JMBCLR0OFF_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Incoming JTAG Mailbox 1 flag auto-clear disable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum JMBCLR1OFF_A { # [ doc = "0: JMBIN1FG cleared on read of JMB1IN register" ] JMBCLR1OFF_0 = 0 , # [ doc = "1: JMBIN1FG cleared by software" ] JMBCLR1OFF_1 = 1 } impl From < JMBCLR1OFF_A > for bool { # [ inline ( always ) ] fn from ( variant : JMBCLR1OFF_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `JMBCLR1OFF`" ] pub type JMBCLR1OFF_R = crate :: R < bool , JMBCLR1OFF_A > ; impl JMBCLR1OFF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> JMBCLR1OFF_A { match self . bits { false => JMBCLR1OFF_A :: JMBCLR1OFF_0 , true => JMBCLR1OFF_A :: JMBCLR1OFF_1 } } # [ doc = "Checks if the value of the field is `JMBCLR1OFF_0`" ] # [ inline ( always ) ] pub fn is_jmbclr1off_0 ( & self ) -> bool { * self == JMBCLR1OFF_A :: JMBCLR1OFF_0 } # [ doc = "Checks if the value of the field is `JMBCLR1OFF_1`" ] # [ inline ( always ) ] pub fn is_jmbclr1off_1 ( & self ) -> bool { * self == JMBCLR1OFF_A :: JMBCLR1OFF_1 } }
# [ doc = "Write proxy for field `JMBCLR1OFF`" ] pub struct JMBCLR1OFF_W < 'a > { w : & 'a mut W , } impl < 'a > JMBCLR1OFF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : JMBCLR1OFF_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "JMBIN1FG cleared on read of JMB1IN register" ] # [ inline ( always ) ] pub fn jmbclr1off_0 ( self ) -> & 'a mut W { self . variant ( JMBCLR1OFF_A :: JMBCLR1OFF_0 ) } # [ doc = "JMBIN1FG cleared by software" ] # [ inline ( always ) ] pub fn jmbclr1off_1 ( self ) -> & 'a mut W { self . variant ( JMBCLR1OFF_A :: JMBCLR1OFF_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Incoming JTAG Mailbox 0 flag" ] # [ inline ( always ) ] pub fn jmbin0fg ( & self ) -> JMBIN0FG_R { JMBIN0FG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Incoming JTAG Mailbox 1 flag" ] # [ inline ( always ) ] pub fn jmbin1fg ( & self ) -> JMBIN1FG_R { JMBIN1FG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Outgoing JTAG Mailbox 0 flag" ] # [ inline ( always ) ] pub fn jmbout0fg ( & self ) -> JMBOUT0FG_R { JMBOUT0FG_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Outgoing JTAG Mailbox 1 flag" ] # [ inline ( always ) ] pub fn jmbout1fg ( & self ) -> JMBOUT1FG_R { JMBOUT1FG_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Operation mode of JMB" ] # [ inline ( always ) ] pub fn jmbmode ( & self ) -> JMBMODE_R { JMBMODE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Incoming JTAG Mailbox 0 flag auto-clear disable" ] # [ inline ( always ) ] pub fn jmbclr0off ( & self ) -> JMBCLR0OFF_R { JMBCLR0OFF_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Incoming JTAG Mailbox 1 flag auto-clear disable" ] # [ inline ( always ) ] pub fn jmbclr1off ( & self ) -> JMBCLR1OFF_R { JMBCLR1OFF_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Incoming JTAG Mailbox 0 flag" ] # [ inline ( always ) ] pub fn jmbin0fg ( & mut self ) -> JMBIN0FG_W { JMBIN0FG_W { w : self } }
# [ doc = "Bit 1 - Incoming JTAG Mailbox 1 flag" ] # [ inline ( always ) ] pub fn jmbin1fg ( & mut self ) -> JMBIN1FG_W { JMBIN1FG_W { w : self } }
# [ doc = "Bit 4 - Operation mode of JMB" ] # [ inline ( always ) ] pub fn jmbmode ( & mut self ) -> JMBMODE_W { JMBMODE_W { w : self } }
# [ doc = "Bit 6 - Incoming JTAG Mailbox 0 flag auto-clear disable" ] # [ inline ( always ) ] pub fn jmbclr0off ( & mut self ) -> JMBCLR0OFF_W { JMBCLR0OFF_W { w : self } }
# [ doc = "Bit 7 - Incoming JTAG Mailbox 1 flag auto-clear disable" ] # [ inline ( always ) ] pub fn jmbclr1off ( & mut self ) -> JMBCLR1OFF_W { JMBCLR1OFF_W { w : self } }
}
}
# [ doc = "JTAG Mailbox Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sysjmbi0](sysjmbi0) module" ] pub type SYSJMBI0 = crate :: Reg < u16 , _SYSJMBI0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYSJMBI0 ;
# [ doc = "`read()` method returns [sysjmbi0::R](sysjmbi0::R) reader structure" ] impl crate :: Readable for SYSJMBI0 { }
# [ doc = "`write(|w| ..)` method takes [sysjmbi0::W](sysjmbi0::W) writer structure" ] impl crate :: Writable for SYSJMBI0 { }
# [ doc = "JTAG Mailbox Input" ] pub mod sysjmbi0 {
# [ doc = "Reader of register SYSJMBI0" ] pub type R = crate :: R < u16 , super :: SYSJMBI0 > ;
# [ doc = "Writer for register SYSJMBI0" ] pub type W = crate :: W < u16 , super :: SYSJMBI0 > ;
# [ doc = "Register SYSJMBI0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SYSJMBI0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `MSGLO`" ] pub type MSGLO_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `MSGLO`" ] pub struct MSGLO_W < 'a > { w : & 'a mut W , } impl < 'a > MSGLO_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
# [ doc = "Reader of field `MSGHI`" ] pub type MSGHI_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `MSGHI`" ] pub struct MSGHI_W < 'a > { w : & 'a mut W , } impl < 'a > MSGHI_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 8 ) ) | ( ( ( value as u16 ) & 0xff ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - JTAG mailbox incoming message low byte" ] # [ inline ( always ) ] pub fn msglo ( & self ) -> MSGLO_R { MSGLO_R :: new ( ( self . bits & 0xff ) as u8 ) }
# [ doc = "Bits 8:15 - JTAG mailbox incoming message high byte" ] # [ inline ( always ) ] pub fn msghi ( & self ) -> MSGHI_R { MSGHI_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - JTAG mailbox incoming message low byte" ] # [ inline ( always ) ] pub fn msglo ( & mut self ) -> MSGLO_W { MSGLO_W { w : self } }
# [ doc = "Bits 8:15 - JTAG mailbox incoming message high byte" ] # [ inline ( always ) ] pub fn msghi ( & mut self ) -> MSGHI_W { MSGHI_W { w : self } }
}
}
# [ doc = "JTAG Mailbox Input 1 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sysjmbi1](sysjmbi1) module" ] pub type SYSJMBI1 = crate :: Reg < u16 , _SYSJMBI1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYSJMBI1 ;
# [ doc = "`read()` method returns [sysjmbi1::R](sysjmbi1::R) reader structure" ] impl crate :: Readable for SYSJMBI1 { }
# [ doc = "`write(|w| ..)` method takes [sysjmbi1::W](sysjmbi1::W) writer structure" ] impl crate :: Writable for SYSJMBI1 { }
# [ doc = "JTAG Mailbox Input 1 Register" ] pub mod sysjmbi1 {
# [ doc = "Reader of register SYSJMBI1" ] pub type R = crate :: R < u16 , super :: SYSJMBI1 > ;
# [ doc = "Writer for register SYSJMBI1" ] pub type W = crate :: W < u16 , super :: SYSJMBI1 > ;
# [ doc = "Register SYSJMBI1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SYSJMBI1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `MSGLO`" ] pub type MSGLO_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `MSGLO`" ] pub struct MSGLO_W < 'a > { w : & 'a mut W , } impl < 'a > MSGLO_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
# [ doc = "Reader of field `MSGHI`" ] pub type MSGHI_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `MSGHI`" ] pub struct MSGHI_W < 'a > { w : & 'a mut W , } impl < 'a > MSGHI_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 8 ) ) | ( ( ( value as u16 ) & 0xff ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - JTAG mailbox incoming message low byte" ] # [ inline ( always ) ] pub fn msglo ( & self ) -> MSGLO_R { MSGLO_R :: new ( ( self . bits & 0xff ) as u8 ) }
# [ doc = "Bits 8:15 - JTAG mailbox incoming message high byte" ] # [ inline ( always ) ] pub fn msghi ( & self ) -> MSGHI_R { MSGHI_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - JTAG mailbox incoming message low byte" ] # [ inline ( always ) ] pub fn msglo ( & mut self ) -> MSGLO_W { MSGLO_W { w : self } }
# [ doc = "Bits 8:15 - JTAG mailbox incoming message high byte" ] # [ inline ( always ) ] pub fn msghi ( & mut self ) -> MSGHI_W { MSGHI_W { w : self } }
}
}
# [ doc = "JTAG Mailbox Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sysjmbo0](sysjmbo0) module" ] pub type SYSJMBO0 = crate :: Reg < u16 , _SYSJMBO0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYSJMBO0 ;
# [ doc = "`read()` method returns [sysjmbo0::R](sysjmbo0::R) reader structure" ] impl crate :: Readable for SYSJMBO0 { }
# [ doc = "`write(|w| ..)` method takes [sysjmbo0::W](sysjmbo0::W) writer structure" ] impl crate :: Writable for SYSJMBO0 { }
# [ doc = "JTAG Mailbox Output" ] pub mod sysjmbo0 {
# [ doc = "Reader of register SYSJMBO0" ] pub type R = crate :: R < u16 , super :: SYSJMBO0 > ;
# [ doc = "Writer for register SYSJMBO0" ] pub type W = crate :: W < u16 , super :: SYSJMBO0 > ;
# [ doc = "Register SYSJMBO0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SYSJMBO0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `MSGLO`" ] pub type MSGLO_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `MSGLO`" ] pub struct MSGLO_W < 'a > { w : & 'a mut W , } impl < 'a > MSGLO_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
# [ doc = "Reader of field `MSGHI`" ] pub type MSGHI_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `MSGHI`" ] pub struct MSGHI_W < 'a > { w : & 'a mut W , } impl < 'a > MSGHI_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 8 ) ) | ( ( ( value as u16 ) & 0xff ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - JTAG mailbox outgoing message low byte" ] # [ inline ( always ) ] pub fn msglo ( & self ) -> MSGLO_R { MSGLO_R :: new ( ( self . bits & 0xff ) as u8 ) }
# [ doc = "Bits 8:15 - JTAG mailbox outgoing message high byte" ] # [ inline ( always ) ] pub fn msghi ( & self ) -> MSGHI_R { MSGHI_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - JTAG mailbox outgoing message low byte" ] # [ inline ( always ) ] pub fn msglo ( & mut self ) -> MSGLO_W { MSGLO_W { w : self } }
# [ doc = "Bits 8:15 - JTAG mailbox outgoing message high byte" ] # [ inline ( always ) ] pub fn msghi ( & mut self ) -> MSGHI_W { MSGHI_W { w : self } }
}
}
# [ doc = "JTAG Mailbox Output 1 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sysjmbo1](sysjmbo1) module" ] pub type SYSJMBO1 = crate :: Reg < u16 , _SYSJMBO1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYSJMBO1 ;
# [ doc = "`read()` method returns [sysjmbo1::R](sysjmbo1::R) reader structure" ] impl crate :: Readable for SYSJMBO1 { }
# [ doc = "`write(|w| ..)` method takes [sysjmbo1::W](sysjmbo1::W) writer structure" ] impl crate :: Writable for SYSJMBO1 { }
# [ doc = "JTAG Mailbox Output 1 Register" ] pub mod sysjmbo1 {
# [ doc = "Reader of register SYSJMBO1" ] pub type R = crate :: R < u16 , super :: SYSJMBO1 > ;
# [ doc = "Writer for register SYSJMBO1" ] pub type W = crate :: W < u16 , super :: SYSJMBO1 > ;
# [ doc = "Register SYSJMBO1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SYSJMBO1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `MSGLO`" ] pub type MSGLO_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `MSGLO`" ] pub struct MSGLO_W < 'a > { w : & 'a mut W , } impl < 'a > MSGLO_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
# [ doc = "Reader of field `MSGHI`" ] pub type MSGHI_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `MSGHI`" ] pub struct MSGHI_W < 'a > { w : & 'a mut W , } impl < 'a > MSGHI_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 8 ) ) | ( ( ( value as u16 ) & 0xff ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - JTAG mailbox outgoing message low byte" ] # [ inline ( always ) ] pub fn msglo ( & self ) -> MSGLO_R { MSGLO_R :: new ( ( self . bits & 0xff ) as u8 ) }
# [ doc = "Bits 8:15 - JTAG mailbox outgoing message high byte" ] # [ inline ( always ) ] pub fn msghi ( & self ) -> MSGHI_R { MSGHI_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - JTAG mailbox outgoing message low byte" ] # [ inline ( always ) ] pub fn msglo ( & mut self ) -> MSGLO_W { MSGLO_W { w : self } }
# [ doc = "Bits 8:15 - JTAG mailbox outgoing message high byte" ] # [ inline ( always ) ] pub fn msghi ( & mut self ) -> MSGHI_W { MSGHI_W { w : self } }
}
}
# [ doc = "User NMI Vector Generator\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sysuniv](sysuniv) module" ] pub type SYSUNIV = crate :: Reg < u16 , _SYSUNIV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYSUNIV ;
# [ doc = "`read()` method returns [sysuniv::R](sysuniv::R) reader structure" ] impl crate :: Readable for SYSUNIV { }
# [ doc = "User NMI Vector Generator" ] pub mod sysuniv {
# [ doc = "Reader of register SYSUNIV" ] pub type R = crate :: R < u16 , super :: SYSUNIV > ;
# [ doc = "User NMI vector\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum SYSUNIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: NMIIFG NMI pin" ] NMIIFG = 2 , # [ doc = "4: OFIFG oscillator fault" ] OFIFG = 4 } impl From < SYSUNIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : SYSUNIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `SYSUNIV`" ] pub type SYSUNIV_R = crate :: R < u16 , SYSUNIV_A > ; impl SYSUNIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , SYSUNIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SYSUNIV_A :: NONE ) , 2 => Val ( SYSUNIV_A :: NMIIFG ) , 4 => Val ( SYSUNIV_A :: OFIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == SYSUNIV_A :: NONE } # [ doc = "Checks if the value of the field is `NMIIFG`" ] # [ inline ( always ) ] pub fn is_nmiifg ( & self ) -> bool { * self == SYSUNIV_A :: NMIIFG } # [ doc = "Checks if the value of the field is `OFIFG`" ] # [ inline ( always ) ] pub fn is_ofifg ( & self ) -> bool { * self == SYSUNIV_A :: OFIFG } }
impl R {
# [ doc = "Bits 0:15 - User NMI vector" ] # [ inline ( always ) ] pub fn sysuniv ( & self ) -> SYSUNIV_R { SYSUNIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
# [ doc = "System NMI Vector Generator\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syssniv](syssniv) module" ] pub type SYSSNIV = crate :: Reg < u16 , _SYSSNIV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYSSNIV ;
# [ doc = "`read()` method returns [syssniv::R](syssniv::R) reader structure" ] impl crate :: Readable for SYSSNIV { }
# [ doc = "System NMI Vector Generator" ] pub mod syssniv {
# [ doc = "Reader of register SYSSNIV" ] pub type R = crate :: R < u16 , super :: SYSSNIV > ;
# [ doc = "System NMI vector\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum SYSSNIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: SVS low-power reset entry" ] SVSLIFG = 2 , # [ doc = "4: Uncorrectable FRAM bit error detection" ] UBDIFG = 4 , # [ doc = "6: FRAM Access Time Error" ] ACCTEIFG = 6 , # [ doc = "8: Reserved" ] SYSSNIV_8 = 8 , # [ doc = "10: Reserved" ] SYSSNIV_10 = 10 , # [ doc = "12: Reserved" ] SYSSNIV_12 = 12 , # [ doc = "14: Reserved" ] SYSSNIV_14 = 14 , # [ doc = "16: Reserved" ] SYSSNIV_16 = 16 , # [ doc = "18: VMAIFG Vacant memory access" ] VMAIFG = 18 , # [ doc = "20: JMBINIFG JTAG mailbox input" ] JMBINIFG = 20 , # [ doc = "22: JMBOUTIFG JTAG mailbox output" ] JMBOUTIFG = 22 , # [ doc = "24: Correctable FRAM bit error detection" ] CBDIFG = 24 } impl From < SYSSNIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : SYSSNIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `SYSSNIV`" ] pub type SYSSNIV_R = crate :: R < u16 , SYSSNIV_A > ; impl SYSSNIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , SYSSNIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SYSSNIV_A :: NONE ) , 2 => Val ( SYSSNIV_A :: SVSLIFG ) , 4 => Val ( SYSSNIV_A :: UBDIFG ) , 6 => Val ( SYSSNIV_A :: ACCTEIFG ) , 8 => Val ( SYSSNIV_A :: SYSSNIV_8 ) , 10 => Val ( SYSSNIV_A :: SYSSNIV_10 ) , 12 => Val ( SYSSNIV_A :: SYSSNIV_12 ) , 14 => Val ( SYSSNIV_A :: SYSSNIV_14 ) , 16 => Val ( SYSSNIV_A :: SYSSNIV_16 ) , 18 => Val ( SYSSNIV_A :: VMAIFG ) , 20 => Val ( SYSSNIV_A :: JMBINIFG ) , 22 => Val ( SYSSNIV_A :: JMBOUTIFG ) , 24 => Val ( SYSSNIV_A :: CBDIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == SYSSNIV_A :: NONE } # [ doc = "Checks if the value of the field is `SVSLIFG`" ] # [ inline ( always ) ] pub fn is_svslifg ( & self ) -> bool { * self == SYSSNIV_A :: SVSLIFG } # [ doc = "Checks if the value of the field is `UBDIFG`" ] # [ inline ( always ) ] pub fn is_ubdifg ( & self ) -> bool { * self == SYSSNIV_A :: UBDIFG } # [ doc = "Checks if the value of the field is `ACCTEIFG`" ] # [ inline ( always ) ] pub fn is_accteifg ( & self ) -> bool { * self == SYSSNIV_A :: ACCTEIFG } # [ doc = "Checks if the value of the field is `SYSSNIV_8`" ] # [ inline ( always ) ] pub fn is_syssniv_8 ( & self ) -> bool { * self == SYSSNIV_A :: SYSSNIV_8 } # [ doc = "Checks if the value of the field is `SYSSNIV_10`" ] # [ inline ( always ) ] pub fn is_syssniv_10 ( & self ) -> bool { * self == SYSSNIV_A :: SYSSNIV_10 } # [ doc = "Checks if the value of the field is `SYSSNIV_12`" ] # [ inline ( always ) ] pub fn is_syssniv_12 ( & self ) -> bool { * self == SYSSNIV_A :: SYSSNIV_12 } # [ doc = "Checks if the value of the field is `SYSSNIV_14`" ] # [ inline ( always ) ] pub fn is_syssniv_14 ( & self ) -> bool { * self == SYSSNIV_A :: SYSSNIV_14 } # [ doc = "Checks if the value of the field is `SYSSNIV_16`" ] # [ inline ( always ) ] pub fn is_syssniv_16 ( & self ) -> bool { * self == SYSSNIV_A :: SYSSNIV_16 } # [ doc = "Checks if the value of the field is `VMAIFG`" ] # [ inline ( always ) ] pub fn is_vmaifg ( & self ) -> bool { * self == SYSSNIV_A :: VMAIFG } # [ doc = "Checks if the value of the field is `JMBINIFG`" ] # [ inline ( always ) ] pub fn is_jmbinifg ( & self ) -> bool { * self == SYSSNIV_A :: JMBINIFG } # [ doc = "Checks if the value of the field is `JMBOUTIFG`" ] # [ inline ( always ) ] pub fn is_jmboutifg ( & self ) -> bool { * self == SYSSNIV_A :: JMBOUTIFG } # [ doc = "Checks if the value of the field is `CBDIFG`" ] # [ inline ( always ) ] pub fn is_cbdifg ( & self ) -> bool { * self == SYSSNIV_A :: CBDIFG } }
impl R {
# [ doc = "Bits 0:15 - System NMI vector" ] # [ inline ( always ) ] pub fn syssniv ( & self ) -> SYSSNIV_R { SYSSNIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
# [ doc = "Reset Vector Generator\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sysrstiv](sysrstiv) module" ] pub type SYSRSTIV = crate :: Reg < u16 , _SYSRSTIV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYSRSTIV ;
# [ doc = "`read()` method returns [sysrstiv::R](sysrstiv::R) reader structure" ] impl crate :: Readable for SYSRSTIV { }
# [ doc = "Reset Vector Generator" ] pub mod sysrstiv {
# [ doc = "Reader of register SYSRSTIV" ] pub type R = crate :: R < u16 , super :: SYSRSTIV > ;
# [ doc = "Reset interrupt vector\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum SYSRSTIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Brownout" ] BOR = 2 , # [ doc = "4: RSTIFG RST/NMI" ] RSTNMI = 4 , # [ doc = "6: PMMSWBOR software BOR" ] PMMSWBOR = 6 , # [ doc = "8: LPMx.5 wakeup" ] LPM5WU = 8 , # [ doc = "10: Security violation" ] SECYV = 10 , # [ doc = "12: Reserved" ] SYSRSTIV_12 = 12 , # [ doc = "14: SVSHIFG SVSH event" ] SVSHIFG = 14 , # [ doc = "16: Reserved" ] SYSRSTIV_16 = 16 , # [ doc = "18: Reserved" ] SYSRSTIV_18 = 18 , # [ doc = "20: PMMSWPOR software POR" ] PMMSWPOR = 20 , # [ doc = "22: WDTIFG watchdog timeout" ] WDTIFG = 22 , # [ doc = "24: WDTPW watchdog password violation" ] WDTPW = 24 , # [ doc = "26: FRCTLPW password violation" ] FRCTLPW = 26 , # [ doc = "28: Uncorrectable FRAM bit error detection" ] UBDIFG = 28 , # [ doc = "30: Peripheral area fetch" ] PERF = 30 , # [ doc = "32: PMM password violation" ] PMMPW = 32 , # [ doc = "34: Reserved" ] SYSRSTIV_34 = 34 , # [ doc = "36: FLL unlock (PUC)" ] FLLUL = 36 } impl From < SYSRSTIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : SYSRSTIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `SYSRSTIV`" ] pub type SYSRSTIV_R = crate :: R < u16 , SYSRSTIV_A > ; impl SYSRSTIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , SYSRSTIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SYSRSTIV_A :: NONE ) , 2 => Val ( SYSRSTIV_A :: BOR ) , 4 => Val ( SYSRSTIV_A :: RSTNMI ) , 6 => Val ( SYSRSTIV_A :: PMMSWBOR ) , 8 => Val ( SYSRSTIV_A :: LPM5WU ) , 10 => Val ( SYSRSTIV_A :: SECYV ) , 12 => Val ( SYSRSTIV_A :: SYSRSTIV_12 ) , 14 => Val ( SYSRSTIV_A :: SVSHIFG ) , 16 => Val ( SYSRSTIV_A :: SYSRSTIV_16 ) , 18 => Val ( SYSRSTIV_A :: SYSRSTIV_18 ) , 20 => Val ( SYSRSTIV_A :: PMMSWPOR ) , 22 => Val ( SYSRSTIV_A :: WDTIFG ) , 24 => Val ( SYSRSTIV_A :: WDTPW ) , 26 => Val ( SYSRSTIV_A :: FRCTLPW ) , 28 => Val ( SYSRSTIV_A :: UBDIFG ) , 30 => Val ( SYSRSTIV_A :: PERF ) , 32 => Val ( SYSRSTIV_A :: PMMPW ) , 34 => Val ( SYSRSTIV_A :: SYSRSTIV_34 ) , 36 => Val ( SYSRSTIV_A :: FLLUL ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == SYSRSTIV_A :: NONE } # [ doc = "Checks if the value of the field is `BOR`" ] # [ inline ( always ) ] pub fn is_bor ( & self ) -> bool { * self == SYSRSTIV_A :: BOR } # [ doc = "Checks if the value of the field is `RSTNMI`" ] # [ inline ( always ) ] pub fn is_rstnmi ( & self ) -> bool { * self == SYSRSTIV_A :: RSTNMI } # [ doc = "Checks if the value of the field is `PMMSWBOR`" ] # [ inline ( always ) ] pub fn is_pmmswbor ( & self ) -> bool { * self == SYSRSTIV_A :: PMMSWBOR } # [ doc = "Checks if the value of the field is `LPM5WU`" ] # [ inline ( always ) ] pub fn is_lpm5wu ( & self ) -> bool { * self == SYSRSTIV_A :: LPM5WU } # [ doc = "Checks if the value of the field is `SECYV`" ] # [ inline ( always ) ] pub fn is_secyv ( & self ) -> bool { * self == SYSRSTIV_A :: SECYV } # [ doc = "Checks if the value of the field is `SYSRSTIV_12`" ] # [ inline ( always ) ] pub fn is_sysrstiv_12 ( & self ) -> bool { * self == SYSRSTIV_A :: SYSRSTIV_12 } # [ doc = "Checks if the value of the field is `SVSHIFG`" ] # [ inline ( always ) ] pub fn is_svshifg ( & self ) -> bool { * self == SYSRSTIV_A :: SVSHIFG } # [ doc = "Checks if the value of the field is `SYSRSTIV_16`" ] # [ inline ( always ) ] pub fn is_sysrstiv_16 ( & self ) -> bool { * self == SYSRSTIV_A :: SYSRSTIV_16 } # [ doc = "Checks if the value of the field is `SYSRSTIV_18`" ] # [ inline ( always ) ] pub fn is_sysrstiv_18 ( & self ) -> bool { * self == SYSRSTIV_A :: SYSRSTIV_18 } # [ doc = "Checks if the value of the field is `PMMSWPOR`" ] # [ inline ( always ) ] pub fn is_pmmswpor ( & self ) -> bool { * self == SYSRSTIV_A :: PMMSWPOR } # [ doc = "Checks if the value of the field is `WDTIFG`" ] # [ inline ( always ) ] pub fn is_wdtifg ( & self ) -> bool { * self == SYSRSTIV_A :: WDTIFG } # [ doc = "Checks if the value of the field is `WDTPW`" ] # [ inline ( always ) ] pub fn is_wdtpw ( & self ) -> bool { * self == SYSRSTIV_A :: WDTPW } # [ doc = "Checks if the value of the field is `FRCTLPW`" ] # [ inline ( always ) ] pub fn is_frctlpw ( & self ) -> bool { * self == SYSRSTIV_A :: FRCTLPW } # [ doc = "Checks if the value of the field is `UBDIFG`" ] # [ inline ( always ) ] pub fn is_ubdifg ( & self ) -> bool { * self == SYSRSTIV_A :: UBDIFG } # [ doc = "Checks if the value of the field is `PERF`" ] # [ inline ( always ) ] pub fn is_perf ( & self ) -> bool { * self == SYSRSTIV_A :: PERF } # [ doc = "Checks if the value of the field is `PMMPW`" ] # [ inline ( always ) ] pub fn is_pmmpw ( & self ) -> bool { * self == SYSRSTIV_A :: PMMPW } # [ doc = "Checks if the value of the field is `SYSRSTIV_34`" ] # [ inline ( always ) ] pub fn is_sysrstiv_34 ( & self ) -> bool { * self == SYSRSTIV_A :: SYSRSTIV_34 } # [ doc = "Checks if the value of the field is `FLLUL`" ] # [ inline ( always ) ] pub fn is_fllul ( & self ) -> bool { * self == SYSRSTIV_A :: FLLUL } }
impl R {
# [ doc = "Bits 0:15 - Reset interrupt vector" ] # [ inline ( always ) ] pub fn sysrstiv ( & self ) -> SYSRSTIV_R { SYSRSTIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
# [ doc = "System Configuration Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syscfg0](syscfg0) module" ] pub type SYSCFG0 = crate :: Reg < u16 , _SYSCFG0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYSCFG0 ;
# [ doc = "`read()` method returns [syscfg0::R](syscfg0::R) reader structure" ] impl crate :: Readable for SYSCFG0 { }
# [ doc = "`write(|w| ..)` method takes [syscfg0::W](syscfg0::W) writer structure" ] impl crate :: Writable for SYSCFG0 { }
# [ doc = "System Configuration Register 0" ] pub mod syscfg0 {
# [ doc = "Reader of register SYSCFG0" ] pub type R = crate :: R < u16 , super :: SYSCFG0 > ;
# [ doc = "Writer for register SYSCFG0" ] pub type W = crate :: W < u16 , super :: SYSCFG0 > ;
# [ doc = "Register SYSCFG0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SYSCFG0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Program FRAM write protection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PFWP_A { # [ doc = "0: Program FRAM write enable" ] PFWP_0 = 0 , # [ doc = "1: Program FRAM write protected (not writable)" ] PFWP_1 = 1 } impl From < PFWP_A > for bool { # [ inline ( always ) ] fn from ( variant : PFWP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `PFWP`" ] pub type PFWP_R = crate :: R < bool , PFWP_A > ; impl PFWP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PFWP_A { match self . bits { false => PFWP_A :: PFWP_0 , true => PFWP_A :: PFWP_1 } } # [ doc = "Checks if the value of the field is `PFWP_0`" ] # [ inline ( always ) ] pub fn is_pfwp_0 ( & self ) -> bool { * self == PFWP_A :: PFWP_0 } # [ doc = "Checks if the value of the field is `PFWP_1`" ] # [ inline ( always ) ] pub fn is_pfwp_1 ( & self ) -> bool { * self == PFWP_A :: PFWP_1 } }
# [ doc = "Write proxy for field `PFWP`" ] pub struct PFWP_W < 'a > { w : & 'a mut W , } impl < 'a > PFWP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PFWP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Program FRAM write enable" ] # [ inline ( always ) ] pub fn pfwp_0 ( self ) -> & 'a mut W { self . variant ( PFWP_A :: PFWP_0 ) } # [ doc = "Program FRAM write protected (not writable)" ] # [ inline ( always ) ] pub fn pfwp_1 ( self ) -> & 'a mut W { self . variant ( PFWP_A :: PFWP_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Data FRAM write protection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DFWP_A { # [ doc = "0: Data FRAM write enable" ] DFWP_0 = 0 , # [ doc = "1: Data FRAM write protected (not writable)" ] DFWP_1 = 1 } impl From < DFWP_A > for bool { # [ inline ( always ) ] fn from ( variant : DFWP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DFWP`" ] pub type DFWP_R = crate :: R < bool , DFWP_A > ; impl DFWP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DFWP_A { match self . bits { false => DFWP_A :: DFWP_0 , true => DFWP_A :: DFWP_1 } } # [ doc = "Checks if the value of the field is `DFWP_0`" ] # [ inline ( always ) ] pub fn is_dfwp_0 ( & self ) -> bool { * self == DFWP_A :: DFWP_0 } # [ doc = "Checks if the value of the field is `DFWP_1`" ] # [ inline ( always ) ] pub fn is_dfwp_1 ( & self ) -> bool { * self == DFWP_A :: DFWP_1 } }
# [ doc = "Write proxy for field `DFWP`" ] pub struct DFWP_W < 'a > { w : & 'a mut W , } impl < 'a > DFWP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DFWP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Data FRAM write enable" ] # [ inline ( always ) ] pub fn dfwp_0 ( self ) -> & 'a mut W { self . variant ( DFWP_A :: DFWP_0 ) } # [ doc = "Data FRAM write protected (not writable)" ] # [ inline ( always ) ] pub fn dfwp_1 ( self ) -> & 'a mut W { self . variant ( DFWP_A :: DFWP_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `FRWPPW`" ] pub type FRWPPW_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `FRWPPW`" ] pub struct FRWPPW_W < 'a > { w : & 'a mut W , } impl < 'a > FRWPPW_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 8 ) ) | ( ( ( value as u16 ) & 0xff ) << 8 ) ; self . w } }
# [ doc = "Reader of field `FRWPOA`" ] pub type FRWPOA_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `FRWPOA`" ] pub struct FRWPOA_W < 'a > { w : & 'a mut W , } impl < 'a > FRWPOA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 2 ) ) | ( ( ( value as u16 ) & 0x3f ) << 2 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Program FRAM write protection" ] # [ inline ( always ) ] pub fn pfwp ( & self ) -> PFWP_R { PFWP_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Data FRAM write protection" ] # [ inline ( always ) ] pub fn dfwp ( & self ) -> DFWP_R { DFWP_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:15 - FRAM protection password, FRAM protection password. Write with 0A5h to unlock the FRAM protection registers. Always reads as 096h" ] # [ inline ( always ) ] pub fn frwppw ( & self ) -> FRWPPW_R { FRWPPW_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
# [ doc = "Bits 2:7 - Program FRAM write protection offset address from the beginning of Program FRAM. The offset increases by 1KB resolution" ] # [ inline ( always ) ] pub fn frwpoa ( & self ) -> FRWPOA_R { FRWPOA_R :: new ( ( ( self . bits >> 2 ) & 0x3f ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Program FRAM write protection" ] # [ inline ( always ) ] pub fn pfwp ( & mut self ) -> PFWP_W { PFWP_W { w : self } }
# [ doc = "Bit 1 - Data FRAM write protection" ] # [ inline ( always ) ] pub fn dfwp ( & mut self ) -> DFWP_W { DFWP_W { w : self } }
# [ doc = "Bits 8:15 - FRAM protection password, FRAM protection password. Write with 0A5h to unlock the FRAM protection registers. Always reads as 096h" ] # [ inline ( always ) ] pub fn frwppw ( & mut self ) -> FRWPPW_W { FRWPPW_W { w : self } }
# [ doc = "Bits 2:7 - Program FRAM write protection offset address from the beginning of Program FRAM. The offset increases by 1KB resolution" ] # [ inline ( always ) ] pub fn frwpoa ( & mut self ) -> FRWPOA_W { FRWPOA_W { w : self } }
}
}
# [ doc = "System Configuration Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syscfg1](syscfg1) module" ] pub type SYSCFG1 = crate :: Reg < u16 , _SYSCFG1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYSCFG1 ;
# [ doc = "`read()` method returns [syscfg1::R](syscfg1::R) reader structure" ] impl crate :: Readable for SYSCFG1 { }
# [ doc = "`write(|w| ..)` method takes [syscfg1::W](syscfg1::W) writer structure" ] impl crate :: Writable for SYSCFG1 { }
# [ doc = "System Configuration Register 1" ] pub mod syscfg1 {
# [ doc = "Reader of register SYSCFG1" ] pub type R = crate :: R < u16 , super :: SYSCFG1 > ;
# [ doc = "Writer for register SYSCFG1" ] pub type W = crate :: W < u16 , super :: SYSCFG1 > ;
# [ doc = "Register SYSCFG1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SYSCFG1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Infrared enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IREN_A { # [ doc = "0: Infrared function disabled" ] IREN_0 = 0 , # [ doc = "1: Infrared function enabled" ] IREN_1 = 1 } impl From < IREN_A > for bool { # [ inline ( always ) ] fn from ( variant : IREN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `IREN`" ] pub type IREN_R = crate :: R < bool , IREN_A > ; impl IREN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> IREN_A { match self . bits { false => IREN_A :: IREN_0 , true => IREN_A :: IREN_1 } } # [ doc = "Checks if the value of the field is `IREN_0`" ] # [ inline ( always ) ] pub fn is_iren_0 ( & self ) -> bool { * self == IREN_A :: IREN_0 } # [ doc = "Checks if the value of the field is `IREN_1`" ] # [ inline ( always ) ] pub fn is_iren_1 ( & self ) -> bool { * self == IREN_A :: IREN_1 } }
# [ doc = "Write proxy for field `IREN`" ] pub struct IREN_W < 'a > { w : & 'a mut W , } impl < 'a > IREN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : IREN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Infrared function disabled" ] # [ inline ( always ) ] pub fn iren_0 ( self ) -> & 'a mut W { self . variant ( IREN_A :: IREN_0 ) } # [ doc = "Infrared function enabled" ] # [ inline ( always ) ] pub fn iren_1 ( self ) -> & 'a mut W { self . variant ( IREN_A :: IREN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Infrared polarity select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IRPSEL_A { # [ doc = "0: Normal polarity" ] IRPSEL_0 = 0 , # [ doc = "1: Inverted polarity" ] IRPSEL_1 = 1 } impl From < IRPSEL_A > for bool { # [ inline ( always ) ] fn from ( variant : IRPSEL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `IRPSEL`" ] pub type IRPSEL_R = crate :: R < bool , IRPSEL_A > ; impl IRPSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> IRPSEL_A { match self . bits { false => IRPSEL_A :: IRPSEL_0 , true => IRPSEL_A :: IRPSEL_1 } } # [ doc = "Checks if the value of the field is `IRPSEL_0`" ] # [ inline ( always ) ] pub fn is_irpsel_0 ( & self ) -> bool { * self == IRPSEL_A :: IRPSEL_0 } # [ doc = "Checks if the value of the field is `IRPSEL_1`" ] # [ inline ( always ) ] pub fn is_irpsel_1 ( & self ) -> bool { * self == IRPSEL_A :: IRPSEL_1 } }
# [ doc = "Write proxy for field `IRPSEL`" ] pub struct IRPSEL_W < 'a > { w : & 'a mut W , } impl < 'a > IRPSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : IRPSEL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Normal polarity" ] # [ inline ( always ) ] pub fn irpsel_0 ( self ) -> & 'a mut W { self . variant ( IRPSEL_A :: IRPSEL_0 ) } # [ doc = "Inverted polarity" ] # [ inline ( always ) ] pub fn irpsel_1 ( self ) -> & 'a mut W { self . variant ( IRPSEL_A :: IRPSEL_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Infrared mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IRMSEL_A { # [ doc = "0: FSK mode" ] IRMSEL_0 = 0 , # [ doc = "1: ASK mode" ] IRMSEL_1 = 1 } impl From < IRMSEL_A > for bool { # [ inline ( always ) ] fn from ( variant : IRMSEL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `IRMSEL`" ] pub type IRMSEL_R = crate :: R < bool , IRMSEL_A > ; impl IRMSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> IRMSEL_A { match self . bits { false => IRMSEL_A :: IRMSEL_0 , true => IRMSEL_A :: IRMSEL_1 } } # [ doc = "Checks if the value of the field is `IRMSEL_0`" ] # [ inline ( always ) ] pub fn is_irmsel_0 ( & self ) -> bool { * self == IRMSEL_A :: IRMSEL_0 } # [ doc = "Checks if the value of the field is `IRMSEL_1`" ] # [ inline ( always ) ] pub fn is_irmsel_1 ( & self ) -> bool { * self == IRMSEL_A :: IRMSEL_1 } }
# [ doc = "Write proxy for field `IRMSEL`" ] pub struct IRMSEL_W < 'a > { w : & 'a mut W , } impl < 'a > IRMSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : IRMSEL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "FSK mode" ] # [ inline ( always ) ] pub fn irmsel_0 ( self ) -> & 'a mut W { self . variant ( IRMSEL_A :: IRMSEL_0 ) } # [ doc = "ASK mode" ] # [ inline ( always ) ] pub fn irmsel_1 ( self ) -> & 'a mut W { self . variant ( IRMSEL_A :: IRMSEL_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Infrared data source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IRDSSEL_A { # [ doc = "0: From hardware peripherals upon device configuration" ] IRDSSEL_0 = 0 , # [ doc = "1: From IRDATA bit" ] IRDSSEL_1 = 1 } impl From < IRDSSEL_A > for bool { # [ inline ( always ) ] fn from ( variant : IRDSSEL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `IRDSSEL`" ] pub type IRDSSEL_R = crate :: R < bool , IRDSSEL_A > ; impl IRDSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> IRDSSEL_A { match self . bits { false => IRDSSEL_A :: IRDSSEL_0 , true => IRDSSEL_A :: IRDSSEL_1 } } # [ doc = "Checks if the value of the field is `IRDSSEL_0`" ] # [ inline ( always ) ] pub fn is_irdssel_0 ( & self ) -> bool { * self == IRDSSEL_A :: IRDSSEL_0 } # [ doc = "Checks if the value of the field is `IRDSSEL_1`" ] # [ inline ( always ) ] pub fn is_irdssel_1 ( & self ) -> bool { * self == IRDSSEL_A :: IRDSSEL_1 } }
# [ doc = "Write proxy for field `IRDSSEL`" ] pub struct IRDSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > IRDSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : IRDSSEL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "From hardware peripherals upon device configuration" ] # [ inline ( always ) ] pub fn irdssel_0 ( self ) -> & 'a mut W { self . variant ( IRDSSEL_A :: IRDSSEL_0 ) } # [ doc = "From IRDATA bit" ] # [ inline ( always ) ] pub fn irdssel_1 ( self ) -> & 'a mut W { self . variant ( IRDSSEL_A :: IRDSSEL_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Infrared data\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IRDATA_A { # [ doc = "0: Infrared data logic 0" ] IRDATA_0 = 0 , # [ doc = "1: Infrared data logic 1" ] IRDATA_1 = 1 } impl From < IRDATA_A > for bool { # [ inline ( always ) ] fn from ( variant : IRDATA_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `IRDATA`" ] pub type IRDATA_R = crate :: R < bool , IRDATA_A > ; impl IRDATA_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> IRDATA_A { match self . bits { false => IRDATA_A :: IRDATA_0 , true => IRDATA_A :: IRDATA_1 } } # [ doc = "Checks if the value of the field is `IRDATA_0`" ] # [ inline ( always ) ] pub fn is_irdata_0 ( & self ) -> bool { * self == IRDATA_A :: IRDATA_0 } # [ doc = "Checks if the value of the field is `IRDATA_1`" ] # [ inline ( always ) ] pub fn is_irdata_1 ( & self ) -> bool { * self == IRDATA_A :: IRDATA_1 } }
# [ doc = "Write proxy for field `IRDATA`" ] pub struct IRDATA_W < 'a > { w : & 'a mut W , } impl < 'a > IRDATA_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : IRDATA_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Infrared data logic 0" ] # [ inline ( always ) ] pub fn irdata_0 ( self ) -> & 'a mut W { self . variant ( IRDATA_A :: IRDATA_0 ) } # [ doc = "Infrared data logic 1" ] # [ inline ( always ) ] pub fn irdata_1 ( self ) -> & 'a mut W { self . variant ( IRDATA_A :: IRDATA_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Captivate Conversion triggered Source Selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum SYNCSEL_A { # [ doc = "0: External source is selected" ] SYNCSEL_0 = 0 , # [ doc = "1: ADC as the source is selected" ] SYNCSEL_1 = 1 , # [ doc = "2: internal source is selected" ] SYNCSEL_2 = 2 , # [ doc = "3: Reserved" ] SYNCSEL_3 = 3 } impl From < SYNCSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : SYNCSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `SYNCSEL`" ] pub type SYNCSEL_R = crate :: R < u8 , SYNCSEL_A > ; impl SYNCSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SYNCSEL_A { match self . bits { 0 => SYNCSEL_A :: SYNCSEL_0 , 1 => SYNCSEL_A :: SYNCSEL_1 , 2 => SYNCSEL_A :: SYNCSEL_2 , 3 => SYNCSEL_A :: SYNCSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `SYNCSEL_0`" ] # [ inline ( always ) ] pub fn is_syncsel_0 ( & self ) -> bool { * self == SYNCSEL_A :: SYNCSEL_0 } # [ doc = "Checks if the value of the field is `SYNCSEL_1`" ] # [ inline ( always ) ] pub fn is_syncsel_1 ( & self ) -> bool { * self == SYNCSEL_A :: SYNCSEL_1 } # [ doc = "Checks if the value of the field is `SYNCSEL_2`" ] # [ inline ( always ) ] pub fn is_syncsel_2 ( & self ) -> bool { * self == SYNCSEL_A :: SYNCSEL_2 } # [ doc = "Checks if the value of the field is `SYNCSEL_3`" ] # [ inline ( always ) ] pub fn is_syncsel_3 ( & self ) -> bool { * self == SYNCSEL_A :: SYNCSEL_3 } }
# [ doc = "Write proxy for field `SYNCSEL`" ] pub struct SYNCSEL_W < 'a > { w : & 'a mut W , } impl < 'a > SYNCSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SYNCSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "External source is selected" ] # [ inline ( always ) ] pub fn syncsel_0 ( self ) -> & 'a mut W { self . variant ( SYNCSEL_A :: SYNCSEL_0 ) } # [ doc = "ADC as the source is selected" ] # [ inline ( always ) ] pub fn syncsel_1 ( self ) -> & 'a mut W { self . variant ( SYNCSEL_A :: SYNCSEL_1 ) } # [ doc = "internal source is selected" ] # [ inline ( always ) ] pub fn syncsel_2 ( self ) -> & 'a mut W { self . variant ( SYNCSEL_A :: SYNCSEL_2 ) } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn syncsel_3 ( self ) -> & 'a mut W { self . variant ( SYNCSEL_A :: SYNCSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Infrared enable" ] # [ inline ( always ) ] pub fn iren ( & self ) -> IREN_R { IREN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Infrared polarity select" ] # [ inline ( always ) ] pub fn irpsel ( & self ) -> IRPSEL_R { IRPSEL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Infrared mode select" ] # [ inline ( always ) ] pub fn irmsel ( & self ) -> IRMSEL_R { IRMSEL_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Infrared data source select" ] # [ inline ( always ) ] pub fn irdssel ( & self ) -> IRDSSEL_R { IRDSSEL_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Infrared data" ] # [ inline ( always ) ] pub fn irdata ( & self ) -> IRDATA_R { IRDATA_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - Captivate Conversion triggered Source Selection" ] # [ inline ( always ) ] pub fn syncsel ( & self ) -> SYNCSEL_R { SYNCSEL_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Infrared enable" ] # [ inline ( always ) ] pub fn iren ( & mut self ) -> IREN_W { IREN_W { w : self } }
# [ doc = "Bit 1 - Infrared polarity select" ] # [ inline ( always ) ] pub fn irpsel ( & mut self ) -> IRPSEL_W { IRPSEL_W { w : self } }
# [ doc = "Bit 2 - Infrared mode select" ] # [ inline ( always ) ] pub fn irmsel ( & mut self ) -> IRMSEL_W { IRMSEL_W { w : self } }
# [ doc = "Bit 3 - Infrared data source select" ] # [ inline ( always ) ] pub fn irdssel ( & mut self ) -> IRDSSEL_W { IRDSSEL_W { w : self } }
# [ doc = "Bit 4 - Infrared data" ] # [ inline ( always ) ] pub fn irdata ( & mut self ) -> IRDATA_W { IRDATA_W { w : self } }
# [ doc = "Bits 6:7 - Captivate Conversion triggered Source Selection" ] # [ inline ( always ) ] pub fn syncsel ( & mut self ) -> SYNCSEL_W { SYNCSEL_W { w : self } }
}
}
# [ doc = "System Configuration Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syscfg2](syscfg2) module" ] pub type SYSCFG2 = crate :: Reg < u16 , _SYSCFG2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYSCFG2 ;
# [ doc = "`read()` method returns [syscfg2::R](syscfg2::R) reader structure" ] impl crate :: Readable for SYSCFG2 { }
# [ doc = "`write(|w| ..)` method takes [syscfg2::W](syscfg2::W) writer structure" ] impl crate :: Writable for SYSCFG2 { }
# [ doc = "System Configuration Register 2" ] pub mod syscfg2 {
# [ doc = "Reader of register SYSCFG2" ] pub type R = crate :: R < u16 , super :: SYSCFG2 > ;
# [ doc = "Writer for register SYSCFG2" ] pub type W = crate :: W < u16 , super :: SYSCFG2 > ;
# [ doc = "Register SYSCFG2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SYSCFG2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "ADC input A0 pin select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCPCTL0_A { # [ doc = "0: ADC input A0 disabled" ] ADCPCTL0_0 = 0 , # [ doc = "1: ADC input A0 enabled" ] ADCPCTL0_1 = 1 } impl From < ADCPCTL0_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCPCTL0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCPCTL0`" ] pub type ADCPCTL0_R = crate :: R < bool , ADCPCTL0_A > ; impl ADCPCTL0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCPCTL0_A { match self . bits { false => ADCPCTL0_A :: ADCPCTL0_0 , true => ADCPCTL0_A :: ADCPCTL0_1 } } # [ doc = "Checks if the value of the field is `ADCPCTL0_0`" ] # [ inline ( always ) ] pub fn is_adcpctl0_0 ( & self ) -> bool { * self == ADCPCTL0_A :: ADCPCTL0_0 } # [ doc = "Checks if the value of the field is `ADCPCTL0_1`" ] # [ inline ( always ) ] pub fn is_adcpctl0_1 ( & self ) -> bool { * self == ADCPCTL0_A :: ADCPCTL0_1 } }
# [ doc = "Write proxy for field `ADCPCTL0`" ] pub struct ADCPCTL0_W < 'a > { w : & 'a mut W , } impl < 'a > ADCPCTL0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCPCTL0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "ADC input A0 disabled" ] # [ inline ( always ) ] pub fn adcpctl0_0 ( self ) -> & 'a mut W { self . variant ( ADCPCTL0_A :: ADCPCTL0_0 ) } # [ doc = "ADC input A0 enabled" ] # [ inline ( always ) ] pub fn adcpctl0_1 ( self ) -> & 'a mut W { self . variant ( ADCPCTL0_A :: ADCPCTL0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "ADC input A1 pin select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCPCTL1_A { # [ doc = "0: ADC input A1 disabled" ] ADCPCTL1_0 = 0 , # [ doc = "1: ADC input A1 enabled" ] ADCPCTL1_1 = 1 } impl From < ADCPCTL1_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCPCTL1_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCPCTL1`" ] pub type ADCPCTL1_R = crate :: R < bool , ADCPCTL1_A > ; impl ADCPCTL1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCPCTL1_A { match self . bits { false => ADCPCTL1_A :: ADCPCTL1_0 , true => ADCPCTL1_A :: ADCPCTL1_1 } } # [ doc = "Checks if the value of the field is `ADCPCTL1_0`" ] # [ inline ( always ) ] pub fn is_adcpctl1_0 ( & self ) -> bool { * self == ADCPCTL1_A :: ADCPCTL1_0 } # [ doc = "Checks if the value of the field is `ADCPCTL1_1`" ] # [ inline ( always ) ] pub fn is_adcpctl1_1 ( & self ) -> bool { * self == ADCPCTL1_A :: ADCPCTL1_1 } }
# [ doc = "Write proxy for field `ADCPCTL1`" ] pub struct ADCPCTL1_W < 'a > { w : & 'a mut W , } impl < 'a > ADCPCTL1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCPCTL1_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "ADC input A1 disabled" ] # [ inline ( always ) ] pub fn adcpctl1_0 ( self ) -> & 'a mut W { self . variant ( ADCPCTL1_A :: ADCPCTL1_0 ) } # [ doc = "ADC input A1 enabled" ] # [ inline ( always ) ] pub fn adcpctl1_1 ( self ) -> & 'a mut W { self . variant ( ADCPCTL1_A :: ADCPCTL1_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "ADC input A2 pin select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCPCTL2_A { # [ doc = "0: ADC input A2 disabled" ] ADCPCTL2_0 = 0 , # [ doc = "1: ADC input A2 enabled" ] ADCPCTL2_1 = 1 } impl From < ADCPCTL2_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCPCTL2_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCPCTL2`" ] pub type ADCPCTL2_R = crate :: R < bool , ADCPCTL2_A > ; impl ADCPCTL2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCPCTL2_A { match self . bits { false => ADCPCTL2_A :: ADCPCTL2_0 , true => ADCPCTL2_A :: ADCPCTL2_1 } } # [ doc = "Checks if the value of the field is `ADCPCTL2_0`" ] # [ inline ( always ) ] pub fn is_adcpctl2_0 ( & self ) -> bool { * self == ADCPCTL2_A :: ADCPCTL2_0 } # [ doc = "Checks if the value of the field is `ADCPCTL2_1`" ] # [ inline ( always ) ] pub fn is_adcpctl2_1 ( & self ) -> bool { * self == ADCPCTL2_A :: ADCPCTL2_1 } }
# [ doc = "Write proxy for field `ADCPCTL2`" ] pub struct ADCPCTL2_W < 'a > { w : & 'a mut W , } impl < 'a > ADCPCTL2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCPCTL2_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "ADC input A2 disabled" ] # [ inline ( always ) ] pub fn adcpctl2_0 ( self ) -> & 'a mut W { self . variant ( ADCPCTL2_A :: ADCPCTL2_0 ) } # [ doc = "ADC input A2 enabled" ] # [ inline ( always ) ] pub fn adcpctl2_1 ( self ) -> & 'a mut W { self . variant ( ADCPCTL2_A :: ADCPCTL2_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "ADC input A3 pin select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCPCTL3_A { # [ doc = "0: ADC input A3 disabled" ] ADCPCTL3_0 = 0 , # [ doc = "1: ADC input A3 enabled" ] ADCPCTL3_1 = 1 } impl From < ADCPCTL3_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCPCTL3_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCPCTL3`" ] pub type ADCPCTL3_R = crate :: R < bool , ADCPCTL3_A > ; impl ADCPCTL3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCPCTL3_A { match self . bits { false => ADCPCTL3_A :: ADCPCTL3_0 , true => ADCPCTL3_A :: ADCPCTL3_1 } } # [ doc = "Checks if the value of the field is `ADCPCTL3_0`" ] # [ inline ( always ) ] pub fn is_adcpctl3_0 ( & self ) -> bool { * self == ADCPCTL3_A :: ADCPCTL3_0 } # [ doc = "Checks if the value of the field is `ADCPCTL3_1`" ] # [ inline ( always ) ] pub fn is_adcpctl3_1 ( & self ) -> bool { * self == ADCPCTL3_A :: ADCPCTL3_1 } }
# [ doc = "Write proxy for field `ADCPCTL3`" ] pub struct ADCPCTL3_W < 'a > { w : & 'a mut W , } impl < 'a > ADCPCTL3_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCPCTL3_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "ADC input A3 disabled" ] # [ inline ( always ) ] pub fn adcpctl3_0 ( self ) -> & 'a mut W { self . variant ( ADCPCTL3_A :: ADCPCTL3_0 ) } # [ doc = "ADC input A3 enabled" ] # [ inline ( always ) ] pub fn adcpctl3_1 ( self ) -> & 'a mut W { self . variant ( ADCPCTL3_A :: ADCPCTL3_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "ADC input A4 pin select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCPCTL4_A { # [ doc = "0: ADC input A4 disabled" ] ADCPCTL4_0 = 0 , # [ doc = "1: ADC input A4 enabled" ] ADCPCTL4_1 = 1 } impl From < ADCPCTL4_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCPCTL4_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCPCTL4`" ] pub type ADCPCTL4_R = crate :: R < bool , ADCPCTL4_A > ; impl ADCPCTL4_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCPCTL4_A { match self . bits { false => ADCPCTL4_A :: ADCPCTL4_0 , true => ADCPCTL4_A :: ADCPCTL4_1 } } # [ doc = "Checks if the value of the field is `ADCPCTL4_0`" ] # [ inline ( always ) ] pub fn is_adcpctl4_0 ( & self ) -> bool { * self == ADCPCTL4_A :: ADCPCTL4_0 } # [ doc = "Checks if the value of the field is `ADCPCTL4_1`" ] # [ inline ( always ) ] pub fn is_adcpctl4_1 ( & self ) -> bool { * self == ADCPCTL4_A :: ADCPCTL4_1 } }
# [ doc = "Write proxy for field `ADCPCTL4`" ] pub struct ADCPCTL4_W < 'a > { w : & 'a mut W , } impl < 'a > ADCPCTL4_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCPCTL4_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "ADC input A4 disabled" ] # [ inline ( always ) ] pub fn adcpctl4_0 ( self ) -> & 'a mut W { self . variant ( ADCPCTL4_A :: ADCPCTL4_0 ) } # [ doc = "ADC input A4 enabled" ] # [ inline ( always ) ] pub fn adcpctl4_1 ( self ) -> & 'a mut W { self . variant ( ADCPCTL4_A :: ADCPCTL4_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "ADC input A5 pin select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCPCTL5_A { # [ doc = "0: ADC input A5 disabled" ] ADCPCTL5_0 = 0 , # [ doc = "1: ADC input A5 enabled" ] ADCPCTL5_1 = 1 } impl From < ADCPCTL5_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCPCTL5_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCPCTL5`" ] pub type ADCPCTL5_R = crate :: R < bool , ADCPCTL5_A > ; impl ADCPCTL5_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCPCTL5_A { match self . bits { false => ADCPCTL5_A :: ADCPCTL5_0 , true => ADCPCTL5_A :: ADCPCTL5_1 } } # [ doc = "Checks if the value of the field is `ADCPCTL5_0`" ] # [ inline ( always ) ] pub fn is_adcpctl5_0 ( & self ) -> bool { * self == ADCPCTL5_A :: ADCPCTL5_0 } # [ doc = "Checks if the value of the field is `ADCPCTL5_1`" ] # [ inline ( always ) ] pub fn is_adcpctl5_1 ( & self ) -> bool { * self == ADCPCTL5_A :: ADCPCTL5_1 } }
# [ doc = "Write proxy for field `ADCPCTL5`" ] pub struct ADCPCTL5_W < 'a > { w : & 'a mut W , } impl < 'a > ADCPCTL5_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCPCTL5_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "ADC input A5 disabled" ] # [ inline ( always ) ] pub fn adcpctl5_0 ( self ) -> & 'a mut W { self . variant ( ADCPCTL5_A :: ADCPCTL5_0 ) } # [ doc = "ADC input A5 enabled" ] # [ inline ( always ) ] pub fn adcpctl5_1 ( self ) -> & 'a mut W { self . variant ( ADCPCTL5_A :: ADCPCTL5_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "ADC input A6 pin select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCPCTL6_A { # [ doc = "0: ADC input A6 disabled" ] ADCPCTL6_0 = 0 , # [ doc = "1: ADC input A6 enabled" ] ADCPCTL6_1 = 1 } impl From < ADCPCTL6_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCPCTL6_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCPCTL6`" ] pub type ADCPCTL6_R = crate :: R < bool , ADCPCTL6_A > ; impl ADCPCTL6_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCPCTL6_A { match self . bits { false => ADCPCTL6_A :: ADCPCTL6_0 , true => ADCPCTL6_A :: ADCPCTL6_1 } } # [ doc = "Checks if the value of the field is `ADCPCTL6_0`" ] # [ inline ( always ) ] pub fn is_adcpctl6_0 ( & self ) -> bool { * self == ADCPCTL6_A :: ADCPCTL6_0 } # [ doc = "Checks if the value of the field is `ADCPCTL6_1`" ] # [ inline ( always ) ] pub fn is_adcpctl6_1 ( & self ) -> bool { * self == ADCPCTL6_A :: ADCPCTL6_1 } }
# [ doc = "Write proxy for field `ADCPCTL6`" ] pub struct ADCPCTL6_W < 'a > { w : & 'a mut W , } impl < 'a > ADCPCTL6_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCPCTL6_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "ADC input A6 disabled" ] # [ inline ( always ) ] pub fn adcpctl6_0 ( self ) -> & 'a mut W { self . variant ( ADCPCTL6_A :: ADCPCTL6_0 ) } # [ doc = "ADC input A6 enabled" ] # [ inline ( always ) ] pub fn adcpctl6_1 ( self ) -> & 'a mut W { self . variant ( ADCPCTL6_A :: ADCPCTL6_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "ADC input A7 pin select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCPCTL7_A { # [ doc = "0: ADC input A7 disabled" ] ADCPCTL7_0 = 0 , # [ doc = "1: ADC input A7 enabled" ] ADCPCTL7_1 = 1 } impl From < ADCPCTL7_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCPCTL7_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCPCTL7`" ] pub type ADCPCTL7_R = crate :: R < bool , ADCPCTL7_A > ; impl ADCPCTL7_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCPCTL7_A { match self . bits { false => ADCPCTL7_A :: ADCPCTL7_0 , true => ADCPCTL7_A :: ADCPCTL7_1 } } # [ doc = "Checks if the value of the field is `ADCPCTL7_0`" ] # [ inline ( always ) ] pub fn is_adcpctl7_0 ( & self ) -> bool { * self == ADCPCTL7_A :: ADCPCTL7_0 } # [ doc = "Checks if the value of the field is `ADCPCTL7_1`" ] # [ inline ( always ) ] pub fn is_adcpctl7_1 ( & self ) -> bool { * self == ADCPCTL7_A :: ADCPCTL7_1 } }
# [ doc = "Write proxy for field `ADCPCTL7`" ] pub struct ADCPCTL7_W < 'a > { w : & 'a mut W , } impl < 'a > ADCPCTL7_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCPCTL7_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "ADC input A7 disabled" ] # [ inline ( always ) ] pub fn adcpctl7_0 ( self ) -> & 'a mut W { self . variant ( ADCPCTL7_A :: ADCPCTL7_0 ) } # [ doc = "ADC input A7 enabled" ] # [ inline ( always ) ] pub fn adcpctl7_1 ( self ) -> & 'a mut W { self . variant ( ADCPCTL7_A :: ADCPCTL7_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "ADC input A8 pin select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCPCTL8_A { # [ doc = "0: ADC input A8 disabled" ] ADCPCTL8_0 = 0 , # [ doc = "1: ADC input A8 enabled" ] ADCPCTL8_1 = 1 } impl From < ADCPCTL8_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCPCTL8_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCPCTL8`" ] pub type ADCPCTL8_R = crate :: R < bool , ADCPCTL8_A > ; impl ADCPCTL8_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCPCTL8_A { match self . bits { false => ADCPCTL8_A :: ADCPCTL8_0 , true => ADCPCTL8_A :: ADCPCTL8_1 } } # [ doc = "Checks if the value of the field is `ADCPCTL8_0`" ] # [ inline ( always ) ] pub fn is_adcpctl8_0 ( & self ) -> bool { * self == ADCPCTL8_A :: ADCPCTL8_0 } # [ doc = "Checks if the value of the field is `ADCPCTL8_1`" ] # [ inline ( always ) ] pub fn is_adcpctl8_1 ( & self ) -> bool { * self == ADCPCTL8_A :: ADCPCTL8_1 } }
# [ doc = "Write proxy for field `ADCPCTL8`" ] pub struct ADCPCTL8_W < 'a > { w : & 'a mut W , } impl < 'a > ADCPCTL8_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCPCTL8_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "ADC input A8 disabled" ] # [ inline ( always ) ] pub fn adcpctl8_0 ( self ) -> & 'a mut W { self . variant ( ADCPCTL8_A :: ADCPCTL8_0 ) } # [ doc = "ADC input A8 enabled" ] # [ inline ( always ) ] pub fn adcpctl8_1 ( self ) -> & 'a mut W { self . variant ( ADCPCTL8_A :: ADCPCTL8_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "ADC input A9 pin select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCPCTL9_A { # [ doc = "0: ADC input A9 disabled" ] ADCPCTL9_0 = 0 , # [ doc = "1: ADC input A9 enabled" ] ADCPCTL9_1 = 1 } impl From < ADCPCTL9_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCPCTL9_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCPCTL9`" ] pub type ADCPCTL9_R = crate :: R < bool , ADCPCTL9_A > ; impl ADCPCTL9_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCPCTL9_A { match self . bits { false => ADCPCTL9_A :: ADCPCTL9_0 , true => ADCPCTL9_A :: ADCPCTL9_1 } } # [ doc = "Checks if the value of the field is `ADCPCTL9_0`" ] # [ inline ( always ) ] pub fn is_adcpctl9_0 ( & self ) -> bool { * self == ADCPCTL9_A :: ADCPCTL9_0 } # [ doc = "Checks if the value of the field is `ADCPCTL9_1`" ] # [ inline ( always ) ] pub fn is_adcpctl9_1 ( & self ) -> bool { * self == ADCPCTL9_A :: ADCPCTL9_1 } }
# [ doc = "Write proxy for field `ADCPCTL9`" ] pub struct ADCPCTL9_W < 'a > { w : & 'a mut W , } impl < 'a > ADCPCTL9_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCPCTL9_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "ADC input A9 disabled" ] # [ inline ( always ) ] pub fn adcpctl9_0 ( self ) -> & 'a mut W { self . variant ( ADCPCTL9_A :: ADCPCTL9_0 ) } # [ doc = "ADC input A9 enabled" ] # [ inline ( always ) ] pub fn adcpctl9_1 ( self ) -> & 'a mut W { self . variant ( ADCPCTL9_A :: ADCPCTL9_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "eUSCIB Remapping source selection , please refer to device specific for details\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum USCIBRMP_A { # [ doc = "0: P1.x is selected, please refer to device specific for details" ] USCIBRMP_0 = 0 , # [ doc = "1: other port is selected, please refer to device specific for details" ] USCIBRMP_1 = 1 } impl From < USCIBRMP_A > for bool { # [ inline ( always ) ] fn from ( variant : USCIBRMP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `USCIBRMP`" ] pub type USCIBRMP_R = crate :: R < bool , USCIBRMP_A > ; impl USCIBRMP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> USCIBRMP_A { match self . bits { false => USCIBRMP_A :: USCIBRMP_0 , true => USCIBRMP_A :: USCIBRMP_1 } } # [ doc = "Checks if the value of the field is `USCIBRMP_0`" ] # [ inline ( always ) ] pub fn is_uscibrmp_0 ( & self ) -> bool { * self == USCIBRMP_A :: USCIBRMP_0 } # [ doc = "Checks if the value of the field is `USCIBRMP_1`" ] # [ inline ( always ) ] pub fn is_uscibrmp_1 ( & self ) -> bool { * self == USCIBRMP_A :: USCIBRMP_1 } }
# [ doc = "Write proxy for field `USCIBRMP`" ] pub struct USCIBRMP_W < 'a > { w : & 'a mut W , } impl < 'a > USCIBRMP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : USCIBRMP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "P1.x is selected, please refer to device specific for details" ] # [ inline ( always ) ] pub fn uscibrmp_0 ( self ) -> & 'a mut W { self . variant ( USCIBRMP_A :: USCIBRMP_0 ) } # [ doc = "other port is selected, please refer to device specific for details" ] # [ inline ( always ) ] pub fn uscibrmp_1 ( self ) -> & 'a mut W { self . variant ( USCIBRMP_A :: USCIBRMP_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "RTC clock selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RTCCKSEL_A { # [ doc = "0: SMCLK is selected" ] RTC_SMCLK = 0 , # [ doc = "1: ACLK is selected" ] RTC_ACLK = 1 } impl From < RTCCKSEL_A > for bool { # [ inline ( always ) ] fn from ( variant : RTCCKSEL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `RTCCKSEL`" ] pub type RTCCKSEL_R = crate :: R < bool , RTCCKSEL_A > ; impl RTCCKSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RTCCKSEL_A { match self . bits { false => RTCCKSEL_A :: RTC_SMCLK , true => RTCCKSEL_A :: RTC_ACLK } } # [ doc = "Checks if the value of the field is `RTC_SMCLK`" ] # [ inline ( always ) ] pub fn is_rtc_smclk ( & self ) -> bool { * self == RTCCKSEL_A :: RTC_SMCLK } # [ doc = "Checks if the value of the field is `RTC_ACLK`" ] # [ inline ( always ) ] pub fn is_rtc_aclk ( & self ) -> bool { * self == RTCCKSEL_A :: RTC_ACLK } }
# [ doc = "Write proxy for field `RTCCKSEL`" ] pub struct RTCCKSEL_W < 'a > { w : & 'a mut W , } impl < 'a > RTCCKSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RTCCKSEL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SMCLK is selected" ] # [ inline ( always ) ] pub fn rtc_smclk ( self ) -> & 'a mut W { self . variant ( RTCCKSEL_A :: RTC_SMCLK ) } # [ doc = "ACLK is selected" ] # [ inline ( always ) ] pub fn rtc_aclk ( self ) -> & 'a mut W { self . variant ( RTCCKSEL_A :: RTC_ACLK ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - ADC input A0 pin select" ] # [ inline ( always ) ] pub fn adcpctl0 ( & self ) -> ADCPCTL0_R { ADCPCTL0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - ADC input A1 pin select" ] # [ inline ( always ) ] pub fn adcpctl1 ( & self ) -> ADCPCTL1_R { ADCPCTL1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - ADC input A2 pin select" ] # [ inline ( always ) ] pub fn adcpctl2 ( & self ) -> ADCPCTL2_R { ADCPCTL2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - ADC input A3 pin select" ] # [ inline ( always ) ] pub fn adcpctl3 ( & self ) -> ADCPCTL3_R { ADCPCTL3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - ADC input A4 pin select" ] # [ inline ( always ) ] pub fn adcpctl4 ( & self ) -> ADCPCTL4_R { ADCPCTL4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - ADC input A5 pin select" ] # [ inline ( always ) ] pub fn adcpctl5 ( & self ) -> ADCPCTL5_R { ADCPCTL5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - ADC input A6 pin select" ] # [ inline ( always ) ] pub fn adcpctl6 ( & self ) -> ADCPCTL6_R { ADCPCTL6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - ADC input A7 pin select" ] # [ inline ( always ) ] pub fn adcpctl7 ( & self ) -> ADCPCTL7_R { ADCPCTL7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - ADC input A8 pin select" ] # [ inline ( always ) ] pub fn adcpctl8 ( & self ) -> ADCPCTL8_R { ADCPCTL8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - ADC input A9 pin select" ] # [ inline ( always ) ] pub fn adcpctl9 ( & self ) -> ADCPCTL9_R { ADCPCTL9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - eUSCIB Remapping source selection , please refer to device specific for details" ] # [ inline ( always ) ] pub fn uscibrmp ( & self ) -> USCIBRMP_R { USCIBRMP_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - RTC clock selection" ] # [ inline ( always ) ] pub fn rtccksel ( & self ) -> RTCCKSEL_R { RTCCKSEL_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - ADC input A0 pin select" ] # [ inline ( always ) ] pub fn adcpctl0 ( & mut self ) -> ADCPCTL0_W { ADCPCTL0_W { w : self } }
# [ doc = "Bit 1 - ADC input A1 pin select" ] # [ inline ( always ) ] pub fn adcpctl1 ( & mut self ) -> ADCPCTL1_W { ADCPCTL1_W { w : self } }
# [ doc = "Bit 2 - ADC input A2 pin select" ] # [ inline ( always ) ] pub fn adcpctl2 ( & mut self ) -> ADCPCTL2_W { ADCPCTL2_W { w : self } }
# [ doc = "Bit 3 - ADC input A3 pin select" ] # [ inline ( always ) ] pub fn adcpctl3 ( & mut self ) -> ADCPCTL3_W { ADCPCTL3_W { w : self } }
# [ doc = "Bit 4 - ADC input A4 pin select" ] # [ inline ( always ) ] pub fn adcpctl4 ( & mut self ) -> ADCPCTL4_W { ADCPCTL4_W { w : self } }
# [ doc = "Bit 5 - ADC input A5 pin select" ] # [ inline ( always ) ] pub fn adcpctl5 ( & mut self ) -> ADCPCTL5_W { ADCPCTL5_W { w : self } }
# [ doc = "Bit 6 - ADC input A6 pin select" ] # [ inline ( always ) ] pub fn adcpctl6 ( & mut self ) -> ADCPCTL6_W { ADCPCTL6_W { w : self } }
# [ doc = "Bit 7 - ADC input A7 pin select" ] # [ inline ( always ) ] pub fn adcpctl7 ( & mut self ) -> ADCPCTL7_W { ADCPCTL7_W { w : self } }
# [ doc = "Bit 8 - ADC input A8 pin select" ] # [ inline ( always ) ] pub fn adcpctl8 ( & mut self ) -> ADCPCTL8_W { ADCPCTL8_W { w : self } }
# [ doc = "Bit 9 - ADC input A9 pin select" ] # [ inline ( always ) ] pub fn adcpctl9 ( & mut self ) -> ADCPCTL9_W { ADCPCTL9_W { w : self } }
# [ doc = "Bit 11 - eUSCIB Remapping source selection , please refer to device specific for details" ] # [ inline ( always ) ] pub fn uscibrmp ( & mut self ) -> USCIBRMP_W { USCIBRMP_W { w : self } }
# [ doc = "Bit 10 - RTC clock selection" ] # [ inline ( always ) ] pub fn rtccksel ( & mut self ) -> RTCCKSEL_W { RTCCKSEL_W { w : self } }
}
}
# [ doc = "System Configuration Register 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syscfg3](syscfg3) module" ] pub type SYSCFG3 = crate :: Reg < u16 , _SYSCFG3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYSCFG3 ;
# [ doc = "`read()` method returns [syscfg3::R](syscfg3::R) reader structure" ] impl crate :: Readable for SYSCFG3 { }
# [ doc = "`write(|w| ..)` method takes [syscfg3::W](syscfg3::W) writer structure" ] impl crate :: Writable for SYSCFG3 { }
# [ doc = "System Configuration Register 3" ] pub mod syscfg3 {
# [ doc = "Reader of register SYSCFG3" ] pub type R = crate :: R < u16 , super :: SYSCFG3 > ;
# [ doc = "Writer for register SYSCFG3" ] pub type W = crate :: W < u16 , super :: SYSCFG3 > ;
# [ doc = "Register SYSCFG3 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SYSCFG3 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "eUSCIA remapping source selection, please refer to device specific for details\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum USCIARMP_A { # [ doc = "0: P1.x is selected, please refer to device specific for details" ] USCIARMP_0 = 0 , # [ doc = "1: other port is selected, please refer to device specific for details" ] USCIARMP_1 = 1 } impl From < USCIARMP_A > for bool { # [ inline ( always ) ] fn from ( variant : USCIARMP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `USCIARMP`" ] pub type USCIARMP_R = crate :: R < bool , USCIARMP_A > ; impl USCIARMP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> USCIARMP_A { match self . bits { false => USCIARMP_A :: USCIARMP_0 , true => USCIARMP_A :: USCIARMP_1 } } # [ doc = "Checks if the value of the field is `USCIARMP_0`" ] # [ inline ( always ) ] pub fn is_usciarmp_0 ( & self ) -> bool { * self == USCIARMP_A :: USCIARMP_0 } # [ doc = "Checks if the value of the field is `USCIARMP_1`" ] # [ inline ( always ) ] pub fn is_usciarmp_1 ( & self ) -> bool { * self == USCIARMP_A :: USCIARMP_1 } }
# [ doc = "Write proxy for field `USCIARMP`" ] pub struct USCIARMP_W < 'a > { w : & 'a mut W , } impl < 'a > USCIARMP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : USCIARMP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "P1.x is selected, please refer to device specific for details" ] # [ inline ( always ) ] pub fn usciarmp_0 ( self ) -> & 'a mut W { self . variant ( USCIARMP_A :: USCIARMP_0 ) } # [ doc = "other port is selected, please refer to device specific for details" ] # [ inline ( always ) ] pub fn usciarmp_1 ( self ) -> & 'a mut W { self . variant ( USCIARMP_A :: USCIARMP_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - eUSCIA remapping source selection, please refer to device specific for details" ] # [ inline ( always ) ] pub fn usciarmp ( & self ) -> USCIARMP_R { USCIARMP_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - eUSCIA remapping source selection, please refer to device specific for details" ] # [ inline ( always ) ] pub fn usciarmp ( & mut self ) -> USCIARMP_W { USCIARMP_W { w : self } }
}
}
}
# [ doc = "CS" ] pub struct CS { _marker : PhantomData < * const ( ) > } unsafe impl Send for CS { } impl CS { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const cs :: RegisterBlock { 0x0180 as * const _ } } impl Deref for CS { type Target = cs :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * CS :: ptr ( ) } } }
# [ doc = "CS" ] pub mod cs {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Clock System Control 0" ] pub csctl0 : CSCTL0 , # [ doc = "0x02 - Clock System Control 1" ] pub csctl1 : CSCTL1 , # [ doc = "0x04 - Clock System Control 2" ] pub csctl2 : CSCTL2 , # [ doc = "0x06 - Clock System Control 3" ] pub csctl3 : CSCTL3 , # [ doc = "0x08 - Clock System Control 4" ] pub csctl4 : CSCTL4 , # [ doc = "0x0a - Clock System Control 5" ] pub csctl5 : CSCTL5 , # [ doc = "0x0c - Clock System Control 6" ] pub csctl6 : CSCTL6 , # [ doc = "0x0e - Clock System Control Register 7" ] pub csctl7 : CSCTL7 , # [ doc = "0x10 - Clock System Control Register 8" ] pub csctl8 : CSCTL8 , }
# [ doc = "Clock System Control 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csctl0](csctl0) module" ] pub type CSCTL0 = crate :: Reg < u16 , _CSCTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CSCTL0 ;
# [ doc = "`read()` method returns [csctl0::R](csctl0::R) reader structure" ] impl crate :: Readable for CSCTL0 { }
# [ doc = "`write(|w| ..)` method takes [csctl0::W](csctl0::W) writer structure" ] impl crate :: Writable for CSCTL0 { }
# [ doc = "Clock System Control 0" ] pub mod csctl0 {
# [ doc = "Reader of register CSCTL0" ] pub type R = crate :: R < u16 , super :: CSCTL0 > ;
# [ doc = "Writer for register CSCTL0" ] pub type W = crate :: W < u16 , super :: CSCTL0 > ;
# [ doc = "Register CSCTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CSCTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DCO`" ] pub type DCO_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `DCO`" ] pub struct DCO_W < 'a > { w : & 'a mut W , } impl < 'a > DCO_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01ff ) | ( ( value as u16 ) & 0x01ff ) ; self . w } }
# [ doc = "Reader of field `MOD`" ] pub type MOD_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `MOD`" ] pub struct MOD_W < 'a > { w : & 'a mut W , } impl < 'a > MOD_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x1f << 9 ) ) | ( ( ( value as u16 ) & 0x1f ) << 9 ) ; self . w } }
impl R {
# [ doc = "Bits 0:8 - DCO tap selection. These bits select the DCO tap and are modified automatically during FLL operation." ] # [ inline ( always ) ] pub fn dco ( & self ) -> DCO_R { DCO_R :: new ( ( self . bits & 0x01ff ) as u16 ) }
# [ doc = "Bits 9:13 - Modulation bit counter. These bits select the modulation pattern. All MOD bits are modified automatically during FLL operation. The DCO register value is incremented when the modulation bit counter rolls over from 31 to 0. If the modulation bit counter decrements from 0 to the maximum count, the DCO register value is also decreased." ] # [ inline ( always ) ] pub fn mod_ ( & self ) -> MOD_R { MOD_R :: new ( ( ( self . bits >> 9 ) & 0x1f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:8 - DCO tap selection. These bits select the DCO tap and are modified automatically during FLL operation." ] # [ inline ( always ) ] pub fn dco ( & mut self ) -> DCO_W { DCO_W { w : self } }
# [ doc = "Bits 9:13 - Modulation bit counter. These bits select the modulation pattern. All MOD bits are modified automatically during FLL operation. The DCO register value is incremented when the modulation bit counter rolls over from 31 to 0. If the modulation bit counter decrements from 0 to the maximum count, the DCO register value is also decreased." ] # [ inline ( always ) ] pub fn mod_ ( & mut self ) -> MOD_W { MOD_W { w : self } }
}
}
# [ doc = "Clock System Control 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csctl1](csctl1) module" ] pub type CSCTL1 = crate :: Reg < u16 , _CSCTL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CSCTL1 ;
# [ doc = "`read()` method returns [csctl1::R](csctl1::R) reader structure" ] impl crate :: Readable for CSCTL1 { }
# [ doc = "`write(|w| ..)` method takes [csctl1::W](csctl1::W) writer structure" ] impl crate :: Writable for CSCTL1 { }
# [ doc = "Clock System Control 1" ] pub mod csctl1 {
# [ doc = "Reader of register CSCTL1" ] pub type R = crate :: R < u16 , super :: CSCTL1 > ;
# [ doc = "Writer for register CSCTL1" ] pub type W = crate :: W < u16 , super :: CSCTL1 > ;
# [ doc = "Register CSCTL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CSCTL1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Modulation. This bit enables/disables the modulation.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DISMOD_A { # [ doc = "0: Modulation enabled" ] DISMOD_0 = 0 , # [ doc = "1: Modulation disabled" ] DISMOD_1 = 1 } impl From < DISMOD_A > for bool { # [ inline ( always ) ] fn from ( variant : DISMOD_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DISMOD`" ] pub type DISMOD_R = crate :: R < bool , DISMOD_A > ; impl DISMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DISMOD_A { match self . bits { false => DISMOD_A :: DISMOD_0 , true => DISMOD_A :: DISMOD_1 } } # [ doc = "Checks if the value of the field is `DISMOD_0`" ] # [ inline ( always ) ] pub fn is_dismod_0 ( & self ) -> bool { * self == DISMOD_A :: DISMOD_0 } # [ doc = "Checks if the value of the field is `DISMOD_1`" ] # [ inline ( always ) ] pub fn is_dismod_1 ( & self ) -> bool { * self == DISMOD_A :: DISMOD_1 } }
# [ doc = "Write proxy for field `DISMOD`" ] pub struct DISMOD_W < 'a > { w : & 'a mut W , } impl < 'a > DISMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DISMOD_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Modulation enabled" ] # [ inline ( always ) ] pub fn dismod_0 ( self ) -> & 'a mut W { self . variant ( DISMOD_A :: DISMOD_0 ) } # [ doc = "Modulation disabled" ] # [ inline ( always ) ] pub fn dismod_1 ( self ) -> & 'a mut W { self . variant ( DISMOD_A :: DISMOD_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "DCO Range Select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum DCORSEL_A { # [ doc = "0: 1 MHz" ] DCORSEL_0 = 0 , # [ doc = "1: 2 MHz" ] DCORSEL_1 = 1 , # [ doc = "2: 4 MHz" ] DCORSEL_2 = 2 , # [ doc = "3: 8 MHz" ] DCORSEL_3 = 3 , # [ doc = "4: 12 MHz" ] DCORSEL_4 = 4 , # [ doc = "5: 16 MHz" ] DCORSEL_5 = 5 , # [ doc = "6: 20 MHz(Only avaliable in 24MHz clock system)" ] DCORSEL_6 = 6 , # [ doc = "7: 24 MHz(Only avaliable in 24MHz clock system)" ] DCORSEL_7 = 7 } impl From < DCORSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : DCORSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `DCORSEL`" ] pub type DCORSEL_R = crate :: R < u8 , DCORSEL_A > ; impl DCORSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DCORSEL_A { match self . bits { 0 => DCORSEL_A :: DCORSEL_0 , 1 => DCORSEL_A :: DCORSEL_1 , 2 => DCORSEL_A :: DCORSEL_2 , 3 => DCORSEL_A :: DCORSEL_3 , 4 => DCORSEL_A :: DCORSEL_4 , 5 => DCORSEL_A :: DCORSEL_5 , 6 => DCORSEL_A :: DCORSEL_6 , 7 => DCORSEL_A :: DCORSEL_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DCORSEL_0`" ] # [ inline ( always ) ] pub fn is_dcorsel_0 ( & self ) -> bool { * self == DCORSEL_A :: DCORSEL_0 } # [ doc = "Checks if the value of the field is `DCORSEL_1`" ] # [ inline ( always ) ] pub fn is_dcorsel_1 ( & self ) -> bool { * self == DCORSEL_A :: DCORSEL_1 } # [ doc = "Checks if the value of the field is `DCORSEL_2`" ] # [ inline ( always ) ] pub fn is_dcorsel_2 ( & self ) -> bool { * self == DCORSEL_A :: DCORSEL_2 } # [ doc = "Checks if the value of the field is `DCORSEL_3`" ] # [ inline ( always ) ] pub fn is_dcorsel_3 ( & self ) -> bool { * self == DCORSEL_A :: DCORSEL_3 } # [ doc = "Checks if the value of the field is `DCORSEL_4`" ] # [ inline ( always ) ] pub fn is_dcorsel_4 ( & self ) -> bool { * self == DCORSEL_A :: DCORSEL_4 } # [ doc = "Checks if the value of the field is `DCORSEL_5`" ] # [ inline ( always ) ] pub fn is_dcorsel_5 ( & self ) -> bool { * self == DCORSEL_A :: DCORSEL_5 } # [ doc = "Checks if the value of the field is `DCORSEL_6`" ] # [ inline ( always ) ] pub fn is_dcorsel_6 ( & self ) -> bool { * self == DCORSEL_A :: DCORSEL_6 } # [ doc = "Checks if the value of the field is `DCORSEL_7`" ] # [ inline ( always ) ] pub fn is_dcorsel_7 ( & self ) -> bool { * self == DCORSEL_A :: DCORSEL_7 } }
# [ doc = "Write proxy for field `DCORSEL`" ] pub struct DCORSEL_W < 'a > { w : & 'a mut W , } impl < 'a > DCORSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DCORSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "1 MHz" ] # [ inline ( always ) ] pub fn dcorsel_0 ( self ) -> & 'a mut W { self . variant ( DCORSEL_A :: DCORSEL_0 ) } # [ doc = "2 MHz" ] # [ inline ( always ) ] pub fn dcorsel_1 ( self ) -> & 'a mut W { self . variant ( DCORSEL_A :: DCORSEL_1 ) } # [ doc = "4 MHz" ] # [ inline ( always ) ] pub fn dcorsel_2 ( self ) -> & 'a mut W { self . variant ( DCORSEL_A :: DCORSEL_2 ) } # [ doc = "8 MHz" ] # [ inline ( always ) ] pub fn dcorsel_3 ( self ) -> & 'a mut W { self . variant ( DCORSEL_A :: DCORSEL_3 ) } # [ doc = "12 MHz" ] # [ inline ( always ) ] pub fn dcorsel_4 ( self ) -> & 'a mut W { self . variant ( DCORSEL_A :: DCORSEL_4 ) } # [ doc = "16 MHz" ] # [ inline ( always ) ] pub fn dcorsel_5 ( self ) -> & 'a mut W { self . variant ( DCORSEL_A :: DCORSEL_5 ) } # [ doc = "20 MHz(Only avaliable in 24MHz clock system)" ] # [ inline ( always ) ] pub fn dcorsel_6 ( self ) -> & 'a mut W { self . variant ( DCORSEL_A :: DCORSEL_6 ) } # [ doc = "24 MHz(Only avaliable in 24MHz clock system)" ] # [ inline ( always ) ] pub fn dcorsel_7 ( self ) -> & 'a mut W { self . variant ( DCORSEL_A :: DCORSEL_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 1 ) ) | ( ( ( value as u16 ) & 0x07 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `DCOFTRIM`" ] pub type DCOFTRIM_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `DCOFTRIM`" ] pub struct DCOFTRIM_W < 'a > { w : & 'a mut W , } impl < 'a > DCOFTRIM_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 4 ) ) | ( ( ( value as u16 ) & 0x07 ) << 4 ) ; self . w } }
# [ doc = "DCO Frequency Trim Enable. When this bit is set, DCOFTRIM value is selected to set DCO frequency. Otherwise, DCOFTRIM value is bypassed and DCO applies default settings in manufacture.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DCOFTRIMEN_A { # [ doc = "0: Disable frequency trim" ] DCOFTRIMEN_0 = 0 , # [ doc = "1: Enable frequency trim" ] DCOFTRIMEN_1 = 1 } impl From < DCOFTRIMEN_A > for bool { # [ inline ( always ) ] fn from ( variant : DCOFTRIMEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DCOFTRIMEN`" ] pub type DCOFTRIMEN_R = crate :: R < bool , DCOFTRIMEN_A > ; impl DCOFTRIMEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DCOFTRIMEN_A { match self . bits { false => DCOFTRIMEN_A :: DCOFTRIMEN_0 , true => DCOFTRIMEN_A :: DCOFTRIMEN_1 } } # [ doc = "Checks if the value of the field is `DCOFTRIMEN_0`" ] # [ inline ( always ) ] pub fn is_dcoftrimen_0 ( & self ) -> bool { * self == DCOFTRIMEN_A :: DCOFTRIMEN_0 } # [ doc = "Checks if the value of the field is `DCOFTRIMEN_1`" ] # [ inline ( always ) ] pub fn is_dcoftrimen_1 ( & self ) -> bool { * self == DCOFTRIMEN_A :: DCOFTRIMEN_1 } }
# [ doc = "Write proxy for field `DCOFTRIMEN`" ] pub struct DCOFTRIMEN_W < 'a > { w : & 'a mut W , } impl < 'a > DCOFTRIMEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DCOFTRIMEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disable frequency trim" ] # [ inline ( always ) ] pub fn dcoftrimen_0 ( self ) -> & 'a mut W { self . variant ( DCOFTRIMEN_A :: DCOFTRIMEN_0 ) } # [ doc = "Enable frequency trim" ] # [ inline ( always ) ] pub fn dcoftrimen_1 ( self ) -> & 'a mut W { self . variant ( DCOFTRIMEN_A :: DCOFTRIMEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Modulation. This bit enables/disables the modulation." ] # [ inline ( always ) ] pub fn dismod ( & self ) -> DISMOD_R { DISMOD_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bits 1:3 - DCO Range Select" ] # [ inline ( always ) ] pub fn dcorsel ( & self ) -> DCORSEL_R { DCORSEL_R :: new ( ( ( self . bits >> 1 ) & 0x07 ) as u8 ) }
# [ doc = "Bits 4:6 - DCO frequency trim. These bits trims the DCO frequency. By default, it is chipspecific trimmed. These bits can also be trimmed by user code." ] # [ inline ( always ) ] pub fn dcoftrim ( & self ) -> DCOFTRIM_R { DCOFTRIM_R :: new ( ( ( self . bits >> 4 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 7 - DCO Frequency Trim Enable. When this bit is set, DCOFTRIM value is selected to set DCO frequency. Otherwise, DCOFTRIM value is bypassed and DCO applies default settings in manufacture." ] # [ inline ( always ) ] pub fn dcoftrimen ( & self ) -> DCOFTRIMEN_R { DCOFTRIMEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Modulation. This bit enables/disables the modulation." ] # [ inline ( always ) ] pub fn dismod ( & mut self ) -> DISMOD_W { DISMOD_W { w : self } }
# [ doc = "Bits 1:3 - DCO Range Select" ] # [ inline ( always ) ] pub fn dcorsel ( & mut self ) -> DCORSEL_W { DCORSEL_W { w : self } }
# [ doc = "Bits 4:6 - DCO frequency trim. These bits trims the DCO frequency. By default, it is chipspecific trimmed. These bits can also be trimmed by user code." ] # [ inline ( always ) ] pub fn dcoftrim ( & mut self ) -> DCOFTRIM_W { DCOFTRIM_W { w : self } }
# [ doc = "Bit 7 - DCO Frequency Trim Enable. When this bit is set, DCOFTRIM value is selected to set DCO frequency. Otherwise, DCOFTRIM value is bypassed and DCO applies default settings in manufacture." ] # [ inline ( always ) ] pub fn dcoftrimen ( & mut self ) -> DCOFTRIMEN_W { DCOFTRIMEN_W { w : self } }
}
}
# [ doc = "Clock System Control 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csctl2](csctl2) module" ] pub type CSCTL2 = crate :: Reg < u16 , _CSCTL2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CSCTL2 ;
# [ doc = "`read()` method returns [csctl2::R](csctl2::R) reader structure" ] impl crate :: Readable for CSCTL2 { }
# [ doc = "`write(|w| ..)` method takes [csctl2::W](csctl2::W) writer structure" ] impl crate :: Writable for CSCTL2 { }
# [ doc = "Clock System Control 2" ] pub mod csctl2 {
# [ doc = "Reader of register CSCTL2" ] pub type R = crate :: R < u16 , super :: CSCTL2 > ;
# [ doc = "Writer for register CSCTL2" ] pub type W = crate :: W < u16 , super :: CSCTL2 > ;
# [ doc = "Register CSCTL2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CSCTL2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `FLLN`" ] pub type FLLN_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `FLLN`" ] pub struct FLLN_W < 'a > { w : & 'a mut W , } impl < 'a > FLLN_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
# [ doc = "FLL loop divider. These bits divide f(DCOCLK) in the FLL feedback loop. This results in an additional multiplier for the multiplier bits. See also multiplier bits.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum FLLD_A { # [ doc = "0: fDCOCLK / 1" ] _1 = 0 , # [ doc = "1: fDCOCLK / 2" ] _2 = 1 , # [ doc = "2: fDCOCLK / 4" ] _4 = 2 , # [ doc = "3: fDCOCLK / 8" ] _8 = 3 , # [ doc = "4: fDCOCLK / 16" ] _16 = 4 , # [ doc = "5: fDCOCLK / 32" ] _32 = 5 , # [ doc = "6: fDCOCLK / 40(Only avaliable in 24MHz clock system)" ] FLLD_6 = 6 , # [ doc = "7: fDCOCLK / 48(Only avaliable in 24MHz clock system)" ] FLLD_7 = 7 } impl From < FLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : FLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `FLLD`" ] pub type FLLD_R = crate :: R < u8 , FLLD_A > ; impl FLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> FLLD_A { match self . bits { 0 => FLLD_A :: _1 , 1 => FLLD_A :: _2 , 2 => FLLD_A :: _4 , 3 => FLLD_A :: _8 , 4 => FLLD_A :: _16 , 5 => FLLD_A :: _32 , 6 => FLLD_A :: FLLD_6 , 7 => FLLD_A :: FLLD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == FLLD_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == FLLD_A :: _2 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == FLLD_A :: _4 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == FLLD_A :: _8 } # [ doc = "Checks if the value of the field is `_16`" ] # [ inline ( always ) ] pub fn is_16 ( & self ) -> bool { * self == FLLD_A :: _16 } # [ doc = "Checks if the value of the field is `_32`" ] # [ inline ( always ) ] pub fn is_32 ( & self ) -> bool { * self == FLLD_A :: _32 } # [ doc = "Checks if the value of the field is `FLLD_6`" ] # [ inline ( always ) ] pub fn is_flld_6 ( & self ) -> bool { * self == FLLD_A :: FLLD_6 } # [ doc = "Checks if the value of the field is `FLLD_7`" ] # [ inline ( always ) ] pub fn is_flld_7 ( & self ) -> bool { * self == FLLD_A :: FLLD_7 } }
# [ doc = "Write proxy for field `FLLD`" ] pub struct FLLD_W < 'a > { w : & 'a mut W , } impl < 'a > FLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : FLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "fDCOCLK / 1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( FLLD_A :: _1 ) } # [ doc = "fDCOCLK / 2" ] # [ inline ( always ) ] pub fn _2 ( self ) -> & 'a mut W { self . variant ( FLLD_A :: _2 ) } # [ doc = "fDCOCLK / 4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( FLLD_A :: _4 ) } # [ doc = "fDCOCLK / 8" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( FLLD_A :: _8 ) } # [ doc = "fDCOCLK / 16" ] # [ inline ( always ) ] pub fn _16 ( self ) -> & 'a mut W { self . variant ( FLLD_A :: _16 ) } # [ doc = "fDCOCLK / 32" ] # [ inline ( always ) ] pub fn _32 ( self ) -> & 'a mut W { self . variant ( FLLD_A :: _32 ) } # [ doc = "fDCOCLK / 40(Only avaliable in 24MHz clock system)" ] # [ inline ( always ) ] pub fn flld_6 ( self ) -> & 'a mut W { self . variant ( FLLD_A :: FLLD_6 ) } # [ doc = "fDCOCLK / 48(Only avaliable in 24MHz clock system)" ] # [ inline ( always ) ] pub fn flld_7 ( self ) -> & 'a mut W { self . variant ( FLLD_A :: FLLD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 12 ) ) | ( ( ( value as u16 ) & 0x07 ) << 12 ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - Multiplier bits. These bits set the multiplier value N of the DCO. N must be greater than 0. Writing zero to FLLN causes N to be set to 1." ] # [ inline ( always ) ] pub fn flln ( & self ) -> FLLN_R { FLLN_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
# [ doc = "Bits 12:14 - FLL loop divider. These bits divide f(DCOCLK) in the FLL feedback loop. This results in an additional multiplier for the multiplier bits. See also multiplier bits." ] # [ inline ( always ) ] pub fn flld ( & self ) -> FLLD_R { FLLD_R :: new ( ( ( self . bits >> 12 ) & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:9 - Multiplier bits. These bits set the multiplier value N of the DCO. N must be greater than 0. Writing zero to FLLN causes N to be set to 1." ] # [ inline ( always ) ] pub fn flln ( & mut self ) -> FLLN_W { FLLN_W { w : self } }
# [ doc = "Bits 12:14 - FLL loop divider. These bits divide f(DCOCLK) in the FLL feedback loop. This results in an additional multiplier for the multiplier bits. See also multiplier bits." ] # [ inline ( always ) ] pub fn flld ( & mut self ) -> FLLD_W { FLLD_W { w : self } }
}
}
# [ doc = "Clock System Control 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csctl3](csctl3) module" ] pub type CSCTL3 = crate :: Reg < u16 , _CSCTL3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CSCTL3 ;
# [ doc = "`read()` method returns [csctl3::R](csctl3::R) reader structure" ] impl crate :: Readable for CSCTL3 { }
# [ doc = "`write(|w| ..)` method takes [csctl3::W](csctl3::W) writer structure" ] impl crate :: Writable for CSCTL3 { }
# [ doc = "Clock System Control 3" ] pub mod csctl3 {
# [ doc = "Reader of register CSCTL3" ] pub type R = crate :: R < u16 , super :: CSCTL3 > ;
# [ doc = "Writer for register CSCTL3" ] pub type W = crate :: W < u16 , super :: CSCTL3 > ;
# [ doc = "Register CSCTL3 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CSCTL3 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "FLL reference divider. These bits define the divide factor for f(FLLREFCLK). If XT1 supports high frequency input higher than 32 kHz, the divided frequency is used as the FLL reference frequency. If XT1 only supports 32-kHz clock, FLLREFDIV is always read and written as zero, 000b = fFLLREFCLK / 1\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum FLLREFDIV_A { # [ doc = "0: fFLLREFCLK / 1" ] _1 = 0 , # [ doc = "1: fFLLREFCLK / 32" ] _32 = 1 , # [ doc = "2: fFLLREFCLK / 64" ] _64 = 2 , # [ doc = "3: fFLLREFCLK / 128" ] _128 = 3 , # [ doc = "4: fFLLREFCLK / 256" ] _256 = 4 , # [ doc = "5: fFLLREFCLK / 512" ] _512 = 5 , # [ doc = "6: fFLLREFCLK / 640 (only available in 24MHz clock system)" ] FLLREFDIV_6 = 6 , # [ doc = "7: fFLLREFCLK / 768(only available in 24MHz clock system)" ] FLLREFDIV_7 = 7 } impl From < FLLREFDIV_A > for u8 { # [ inline ( always ) ] fn from ( variant : FLLREFDIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `FLLREFDIV`" ] pub type FLLREFDIV_R = crate :: R < u8 , FLLREFDIV_A > ; impl FLLREFDIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> FLLREFDIV_A { match self . bits { 0 => FLLREFDIV_A :: _1 , 1 => FLLREFDIV_A :: _32 , 2 => FLLREFDIV_A :: _64 , 3 => FLLREFDIV_A :: _128 , 4 => FLLREFDIV_A :: _256 , 5 => FLLREFDIV_A :: _512 , 6 => FLLREFDIV_A :: FLLREFDIV_6 , 7 => FLLREFDIV_A :: FLLREFDIV_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == FLLREFDIV_A :: _1 } # [ doc = "Checks if the value of the field is `_32`" ] # [ inline ( always ) ] pub fn is_32 ( & self ) -> bool { * self == FLLREFDIV_A :: _32 } # [ doc = "Checks if the value of the field is `_64`" ] # [ inline ( always ) ] pub fn is_64 ( & self ) -> bool { * self == FLLREFDIV_A :: _64 } # [ doc = "Checks if the value of the field is `_128`" ] # [ inline ( always ) ] pub fn is_128 ( & self ) -> bool { * self == FLLREFDIV_A :: _128 } # [ doc = "Checks if the value of the field is `_256`" ] # [ inline ( always ) ] pub fn is_256 ( & self ) -> bool { * self == FLLREFDIV_A :: _256 } # [ doc = "Checks if the value of the field is `_512`" ] # [ inline ( always ) ] pub fn is_512 ( & self ) -> bool { * self == FLLREFDIV_A :: _512 } # [ doc = "Checks if the value of the field is `FLLREFDIV_6`" ] # [ inline ( always ) ] pub fn is_fllrefdiv_6 ( & self ) -> bool { * self == FLLREFDIV_A :: FLLREFDIV_6 } # [ doc = "Checks if the value of the field is `FLLREFDIV_7`" ] # [ inline ( always ) ] pub fn is_fllrefdiv_7 ( & self ) -> bool { * self == FLLREFDIV_A :: FLLREFDIV_7 } }
# [ doc = "Write proxy for field `FLLREFDIV`" ] pub struct FLLREFDIV_W < 'a > { w : & 'a mut W , } impl < 'a > FLLREFDIV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : FLLREFDIV_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "fFLLREFCLK / 1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( FLLREFDIV_A :: _1 ) } # [ doc = "fFLLREFCLK / 32" ] # [ inline ( always ) ] pub fn _32 ( self ) -> & 'a mut W { self . variant ( FLLREFDIV_A :: _32 ) } # [ doc = "fFLLREFCLK / 64" ] # [ inline ( always ) ] pub fn _64 ( self ) -> & 'a mut W { self . variant ( FLLREFDIV_A :: _64 ) } # [ doc = "fFLLREFCLK / 128" ] # [ inline ( always ) ] pub fn _128 ( self ) -> & 'a mut W { self . variant ( FLLREFDIV_A :: _128 ) } # [ doc = "fFLLREFCLK / 256" ] # [ inline ( always ) ] pub fn _256 ( self ) -> & 'a mut W { self . variant ( FLLREFDIV_A :: _256 ) } # [ doc = "fFLLREFCLK / 512" ] # [ inline ( always ) ] pub fn _512 ( self ) -> & 'a mut W { self . variant ( FLLREFDIV_A :: _512 ) } # [ doc = "fFLLREFCLK / 640 (only available in 24MHz clock system)" ] # [ inline ( always ) ] pub fn fllrefdiv_6 ( self ) -> & 'a mut W { self . variant ( FLLREFDIV_A :: FLLREFDIV_6 ) } # [ doc = "fFLLREFCLK / 768(only available in 24MHz clock system)" ] # [ inline ( always ) ] pub fn fllrefdiv_7 ( self ) -> & 'a mut W { self . variant ( FLLREFDIV_A :: FLLREFDIV_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u16 ) & 0x07 ) ; self . w } }
# [ doc = "FLL reference select. These bits select the FLL reference clock source.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum SELREF_A { # [ doc = "0: XT1CLK" ] XT1CLK = 0 , # [ doc = "1: REFOCLK" ] REFOCLK = 1 , # [ doc = "2: served for future use" ] SELREF_2 = 2 , # [ doc = "3: served for future use" ] SELREF_3 = 3 } impl From < SELREF_A > for u8 { # [ inline ( always ) ] fn from ( variant : SELREF_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `SELREF`" ] pub type SELREF_R = crate :: R < u8 , SELREF_A > ; impl SELREF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SELREF_A { match self . bits { 0 => SELREF_A :: XT1CLK , 1 => SELREF_A :: REFOCLK , 2 => SELREF_A :: SELREF_2 , 3 => SELREF_A :: SELREF_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `XT1CLK`" ] # [ inline ( always ) ] pub fn is_xt1clk ( & self ) -> bool { * self == SELREF_A :: XT1CLK } # [ doc = "Checks if the value of the field is `REFOCLK`" ] # [ inline ( always ) ] pub fn is_refoclk ( & self ) -> bool { * self == SELREF_A :: REFOCLK } # [ doc = "Checks if the value of the field is `SELREF_2`" ] # [ inline ( always ) ] pub fn is_selref_2 ( & self ) -> bool { * self == SELREF_A :: SELREF_2 } # [ doc = "Checks if the value of the field is `SELREF_3`" ] # [ inline ( always ) ] pub fn is_selref_3 ( & self ) -> bool { * self == SELREF_A :: SELREF_3 } }
# [ doc = "Write proxy for field `SELREF`" ] pub struct SELREF_W < 'a > { w : & 'a mut W , } impl < 'a > SELREF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SELREF_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "XT1CLK" ] # [ inline ( always ) ] pub fn xt1clk ( self ) -> & 'a mut W { self . variant ( SELREF_A :: XT1CLK ) } # [ doc = "REFOCLK" ] # [ inline ( always ) ] pub fn refoclk ( self ) -> & 'a mut W { self . variant ( SELREF_A :: REFOCLK ) } # [ doc = "served for future use" ] # [ inline ( always ) ] pub fn selref_2 ( self ) -> & 'a mut W { self . variant ( SELREF_A :: SELREF_2 ) } # [ doc = "served for future use" ] # [ inline ( always ) ] pub fn selref_3 ( self ) -> & 'a mut W { self . variant ( SELREF_A :: SELREF_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "REFO Low Power Enable. This bit turns on REFO low-power mode. During switch, the low-power mode will be invalid until REFOREADY is set.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum REFOLP_A { # [ doc = "0: REFO Low Power Disabled (High Power Mode)" ] REFOLP_0 = 0 , # [ doc = "1: REFO Low Power Enabled" ] REFOLP_1 = 1 } impl From < REFOLP_A > for bool { # [ inline ( always ) ] fn from ( variant : REFOLP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `REFOLP`" ] pub type REFOLP_R = crate :: R < bool , REFOLP_A > ; impl REFOLP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> REFOLP_A { match self . bits { false => REFOLP_A :: REFOLP_0 , true => REFOLP_A :: REFOLP_1 } } # [ doc = "Checks if the value of the field is `REFOLP_0`" ] # [ inline ( always ) ] pub fn is_refolp_0 ( & self ) -> bool { * self == REFOLP_A :: REFOLP_0 } # [ doc = "Checks if the value of the field is `REFOLP_1`" ] # [ inline ( always ) ] pub fn is_refolp_1 ( & self ) -> bool { * self == REFOLP_A :: REFOLP_1 } }
# [ doc = "Write proxy for field `REFOLP`" ] pub struct REFOLP_W < 'a > { w : & 'a mut W , } impl < 'a > REFOLP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : REFOLP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "REFO Low Power Disabled (High Power Mode)" ] # [ inline ( always ) ] pub fn refolp_0 ( self ) -> & 'a mut W { self . variant ( REFOLP_A :: REFOLP_0 ) } # [ doc = "REFO Low Power Enabled" ] # [ inline ( always ) ] pub fn refolp_1 ( self ) -> & 'a mut W { self . variant ( REFOLP_A :: REFOLP_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - FLL reference divider. These bits define the divide factor for f(FLLREFCLK). If XT1 supports high frequency input higher than 32 kHz, the divided frequency is used as the FLL reference frequency. If XT1 only supports 32-kHz clock, FLLREFDIV is always read and written as zero, 000b = fFLLREFCLK / 1" ] # [ inline ( always ) ] pub fn fllrefdiv ( & self ) -> FLLREFDIV_R { FLLREFDIV_R :: new ( ( self . bits & 0x07 ) as u8 ) }
# [ doc = "Bits 4:5 - FLL reference select. These bits select the FLL reference clock source." ] # [ inline ( always ) ] pub fn selref ( & self ) -> SELREF_R { SELREF_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 7 - REFO Low Power Enable. This bit turns on REFO low-power mode. During switch, the low-power mode will be invalid until REFOREADY is set." ] # [ inline ( always ) ] pub fn refolp ( & self ) -> REFOLP_R { REFOLP_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:2 - FLL reference divider. These bits define the divide factor for f(FLLREFCLK). If XT1 supports high frequency input higher than 32 kHz, the divided frequency is used as the FLL reference frequency. If XT1 only supports 32-kHz clock, FLLREFDIV is always read and written as zero, 000b = fFLLREFCLK / 1" ] # [ inline ( always ) ] pub fn fllrefdiv ( & mut self ) -> FLLREFDIV_W { FLLREFDIV_W { w : self } }
# [ doc = "Bits 4:5 - FLL reference select. These bits select the FLL reference clock source." ] # [ inline ( always ) ] pub fn selref ( & mut self ) -> SELREF_W { SELREF_W { w : self } }
# [ doc = "Bit 7 - REFO Low Power Enable. This bit turns on REFO low-power mode. During switch, the low-power mode will be invalid until REFOREADY is set." ] # [ inline ( always ) ] pub fn refolp ( & mut self ) -> REFOLP_W { REFOLP_W { w : self } }
}
}
# [ doc = "Clock System Control 4\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csctl4](csctl4) module" ] pub type CSCTL4 = crate :: Reg < u16 , _CSCTL4 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CSCTL4 ;
# [ doc = "`read()` method returns [csctl4::R](csctl4::R) reader structure" ] impl crate :: Readable for CSCTL4 { }
# [ doc = "`write(|w| ..)` method takes [csctl4::W](csctl4::W) writer structure" ] impl crate :: Writable for CSCTL4 { }
# [ doc = "Clock System Control 4" ] pub mod csctl4 {
# [ doc = "Reader of register CSCTL4" ] pub type R = crate :: R < u16 , super :: CSCTL4 > ;
# [ doc = "Writer for register CSCTL4" ] pub type W = crate :: W < u16 , super :: CSCTL4 > ;
# [ doc = "Register CSCTL4 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CSCTL4 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Selects the MCLK and SMCLK source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum SELMS_A { # [ doc = "0: DCOCLKDIV" ] DCOCLKDIV = 0 , # [ doc = "1: REFOCLK" ] REFOCLK = 1 , # [ doc = "2: XT1CLK" ] XT1CLK = 2 , # [ doc = "3: VLOCLK" ] VLOCLK = 3 , # [ doc = "4: Reserved for future use" ] SELMS_4 = 4 , # [ doc = "5: Reserved for future use" ] SELMS_5 = 5 , # [ doc = "6: Reserved for future use" ] SELMS_6 = 6 , # [ doc = "7: Reserved for future use" ] SELMS_7 = 7 } impl From < SELMS_A > for u8 { # [ inline ( always ) ] fn from ( variant : SELMS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `SELMS`" ] pub type SELMS_R = crate :: R < u8 , SELMS_A > ; impl SELMS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SELMS_A { match self . bits { 0 => SELMS_A :: DCOCLKDIV , 1 => SELMS_A :: REFOCLK , 2 => SELMS_A :: XT1CLK , 3 => SELMS_A :: VLOCLK , 4 => SELMS_A :: SELMS_4 , 5 => SELMS_A :: SELMS_5 , 6 => SELMS_A :: SELMS_6 , 7 => SELMS_A :: SELMS_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DCOCLKDIV`" ] # [ inline ( always ) ] pub fn is_dcoclkdiv ( & self ) -> bool { * self == SELMS_A :: DCOCLKDIV } # [ doc = "Checks if the value of the field is `REFOCLK`" ] # [ inline ( always ) ] pub fn is_refoclk ( & self ) -> bool { * self == SELMS_A :: REFOCLK } # [ doc = "Checks if the value of the field is `XT1CLK`" ] # [ inline ( always ) ] pub fn is_xt1clk ( & self ) -> bool { * self == SELMS_A :: XT1CLK } # [ doc = "Checks if the value of the field is `VLOCLK`" ] # [ inline ( always ) ] pub fn is_vloclk ( & self ) -> bool { * self == SELMS_A :: VLOCLK } # [ doc = "Checks if the value of the field is `SELMS_4`" ] # [ inline ( always ) ] pub fn is_selms_4 ( & self ) -> bool { * self == SELMS_A :: SELMS_4 } # [ doc = "Checks if the value of the field is `SELMS_5`" ] # [ inline ( always ) ] pub fn is_selms_5 ( & self ) -> bool { * self == SELMS_A :: SELMS_5 } # [ doc = "Checks if the value of the field is `SELMS_6`" ] # [ inline ( always ) ] pub fn is_selms_6 ( & self ) -> bool { * self == SELMS_A :: SELMS_6 } # [ doc = "Checks if the value of the field is `SELMS_7`" ] # [ inline ( always ) ] pub fn is_selms_7 ( & self ) -> bool { * self == SELMS_A :: SELMS_7 } }
# [ doc = "Write proxy for field `SELMS`" ] pub struct SELMS_W < 'a > { w : & 'a mut W , } impl < 'a > SELMS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SELMS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "DCOCLKDIV" ] # [ inline ( always ) ] pub fn dcoclkdiv ( self ) -> & 'a mut W { self . variant ( SELMS_A :: DCOCLKDIV ) } # [ doc = "REFOCLK" ] # [ inline ( always ) ] pub fn refoclk ( self ) -> & 'a mut W { self . variant ( SELMS_A :: REFOCLK ) } # [ doc = "XT1CLK" ] # [ inline ( always ) ] pub fn xt1clk ( self ) -> & 'a mut W { self . variant ( SELMS_A :: XT1CLK ) } # [ doc = "VLOCLK" ] # [ inline ( always ) ] pub fn vloclk ( self ) -> & 'a mut W { self . variant ( SELMS_A :: VLOCLK ) } # [ doc = "Reserved for future use" ] # [ inline ( always ) ] pub fn selms_4 ( self ) -> & 'a mut W { self . variant ( SELMS_A :: SELMS_4 ) } # [ doc = "Reserved for future use" ] # [ inline ( always ) ] pub fn selms_5 ( self ) -> & 'a mut W { self . variant ( SELMS_A :: SELMS_5 ) } # [ doc = "Reserved for future use" ] # [ inline ( always ) ] pub fn selms_6 ( self ) -> & 'a mut W { self . variant ( SELMS_A :: SELMS_6 ) } # [ doc = "Reserved for future use" ] # [ inline ( always ) ] pub fn selms_7 ( self ) -> & 'a mut W { self . variant ( SELMS_A :: SELMS_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u16 ) & 0x07 ) ; self . w } }
# [ doc = "Selects the ACLK source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum SELA_A { # [ doc = "0: XT1CLK with divider (must be no more than 40 kHz)" ] XT1CLK = 0 , # [ doc = "1: REFO (internal 32-kHz clock source)" ] REFOCLK = 1 , # [ doc = "2: VLO (internal 10-kHz clock source)" ] VLOCLK = 2 } impl From < SELA_A > for u8 { # [ inline ( always ) ] fn from ( variant : SELA_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `SELA`" ] pub type SELA_R = crate :: R < u8 , SELA_A > ; impl SELA_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SELA_A { match self . bits { 0 => SELA_A :: XT1CLK , 1 => SELA_A :: REFOCLK , 2 => SELA_A :: VLOCLK , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `XT1CLK`" ] # [ inline ( always ) ] pub fn is_xt1clk ( & self ) -> bool { * self == SELA_A :: XT1CLK } # [ doc = "Checks if the value of the field is `REFOCLK`" ] # [ inline ( always ) ] pub fn is_refoclk ( & self ) -> bool { * self == SELA_A :: REFOCLK } # [ doc = "Checks if the value of the field is `VLOCLK`" ] # [ inline ( always ) ] pub fn is_vloclk ( & self ) -> bool { * self == SELA_A :: VLOCLK } }
# [ doc = "Write proxy for field `SELA`" ] pub struct SELA_W < 'a > { w : & 'a mut W , } impl < 'a > SELA_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SELA_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "XT1CLK with divider (must be no more than 40 kHz)" ] # [ inline ( always ) ] pub fn xt1clk ( self ) -> & 'a mut W { self . variant ( SELA_A :: XT1CLK ) } # [ doc = "REFO (internal 32-kHz clock source)" ] # [ inline ( always ) ] pub fn refoclk ( self ) -> & 'a mut W { self . variant ( SELA_A :: REFOCLK ) } # [ doc = "VLO (internal 10-kHz clock source)" ] # [ inline ( always ) ] pub fn vloclk ( self ) -> & 'a mut W { self . variant ( SELA_A :: VLOCLK ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Selects the MCLK and SMCLK source" ] # [ inline ( always ) ] pub fn selms ( & self ) -> SELMS_R { SELMS_R :: new ( ( self . bits & 0x07 ) as u8 ) }
# [ doc = "Bits 8:9 - Selects the ACLK source" ] # [ inline ( always ) ] pub fn sela ( & self ) -> SELA_R { SELA_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Selects the MCLK and SMCLK source" ] # [ inline ( always ) ] pub fn selms ( & mut self ) -> SELMS_W { SELMS_W { w : self } }
# [ doc = "Bits 8:9 - Selects the ACLK source" ] # [ inline ( always ) ] pub fn sela ( & mut self ) -> SELA_W { SELA_W { w : self } }
}
}
# [ doc = "Clock System Control 5\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csctl5](csctl5) module" ] pub type CSCTL5 = crate :: Reg < u16 , _CSCTL5 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CSCTL5 ;
# [ doc = "`read()` method returns [csctl5::R](csctl5::R) reader structure" ] impl crate :: Readable for CSCTL5 { }
# [ doc = "`write(|w| ..)` method takes [csctl5::W](csctl5::W) writer structure" ] impl crate :: Writable for CSCTL5 { }
# [ doc = "Clock System Control 5" ] pub mod csctl5 {
# [ doc = "Reader of register CSCTL5" ] pub type R = crate :: R < u16 , super :: CSCTL5 > ;
# [ doc = "Writer for register CSCTL5" ] pub type W = crate :: W < u16 , super :: CSCTL5 > ;
# [ doc = "Register CSCTL5 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CSCTL5 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "MCLK source divider\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum DIVM_A { # [ doc = "0: /1" ] _1 = 0 , # [ doc = "1: /2" ] _2 = 1 , # [ doc = "2: /4" ] _4 = 2 , # [ doc = "3: /8" ] _8 = 3 , # [ doc = "4: /16" ] _16 = 4 , # [ doc = "5: /32" ] _32 = 5 , # [ doc = "6: /64" ] _64 = 6 , # [ doc = "7: /128" ] _128 = 7 } impl From < DIVM_A > for u8 { # [ inline ( always ) ] fn from ( variant : DIVM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `DIVM`" ] pub type DIVM_R = crate :: R < u8 , DIVM_A > ; impl DIVM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DIVM_A { match self . bits { 0 => DIVM_A :: _1 , 1 => DIVM_A :: _2 , 2 => DIVM_A :: _4 , 3 => DIVM_A :: _8 , 4 => DIVM_A :: _16 , 5 => DIVM_A :: _32 , 6 => DIVM_A :: _64 , 7 => DIVM_A :: _128 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == DIVM_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == DIVM_A :: _2 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == DIVM_A :: _4 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == DIVM_A :: _8 } # [ doc = "Checks if the value of the field is `_16`" ] # [ inline ( always ) ] pub fn is_16 ( & self ) -> bool { * self == DIVM_A :: _16 } # [ doc = "Checks if the value of the field is `_32`" ] # [ inline ( always ) ] pub fn is_32 ( & self ) -> bool { * self == DIVM_A :: _32 } # [ doc = "Checks if the value of the field is `_64`" ] # [ inline ( always ) ] pub fn is_64 ( & self ) -> bool { * self == DIVM_A :: _64 } # [ doc = "Checks if the value of the field is `_128`" ] # [ inline ( always ) ] pub fn is_128 ( & self ) -> bool { * self == DIVM_A :: _128 } }
# [ doc = "Write proxy for field `DIVM`" ] pub struct DIVM_W < 'a > { w : & 'a mut W , } impl < 'a > DIVM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DIVM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "/1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( DIVM_A :: _1 ) } # [ doc = "/2" ] # [ inline ( always ) ] pub fn _2 ( self ) -> & 'a mut W { self . variant ( DIVM_A :: _2 ) } # [ doc = "/4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( DIVM_A :: _4 ) } # [ doc = "/8" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( DIVM_A :: _8 ) } # [ doc = "/16" ] # [ inline ( always ) ] pub fn _16 ( self ) -> & 'a mut W { self . variant ( DIVM_A :: _16 ) } # [ doc = "/32" ] # [ inline ( always ) ] pub fn _32 ( self ) -> & 'a mut W { self . variant ( DIVM_A :: _32 ) } # [ doc = "/64" ] # [ inline ( always ) ] pub fn _64 ( self ) -> & 'a mut W { self . variant ( DIVM_A :: _64 ) } # [ doc = "/128" ] # [ inline ( always ) ] pub fn _128 ( self ) -> & 'a mut W { self . variant ( DIVM_A :: _128 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u16 ) & 0x07 ) ; self . w } }
# [ doc = "SMCLK source divider. SMCLK directly derives from MCLK. SMCLK frequency is the combination of DIVM and DIVS out of selected clock source.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum DIVS_A { # [ doc = "0: /1" ] _1 = 0 , # [ doc = "1: /2" ] _2 = 1 , # [ doc = "2: /4" ] _4 = 2 , # [ doc = "3: /8" ] _8 = 3 } impl From < DIVS_A > for u8 { # [ inline ( always ) ] fn from ( variant : DIVS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `DIVS`" ] pub type DIVS_R = crate :: R < u8 , DIVS_A > ; impl DIVS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DIVS_A { match self . bits { 0 => DIVS_A :: _1 , 1 => DIVS_A :: _2 , 2 => DIVS_A :: _4 , 3 => DIVS_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == DIVS_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == DIVS_A :: _2 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == DIVS_A :: _4 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == DIVS_A :: _8 } }
# [ doc = "Write proxy for field `DIVS`" ] pub struct DIVS_W < 'a > { w : & 'a mut W , } impl < 'a > DIVS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DIVS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "/1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( DIVS_A :: _1 ) } # [ doc = "/2" ] # [ inline ( always ) ] pub fn _2 ( self ) -> & 'a mut W { self . variant ( DIVS_A :: _2 ) } # [ doc = "/4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( DIVS_A :: _4 ) } # [ doc = "/8" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( DIVS_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "SMCLK off. This bit turns off SMCLK clock\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SMCLKOFF_A { # [ doc = "0: SMCLK on" ] SMCLKOFF_0 = 0 , # [ doc = "1: SMCLK off" ] SMCLKOFF_1 = 1 } impl From < SMCLKOFF_A > for bool { # [ inline ( always ) ] fn from ( variant : SMCLKOFF_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SMCLKOFF`" ] pub type SMCLKOFF_R = crate :: R < bool , SMCLKOFF_A > ; impl SMCLKOFF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SMCLKOFF_A { match self . bits { false => SMCLKOFF_A :: SMCLKOFF_0 , true => SMCLKOFF_A :: SMCLKOFF_1 } } # [ doc = "Checks if the value of the field is `SMCLKOFF_0`" ] # [ inline ( always ) ] pub fn is_smclkoff_0 ( & self ) -> bool { * self == SMCLKOFF_A :: SMCLKOFF_0 } # [ doc = "Checks if the value of the field is `SMCLKOFF_1`" ] # [ inline ( always ) ] pub fn is_smclkoff_1 ( & self ) -> bool { * self == SMCLKOFF_A :: SMCLKOFF_1 } }
# [ doc = "Write proxy for field `SMCLKOFF`" ] pub struct SMCLKOFF_W < 'a > { w : & 'a mut W , } impl < 'a > SMCLKOFF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SMCLKOFF_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SMCLK on" ] # [ inline ( always ) ] pub fn smclkoff_0 ( self ) -> & 'a mut W { self . variant ( SMCLKOFF_A :: SMCLKOFF_0 ) } # [ doc = "SMCLK off" ] # [ inline ( always ) ] pub fn smclkoff_1 ( self ) -> & 'a mut W { self . variant ( SMCLKOFF_A :: SMCLKOFF_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "VLO automatic off enable. This bit turns off VLO, if VLO is not used.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum VLOAUTOOFF_A { # [ doc = "0: VLO always on" ] VLOAUTOOFF_0 = 0 , # [ doc = "1: VLO automatically turned off if not used(default)" ] VLOAUTOOFF_1 = 1 } impl From < VLOAUTOOFF_A > for bool { # [ inline ( always ) ] fn from ( variant : VLOAUTOOFF_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `VLOAUTOOFF`" ] pub type VLOAUTOOFF_R = crate :: R < bool , VLOAUTOOFF_A > ; impl VLOAUTOOFF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> VLOAUTOOFF_A { match self . bits { false => VLOAUTOOFF_A :: VLOAUTOOFF_0 , true => VLOAUTOOFF_A :: VLOAUTOOFF_1 } } # [ doc = "Checks if the value of the field is `VLOAUTOOFF_0`" ] # [ inline ( always ) ] pub fn is_vloautooff_0 ( & self ) -> bool { * self == VLOAUTOOFF_A :: VLOAUTOOFF_0 } # [ doc = "Checks if the value of the field is `VLOAUTOOFF_1`" ] # [ inline ( always ) ] pub fn is_vloautooff_1 ( & self ) -> bool { * self == VLOAUTOOFF_A :: VLOAUTOOFF_1 } }
# [ doc = "Write proxy for field `VLOAUTOOFF`" ] pub struct VLOAUTOOFF_W < 'a > { w : & 'a mut W , } impl < 'a > VLOAUTOOFF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : VLOAUTOOFF_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "VLO always on" ] # [ inline ( always ) ] pub fn vloautooff_0 ( self ) -> & 'a mut W { self . variant ( VLOAUTOOFF_A :: VLOAUTOOFF_0 ) } # [ doc = "VLO automatically turned off if not used(default)" ] # [ inline ( always ) ] pub fn vloautooff_1 ( self ) -> & 'a mut W { self . variant ( VLOAUTOOFF_A :: VLOAUTOOFF_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - MCLK source divider" ] # [ inline ( always ) ] pub fn divm ( & self ) -> DIVM_R { DIVM_R :: new ( ( self . bits & 0x07 ) as u8 ) }
# [ doc = "Bits 4:5 - SMCLK source divider. SMCLK directly derives from MCLK. SMCLK frequency is the combination of DIVM and DIVS out of selected clock source." ] # [ inline ( always ) ] pub fn divs ( & self ) -> DIVS_R { DIVS_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - SMCLK off. This bit turns off SMCLK clock" ] # [ inline ( always ) ] pub fn smclkoff ( & self ) -> SMCLKOFF_R { SMCLKOFF_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - VLO automatic off enable. This bit turns off VLO, if VLO is not used." ] # [ inline ( always ) ] pub fn vloautooff ( & self ) -> VLOAUTOOFF_R { VLOAUTOOFF_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:2 - MCLK source divider" ] # [ inline ( always ) ] pub fn divm ( & mut self ) -> DIVM_W { DIVM_W { w : self } }
# [ doc = "Bits 4:5 - SMCLK source divider. SMCLK directly derives from MCLK. SMCLK frequency is the combination of DIVM and DIVS out of selected clock source." ] # [ inline ( always ) ] pub fn divs ( & mut self ) -> DIVS_W { DIVS_W { w : self } }
# [ doc = "Bit 8 - SMCLK off. This bit turns off SMCLK clock" ] # [ inline ( always ) ] pub fn smclkoff ( & mut self ) -> SMCLKOFF_W { SMCLKOFF_W { w : self } }
# [ doc = "Bit 12 - VLO automatic off enable. This bit turns off VLO, if VLO is not used." ] # [ inline ( always ) ] pub fn vloautooff ( & mut self ) -> VLOAUTOOFF_W { VLOAUTOOFF_W { w : self } }
}
}
# [ doc = "Clock System Control 6\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csctl6](csctl6) module" ] pub type CSCTL6 = crate :: Reg < u16 , _CSCTL6 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CSCTL6 ;
# [ doc = "`read()` method returns [csctl6::R](csctl6::R) reader structure" ] impl crate :: Readable for CSCTL6 { }
# [ doc = "`write(|w| ..)` method takes [csctl6::W](csctl6::W) writer structure" ] impl crate :: Writable for CSCTL6 { }
# [ doc = "Clock System Control 6" ] pub mod csctl6 {
# [ doc = "Reader of register CSCTL6" ] pub type R = crate :: R < u16 , super :: CSCTL6 > ;
# [ doc = "Writer for register CSCTL6" ] pub type W = crate :: W < u16 , super :: CSCTL6 > ;
# [ doc = "Register CSCTL6 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CSCTL6 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "XT1 automatic off enable. This bit allows XT1 turned turns off when it is not used\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum XT1AUTOOFF_A { # [ doc = "0: XT1 is on if XT1 is selected by the port selection and XT1 is not in bypass mode of operation." ] XT1AUTOOFF_0 = 0 , # [ doc = "1: XT1 is off if it is not used as a source for ACLK, MCLK, or SMCLK or is not used as a reference source required for FLL operation." ] XT1AUTOOFF_1 = 1 } impl From < XT1AUTOOFF_A > for bool { # [ inline ( always ) ] fn from ( variant : XT1AUTOOFF_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `XT1AUTOOFF`" ] pub type XT1AUTOOFF_R = crate :: R < bool , XT1AUTOOFF_A > ; impl XT1AUTOOFF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> XT1AUTOOFF_A { match self . bits { false => XT1AUTOOFF_A :: XT1AUTOOFF_0 , true => XT1AUTOOFF_A :: XT1AUTOOFF_1 } } # [ doc = "Checks if the value of the field is `XT1AUTOOFF_0`" ] # [ inline ( always ) ] pub fn is_xt1autooff_0 ( & self ) -> bool { * self == XT1AUTOOFF_A :: XT1AUTOOFF_0 } # [ doc = "Checks if the value of the field is `XT1AUTOOFF_1`" ] # [ inline ( always ) ] pub fn is_xt1autooff_1 ( & self ) -> bool { * self == XT1AUTOOFF_A :: XT1AUTOOFF_1 } }
# [ doc = "Write proxy for field `XT1AUTOOFF`" ] pub struct XT1AUTOOFF_W < 'a > { w : & 'a mut W , } impl < 'a > XT1AUTOOFF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : XT1AUTOOFF_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "XT1 is on if XT1 is selected by the port selection and XT1 is not in bypass mode of operation." ] # [ inline ( always ) ] pub fn xt1autooff_0 ( self ) -> & 'a mut W { self . variant ( XT1AUTOOFF_A :: XT1AUTOOFF_0 ) } # [ doc = "XT1 is off if it is not used as a source for ACLK, MCLK, or SMCLK or is not used as a reference source required for FLL operation." ] # [ inline ( always ) ] pub fn xt1autooff_1 ( self ) -> & 'a mut W { self . variant ( XT1AUTOOFF_A :: XT1AUTOOFF_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Automatic Gain Control (AGC) disable.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum XT1AGCOFF_A { # [ doc = "0: AGC on" ] XT1AGCOFF_0 = 0 , # [ doc = "1: AGC off" ] XT1AGCOFF_1 = 1 } impl From < XT1AGCOFF_A > for bool { # [ inline ( always ) ] fn from ( variant : XT1AGCOFF_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `XT1AGCOFF`" ] pub type XT1AGCOFF_R = crate :: R < bool , XT1AGCOFF_A > ; impl XT1AGCOFF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> XT1AGCOFF_A { match self . bits { false => XT1AGCOFF_A :: XT1AGCOFF_0 , true => XT1AGCOFF_A :: XT1AGCOFF_1 } } # [ doc = "Checks if the value of the field is `XT1AGCOFF_0`" ] # [ inline ( always ) ] pub fn is_xt1agcoff_0 ( & self ) -> bool { * self == XT1AGCOFF_A :: XT1AGCOFF_0 } # [ doc = "Checks if the value of the field is `XT1AGCOFF_1`" ] # [ inline ( always ) ] pub fn is_xt1agcoff_1 ( & self ) -> bool { * self == XT1AGCOFF_A :: XT1AGCOFF_1 } }
# [ doc = "Write proxy for field `XT1AGCOFF`" ] pub struct XT1AGCOFF_W < 'a > { w : & 'a mut W , } impl < 'a > XT1AGCOFF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : XT1AGCOFF_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "AGC on" ] # [ inline ( always ) ] pub fn xt1agcoff_0 ( self ) -> & 'a mut W { self . variant ( XT1AGCOFF_A :: XT1AGCOFF_0 ) } # [ doc = "AGC off" ] # [ inline ( always ) ] pub fn xt1agcoff_1 ( self ) -> & 'a mut W { self . variant ( XT1AGCOFF_A :: XT1AGCOFF_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "The XT1 High-frequency selection. These bits must be set to appropriate frequency for crystal or bypass modes of operation.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum XT1HFFREQ_A { # [ doc = "0: 1 to 4 MHz" ] XT1HFFREQ_0 = 0 , # [ doc = "1: 4 MHz to 6 MHz" ] XT1HFFREQ_1 = 1 , # [ doc = "2: 6 MHz to 16 MHz" ] XT1HFFREQ_2 = 2 , # [ doc = "3: 16 MHz to 24 MHz" ] XT1HFFREQ_3 = 3 } impl From < XT1HFFREQ_A > for u8 { # [ inline ( always ) ] fn from ( variant : XT1HFFREQ_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `XT1HFFREQ`" ] pub type XT1HFFREQ_R = crate :: R < u8 , XT1HFFREQ_A > ; impl XT1HFFREQ_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> XT1HFFREQ_A { match self . bits { 0 => XT1HFFREQ_A :: XT1HFFREQ_0 , 1 => XT1HFFREQ_A :: XT1HFFREQ_1 , 2 => XT1HFFREQ_A :: XT1HFFREQ_2 , 3 => XT1HFFREQ_A :: XT1HFFREQ_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `XT1HFFREQ_0`" ] # [ inline ( always ) ] pub fn is_xt1hffreq_0 ( & self ) -> bool { * self == XT1HFFREQ_A :: XT1HFFREQ_0 } # [ doc = "Checks if the value of the field is `XT1HFFREQ_1`" ] # [ inline ( always ) ] pub fn is_xt1hffreq_1 ( & self ) -> bool { * self == XT1HFFREQ_A :: XT1HFFREQ_1 } # [ doc = "Checks if the value of the field is `XT1HFFREQ_2`" ] # [ inline ( always ) ] pub fn is_xt1hffreq_2 ( & self ) -> bool { * self == XT1HFFREQ_A :: XT1HFFREQ_2 } # [ doc = "Checks if the value of the field is `XT1HFFREQ_3`" ] # [ inline ( always ) ] pub fn is_xt1hffreq_3 ( & self ) -> bool { * self == XT1HFFREQ_A :: XT1HFFREQ_3 } }
# [ doc = "Write proxy for field `XT1HFFREQ`" ] pub struct XT1HFFREQ_W < 'a > { w : & 'a mut W , } impl < 'a > XT1HFFREQ_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : XT1HFFREQ_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "1 to 4 MHz" ] # [ inline ( always ) ] pub fn xt1hffreq_0 ( self ) -> & 'a mut W { self . variant ( XT1HFFREQ_A :: XT1HFFREQ_0 ) } # [ doc = "4 MHz to 6 MHz" ] # [ inline ( always ) ] pub fn xt1hffreq_1 ( self ) -> & 'a mut W { self . variant ( XT1HFFREQ_A :: XT1HFFREQ_1 ) } # [ doc = "6 MHz to 16 MHz" ] # [ inline ( always ) ] pub fn xt1hffreq_2 ( self ) -> & 'a mut W { self . variant ( XT1HFFREQ_A :: XT1HFFREQ_2 ) } # [ doc = "16 MHz to 24 MHz" ] # [ inline ( always ) ] pub fn xt1hffreq_3 ( self ) -> & 'a mut W { self . variant ( XT1HFFREQ_A :: XT1HFFREQ_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u16 ) & 0x03 ) << 2 ) ; self . w } }
# [ doc = "XT1 bypass select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum XT1BYPASS_A { # [ doc = "0: XT1 source internally" ] XT1BYPASS_0 = 0 , # [ doc = "1: XT1 sources externally from pin" ] XT1BYPASS_1 = 1 } impl From < XT1BYPASS_A > for bool { # [ inline ( always ) ] fn from ( variant : XT1BYPASS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `XT1BYPASS`" ] pub type XT1BYPASS_R = crate :: R < bool , XT1BYPASS_A > ; impl XT1BYPASS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> XT1BYPASS_A { match self . bits { false => XT1BYPASS_A :: XT1BYPASS_0 , true => XT1BYPASS_A :: XT1BYPASS_1 } } # [ doc = "Checks if the value of the field is `XT1BYPASS_0`" ] # [ inline ( always ) ] pub fn is_xt1bypass_0 ( & self ) -> bool { * self == XT1BYPASS_A :: XT1BYPASS_0 } # [ doc = "Checks if the value of the field is `XT1BYPASS_1`" ] # [ inline ( always ) ] pub fn is_xt1bypass_1 ( & self ) -> bool { * self == XT1BYPASS_A :: XT1BYPASS_1 } }
# [ doc = "Write proxy for field `XT1BYPASS`" ] pub struct XT1BYPASS_W < 'a > { w : & 'a mut W , } impl < 'a > XT1BYPASS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : XT1BYPASS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "XT1 source internally" ] # [ inline ( always ) ] pub fn xt1bypass_0 ( self ) -> & 'a mut W { self . variant ( XT1BYPASS_A :: XT1BYPASS_0 ) } # [ doc = "XT1 sources externally from pin" ] # [ inline ( always ) ] pub fn xt1bypass_1 ( self ) -> & 'a mut W { self . variant ( XT1BYPASS_A :: XT1BYPASS_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "XT1 mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum XTS_A { # [ doc = "0: Low-frequency mode." ] XTS_0 = 0 , # [ doc = "1: High-frequency mode." ] XTS_1 = 1 } impl From < XTS_A > for bool { # [ inline ( always ) ] fn from ( variant : XTS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `XTS`" ] pub type XTS_R = crate :: R < bool , XTS_A > ; impl XTS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> XTS_A { match self . bits { false => XTS_A :: XTS_0 , true => XTS_A :: XTS_1 } } # [ doc = "Checks if the value of the field is `XTS_0`" ] # [ inline ( always ) ] pub fn is_xts_0 ( & self ) -> bool { * self == XTS_A :: XTS_0 } # [ doc = "Checks if the value of the field is `XTS_1`" ] # [ inline ( always ) ] pub fn is_xts_1 ( & self ) -> bool { * self == XTS_A :: XTS_1 } }
# [ doc = "Write proxy for field `XTS`" ] pub struct XTS_W < 'a > { w : & 'a mut W , } impl < 'a > XTS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : XTS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Low-frequency mode." ] # [ inline ( always ) ] pub fn xts_0 ( self ) -> & 'a mut W { self . variant ( XTS_A :: XTS_0 ) } # [ doc = "High-frequency mode." ] # [ inline ( always ) ] pub fn xts_1 ( self ) -> & 'a mut W { self . variant ( XTS_A :: XTS_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "The XT1 oscillator current can be adjusted to its drive needs. Initially, it starts with the highest supply current for reliable and quick startup. If needed, user software can reduce the drive strength. The configuration of these bits is retained during LPM3.5 until LOCKLPM5 is cleared, but not the register bits itself; therefore, reconfiguration after wake-up from LPM3.5 before clearing LOCKLPM5 is required.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum XT1DRIVE_A { # [ doc = "0: Lowest drive strength and current consumption" ] XT1DRIVE_0 = 0 , # [ doc = "1: Lower drive strength and current consumption" ] XT1DRIVE_1 = 1 , # [ doc = "2: Higher drive strength and current consumption" ] XT1DRIVE_2 = 2 , # [ doc = "3: Highest drive strength and current consumption" ] XT1DRIVE_3 = 3 } impl From < XT1DRIVE_A > for u8 { # [ inline ( always ) ] fn from ( variant : XT1DRIVE_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `XT1DRIVE`" ] pub type XT1DRIVE_R = crate :: R < u8 , XT1DRIVE_A > ; impl XT1DRIVE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> XT1DRIVE_A { match self . bits { 0 => XT1DRIVE_A :: XT1DRIVE_0 , 1 => XT1DRIVE_A :: XT1DRIVE_1 , 2 => XT1DRIVE_A :: XT1DRIVE_2 , 3 => XT1DRIVE_A :: XT1DRIVE_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `XT1DRIVE_0`" ] # [ inline ( always ) ] pub fn is_xt1drive_0 ( & self ) -> bool { * self == XT1DRIVE_A :: XT1DRIVE_0 } # [ doc = "Checks if the value of the field is `XT1DRIVE_1`" ] # [ inline ( always ) ] pub fn is_xt1drive_1 ( & self ) -> bool { * self == XT1DRIVE_A :: XT1DRIVE_1 } # [ doc = "Checks if the value of the field is `XT1DRIVE_2`" ] # [ inline ( always ) ] pub fn is_xt1drive_2 ( & self ) -> bool { * self == XT1DRIVE_A :: XT1DRIVE_2 } # [ doc = "Checks if the value of the field is `XT1DRIVE_3`" ] # [ inline ( always ) ] pub fn is_xt1drive_3 ( & self ) -> bool { * self == XT1DRIVE_A :: XT1DRIVE_3 } }
# [ doc = "Write proxy for field `XT1DRIVE`" ] pub struct XT1DRIVE_W < 'a > { w : & 'a mut W , } impl < 'a > XT1DRIVE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : XT1DRIVE_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Lowest drive strength and current consumption" ] # [ inline ( always ) ] pub fn xt1drive_0 ( self ) -> & 'a mut W { self . variant ( XT1DRIVE_A :: XT1DRIVE_0 ) } # [ doc = "Lower drive strength and current consumption" ] # [ inline ( always ) ] pub fn xt1drive_1 ( self ) -> & 'a mut W { self . variant ( XT1DRIVE_A :: XT1DRIVE_1 ) } # [ doc = "Higher drive strength and current consumption" ] # [ inline ( always ) ] pub fn xt1drive_2 ( self ) -> & 'a mut W { self . variant ( XT1DRIVE_A :: XT1DRIVE_2 ) } # [ doc = "Highest drive strength and current consumption" ] # [ inline ( always ) ] pub fn xt1drive_3 ( self ) -> & 'a mut W { self . variant ( XT1DRIVE_A :: XT1DRIVE_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "ACLK source divider.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum DIVA_A { # [ doc = "0: /1" ] _1 = 0 , # [ doc = "1: /16" ] _16 = 1 , # [ doc = "2: /32" ] _32 = 2 , # [ doc = "3: /64" ] _64 = 3 , # [ doc = "4: /128" ] _128 = 4 , # [ doc = "5: /256" ] _256 = 5 , # [ doc = "6: /384" ] _384 = 6 , # [ doc = "7: /512" ] _512 = 7 , # [ doc = "8: /768(Only available in 24MHz clock system, 24 MHz preference)" ] _768 = 8 , # [ doc = "9: /1024(Only available in 24MHz clock system, 24 MHz preference)" ] _1024 = 9 , # [ doc = "10: /108(Only available in 24MHz clock system, 24 MHz preference)" ] _108 = 10 , # [ doc = "11: 338(Only available in 24MHz clock system, 24 MHz preference)" ] _338 = 11 , # [ doc = "12: 414(Only available in 24MHz clock system, 24 MHz preference)" ] _414 = 12 , # [ doc = "13: 640(Only available in 24MHz clock system, 24 MHz preference)" ] _640 = 13 , # [ doc = "14: Reserved" ] DIVA_14 = 14 , # [ doc = "15: Reserved" ] DIVA_15 = 15 } impl From < DIVA_A > for u8 { # [ inline ( always ) ] fn from ( variant : DIVA_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `DIVA`" ] pub type DIVA_R = crate :: R < u8 , DIVA_A > ; impl DIVA_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DIVA_A { match self . bits { 0 => DIVA_A :: _1 , 1 => DIVA_A :: _16 , 2 => DIVA_A :: _32 , 3 => DIVA_A :: _64 , 4 => DIVA_A :: _128 , 5 => DIVA_A :: _256 , 6 => DIVA_A :: _384 , 7 => DIVA_A :: _512 , 8 => DIVA_A :: _768 , 9 => DIVA_A :: _1024 , 10 => DIVA_A :: _108 , 11 => DIVA_A :: _338 , 12 => DIVA_A :: _414 , 13 => DIVA_A :: _640 , 14 => DIVA_A :: DIVA_14 , 15 => DIVA_A :: DIVA_15 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == DIVA_A :: _1 } # [ doc = "Checks if the value of the field is `_16`" ] # [ inline ( always ) ] pub fn is_16 ( & self ) -> bool { * self == DIVA_A :: _16 } # [ doc = "Checks if the value of the field is `_32`" ] # [ inline ( always ) ] pub fn is_32 ( & self ) -> bool { * self == DIVA_A :: _32 } # [ doc = "Checks if the value of the field is `_64`" ] # [ inline ( always ) ] pub fn is_64 ( & self ) -> bool { * self == DIVA_A :: _64 } # [ doc = "Checks if the value of the field is `_128`" ] # [ inline ( always ) ] pub fn is_128 ( & self ) -> bool { * self == DIVA_A :: _128 } # [ doc = "Checks if the value of the field is `_256`" ] # [ inline ( always ) ] pub fn is_256 ( & self ) -> bool { * self == DIVA_A :: _256 } # [ doc = "Checks if the value of the field is `_384`" ] # [ inline ( always ) ] pub fn is_384 ( & self ) -> bool { * self == DIVA_A :: _384 } # [ doc = "Checks if the value of the field is `_512`" ] # [ inline ( always ) ] pub fn is_512 ( & self ) -> bool { * self == DIVA_A :: _512 } # [ doc = "Checks if the value of the field is `_768`" ] # [ inline ( always ) ] pub fn is_768 ( & self ) -> bool { * self == DIVA_A :: _768 } # [ doc = "Checks if the value of the field is `_1024`" ] # [ inline ( always ) ] pub fn is_1024 ( & self ) -> bool { * self == DIVA_A :: _1024 } # [ doc = "Checks if the value of the field is `_108`" ] # [ inline ( always ) ] pub fn is_108 ( & self ) -> bool { * self == DIVA_A :: _108 } # [ doc = "Checks if the value of the field is `_338`" ] # [ inline ( always ) ] pub fn is_338 ( & self ) -> bool { * self == DIVA_A :: _338 } # [ doc = "Checks if the value of the field is `_414`" ] # [ inline ( always ) ] pub fn is_414 ( & self ) -> bool { * self == DIVA_A :: _414 } # [ doc = "Checks if the value of the field is `_640`" ] # [ inline ( always ) ] pub fn is_640 ( & self ) -> bool { * self == DIVA_A :: _640 } # [ doc = "Checks if the value of the field is `DIVA_14`" ] # [ inline ( always ) ] pub fn is_diva_14 ( & self ) -> bool { * self == DIVA_A :: DIVA_14 } # [ doc = "Checks if the value of the field is `DIVA_15`" ] # [ inline ( always ) ] pub fn is_diva_15 ( & self ) -> bool { * self == DIVA_A :: DIVA_15 } }
# [ doc = "Write proxy for field `DIVA`" ] pub struct DIVA_W < 'a > { w : & 'a mut W , } impl < 'a > DIVA_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DIVA_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "/1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( DIVA_A :: _1 ) } # [ doc = "/16" ] # [ inline ( always ) ] pub fn _16 ( self ) -> & 'a mut W { self . variant ( DIVA_A :: _16 ) } # [ doc = "/32" ] # [ inline ( always ) ] pub fn _32 ( self ) -> & 'a mut W { self . variant ( DIVA_A :: _32 ) } # [ doc = "/64" ] # [ inline ( always ) ] pub fn _64 ( self ) -> & 'a mut W { self . variant ( DIVA_A :: _64 ) } # [ doc = "/128" ] # [ inline ( always ) ] pub fn _128 ( self ) -> & 'a mut W { self . variant ( DIVA_A :: _128 ) } # [ doc = "/256" ] # [ inline ( always ) ] pub fn _256 ( self ) -> & 'a mut W { self . variant ( DIVA_A :: _256 ) } # [ doc = "/384" ] # [ inline ( always ) ] pub fn _384 ( self ) -> & 'a mut W { self . variant ( DIVA_A :: _384 ) } # [ doc = "/512" ] # [ inline ( always ) ] pub fn _512 ( self ) -> & 'a mut W { self . variant ( DIVA_A :: _512 ) } # [ doc = "/768(Only available in 24MHz clock system, 24 MHz preference)" ] # [ inline ( always ) ] pub fn _768 ( self ) -> & 'a mut W { self . variant ( DIVA_A :: _768 ) } # [ doc = "/1024(Only available in 24MHz clock system, 24 MHz preference)" ] # [ inline ( always ) ] pub fn _1024 ( self ) -> & 'a mut W { self . variant ( DIVA_A :: _1024 ) } # [ doc = "/108(Only available in 24MHz clock system, 24 MHz preference)" ] # [ inline ( always ) ] pub fn _108 ( self ) -> & 'a mut W { self . variant ( DIVA_A :: _108 ) } # [ doc = "338(Only available in 24MHz clock system, 24 MHz preference)" ] # [ inline ( always ) ] pub fn _338 ( self ) -> & 'a mut W { self . variant ( DIVA_A :: _338 ) } # [ doc = "414(Only available in 24MHz clock system, 24 MHz preference)" ] # [ inline ( always ) ] pub fn _414 ( self ) -> & 'a mut W { self . variant ( DIVA_A :: _414 ) } # [ doc = "640(Only available in 24MHz clock system, 24 MHz preference)" ] # [ inline ( always ) ] pub fn _640 ( self ) -> & 'a mut W { self . variant ( DIVA_A :: _640 ) } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn diva_14 ( self ) -> & 'a mut W { self . variant ( DIVA_A :: DIVA_14 ) } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn diva_15 ( self ) -> & 'a mut W { self . variant ( DIVA_A :: DIVA_15 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 8 ) ) | ( ( ( value as u16 ) & 0x0f ) << 8 ) ; self . w } }
# [ doc = "The XT1 oscillator fault detection off\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum XT1FAULTOFF_A { # [ doc = "0: Enabling XT1 fault to switch ACLK to REFO" ] XT1FAULTOFF_0 = 0 , # [ doc = "1: Disabling XT1 fault to switch ACLK to REFO" ] XT1FAULTOFF_1 = 1 } impl From < XT1FAULTOFF_A > for bool { # [ inline ( always ) ] fn from ( variant : XT1FAULTOFF_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `XT1FAULTOFF`" ] pub type XT1FAULTOFF_R = crate :: R < bool , XT1FAULTOFF_A > ; impl XT1FAULTOFF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> XT1FAULTOFF_A { match self . bits { false => XT1FAULTOFF_A :: XT1FAULTOFF_0 , true => XT1FAULTOFF_A :: XT1FAULTOFF_1 } } # [ doc = "Checks if the value of the field is `XT1FAULTOFF_0`" ] # [ inline ( always ) ] pub fn is_xt1faultoff_0 ( & self ) -> bool { * self == XT1FAULTOFF_A :: XT1FAULTOFF_0 } # [ doc = "Checks if the value of the field is `XT1FAULTOFF_1`" ] # [ inline ( always ) ] pub fn is_xt1faultoff_1 ( & self ) -> bool { * self == XT1FAULTOFF_A :: XT1FAULTOFF_1 } }
# [ doc = "Write proxy for field `XT1FAULTOFF`" ] pub struct XT1FAULTOFF_W < 'a > { w : & 'a mut W , } impl < 'a > XT1FAULTOFF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : XT1FAULTOFF_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Enabling XT1 fault to switch ACLK to REFO" ] # [ inline ( always ) ] pub fn xt1faultoff_0 ( self ) -> & 'a mut W { self . variant ( XT1FAULTOFF_A :: XT1FAULTOFF_0 ) } # [ doc = "Disabling XT1 fault to switch ACLK to REFO" ] # [ inline ( always ) ] pub fn xt1faultoff_1 ( self ) -> & 'a mut W { self . variant ( XT1FAULTOFF_A :: XT1FAULTOFF_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - XT1 automatic off enable. This bit allows XT1 turned turns off when it is not used" ] # [ inline ( always ) ] pub fn xt1autooff ( & self ) -> XT1AUTOOFF_R { XT1AUTOOFF_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Automatic Gain Control (AGC) disable." ] # [ inline ( always ) ] pub fn xt1agcoff ( & self ) -> XT1AGCOFF_R { XT1AGCOFF_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 2:3 - The XT1 High-frequency selection. These bits must be set to appropriate frequency for crystal or bypass modes of operation." ] # [ inline ( always ) ] pub fn xt1hffreq ( & self ) -> XT1HFFREQ_R { XT1HFFREQ_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 4 - XT1 bypass select" ] # [ inline ( always ) ] pub fn xt1bypass ( & self ) -> XT1BYPASS_R { XT1BYPASS_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - XT1 mode select" ] # [ inline ( always ) ] pub fn xts ( & self ) -> XTS_R { XTS_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - The XT1 oscillator current can be adjusted to its drive needs. Initially, it starts with the highest supply current for reliable and quick startup. If needed, user software can reduce the drive strength. The configuration of these bits is retained during LPM3.5 until LOCKLPM5 is cleared, but not the register bits itself; therefore, reconfiguration after wake-up from LPM3.5 before clearing LOCKLPM5 is required." ] # [ inline ( always ) ] pub fn xt1drive ( & self ) -> XT1DRIVE_R { XT1DRIVE_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:11 - ACLK source divider." ] # [ inline ( always ) ] pub fn diva ( & self ) -> DIVA_R { DIVA_R :: new ( ( ( self . bits >> 8 ) & 0x0f ) as u8 ) }
# [ doc = "Bit 13 - The XT1 oscillator fault detection off" ] # [ inline ( always ) ] pub fn xt1faultoff ( & self ) -> XT1FAULTOFF_R { XT1FAULTOFF_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - XT1 automatic off enable. This bit allows XT1 turned turns off when it is not used" ] # [ inline ( always ) ] pub fn xt1autooff ( & mut self ) -> XT1AUTOOFF_W { XT1AUTOOFF_W { w : self } }
# [ doc = "Bit 1 - Automatic Gain Control (AGC) disable." ] # [ inline ( always ) ] pub fn xt1agcoff ( & mut self ) -> XT1AGCOFF_W { XT1AGCOFF_W { w : self } }
# [ doc = "Bits 2:3 - The XT1 High-frequency selection. These bits must be set to appropriate frequency for crystal or bypass modes of operation." ] # [ inline ( always ) ] pub fn xt1hffreq ( & mut self ) -> XT1HFFREQ_W { XT1HFFREQ_W { w : self } }
# [ doc = "Bit 4 - XT1 bypass select" ] # [ inline ( always ) ] pub fn xt1bypass ( & mut self ) -> XT1BYPASS_W { XT1BYPASS_W { w : self } }
# [ doc = "Bit 5 - XT1 mode select" ] # [ inline ( always ) ] pub fn xts ( & mut self ) -> XTS_W { XTS_W { w : self } }
# [ doc = "Bits 6:7 - The XT1 oscillator current can be adjusted to its drive needs. Initially, it starts with the highest supply current for reliable and quick startup. If needed, user software can reduce the drive strength. The configuration of these bits is retained during LPM3.5 until LOCKLPM5 is cleared, but not the register bits itself; therefore, reconfiguration after wake-up from LPM3.5 before clearing LOCKLPM5 is required." ] # [ inline ( always ) ] pub fn xt1drive ( & mut self ) -> XT1DRIVE_W { XT1DRIVE_W { w : self } }
# [ doc = "Bits 8:11 - ACLK source divider." ] # [ inline ( always ) ] pub fn diva ( & mut self ) -> DIVA_W { DIVA_W { w : self } }
# [ doc = "Bit 13 - The XT1 oscillator fault detection off" ] # [ inline ( always ) ] pub fn xt1faultoff ( & mut self ) -> XT1FAULTOFF_W { XT1FAULTOFF_W { w : self } }
}
}
# [ doc = "Clock System Control Register 7\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csctl7](csctl7) module" ] pub type CSCTL7 = crate :: Reg < u16 , _CSCTL7 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CSCTL7 ;
# [ doc = "`read()` method returns [csctl7::R](csctl7::R) reader structure" ] impl crate :: Readable for CSCTL7 { }
# [ doc = "`write(|w| ..)` method takes [csctl7::W](csctl7::W) writer structure" ] impl crate :: Writable for CSCTL7 { }
# [ doc = "Clock System Control Register 7" ] pub mod csctl7 {
# [ doc = "Reader of register CSCTL7" ] pub type R = crate :: R < u16 , super :: CSCTL7 > ;
# [ doc = "Writer for register CSCTL7" ] pub type W = crate :: W < u16 , super :: CSCTL7 > ;
# [ doc = "Register CSCTL7 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CSCTL7 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "REFO ready flag. This bit reflects the REFO readiness whent REFO is good for operation (such as FLL reference)\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum REFOREADY_A { # [ doc = "0: REFO unstable" ] REFOREADY_0 = 0 , # [ doc = "1: REFO ready to go" ] REFOREADY_1 = 1 } impl From < REFOREADY_A > for bool { # [ inline ( always ) ] fn from ( variant : REFOREADY_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `REFOREADY`" ] pub type REFOREADY_R = crate :: R < bool , REFOREADY_A > ; impl REFOREADY_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> REFOREADY_A { match self . bits { false => REFOREADY_A :: REFOREADY_0 , true => REFOREADY_A :: REFOREADY_1 } } # [ doc = "Checks if the value of the field is `REFOREADY_0`" ] # [ inline ( always ) ] pub fn is_refoready_0 ( & self ) -> bool { * self == REFOREADY_A :: REFOREADY_0 } # [ doc = "Checks if the value of the field is `REFOREADY_1`" ] # [ inline ( always ) ] pub fn is_refoready_1 ( & self ) -> bool { * self == REFOREADY_A :: REFOREADY_1 } }
# [ doc = "DCO fault flag. If this bit is set, the OFIFG flag is also set. The DCOFFG bit is set if DCO = {0} or DCO = {511}. DCOFFG can be cleared by software. If the DCO fault condition still remains, DCOFFG is set. As long as DCOFFG is set, FLLUNLOCK shows the DCOERROR condition.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DCOFFG_A { # [ doc = "0: No fault condition occurred after the last reset." ] DCOFFG_0 = 0 , # [ doc = "1: DCO fault. A DCO fault occurred after the last reset." ] DCOFFG_1 = 1 } impl From < DCOFFG_A > for bool { # [ inline ( always ) ] fn from ( variant : DCOFFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DCOFFG`" ] pub type DCOFFG_R = crate :: R < bool , DCOFFG_A > ; impl DCOFFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DCOFFG_A { match self . bits { false => DCOFFG_A :: DCOFFG_0 , true => DCOFFG_A :: DCOFFG_1 } } # [ doc = "Checks if the value of the field is `DCOFFG_0`" ] # [ inline ( always ) ] pub fn is_dcoffg_0 ( & self ) -> bool { * self == DCOFFG_A :: DCOFFG_0 } # [ doc = "Checks if the value of the field is `DCOFFG_1`" ] # [ inline ( always ) ] pub fn is_dcoffg_1 ( & self ) -> bool { * self == DCOFFG_A :: DCOFFG_1 } }
# [ doc = "Write proxy for field `DCOFFG`" ] pub struct DCOFFG_W < 'a > { w : & 'a mut W , } impl < 'a > DCOFFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DCOFFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No fault condition occurred after the last reset." ] # [ inline ( always ) ] pub fn dcoffg_0 ( self ) -> & 'a mut W { self . variant ( DCOFFG_A :: DCOFFG_0 ) } # [ doc = "DCO fault. A DCO fault occurred after the last reset." ] # [ inline ( always ) ] pub fn dcoffg_1 ( self ) -> & 'a mut W { self . variant ( DCOFFG_A :: DCOFFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "T1 oscillator fault flag. If this bit is set, the OFIFG flag is also set. XT1OFFG is set if a XT1 fault condition exists. XT1OFFG can be cleared by software. If the XT1 fault condition still remains, XT1OFFG is set.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum XT1OFFG_A { # [ doc = "0: No fault condition occurred after the last reset." ] XT1OFFG_0 = 0 , # [ doc = "1: XT1 fault. An XT1 fault occurred after the last reset." ] XT1OFFG_1 = 1 } impl From < XT1OFFG_A > for bool { # [ inline ( always ) ] fn from ( variant : XT1OFFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `XT1OFFG`" ] pub type XT1OFFG_R = crate :: R < bool , XT1OFFG_A > ; impl XT1OFFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> XT1OFFG_A { match self . bits { false => XT1OFFG_A :: XT1OFFG_0 , true => XT1OFFG_A :: XT1OFFG_1 } } # [ doc = "Checks if the value of the field is `XT1OFFG_0`" ] # [ inline ( always ) ] pub fn is_xt1offg_0 ( & self ) -> bool { * self == XT1OFFG_A :: XT1OFFG_0 } # [ doc = "Checks if the value of the field is `XT1OFFG_1`" ] # [ inline ( always ) ] pub fn is_xt1offg_1 ( & self ) -> bool { * self == XT1OFFG_A :: XT1OFFG_1 } }
# [ doc = "Write proxy for field `XT1OFFG`" ] pub struct XT1OFFG_W < 'a > { w : & 'a mut W , } impl < 'a > XT1OFFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : XT1OFFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No fault condition occurred after the last reset." ] # [ inline ( always ) ] pub fn xt1offg_0 ( self ) -> & 'a mut W { self . variant ( XT1OFFG_A :: XT1OFFG_0 ) } # [ doc = "XT1 fault. An XT1 fault occurred after the last reset." ] # [ inline ( always ) ] pub fn xt1offg_1 ( self ) -> & 'a mut W { self . variant ( XT1OFFG_A :: XT1OFFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "FLL unlock interrupt flag. This flag is set when FLLUNLOCK bits equal 10b (DCO too fast). If FLLULPUC is also set, a PUC is triggered when FLLUIFG is set.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FLLULIFG_A { # [ doc = "0: FLLUNLOCK bits not equal to 10b" ] FLLULIFG_0 = 0 , # [ doc = "1: FLLUNLOCK bits equal to 10b" ] FLLULIFG_1 = 1 } impl From < FLLULIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : FLLULIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `FLLULIFG`" ] pub type FLLULIFG_R = crate :: R < bool , FLLULIFG_A > ; impl FLLULIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> FLLULIFG_A { match self . bits { false => FLLULIFG_A :: FLLULIFG_0 , true => FLLULIFG_A :: FLLULIFG_1 } } # [ doc = "Checks if the value of the field is `FLLULIFG_0`" ] # [ inline ( always ) ] pub fn is_fllulifg_0 ( & self ) -> bool { * self == FLLULIFG_A :: FLLULIFG_0 } # [ doc = "Checks if the value of the field is `FLLULIFG_1`" ] # [ inline ( always ) ] pub fn is_fllulifg_1 ( & self ) -> bool { * self == FLLULIFG_A :: FLLULIFG_1 } }
# [ doc = "Write proxy for field `FLLULIFG`" ] pub struct FLLULIFG_W < 'a > { w : & 'a mut W , } impl < 'a > FLLULIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : FLLULIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "FLLUNLOCK bits not equal to 10b" ] # [ inline ( always ) ] pub fn fllulifg_0 ( self ) -> & 'a mut W { self . variant ( FLLULIFG_A :: FLLULIFG_0 ) } # [ doc = "FLLUNLOCK bits equal to 10b" ] # [ inline ( always ) ] pub fn fllulifg_1 ( self ) -> & 'a mut W { self . variant ( FLLULIFG_A :: FLLULIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Enable start counter for XT1.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENSTFCNT1_A { # [ doc = "0: Startup fault counter disabled. Counter is cleared.." ] ENSTFCNT1_0 = 0 , # [ doc = "1: Startup fault counter enabled." ] ENSTFCNT1_1 = 1 } impl From < ENSTFCNT1_A > for bool { # [ inline ( always ) ] fn from ( variant : ENSTFCNT1_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ENSTFCNT1`" ] pub type ENSTFCNT1_R = crate :: R < bool , ENSTFCNT1_A > ; impl ENSTFCNT1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ENSTFCNT1_A { match self . bits { false => ENSTFCNT1_A :: ENSTFCNT1_0 , true => ENSTFCNT1_A :: ENSTFCNT1_1 } } # [ doc = "Checks if the value of the field is `ENSTFCNT1_0`" ] # [ inline ( always ) ] pub fn is_enstfcnt1_0 ( & self ) -> bool { * self == ENSTFCNT1_A :: ENSTFCNT1_0 } # [ doc = "Checks if the value of the field is `ENSTFCNT1_1`" ] # [ inline ( always ) ] pub fn is_enstfcnt1_1 ( & self ) -> bool { * self == ENSTFCNT1_A :: ENSTFCNT1_1 } }
# [ doc = "Write proxy for field `ENSTFCNT1`" ] pub struct ENSTFCNT1_W < 'a > { w : & 'a mut W , } impl < 'a > ENSTFCNT1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ENSTFCNT1_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Startup fault counter disabled. Counter is cleared.." ] # [ inline ( always ) ] pub fn enstfcnt1_0 ( self ) -> & 'a mut W { self . variant ( ENSTFCNT1_A :: ENSTFCNT1_0 ) } # [ doc = "Startup fault counter enabled." ] # [ inline ( always ) ] pub fn enstfcnt1_1 ( self ) -> & 'a mut W { self . variant ( ENSTFCNT1_A :: ENSTFCNT1_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Unlock. These bits indicate the current FLL unlock condition. These bits are both set as long as the DCOFFG flag is set.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum FLLUNLOCK_A { # [ doc = "0: FLL is locked. No unlock condition currently active." ] FLLUNLOCK_0 = 0 , # [ doc = "1: DCOCLK is currently too slow." ] FLLUNLOCK_1 = 1 , # [ doc = "2: DCOCLK is currently too fast." ] FLLUNLOCK_2 = 2 , # [ doc = "3: DCOERROR. DCO out of range." ] FLLUNLOCK_3 = 3 } impl From < FLLUNLOCK_A > for u8 { # [ inline ( always ) ] fn from ( variant : FLLUNLOCK_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `FLLUNLOCK`" ] pub type FLLUNLOCK_R = crate :: R < u8 , FLLUNLOCK_A > ; impl FLLUNLOCK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> FLLUNLOCK_A { match self . bits { 0 => FLLUNLOCK_A :: FLLUNLOCK_0 , 1 => FLLUNLOCK_A :: FLLUNLOCK_1 , 2 => FLLUNLOCK_A :: FLLUNLOCK_2 , 3 => FLLUNLOCK_A :: FLLUNLOCK_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `FLLUNLOCK_0`" ] # [ inline ( always ) ] pub fn is_fllunlock_0 ( & self ) -> bool { * self == FLLUNLOCK_A :: FLLUNLOCK_0 } # [ doc = "Checks if the value of the field is `FLLUNLOCK_1`" ] # [ inline ( always ) ] pub fn is_fllunlock_1 ( & self ) -> bool { * self == FLLUNLOCK_A :: FLLUNLOCK_1 } # [ doc = "Checks if the value of the field is `FLLUNLOCK_2`" ] # [ inline ( always ) ] pub fn is_fllunlock_2 ( & self ) -> bool { * self == FLLUNLOCK_A :: FLLUNLOCK_2 } # [ doc = "Checks if the value of the field is `FLLUNLOCK_3`" ] # [ inline ( always ) ] pub fn is_fllunlock_3 ( & self ) -> bool { * self == FLLUNLOCK_A :: FLLUNLOCK_3 } }
# [ doc = "Write proxy for field `FLLUNLOCK`" ] pub struct FLLUNLOCK_W < 'a > { w : & 'a mut W , } impl < 'a > FLLUNLOCK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : FLLUNLOCK_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "FLL is locked. No unlock condition currently active." ] # [ inline ( always ) ] pub fn fllunlock_0 ( self ) -> & 'a mut W { self . variant ( FLLUNLOCK_A :: FLLUNLOCK_0 ) } # [ doc = "DCOCLK is currently too slow." ] # [ inline ( always ) ] pub fn fllunlock_1 ( self ) -> & 'a mut W { self . variant ( FLLUNLOCK_A :: FLLUNLOCK_1 ) } # [ doc = "DCOCLK is currently too fast." ] # [ inline ( always ) ] pub fn fllunlock_2 ( self ) -> & 'a mut W { self . variant ( FLLUNLOCK_A :: FLLUNLOCK_2 ) } # [ doc = "DCOERROR. DCO out of range." ] # [ inline ( always ) ] pub fn fllunlock_3 ( self ) -> & 'a mut W { self . variant ( FLLUNLOCK_A :: FLLUNLOCK_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Unlock history bits. These bits indicate the FLL unlock condition history. As soon as any unlock condition happens, the respective bits are set and remain set until cleared by software by writing 0 to it or by a POR.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum FLLUNLOCKHIS_A { # [ doc = "0: FLL is locked. No unlock situation has been detected since the last reset of these bits." ] FLLUNLOCKHIS_0 = 0 , # [ doc = "1: DCOCLK has been too slow since the bits were cleared." ] FLLUNLOCKHIS_1 = 1 , # [ doc = "2: DCOCLK has been too fast since the bits were cleared." ] FLLUNLOCKHIS_2 = 2 , # [ doc = "3: DCOCLK has been both too fast and too slow since the bits were cleared." ] FLLUNLOCKHIS_3 = 3 } impl From < FLLUNLOCKHIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : FLLUNLOCKHIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `FLLUNLOCKHIS`" ] pub type FLLUNLOCKHIS_R = crate :: R < u8 , FLLUNLOCKHIS_A > ; impl FLLUNLOCKHIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> FLLUNLOCKHIS_A { match self . bits { 0 => FLLUNLOCKHIS_A :: FLLUNLOCKHIS_0 , 1 => FLLUNLOCKHIS_A :: FLLUNLOCKHIS_1 , 2 => FLLUNLOCKHIS_A :: FLLUNLOCKHIS_2 , 3 => FLLUNLOCKHIS_A :: FLLUNLOCKHIS_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `FLLUNLOCKHIS_0`" ] # [ inline ( always ) ] pub fn is_fllunlockhis_0 ( & self ) -> bool { * self == FLLUNLOCKHIS_A :: FLLUNLOCKHIS_0 } # [ doc = "Checks if the value of the field is `FLLUNLOCKHIS_1`" ] # [ inline ( always ) ] pub fn is_fllunlockhis_1 ( & self ) -> bool { * self == FLLUNLOCKHIS_A :: FLLUNLOCKHIS_1 } # [ doc = "Checks if the value of the field is `FLLUNLOCKHIS_2`" ] # [ inline ( always ) ] pub fn is_fllunlockhis_2 ( & self ) -> bool { * self == FLLUNLOCKHIS_A :: FLLUNLOCKHIS_2 } # [ doc = "Checks if the value of the field is `FLLUNLOCKHIS_3`" ] # [ inline ( always ) ] pub fn is_fllunlockhis_3 ( & self ) -> bool { * self == FLLUNLOCKHIS_A :: FLLUNLOCKHIS_3 } }
# [ doc = "Write proxy for field `FLLUNLOCKHIS`" ] pub struct FLLUNLOCKHIS_W < 'a > { w : & 'a mut W , } impl < 'a > FLLUNLOCKHIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : FLLUNLOCKHIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "FLL is locked. No unlock situation has been detected since the last reset of these bits." ] # [ inline ( always ) ] pub fn fllunlockhis_0 ( self ) -> & 'a mut W { self . variant ( FLLUNLOCKHIS_A :: FLLUNLOCKHIS_0 ) } # [ doc = "DCOCLK has been too slow since the bits were cleared." ] # [ inline ( always ) ] pub fn fllunlockhis_1 ( self ) -> & 'a mut W { self . variant ( FLLUNLOCKHIS_A :: FLLUNLOCKHIS_1 ) } # [ doc = "DCOCLK has been too fast since the bits were cleared." ] # [ inline ( always ) ] pub fn fllunlockhis_2 ( self ) -> & 'a mut W { self . variant ( FLLUNLOCKHIS_A :: FLLUNLOCKHIS_2 ) } # [ doc = "DCOCLK has been both too fast and too slow since the bits were cleared." ] # [ inline ( always ) ] pub fn fllunlockhis_3 ( self ) -> & 'a mut W { self . variant ( FLLUNLOCKHIS_A :: FLLUNLOCKHIS_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u16 ) & 0x03 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `FLLULPUC`" ] pub type FLLULPUC_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FLLULPUC`" ] pub struct FLLULPUC_W < 'a > { w : & 'a mut W , } impl < 'a > FLLULPUC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Warning enable. If this bit is set, an interrupt is generated based on the FLLUNLOCKHIS bits. If FLLUNLOCKHIS is not equal to 00, an OFIFG is generated.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FLLWARNEN_A { # [ doc = "0: FLLUNLOCKHIS status cannot set OFIFG." ] FLLWARNEN_0 = 0 , # [ doc = "1: FLLUNLOCKHIS status can set OFIFG." ] FLLWARNEN_1 = 1 } impl From < FLLWARNEN_A > for bool { # [ inline ( always ) ] fn from ( variant : FLLWARNEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `FLLWARNEN`" ] pub type FLLWARNEN_R = crate :: R < bool , FLLWARNEN_A > ; impl FLLWARNEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> FLLWARNEN_A { match self . bits { false => FLLWARNEN_A :: FLLWARNEN_0 , true => FLLWARNEN_A :: FLLWARNEN_1 } } # [ doc = "Checks if the value of the field is `FLLWARNEN_0`" ] # [ inline ( always ) ] pub fn is_fllwarnen_0 ( & self ) -> bool { * self == FLLWARNEN_A :: FLLWARNEN_0 } # [ doc = "Checks if the value of the field is `FLLWARNEN_1`" ] # [ inline ( always ) ] pub fn is_fllwarnen_1 ( & self ) -> bool { * self == FLLWARNEN_A :: FLLWARNEN_1 } }
# [ doc = "Write proxy for field `FLLWARNEN`" ] pub struct FLLWARNEN_W < 'a > { w : & 'a mut W , } impl < 'a > FLLWARNEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : FLLWARNEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "FLLUNLOCKHIS status cannot set OFIFG." ] # [ inline ( always ) ] pub fn fllwarnen_0 ( self ) -> & 'a mut W { self . variant ( FLLWARNEN_A :: FLLWARNEN_0 ) } # [ doc = "FLLUNLOCKHIS status can set OFIFG." ] # [ inline ( always ) ] pub fn fllwarnen_1 ( self ) -> & 'a mut W { self . variant ( FLLWARNEN_A :: FLLWARNEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
impl R {
# [ doc = "Bit 2 - REFO ready flag. This bit reflects the REFO readiness whent REFO is good for operation (such as FLL reference)" ] # [ inline ( always ) ] pub fn refoready ( & self ) -> REFOREADY_R { REFOREADY_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 0 - DCO fault flag. If this bit is set, the OFIFG flag is also set. The DCOFFG bit is set if DCO = {0} or DCO = {511}. DCOFFG can be cleared by software. If the DCO fault condition still remains, DCOFFG is set. As long as DCOFFG is set, FLLUNLOCK shows the DCOERROR condition." ] # [ inline ( always ) ] pub fn dcoffg ( & self ) -> DCOFFG_R { DCOFFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - T1 oscillator fault flag. If this bit is set, the OFIFG flag is also set. XT1OFFG is set if a XT1 fault condition exists. XT1OFFG can be cleared by software. If the XT1 fault condition still remains, XT1OFFG is set." ] # [ inline ( always ) ] pub fn xt1offg ( & self ) -> XT1OFFG_R { XT1OFFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - FLL unlock interrupt flag. This flag is set when FLLUNLOCK bits equal 10b (DCO too fast). If FLLULPUC is also set, a PUC is triggered when FLLUIFG is set." ] # [ inline ( always ) ] pub fn fllulifg ( & self ) -> FLLULIFG_R { FLLULIFG_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Enable start counter for XT1." ] # [ inline ( always ) ] pub fn enstfcnt1 ( & self ) -> ENSTFCNT1_R { ENSTFCNT1_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:9 - Unlock. These bits indicate the current FLL unlock condition. These bits are both set as long as the DCOFFG flag is set." ] # [ inline ( always ) ] pub fn fllunlock ( & self ) -> FLLUNLOCK_R { FLLUNLOCK_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 10:11 - Unlock history bits. These bits indicate the FLL unlock condition history. As soon as any unlock condition happens, the respective bits are set and remain set until cleared by software by writing 0 to it or by a POR." ] # [ inline ( always ) ] pub fn fllunlockhis ( & self ) -> FLLUNLOCKHIS_R { FLLUNLOCKHIS_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 12 - FLL unlock PUC enable. If the FLLULPUC bit is set, a reset (PUC) is triggered if FLLULIFG is set. FLLULIFG indicates when FLLUNLOCK bits equal 10 (too fast). FLLULPUC is automatically cleared upon servicing the event. If FLLULPUC is cleared (0), no PUC can be triggered by FLLULIFG." ] # [ inline ( always ) ] pub fn fllulpuc ( & self ) -> FLLULPUC_R { FLLULPUC_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Warning enable. If this bit is set, an interrupt is generated based on the FLLUNLOCKHIS bits. If FLLUNLOCKHIS is not equal to 00, an OFIFG is generated." ] # [ inline ( always ) ] pub fn fllwarnen ( & self ) -> FLLWARNEN_R { FLLWARNEN_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - DCO fault flag. If this bit is set, the OFIFG flag is also set. The DCOFFG bit is set if DCO = {0} or DCO = {511}. DCOFFG can be cleared by software. If the DCO fault condition still remains, DCOFFG is set. As long as DCOFFG is set, FLLUNLOCK shows the DCOERROR condition." ] # [ inline ( always ) ] pub fn dcoffg ( & mut self ) -> DCOFFG_W { DCOFFG_W { w : self } }
# [ doc = "Bit 1 - T1 oscillator fault flag. If this bit is set, the OFIFG flag is also set. XT1OFFG is set if a XT1 fault condition exists. XT1OFFG can be cleared by software. If the XT1 fault condition still remains, XT1OFFG is set." ] # [ inline ( always ) ] pub fn xt1offg ( & mut self ) -> XT1OFFG_W { XT1OFFG_W { w : self } }
# [ doc = "Bit 4 - FLL unlock interrupt flag. This flag is set when FLLUNLOCK bits equal 10b (DCO too fast). If FLLULPUC is also set, a PUC is triggered when FLLUIFG is set." ] # [ inline ( always ) ] pub fn fllulifg ( & mut self ) -> FLLULIFG_W { FLLULIFG_W { w : self } }
# [ doc = "Bit 6 - Enable start counter for XT1." ] # [ inline ( always ) ] pub fn enstfcnt1 ( & mut self ) -> ENSTFCNT1_W { ENSTFCNT1_W { w : self } }
# [ doc = "Bits 8:9 - Unlock. These bits indicate the current FLL unlock condition. These bits are both set as long as the DCOFFG flag is set." ] # [ inline ( always ) ] pub fn fllunlock ( & mut self ) -> FLLUNLOCK_W { FLLUNLOCK_W { w : self } }
# [ doc = "Bits 10:11 - Unlock history bits. These bits indicate the FLL unlock condition history. As soon as any unlock condition happens, the respective bits are set and remain set until cleared by software by writing 0 to it or by a POR." ] # [ inline ( always ) ] pub fn fllunlockhis ( & mut self ) -> FLLUNLOCKHIS_W { FLLUNLOCKHIS_W { w : self } }
# [ doc = "Bit 12 - FLL unlock PUC enable. If the FLLULPUC bit is set, a reset (PUC) is triggered if FLLULIFG is set. FLLULIFG indicates when FLLUNLOCK bits equal 10 (too fast). FLLULPUC is automatically cleared upon servicing the event. If FLLULPUC is cleared (0), no PUC can be triggered by FLLULIFG." ] # [ inline ( always ) ] pub fn fllulpuc ( & mut self ) -> FLLULPUC_W { FLLULPUC_W { w : self } }
# [ doc = "Bit 13 - Warning enable. If this bit is set, an interrupt is generated based on the FLLUNLOCKHIS bits. If FLLUNLOCKHIS is not equal to 00, an OFIFG is generated." ] # [ inline ( always ) ] pub fn fllwarnen ( & mut self ) -> FLLWARNEN_W { FLLWARNEN_W { w : self } }
}
}
# [ doc = "Clock System Control Register 8\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csctl8](csctl8) module" ] pub type CSCTL8 = crate :: Reg < u16 , _CSCTL8 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CSCTL8 ;
# [ doc = "`read()` method returns [csctl8::R](csctl8::R) reader structure" ] impl crate :: Readable for CSCTL8 { }
# [ doc = "`write(|w| ..)` method takes [csctl8::W](csctl8::W) writer structure" ] impl crate :: Writable for CSCTL8 { }
# [ doc = "Clock System Control Register 8" ] pub mod csctl8 {
# [ doc = "Reader of register CSCTL8" ] pub type R = crate :: R < u16 , super :: CSCTL8 > ;
# [ doc = "Writer for register CSCTL8" ] pub type W = crate :: W < u16 , super :: CSCTL8 > ;
# [ doc = "Register CSCTL8 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CSCTL8 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "ACLK clock request enable. Setting this enables conditional module requests for ACLK\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ACLKREQEN_A { # [ doc = "0: ACLK conditional requests are disabled." ] ACLKREQEN_0 = 0 , # [ doc = "1: ACLK conditional requests are enabled." ] ACLKREQEN_1 = 1 } impl From < ACLKREQEN_A > for bool { # [ inline ( always ) ] fn from ( variant : ACLKREQEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ACLKREQEN`" ] pub type ACLKREQEN_R = crate :: R < bool , ACLKREQEN_A > ; impl ACLKREQEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ACLKREQEN_A { match self . bits { false => ACLKREQEN_A :: ACLKREQEN_0 , true => ACLKREQEN_A :: ACLKREQEN_1 } } # [ doc = "Checks if the value of the field is `ACLKREQEN_0`" ] # [ inline ( always ) ] pub fn is_aclkreqen_0 ( & self ) -> bool { * self == ACLKREQEN_A :: ACLKREQEN_0 } # [ doc = "Checks if the value of the field is `ACLKREQEN_1`" ] # [ inline ( always ) ] pub fn is_aclkreqen_1 ( & self ) -> bool { * self == ACLKREQEN_A :: ACLKREQEN_1 } }
# [ doc = "Write proxy for field `ACLKREQEN`" ] pub struct ACLKREQEN_W < 'a > { w : & 'a mut W , } impl < 'a > ACLKREQEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ACLKREQEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "ACLK conditional requests are disabled." ] # [ inline ( always ) ] pub fn aclkreqen_0 ( self ) -> & 'a mut W { self . variant ( ACLKREQEN_A :: ACLKREQEN_0 ) } # [ doc = "ACLK conditional requests are enabled." ] # [ inline ( always ) ] pub fn aclkreqen_1 ( self ) -> & 'a mut W { self . variant ( ACLKREQEN_A :: ACLKREQEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "MCLK clock request enable. Setting this enables conditional module requests for MCLK\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MCLKREQEN_A { # [ doc = "0: MCLK conditional requests are disabled." ] MCLKREQEN_0 = 0 , # [ doc = "1: MCLK conditional requests are enabled." ] MCLKREQEN_1 = 1 } impl From < MCLKREQEN_A > for bool { # [ inline ( always ) ] fn from ( variant : MCLKREQEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `MCLKREQEN`" ] pub type MCLKREQEN_R = crate :: R < bool , MCLKREQEN_A > ; impl MCLKREQEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MCLKREQEN_A { match self . bits { false => MCLKREQEN_A :: MCLKREQEN_0 , true => MCLKREQEN_A :: MCLKREQEN_1 } } # [ doc = "Checks if the value of the field is `MCLKREQEN_0`" ] # [ inline ( always ) ] pub fn is_mclkreqen_0 ( & self ) -> bool { * self == MCLKREQEN_A :: MCLKREQEN_0 } # [ doc = "Checks if the value of the field is `MCLKREQEN_1`" ] # [ inline ( always ) ] pub fn is_mclkreqen_1 ( & self ) -> bool { * self == MCLKREQEN_A :: MCLKREQEN_1 } }
# [ doc = "Write proxy for field `MCLKREQEN`" ] pub struct MCLKREQEN_W < 'a > { w : & 'a mut W , } impl < 'a > MCLKREQEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MCLKREQEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "MCLK conditional requests are disabled." ] # [ inline ( always ) ] pub fn mclkreqen_0 ( self ) -> & 'a mut W { self . variant ( MCLKREQEN_A :: MCLKREQEN_0 ) } # [ doc = "MCLK conditional requests are enabled." ] # [ inline ( always ) ] pub fn mclkreqen_1 ( self ) -> & 'a mut W { self . variant ( MCLKREQEN_A :: MCLKREQEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "SMCLK clock request enable. Setting this enables conditional module requests for SMCLK\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SMCLKREQEN_A { # [ doc = "0: SMCLK conditional requests are disabled." ] SMCLKREQEN_0 = 0 , # [ doc = "1: SMCLK conditional requests are enabled." ] SMCLKREQEN_1 = 1 } impl From < SMCLKREQEN_A > for bool { # [ inline ( always ) ] fn from ( variant : SMCLKREQEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SMCLKREQEN`" ] pub type SMCLKREQEN_R = crate :: R < bool , SMCLKREQEN_A > ; impl SMCLKREQEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SMCLKREQEN_A { match self . bits { false => SMCLKREQEN_A :: SMCLKREQEN_0 , true => SMCLKREQEN_A :: SMCLKREQEN_1 } } # [ doc = "Checks if the value of the field is `SMCLKREQEN_0`" ] # [ inline ( always ) ] pub fn is_smclkreqen_0 ( & self ) -> bool { * self == SMCLKREQEN_A :: SMCLKREQEN_0 } # [ doc = "Checks if the value of the field is `SMCLKREQEN_1`" ] # [ inline ( always ) ] pub fn is_smclkreqen_1 ( & self ) -> bool { * self == SMCLKREQEN_A :: SMCLKREQEN_1 } }
# [ doc = "Write proxy for field `SMCLKREQEN`" ] pub struct SMCLKREQEN_W < 'a > { w : & 'a mut W , } impl < 'a > SMCLKREQEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SMCLKREQEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SMCLK conditional requests are disabled." ] # [ inline ( always ) ] pub fn smclkreqen_0 ( self ) -> & 'a mut W { self . variant ( SMCLKREQEN_A :: SMCLKREQEN_0 ) } # [ doc = "SMCLK conditional requests are enabled." ] # [ inline ( always ) ] pub fn smclkreqen_1 ( self ) -> & 'a mut W { self . variant ( SMCLKREQEN_A :: SMCLKREQEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "MODOSC clock request enable. Setting this enables conditional module requests for MODOSC.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODOSCREQEN_A { # [ doc = "0: MODOSC conditional requests are disabled." ] MODOSCREQEN_0 = 0 , # [ doc = "1: MODOSC conditional requests are enabled." ] MODOSCREQEN_1 = 1 } impl From < MODOSCREQEN_A > for bool { # [ inline ( always ) ] fn from ( variant : MODOSCREQEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `MODOSCREQEN`" ] pub type MODOSCREQEN_R = crate :: R < bool , MODOSCREQEN_A > ; impl MODOSCREQEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MODOSCREQEN_A { match self . bits { false => MODOSCREQEN_A :: MODOSCREQEN_0 , true => MODOSCREQEN_A :: MODOSCREQEN_1 } } # [ doc = "Checks if the value of the field is `MODOSCREQEN_0`" ] # [ inline ( always ) ] pub fn is_modoscreqen_0 ( & self ) -> bool { * self == MODOSCREQEN_A :: MODOSCREQEN_0 } # [ doc = "Checks if the value of the field is `MODOSCREQEN_1`" ] # [ inline ( always ) ] pub fn is_modoscreqen_1 ( & self ) -> bool { * self == MODOSCREQEN_A :: MODOSCREQEN_1 } }
# [ doc = "Write proxy for field `MODOSCREQEN`" ] pub struct MODOSCREQEN_W < 'a > { w : & 'a mut W , } impl < 'a > MODOSCREQEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MODOSCREQEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "MODOSC conditional requests are disabled." ] # [ inline ( always ) ] pub fn modoscreqen_0 ( self ) -> & 'a mut W { self . variant ( MODOSCREQEN_A :: MODOSCREQEN_0 ) } # [ doc = "MODOSC conditional requests are enabled." ] # [ inline ( always ) ] pub fn modoscreqen_1 ( self ) -> & 'a mut W { self . variant ( MODOSCREQEN_A :: MODOSCREQEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - ACLK clock request enable. Setting this enables conditional module requests for ACLK" ] # [ inline ( always ) ] pub fn aclkreqen ( & self ) -> ACLKREQEN_R { ACLKREQEN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - MCLK clock request enable. Setting this enables conditional module requests for MCLK" ] # [ inline ( always ) ] pub fn mclkreqen ( & self ) -> MCLKREQEN_R { MCLKREQEN_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - SMCLK clock request enable. Setting this enables conditional module requests for SMCLK" ] # [ inline ( always ) ] pub fn smclkreqen ( & self ) -> SMCLKREQEN_R { SMCLKREQEN_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - MODOSC clock request enable. Setting this enables conditional module requests for MODOSC." ] # [ inline ( always ) ] pub fn modoscreqen ( & self ) -> MODOSCREQEN_R { MODOSCREQEN_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - ACLK clock request enable. Setting this enables conditional module requests for ACLK" ] # [ inline ( always ) ] pub fn aclkreqen ( & mut self ) -> ACLKREQEN_W { ACLKREQEN_W { w : self } }
# [ doc = "Bit 1 - MCLK clock request enable. Setting this enables conditional module requests for MCLK" ] # [ inline ( always ) ] pub fn mclkreqen ( & mut self ) -> MCLKREQEN_W { MCLKREQEN_W { w : self } }
# [ doc = "Bit 2 - SMCLK clock request enable. Setting this enables conditional module requests for SMCLK" ] # [ inline ( always ) ] pub fn smclkreqen ( & mut self ) -> SMCLKREQEN_W { SMCLKREQEN_W { w : self } }
# [ doc = "Bit 3 - MODOSC clock request enable. Setting this enables conditional module requests for MODOSC." ] # [ inline ( always ) ] pub fn modoscreqen ( & mut self ) -> MODOSCREQEN_W { MODOSCREQEN_W { w : self } }
}
}
}
# [ doc = "FRCTL" ] pub struct FRCTL { _marker : PhantomData < * const ( ) > } unsafe impl Send for FRCTL { } impl FRCTL { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const frctl :: RegisterBlock { 0x01a0 as * const _ } } impl Deref for FRCTL { type Target = frctl :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * FRCTL :: ptr ( ) } } }
# [ doc = "FRCTL" ] pub mod frctl {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - FRAM Controller Control Register 0" ] pub frctl0 : FRCTL0 , _reserved1 : [ u8 ; 2usize ] , # [ doc = "0x04 - General Control Register 0" ] pub gcctl0 : GCCTL0 , # [ doc = "0x06 - General Control Register 1" ] pub gcctl1 : GCCTL1 , }
# [ doc = "FRAM Controller Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [frctl0](frctl0) module" ] pub type FRCTL0 = crate :: Reg < u16 , _FRCTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _FRCTL0 ;
# [ doc = "`read()` method returns [frctl0::R](frctl0::R) reader structure" ] impl crate :: Readable for FRCTL0 { }
# [ doc = "`write(|w| ..)` method takes [frctl0::W](frctl0::W) writer structure" ] impl crate :: Writable for FRCTL0 { }
# [ doc = "FRAM Controller Control Register 0" ] pub mod frctl0 {
# [ doc = "Reader of register FRCTL0" ] pub type R = crate :: R < u16 , super :: FRCTL0 > ;
# [ doc = "Writer for register FRCTL0" ] pub type W = crate :: W < u16 , super :: FRCTL0 > ;
# [ doc = "Register FRCTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: FRCTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Wait state numbers\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum NWAITS_A { # [ doc = "0: FRAM wait states: 0" ] NWAITS_0 = 0 , # [ doc = "1: FRAM wait states: 1" ] NWAITS_1 = 1 , # [ doc = "2: FRAM wait states: 2" ] NWAITS_2 = 2 , # [ doc = "3: FRAM wait states: 3" ] NWAITS_3 = 3 , # [ doc = "4: FRAM wait states: 4" ] NWAITS_4 = 4 , # [ doc = "5: FRAM wait states: 5" ] NWAITS_5 = 5 , # [ doc = "6: FRAM wait states: 6" ] NWAITS_6 = 6 , # [ doc = "7: FRAM wait states: 7" ] NWAITS_7 = 7 } impl From < NWAITS_A > for u8 { # [ inline ( always ) ] fn from ( variant : NWAITS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `NWAITS`" ] pub type NWAITS_R = crate :: R < u8 , NWAITS_A > ; impl NWAITS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> NWAITS_A { match self . bits { 0 => NWAITS_A :: NWAITS_0 , 1 => NWAITS_A :: NWAITS_1 , 2 => NWAITS_A :: NWAITS_2 , 3 => NWAITS_A :: NWAITS_3 , 4 => NWAITS_A :: NWAITS_4 , 5 => NWAITS_A :: NWAITS_5 , 6 => NWAITS_A :: NWAITS_6 , 7 => NWAITS_A :: NWAITS_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NWAITS_0`" ] # [ inline ( always ) ] pub fn is_nwaits_0 ( & self ) -> bool { * self == NWAITS_A :: NWAITS_0 } # [ doc = "Checks if the value of the field is `NWAITS_1`" ] # [ inline ( always ) ] pub fn is_nwaits_1 ( & self ) -> bool { * self == NWAITS_A :: NWAITS_1 } # [ doc = "Checks if the value of the field is `NWAITS_2`" ] # [ inline ( always ) ] pub fn is_nwaits_2 ( & self ) -> bool { * self == NWAITS_A :: NWAITS_2 } # [ doc = "Checks if the value of the field is `NWAITS_3`" ] # [ inline ( always ) ] pub fn is_nwaits_3 ( & self ) -> bool { * self == NWAITS_A :: NWAITS_3 } # [ doc = "Checks if the value of the field is `NWAITS_4`" ] # [ inline ( always ) ] pub fn is_nwaits_4 ( & self ) -> bool { * self == NWAITS_A :: NWAITS_4 } # [ doc = "Checks if the value of the field is `NWAITS_5`" ] # [ inline ( always ) ] pub fn is_nwaits_5 ( & self ) -> bool { * self == NWAITS_A :: NWAITS_5 } # [ doc = "Checks if the value of the field is `NWAITS_6`" ] # [ inline ( always ) ] pub fn is_nwaits_6 ( & self ) -> bool { * self == NWAITS_A :: NWAITS_6 } # [ doc = "Checks if the value of the field is `NWAITS_7`" ] # [ inline ( always ) ] pub fn is_nwaits_7 ( & self ) -> bool { * self == NWAITS_A :: NWAITS_7 } }
# [ doc = "Write proxy for field `NWAITS`" ] pub struct NWAITS_W < 'a > { w : & 'a mut W , } impl < 'a > NWAITS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NWAITS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "FRAM wait states: 0" ] # [ inline ( always ) ] pub fn nwaits_0 ( self ) -> & 'a mut W { self . variant ( NWAITS_A :: NWAITS_0 ) } # [ doc = "FRAM wait states: 1" ] # [ inline ( always ) ] pub fn nwaits_1 ( self ) -> & 'a mut W { self . variant ( NWAITS_A :: NWAITS_1 ) } # [ doc = "FRAM wait states: 2" ] # [ inline ( always ) ] pub fn nwaits_2 ( self ) -> & 'a mut W { self . variant ( NWAITS_A :: NWAITS_2 ) } # [ doc = "FRAM wait states: 3" ] # [ inline ( always ) ] pub fn nwaits_3 ( self ) -> & 'a mut W { self . variant ( NWAITS_A :: NWAITS_3 ) } # [ doc = "FRAM wait states: 4" ] # [ inline ( always ) ] pub fn nwaits_4 ( self ) -> & 'a mut W { self . variant ( NWAITS_A :: NWAITS_4 ) } # [ doc = "FRAM wait states: 5" ] # [ inline ( always ) ] pub fn nwaits_5 ( self ) -> & 'a mut W { self . variant ( NWAITS_A :: NWAITS_5 ) } # [ doc = "FRAM wait states: 6" ] # [ inline ( always ) ] pub fn nwaits_6 ( self ) -> & 'a mut W { self . variant ( NWAITS_A :: NWAITS_6 ) } # [ doc = "FRAM wait states: 7" ] # [ inline ( always ) ] pub fn nwaits_7 ( self ) -> & 'a mut W { self . variant ( NWAITS_A :: NWAITS_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 4 ) ) | ( ( ( value as u16 ) & 0x07 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `FRCTLPW`" ] pub type FRCTLPW_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `FRCTLPW`" ] pub struct FRCTLPW_W < 'a > { w : & 'a mut W , } impl < 'a > FRCTLPW_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 8 ) ) | ( ( ( value as u16 ) & 0xff ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 4:6 - Wait state numbers" ] # [ inline ( always ) ] pub fn nwaits ( & self ) -> NWAITS_R { NWAITS_R :: new ( ( ( self . bits >> 4 ) & 0x07 ) as u8 ) }
# [ doc = "Bits 8:15 - FRCTLPW password" ] # [ inline ( always ) ] pub fn frctlpw ( & self ) -> FRCTLPW_R { FRCTLPW_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 4:6 - Wait state numbers" ] # [ inline ( always ) ] pub fn nwaits ( & mut self ) -> NWAITS_W { NWAITS_W { w : self } }
# [ doc = "Bits 8:15 - FRCTLPW password" ] # [ inline ( always ) ] pub fn frctlpw ( & mut self ) -> FRCTLPW_W { FRCTLPW_W { w : self } }
}
}
# [ doc = "General Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gcctl0](gcctl0) module" ] pub type GCCTL0 = crate :: Reg < u16 , _GCCTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _GCCTL0 ;
# [ doc = "`read()` method returns [gcctl0::R](gcctl0::R) reader structure" ] impl crate :: Readable for GCCTL0 { }
# [ doc = "`write(|w| ..)` method takes [gcctl0::W](gcctl0::W) writer structure" ] impl crate :: Writable for GCCTL0 { }
# [ doc = "General Control Register 0" ] pub mod gcctl0 {
# [ doc = "Reader of register GCCTL0" ] pub type R = crate :: R < u16 , super :: GCCTL0 > ;
# [ doc = "Writer for register GCCTL0" ] pub type W = crate :: W < u16 , super :: GCCTL0 > ;
# [ doc = "Register GCCTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: GCCTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Enable Power Up Clear (PUC) reset for the uncorrectable bit error detection flag (UBDIFG)\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UBDRSTEN_A { # [ doc = "0: PUC not initiated on uncorrectable bit error detection flag." ] UBDRSTEN_0 = 0 , # [ doc = "1: PUC initiated on uncorrectable bit error detection flag. Generates vector in SYSRSTIV. Clear the UBDIE bit." ] UBDRSTEN_1 = 1 } impl From < UBDRSTEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UBDRSTEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UBDRSTEN`" ] pub type UBDRSTEN_R = crate :: R < bool , UBDRSTEN_A > ; impl UBDRSTEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UBDRSTEN_A { match self . bits { false => UBDRSTEN_A :: UBDRSTEN_0 , true => UBDRSTEN_A :: UBDRSTEN_1 } } # [ doc = "Checks if the value of the field is `UBDRSTEN_0`" ] # [ inline ( always ) ] pub fn is_ubdrsten_0 ( & self ) -> bool { * self == UBDRSTEN_A :: UBDRSTEN_0 } # [ doc = "Checks if the value of the field is `UBDRSTEN_1`" ] # [ inline ( always ) ] pub fn is_ubdrsten_1 ( & self ) -> bool { * self == UBDRSTEN_A :: UBDRSTEN_1 } }
# [ doc = "Write proxy for field `UBDRSTEN`" ] pub struct UBDRSTEN_W < 'a > { w : & 'a mut W , } impl < 'a > UBDRSTEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UBDRSTEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "PUC not initiated on uncorrectable bit error detection flag." ] # [ inline ( always ) ] pub fn ubdrsten_0 ( self ) -> & 'a mut W { self . variant ( UBDRSTEN_A :: UBDRSTEN_0 ) } # [ doc = "PUC initiated on uncorrectable bit error detection flag. Generates vector in SYSRSTIV. Clear the UBDIE bit." ] # [ inline ( always ) ] pub fn ubdrsten_1 ( self ) -> & 'a mut W { self . variant ( UBDRSTEN_A :: UBDRSTEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Enable NMI event for the uncorrectable bit error detection flag (UBDIFG)\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UBDIE_A { # [ doc = "0: Disable NMI for the uncorrectable bit error detection flag (UBDIFG)." ] UBDIE_0 = 0 , # [ doc = "1: Enable NMI for the uncorrectable bit error detection flag (UBDIFG). Generates vector in SYSSNIV. Clear the UBDRSTEN bit." ] UBDIE_1 = 1 } impl From < UBDIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UBDIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UBDIE`" ] pub type UBDIE_R = crate :: R < bool , UBDIE_A > ; impl UBDIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UBDIE_A { match self . bits { false => UBDIE_A :: UBDIE_0 , true => UBDIE_A :: UBDIE_1 } } # [ doc = "Checks if the value of the field is `UBDIE_0`" ] # [ inline ( always ) ] pub fn is_ubdie_0 ( & self ) -> bool { * self == UBDIE_A :: UBDIE_0 } # [ doc = "Checks if the value of the field is `UBDIE_1`" ] # [ inline ( always ) ] pub fn is_ubdie_1 ( & self ) -> bool { * self == UBDIE_A :: UBDIE_1 } }
# [ doc = "Write proxy for field `UBDIE`" ] pub struct UBDIE_W < 'a > { w : & 'a mut W , } impl < 'a > UBDIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UBDIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disable NMI for the uncorrectable bit error detection flag (UBDIFG)." ] # [ inline ( always ) ] pub fn ubdie_0 ( self ) -> & 'a mut W { self . variant ( UBDIE_A :: UBDIE_0 ) } # [ doc = "Enable NMI for the uncorrectable bit error detection flag (UBDIFG). Generates vector in SYSSNIV. Clear the UBDRSTEN bit." ] # [ inline ( always ) ] pub fn ubdie_1 ( self ) -> & 'a mut W { self . variant ( UBDIE_A :: UBDIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Enable NMI event for the correctable bit error detection flag (CBDIFG)\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CBDIE_A { # [ doc = "0: Disable NMI for the correctable bit error detection flag (CBDIFG)." ] CBDIE_0 = 0 , # [ doc = "1: Disable NMI for the correctable bit error detection flag (CBDIFG). Generates vector in SYSSNIV." ] CBDIE_1 = 1 } impl From < CBDIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CBDIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CBDIE`" ] pub type CBDIE_R = crate :: R < bool , CBDIE_A > ; impl CBDIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CBDIE_A { match self . bits { false => CBDIE_A :: CBDIE_0 , true => CBDIE_A :: CBDIE_1 } } # [ doc = "Checks if the value of the field is `CBDIE_0`" ] # [ inline ( always ) ] pub fn is_cbdie_0 ( & self ) -> bool { * self == CBDIE_A :: CBDIE_0 } # [ doc = "Checks if the value of the field is `CBDIE_1`" ] # [ inline ( always ) ] pub fn is_cbdie_1 ( & self ) -> bool { * self == CBDIE_A :: CBDIE_1 } }
# [ doc = "Write proxy for field `CBDIE`" ] pub struct CBDIE_W < 'a > { w : & 'a mut W , } impl < 'a > CBDIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CBDIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disable NMI for the correctable bit error detection flag (CBDIFG)." ] # [ inline ( always ) ] pub fn cbdie_0 ( self ) -> & 'a mut W { self . variant ( CBDIE_A :: CBDIE_0 ) } # [ doc = "Disable NMI for the correctable bit error detection flag (CBDIFG). Generates vector in SYSSNIV." ] # [ inline ( always ) ] pub fn cbdie_1 ( self ) -> & 'a mut W { self . variant ( CBDIE_A :: CBDIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "FRAM Memory Power Control Request\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FRPWR_A { # [ doc = "0: Enable INACTIVE mode." ] FRPWR_0 = 0 , # [ doc = "1: Enable ACTIVE mode." ] FRPWR_1 = 1 } impl From < FRPWR_A > for bool { # [ inline ( always ) ] fn from ( variant : FRPWR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `FRPWR`" ] pub type FRPWR_R = crate :: R < bool , FRPWR_A > ; impl FRPWR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> FRPWR_A { match self . bits { false => FRPWR_A :: FRPWR_0 , true => FRPWR_A :: FRPWR_1 } } # [ doc = "Checks if the value of the field is `FRPWR_0`" ] # [ inline ( always ) ] pub fn is_frpwr_0 ( & self ) -> bool { * self == FRPWR_A :: FRPWR_0 } # [ doc = "Checks if the value of the field is `FRPWR_1`" ] # [ inline ( always ) ] pub fn is_frpwr_1 ( & self ) -> bool { * self == FRPWR_A :: FRPWR_1 } }
# [ doc = "Write proxy for field `FRPWR`" ] pub struct FRPWR_W < 'a > { w : & 'a mut W , } impl < 'a > FRPWR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : FRPWR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Enable INACTIVE mode." ] # [ inline ( always ) ] pub fn frpwr_0 ( self ) -> & 'a mut W { self . variant ( FRPWR_A :: FRPWR_0 ) } # [ doc = "Enable ACTIVE mode." ] # [ inline ( always ) ] pub fn frpwr_1 ( self ) -> & 'a mut W { self . variant ( FRPWR_A :: FRPWR_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Enables FRAM auto power up after LPM\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FRLPMPWR_A { # [ doc = "0: FRAM startup is delayed to the first FRAM access after exit from LPM" ] FRLPMPWR_0 = 0 , # [ doc = "1: FRAM is powered up immediately on exit from LPM" ] FRLPMPWR_1 = 1 } impl From < FRLPMPWR_A > for bool { # [ inline ( always ) ] fn from ( variant : FRLPMPWR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `FRLPMPWR`" ] pub type FRLPMPWR_R = crate :: R < bool , FRLPMPWR_A > ; impl FRLPMPWR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> FRLPMPWR_A { match self . bits { false => FRLPMPWR_A :: FRLPMPWR_0 , true => FRLPMPWR_A :: FRLPMPWR_1 } } # [ doc = "Checks if the value of the field is `FRLPMPWR_0`" ] # [ inline ( always ) ] pub fn is_frlpmpwr_0 ( & self ) -> bool { * self == FRLPMPWR_A :: FRLPMPWR_0 } # [ doc = "Checks if the value of the field is `FRLPMPWR_1`" ] # [ inline ( always ) ] pub fn is_frlpmpwr_1 ( & self ) -> bool { * self == FRLPMPWR_A :: FRLPMPWR_1 } }
# [ doc = "Write proxy for field `FRLPMPWR`" ] pub struct FRLPMPWR_W < 'a > { w : & 'a mut W , } impl < 'a > FRLPMPWR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : FRLPMPWR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "FRAM startup is delayed to the first FRAM access after exit from LPM" ] # [ inline ( always ) ] pub fn frlpmpwr_0 ( self ) -> & 'a mut W { self . variant ( FRLPMPWR_A :: FRLPMPWR_0 ) } # [ doc = "FRAM is powered up immediately on exit from LPM" ] # [ inline ( always ) ] pub fn frlpmpwr_1 ( self ) -> & 'a mut W { self . variant ( FRLPMPWR_A :: FRLPMPWR_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 7 - Enable Power Up Clear (PUC) reset for the uncorrectable bit error detection flag (UBDIFG)" ] # [ inline ( always ) ] pub fn ubdrsten ( & self ) -> UBDRSTEN_R { UBDRSTEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Enable NMI event for the uncorrectable bit error detection flag (UBDIFG)" ] # [ inline ( always ) ] pub fn ubdie ( & self ) -> UBDIE_R { UBDIE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Enable NMI event for the correctable bit error detection flag (CBDIFG)" ] # [ inline ( always ) ] pub fn cbdie ( & self ) -> CBDIE_R { CBDIE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - FRAM Memory Power Control Request" ] # [ inline ( always ) ] pub fn frpwr ( & self ) -> FRPWR_R { FRPWR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Enables FRAM auto power up after LPM" ] # [ inline ( always ) ] pub fn frlpmpwr ( & self ) -> FRLPMPWR_R { FRLPMPWR_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 7 - Enable Power Up Clear (PUC) reset for the uncorrectable bit error detection flag (UBDIFG)" ] # [ inline ( always ) ] pub fn ubdrsten ( & mut self ) -> UBDRSTEN_W { UBDRSTEN_W { w : self } }
# [ doc = "Bit 6 - Enable NMI event for the uncorrectable bit error detection flag (UBDIFG)" ] # [ inline ( always ) ] pub fn ubdie ( & mut self ) -> UBDIE_W { UBDIE_W { w : self } }
# [ doc = "Bit 5 - Enable NMI event for the correctable bit error detection flag (CBDIFG)" ] # [ inline ( always ) ] pub fn cbdie ( & mut self ) -> CBDIE_W { CBDIE_W { w : self } }
# [ doc = "Bit 2 - FRAM Memory Power Control Request" ] # [ inline ( always ) ] pub fn frpwr ( & mut self ) -> FRPWR_W { FRPWR_W { w : self } }
# [ doc = "Bit 1 - Enables FRAM auto power up after LPM" ] # [ inline ( always ) ] pub fn frlpmpwr ( & mut self ) -> FRLPMPWR_W { FRLPMPWR_W { w : self } }
}
}
# [ doc = "General Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gcctl1](gcctl1) module" ] pub type GCCTL1 = crate :: Reg < u16 , _GCCTL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _GCCTL1 ;
# [ doc = "`read()` method returns [gcctl1::R](gcctl1::R) reader structure" ] impl crate :: Readable for GCCTL1 { }
# [ doc = "`write(|w| ..)` method takes [gcctl1::W](gcctl1::W) writer structure" ] impl crate :: Writable for GCCTL1 { }
# [ doc = "General Control Register 1" ] pub mod gcctl1 {
# [ doc = "Reader of register GCCTL1" ] pub type R = crate :: R < u16 , super :: GCCTL1 > ;
# [ doc = "Writer for register GCCTL1" ] pub type W = crate :: W < u16 , super :: GCCTL1 > ;
# [ doc = "Register GCCTL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: GCCTL1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Access time error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ACCTEIFG_A { # [ doc = "0: No interrupt pending." ] ACCTEIFG_0 = 0 , # [ doc = "1: Interrupt pending. Can be cleared by writing '0' or by reading SYSSNIV when it is the highest pending interrupt." ] ACCTEIFG_1 = 1 } impl From < ACCTEIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : ACCTEIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ACCTEIFG`" ] pub type ACCTEIFG_R = crate :: R < bool , ACCTEIFG_A > ; impl ACCTEIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ACCTEIFG_A { match self . bits { false => ACCTEIFG_A :: ACCTEIFG_0 , true => ACCTEIFG_A :: ACCTEIFG_1 } } # [ doc = "Checks if the value of the field is `ACCTEIFG_0`" ] # [ inline ( always ) ] pub fn is_accteifg_0 ( & self ) -> bool { * self == ACCTEIFG_A :: ACCTEIFG_0 } # [ doc = "Checks if the value of the field is `ACCTEIFG_1`" ] # [ inline ( always ) ] pub fn is_accteifg_1 ( & self ) -> bool { * self == ACCTEIFG_A :: ACCTEIFG_1 } }
# [ doc = "Write proxy for field `ACCTEIFG`" ] pub struct ACCTEIFG_W < 'a > { w : & 'a mut W , } impl < 'a > ACCTEIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ACCTEIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending." ] # [ inline ( always ) ] pub fn accteifg_0 ( self ) -> & 'a mut W { self . variant ( ACCTEIFG_A :: ACCTEIFG_0 ) } # [ doc = "Interrupt pending. Can be cleared by writing '0' or by reading SYSSNIV when it is the highest pending interrupt." ] # [ inline ( always ) ] pub fn accteifg_1 ( self ) -> & 'a mut W { self . variant ( ACCTEIFG_A :: ACCTEIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "FRAM uncorrectable bit error detection flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UBDIFG_A { # [ doc = "0: No interrupt pending." ] UBDIFG_0 = 0 , # [ doc = "1: Interrupt pending. Can be cleared by writing '0' or by reading SYSSNIV when it is the highest pending interrupt." ] UBDIFG_1 = 1 } impl From < UBDIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UBDIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UBDIFG`" ] pub type UBDIFG_R = crate :: R < bool , UBDIFG_A > ; impl UBDIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UBDIFG_A { match self . bits { false => UBDIFG_A :: UBDIFG_0 , true => UBDIFG_A :: UBDIFG_1 } } # [ doc = "Checks if the value of the field is `UBDIFG_0`" ] # [ inline ( always ) ] pub fn is_ubdifg_0 ( & self ) -> bool { * self == UBDIFG_A :: UBDIFG_0 } # [ doc = "Checks if the value of the field is `UBDIFG_1`" ] # [ inline ( always ) ] pub fn is_ubdifg_1 ( & self ) -> bool { * self == UBDIFG_A :: UBDIFG_1 } }
# [ doc = "Write proxy for field `UBDIFG`" ] pub struct UBDIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UBDIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UBDIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending." ] # [ inline ( always ) ] pub fn ubdifg_0 ( self ) -> & 'a mut W { self . variant ( UBDIFG_A :: UBDIFG_0 ) } # [ doc = "Interrupt pending. Can be cleared by writing '0' or by reading SYSSNIV when it is the highest pending interrupt." ] # [ inline ( always ) ] pub fn ubdifg_1 ( self ) -> & 'a mut W { self . variant ( UBDIFG_A :: UBDIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "FRAM correctable bit error detection flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CBDIFG_A { # [ doc = "0: No interrupt is pending" ] CBDIFG_0 = 0 , # [ doc = "1: Interrupt pending. Can be cleared by writing '0' or by reading SYSSNIV if it is the highest pending interrupt." ] CBDIFG_1 = 1 } impl From < CBDIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CBDIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CBDIFG`" ] pub type CBDIFG_R = crate :: R < bool , CBDIFG_A > ; impl CBDIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CBDIFG_A { match self . bits { false => CBDIFG_A :: CBDIFG_0 , true => CBDIFG_A :: CBDIFG_1 } } # [ doc = "Checks if the value of the field is `CBDIFG_0`" ] # [ inline ( always ) ] pub fn is_cbdifg_0 ( & self ) -> bool { * self == CBDIFG_A :: CBDIFG_0 } # [ doc = "Checks if the value of the field is `CBDIFG_1`" ] # [ inline ( always ) ] pub fn is_cbdifg_1 ( & self ) -> bool { * self == CBDIFG_A :: CBDIFG_1 } }
# [ doc = "Write proxy for field `CBDIFG`" ] pub struct CBDIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CBDIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CBDIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt is pending" ] # [ inline ( always ) ] pub fn cbdifg_0 ( self ) -> & 'a mut W { self . variant ( CBDIFG_A :: CBDIFG_0 ) } # [ doc = "Interrupt pending. Can be cleared by writing '0' or by reading SYSSNIV if it is the highest pending interrupt." ] # [ inline ( always ) ] pub fn cbdifg_1 ( self ) -> & 'a mut W { self . variant ( CBDIFG_A :: CBDIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 3 - Access time error flag" ] # [ inline ( always ) ] pub fn accteifg ( & self ) -> ACCTEIFG_R { ACCTEIFG_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - FRAM uncorrectable bit error detection flag" ] # [ inline ( always ) ] pub fn ubdifg ( & self ) -> UBDIFG_R { UBDIFG_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - FRAM correctable bit error detection flag" ] # [ inline ( always ) ] pub fn cbdifg ( & self ) -> CBDIFG_R { CBDIFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 3 - Access time error flag" ] # [ inline ( always ) ] pub fn accteifg ( & mut self ) -> ACCTEIFG_W { ACCTEIFG_W { w : self } }
# [ doc = "Bit 2 - FRAM uncorrectable bit error detection flag" ] # [ inline ( always ) ] pub fn ubdifg ( & mut self ) -> UBDIFG_W { UBDIFG_W { w : self } }
# [ doc = "Bit 1 - FRAM correctable bit error detection flag" ] # [ inline ( always ) ] pub fn cbdifg ( & mut self ) -> CBDIFG_W { CBDIFG_W { w : self } }
}
}
}
# [ doc = "CRC" ] pub struct CRC { _marker : PhantomData < * const ( ) > } unsafe impl Send for CRC { } impl CRC { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const crc :: RegisterBlock { 0x01c0 as * const _ } } impl Deref for CRC { type Target = crc :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * CRC :: ptr ( ) } } }
# [ doc = "CRC" ] pub mod crc {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - CRC Data In" ] pub crcdi : CRCDI , # [ doc = "0x02 - CRC Data In Reverse Byte" ] pub crcdirb : CRCDIRB , # [ doc = "0x04 - CRC Initialization and Result" ] pub crcinires : CRCINIRES , # [ doc = "0x06 - CRC Result Reverse" ] pub crcresr : CRCRESR , }
# [ doc = "CRC Data In\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [crcdi](crcdi) module" ] pub type CRCDI = crate :: Reg < u16 , _CRCDI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CRCDI ;
# [ doc = "`read()` method returns [crcdi::R](crcdi::R) reader structure" ] impl crate :: Readable for CRCDI { }
# [ doc = "`write(|w| ..)` method takes [crcdi::W](crcdi::W) writer structure" ] impl crate :: Writable for CRCDI { }
# [ doc = "CRC Data In" ] pub mod crcdi {
# [ doc = "Reader of register CRCDI" ] pub type R = crate :: R < u16 , super :: CRCDI > ;
# [ doc = "Writer for register CRCDI" ] pub type W = crate :: W < u16 , super :: CRCDI > ;
# [ doc = "Register CRCDI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CRCDI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "CRC Data In Reverse Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [crcdirb](crcdirb) module" ] pub type CRCDIRB = crate :: Reg < u16 , _CRCDIRB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CRCDIRB ;
# [ doc = "`read()` method returns [crcdirb::R](crcdirb::R) reader structure" ] impl crate :: Readable for CRCDIRB { }
# [ doc = "`write(|w| ..)` method takes [crcdirb::W](crcdirb::W) writer structure" ] impl crate :: Writable for CRCDIRB { }
# [ doc = "CRC Data In Reverse Byte" ] pub mod crcdirb {
# [ doc = "Reader of register CRCDIRB" ] pub type R = crate :: R < u16 , super :: CRCDIRB > ;
# [ doc = "Writer for register CRCDIRB" ] pub type W = crate :: W < u16 , super :: CRCDIRB > ;
# [ doc = "Register CRCDIRB `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CRCDIRB { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "CRC Initialization and Result\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [crcinires](crcinires) module" ] pub type CRCINIRES = crate :: Reg < u16 , _CRCINIRES > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CRCINIRES ;
# [ doc = "`read()` method returns [crcinires::R](crcinires::R) reader structure" ] impl crate :: Readable for CRCINIRES { }
# [ doc = "`write(|w| ..)` method takes [crcinires::W](crcinires::W) writer structure" ] impl crate :: Writable for CRCINIRES { }
# [ doc = "CRC Initialization and Result" ] pub mod crcinires {
# [ doc = "Reader of register CRCINIRES" ] pub type R = crate :: R < u16 , super :: CRCINIRES > ;
# [ doc = "Writer for register CRCINIRES" ] pub type W = crate :: W < u16 , super :: CRCINIRES > ;
# [ doc = "Register CRCINIRES `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CRCINIRES { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "CRC Result Reverse\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [crcresr](crcresr) module" ] pub type CRCRESR = crate :: Reg < u16 , _CRCRESR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CRCRESR ;
# [ doc = "`read()` method returns [crcresr::R](crcresr::R) reader structure" ] impl crate :: Readable for CRCRESR { }
# [ doc = "`write(|w| ..)` method takes [crcresr::W](crcresr::W) writer structure" ] impl crate :: Writable for CRCRESR { }
# [ doc = "CRC Result Reverse" ] pub mod crcresr {
# [ doc = "Reader of register CRCRESR" ] pub type R = crate :: R < u16 , super :: CRCRESR > ;
# [ doc = "Writer for register CRCRESR" ] pub type W = crate :: W < u16 , super :: CRCRESR > ;
# [ doc = "Register CRCRESR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CRCRESR { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
}
# [ doc = "WDT_A" ] pub struct WDT_A { _marker : PhantomData < * const ( ) > } unsafe impl Send for WDT_A { } impl WDT_A { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const wdt_a :: RegisterBlock { 0x01cc as * const _ } } impl Deref for WDT_A { type Target = wdt_a :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * WDT_A :: ptr ( ) } } }
# [ doc = "WDT_A" ] pub mod wdt_a {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Watchdog Timer Control Register" ] pub wdtctl : WDTCTL , }
# [ doc = "Watchdog Timer Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wdtctl](wdtctl) module" ] pub type WDTCTL = crate :: Reg < u16 , _WDTCTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _WDTCTL ;
# [ doc = "`read()` method returns [wdtctl::R](wdtctl::R) reader structure" ] impl crate :: Readable for WDTCTL { }
# [ doc = "`write(|w| ..)` method takes [wdtctl::W](wdtctl::W) writer structure" ] impl crate :: Writable for WDTCTL { }
# [ doc = "Watchdog Timer Control Register" ] pub mod wdtctl {
# [ doc = "Reader of register WDTCTL" ] pub type R = crate :: R < u16 , super :: WDTCTL > ;
# [ doc = "Writer for register WDTCTL" ] pub type W = crate :: W < u16 , super :: WDTCTL > ;
# [ doc = "Register WDTCTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: WDTCTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Watchdog timer interval select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum WDTIS_A { # [ doc = "0: Watchdog clock source / (2^(31)) (18:12:16 at 32.768 kHz)" ] _2G = 0 , # [ doc = "1: Watchdog clock source /(2^(27)) (01:08:16 at 32.768 kHz)" ] _128M = 1 , # [ doc = "2: Watchdog clock source /(2^(23)) (00:04:16 at 32.768 kHz)" ] _8192K = 2 , # [ doc = "3: Watchdog clock source /(2^(19)) (00:00:16 at 32.768 kHz)" ] _512K = 3 , # [ doc = "4: Watchdog clock source /(2^(15)) (1 s at 32.768 kHz)" ] _32K = 4 , # [ doc = "5: Watchdog clock source / (2^(13)) (250 ms at 32.768 kHz)" ] _8192 = 5 , # [ doc = "6: Watchdog clock source / (2^(9)) (15.625 ms at 32.768 kHz)" ] _512 = 6 , # [ doc = "7: Watchdog clock source / (2^(6)) (1.95 ms at 32.768 kHz)" ] _64 = 7 } impl From < WDTIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : WDTIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `WDTIS`" ] pub type WDTIS_R = crate :: R < u8 , WDTIS_A > ; impl WDTIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> WDTIS_A { match self . bits { 0 => WDTIS_A :: _2G , 1 => WDTIS_A :: _128M , 2 => WDTIS_A :: _8192K , 3 => WDTIS_A :: _512K , 4 => WDTIS_A :: _32K , 5 => WDTIS_A :: _8192 , 6 => WDTIS_A :: _512 , 7 => WDTIS_A :: _64 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_2G`" ] # [ inline ( always ) ] pub fn is_2g ( & self ) -> bool { * self == WDTIS_A :: _2G } # [ doc = "Checks if the value of the field is `_128M`" ] # [ inline ( always ) ] pub fn is_128m ( & self ) -> bool { * self == WDTIS_A :: _128M } # [ doc = "Checks if the value of the field is `_8192K`" ] # [ inline ( always ) ] pub fn is_8192k ( & self ) -> bool { * self == WDTIS_A :: _8192K } # [ doc = "Checks if the value of the field is `_512K`" ] # [ inline ( always ) ] pub fn is_512k ( & self ) -> bool { * self == WDTIS_A :: _512K } # [ doc = "Checks if the value of the field is `_32K`" ] # [ inline ( always ) ] pub fn is_32k ( & self ) -> bool { * self == WDTIS_A :: _32K } # [ doc = "Checks if the value of the field is `_8192`" ] # [ inline ( always ) ] pub fn is_8192 ( & self ) -> bool { * self == WDTIS_A :: _8192 } # [ doc = "Checks if the value of the field is `_512`" ] # [ inline ( always ) ] pub fn is_512 ( & self ) -> bool { * self == WDTIS_A :: _512 } # [ doc = "Checks if the value of the field is `_64`" ] # [ inline ( always ) ] pub fn is_64 ( & self ) -> bool { * self == WDTIS_A :: _64 } }
# [ doc = "Write proxy for field `WDTIS`" ] pub struct WDTIS_W < 'a > { w : & 'a mut W , } impl < 'a > WDTIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : WDTIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Watchdog clock source / (2^(31)) (18:12:16 at 32.768 kHz)" ] # [ inline ( always ) ] pub fn _2g ( self ) -> & 'a mut W { self . variant ( WDTIS_A :: _2G ) } # [ doc = "Watchdog clock source /(2^(27)) (01:08:16 at 32.768 kHz)" ] # [ inline ( always ) ] pub fn _128m ( self ) -> & 'a mut W { self . variant ( WDTIS_A :: _128M ) } # [ doc = "Watchdog clock source /(2^(23)) (00:04:16 at 32.768 kHz)" ] # [ inline ( always ) ] pub fn _8192k ( self ) -> & 'a mut W { self . variant ( WDTIS_A :: _8192K ) } # [ doc = "Watchdog clock source /(2^(19)) (00:00:16 at 32.768 kHz)" ] # [ inline ( always ) ] pub fn _512k ( self ) -> & 'a mut W { self . variant ( WDTIS_A :: _512K ) } # [ doc = "Watchdog clock source /(2^(15)) (1 s at 32.768 kHz)" ] # [ inline ( always ) ] pub fn _32k ( self ) -> & 'a mut W { self . variant ( WDTIS_A :: _32K ) } # [ doc = "Watchdog clock source / (2^(13)) (250 ms at 32.768 kHz)" ] # [ inline ( always ) ] pub fn _8192 ( self ) -> & 'a mut W { self . variant ( WDTIS_A :: _8192 ) } # [ doc = "Watchdog clock source / (2^(9)) (15.625 ms at 32.768 kHz)" ] # [ inline ( always ) ] pub fn _512 ( self ) -> & 'a mut W { self . variant ( WDTIS_A :: _512 ) } # [ doc = "Watchdog clock source / (2^(6)) (1.95 ms at 32.768 kHz)" ] # [ inline ( always ) ] pub fn _64 ( self ) -> & 'a mut W { self . variant ( WDTIS_A :: _64 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u16 ) & 0x07 ) ; self . w } }
# [ doc = "Watchdog timer counter clear\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WDTCNTCL_A { # [ doc = "0: No action" ] WDTCNTCL_0 = 0 , # [ doc = "1: WDTCNT = 0000h" ] WDTCNTCL_1 = 1 } impl From < WDTCNTCL_A > for bool { # [ inline ( always ) ] fn from ( variant : WDTCNTCL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `WDTCNTCL`" ] pub type WDTCNTCL_R = crate :: R < bool , WDTCNTCL_A > ; impl WDTCNTCL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> WDTCNTCL_A { match self . bits { false => WDTCNTCL_A :: WDTCNTCL_0 , true => WDTCNTCL_A :: WDTCNTCL_1 } } # [ doc = "Checks if the value of the field is `WDTCNTCL_0`" ] # [ inline ( always ) ] pub fn is_wdtcntcl_0 ( & self ) -> bool { * self == WDTCNTCL_A :: WDTCNTCL_0 } # [ doc = "Checks if the value of the field is `WDTCNTCL_1`" ] # [ inline ( always ) ] pub fn is_wdtcntcl_1 ( & self ) -> bool { * self == WDTCNTCL_A :: WDTCNTCL_1 } }
# [ doc = "Write proxy for field `WDTCNTCL`" ] pub struct WDTCNTCL_W < 'a > { w : & 'a mut W , } impl < 'a > WDTCNTCL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : WDTCNTCL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No action" ] # [ inline ( always ) ] pub fn wdtcntcl_0 ( self ) -> & 'a mut W { self . variant ( WDTCNTCL_A :: WDTCNTCL_0 ) } # [ doc = "WDTCNT = 0000h" ] # [ inline ( always ) ] pub fn wdtcntcl_1 ( self ) -> & 'a mut W { self . variant ( WDTCNTCL_A :: WDTCNTCL_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Watchdog timer mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WDTTMSEL_A { # [ doc = "0: Watchdog mode" ] WDTTMSEL_0 = 0 , # [ doc = "1: Interval timer mode" ] WDTTMSEL_1 = 1 } impl From < WDTTMSEL_A > for bool { # [ inline ( always ) ] fn from ( variant : WDTTMSEL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `WDTTMSEL`" ] pub type WDTTMSEL_R = crate :: R < bool , WDTTMSEL_A > ; impl WDTTMSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> WDTTMSEL_A { match self . bits { false => WDTTMSEL_A :: WDTTMSEL_0 , true => WDTTMSEL_A :: WDTTMSEL_1 } } # [ doc = "Checks if the value of the field is `WDTTMSEL_0`" ] # [ inline ( always ) ] pub fn is_wdttmsel_0 ( & self ) -> bool { * self == WDTTMSEL_A :: WDTTMSEL_0 } # [ doc = "Checks if the value of the field is `WDTTMSEL_1`" ] # [ inline ( always ) ] pub fn is_wdttmsel_1 ( & self ) -> bool { * self == WDTTMSEL_A :: WDTTMSEL_1 } }
# [ doc = "Write proxy for field `WDTTMSEL`" ] pub struct WDTTMSEL_W < 'a > { w : & 'a mut W , } impl < 'a > WDTTMSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : WDTTMSEL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Watchdog mode" ] # [ inline ( always ) ] pub fn wdttmsel_0 ( self ) -> & 'a mut W { self . variant ( WDTTMSEL_A :: WDTTMSEL_0 ) } # [ doc = "Interval timer mode" ] # [ inline ( always ) ] pub fn wdttmsel_1 ( self ) -> & 'a mut W { self . variant ( WDTTMSEL_A :: WDTTMSEL_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Watchdog timer clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum WDTSSEL_A { # [ doc = "0: SMCLK" ] SMCLK = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: VLOCLK" ] VLOCLK = 2 , # [ doc = "3: BCLK" ] BCLK = 3 } impl From < WDTSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : WDTSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `WDTSSEL`" ] pub type WDTSSEL_R = crate :: R < u8 , WDTSSEL_A > ; impl WDTSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> WDTSSEL_A { match self . bits { 0 => WDTSSEL_A :: SMCLK , 1 => WDTSSEL_A :: ACLK , 2 => WDTSSEL_A :: VLOCLK , 3 => WDTSSEL_A :: BCLK , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == WDTSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == WDTSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `VLOCLK`" ] # [ inline ( always ) ] pub fn is_vloclk ( & self ) -> bool { * self == WDTSSEL_A :: VLOCLK } # [ doc = "Checks if the value of the field is `BCLK`" ] # [ inline ( always ) ] pub fn is_bclk ( & self ) -> bool { * self == WDTSSEL_A :: BCLK } }
# [ doc = "Write proxy for field `WDTSSEL`" ] pub struct WDTSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > WDTSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : WDTSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( WDTSSEL_A :: SMCLK ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( WDTSSEL_A :: ACLK ) } # [ doc = "VLOCLK" ] # [ inline ( always ) ] pub fn vloclk ( self ) -> & 'a mut W { self . variant ( WDTSSEL_A :: VLOCLK ) } # [ doc = "BCLK" ] # [ inline ( always ) ] pub fn bclk ( self ) -> & 'a mut W { self . variant ( WDTSSEL_A :: BCLK ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 5 ) ) | ( ( ( value as u16 ) & 0x03 ) << 5 ) ; self . w } }
# [ doc = "Watchdog timer hold\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WDTHOLD_A { # [ doc = "0: Watchdog timer is not stopped" ] UNHOLD = 0 , # [ doc = "1: Watchdog timer is stopped" ] HOLD = 1 } impl From < WDTHOLD_A > for bool { # [ inline ( always ) ] fn from ( variant : WDTHOLD_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `WDTHOLD`" ] pub type WDTHOLD_R = crate :: R < bool , WDTHOLD_A > ; impl WDTHOLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> WDTHOLD_A { match self . bits { false => WDTHOLD_A :: UNHOLD , true => WDTHOLD_A :: HOLD } } # [ doc = "Checks if the value of the field is `UNHOLD`" ] # [ inline ( always ) ] pub fn is_unhold ( & self ) -> bool { * self == WDTHOLD_A :: UNHOLD } # [ doc = "Checks if the value of the field is `HOLD`" ] # [ inline ( always ) ] pub fn is_hold ( & self ) -> bool { * self == WDTHOLD_A :: HOLD } }
# [ doc = "Write proxy for field `WDTHOLD`" ] pub struct WDTHOLD_W < 'a > { w : & 'a mut W , } impl < 'a > WDTHOLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : WDTHOLD_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Watchdog timer is not stopped" ] # [ inline ( always ) ] pub fn unhold ( self ) -> & 'a mut W { self . variant ( WDTHOLD_A :: UNHOLD ) } # [ doc = "Watchdog timer is stopped" ] # [ inline ( always ) ] pub fn hold ( self ) -> & 'a mut W { self . variant ( WDTHOLD_A :: HOLD ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `WDTPW`" ] pub type WDTPW_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `WDTPW`" ] pub struct WDTPW_W < 'a > { w : & 'a mut W , } impl < 'a > WDTPW_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 8 ) ) | ( ( ( value as u16 ) & 0xff ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Watchdog timer interval select" ] # [ inline ( always ) ] pub fn wdtis ( & self ) -> WDTIS_R { WDTIS_R :: new ( ( self . bits & 0x07 ) as u8 ) }
# [ doc = "Bit 3 - Watchdog timer counter clear" ] # [ inline ( always ) ] pub fn wdtcntcl ( & self ) -> WDTCNTCL_R { WDTCNTCL_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Watchdog timer mode select" ] # [ inline ( always ) ] pub fn wdttmsel ( & self ) -> WDTTMSEL_R { WDTTMSEL_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:6 - Watchdog timer clock source select" ] # [ inline ( always ) ] pub fn wdtssel ( & self ) -> WDTSSEL_R { WDTSSEL_R :: new ( ( ( self . bits >> 5 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 7 - Watchdog timer hold" ] # [ inline ( always ) ] pub fn wdthold ( & self ) -> WDTHOLD_R { WDTHOLD_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:15 - Watchdog timer password" ] # [ inline ( always ) ] pub fn wdtpw ( & self ) -> WDTPW_R { WDTPW_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Watchdog timer interval select" ] # [ inline ( always ) ] pub fn wdtis ( & mut self ) -> WDTIS_W { WDTIS_W { w : self } }
# [ doc = "Bit 3 - Watchdog timer counter clear" ] # [ inline ( always ) ] pub fn wdtcntcl ( & mut self ) -> WDTCNTCL_W { WDTCNTCL_W { w : self } }
# [ doc = "Bit 4 - Watchdog timer mode select" ] # [ inline ( always ) ] pub fn wdttmsel ( & mut self ) -> WDTTMSEL_W { WDTTMSEL_W { w : self } }
# [ doc = "Bits 5:6 - Watchdog timer clock source select" ] # [ inline ( always ) ] pub fn wdtssel ( & mut self ) -> WDTSSEL_W { WDTSSEL_W { w : self } }
# [ doc = "Bit 7 - Watchdog timer hold" ] # [ inline ( always ) ] pub fn wdthold ( & mut self ) -> WDTHOLD_W { WDTHOLD_W { w : self } }
# [ doc = "Bits 8:15 - Watchdog timer password" ] # [ inline ( always ) ] pub fn wdtpw ( & mut self ) -> WDTPW_W { WDTPW_W { w : self } }
}
}
}
# [ doc = "RTC" ] pub struct RTC { _marker : PhantomData < * const ( ) > } unsafe impl Send for RTC { } impl RTC { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const rtc :: RegisterBlock { 0x0300 as * const _ } } impl Deref for RTC { type Target = rtc :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * RTC :: ptr ( ) } } }
# [ doc = "RTC" ] pub mod rtc {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - RTCCTL0 Register" ] pub rtcctl : RTCCTL , _reserved1 : [ u8 ; 2usize ] , # [ doc = "0x04 - Real-Time Clock Interrupt Vector Register" ] pub rtciv : RTCIV , _reserved2 : [ u8 ; 2usize ] , # [ doc = "0x08 - RTC Counter Modulo Register" ] pub rtcmod : RTCMOD , _reserved3 : [ u8 ; 2usize ] , # [ doc = "0x0c - RTC Counter Register" ] pub rtccnt : RTCCNT , }
# [ doc = "RTCCTL0 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rtcctl](rtcctl) module" ] pub type RTCCTL = crate :: Reg < u16 , _RTCCTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RTCCTL ;
# [ doc = "`read()` method returns [rtcctl::R](rtcctl::R) reader structure" ] impl crate :: Readable for RTCCTL { }
# [ doc = "`write(|w| ..)` method takes [rtcctl::W](rtcctl::W) writer structure" ] impl crate :: Writable for RTCCTL { }
# [ doc = "RTCCTL0 Register" ] pub mod rtcctl {
# [ doc = "Reader of register RTCCTL" ] pub type R = crate :: R < u16 , super :: RTCCTL > ;
# [ doc = "Writer for register RTCCTL" ] pub type W = crate :: W < u16 , super :: RTCCTL > ;
# [ doc = "Register RTCCTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RTCCTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Real-time interrupt flag. This bit reports the status of a pending interrupt. This read only bit can be cleared by reading RTCIV register.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RTCIFG_A { # [ doc = "0: No interrupt pending" ] RTCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] RTCIFG_1 = 1 } impl From < RTCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : RTCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `RTCIFG`" ] pub type RTCIFG_R = crate :: R < bool , RTCIFG_A > ; impl RTCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RTCIFG_A { match self . bits { false => RTCIFG_A :: RTCIFG_0 , true => RTCIFG_A :: RTCIFG_1 } } # [ doc = "Checks if the value of the field is `RTCIFG_0`" ] # [ inline ( always ) ] pub fn is_rtcifg_0 ( & self ) -> bool { * self == RTCIFG_A :: RTCIFG_0 } # [ doc = "Checks if the value of the field is `RTCIFG_1`" ] # [ inline ( always ) ] pub fn is_rtcifg_1 ( & self ) -> bool { * self == RTCIFG_A :: RTCIFG_1 } }
# [ doc = "Real-time interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RTCIE_A { # [ doc = "0: Interrupt disabled" ] RTCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] RTCIE_1 = 1 } impl From < RTCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : RTCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `RTCIE`" ] pub type RTCIE_R = crate :: R < bool , RTCIE_A > ; impl RTCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RTCIE_A { match self . bits { false => RTCIE_A :: RTCIE_0 , true => RTCIE_A :: RTCIE_1 } } # [ doc = "Checks if the value of the field is `RTCIE_0`" ] # [ inline ( always ) ] pub fn is_rtcie_0 ( & self ) -> bool { * self == RTCIE_A :: RTCIE_0 } # [ doc = "Checks if the value of the field is `RTCIE_1`" ] # [ inline ( always ) ] pub fn is_rtcie_1 ( & self ) -> bool { * self == RTCIE_A :: RTCIE_1 } }
# [ doc = "Write proxy for field `RTCIE`" ] pub struct RTCIE_W < 'a > { w : & 'a mut W , } impl < 'a > RTCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RTCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn rtcie_0 ( self ) -> & 'a mut W { self . variant ( RTCIE_A :: RTCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn rtcie_1 ( self ) -> & 'a mut W { self . variant ( RTCIE_A :: RTCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Real-time software reset. This is a write only bit and is always read with logic 0. 0b = Write 0 has no effect\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RTCSR_A { # [ doc = "0: Write 0 has no effect" ] RTCSR_0 = 0 , # [ doc = "1: Write 1 to this bit clears the counter value and reloads the shadow register value from the modulo register at the next tick of the selected source clock. No overflow event or interrupt is generated." ] RTCSR_1 = 1 } impl From < RTCSR_A > for bool { # [ inline ( always ) ] fn from ( variant : RTCSR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `RTCSR`" ] pub type RTCSR_R = crate :: R < bool , RTCSR_A > ; impl RTCSR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RTCSR_A { match self . bits { false => RTCSR_A :: RTCSR_0 , true => RTCSR_A :: RTCSR_1 } } # [ doc = "Checks if the value of the field is `RTCSR_0`" ] # [ inline ( always ) ] pub fn is_rtcsr_0 ( & self ) -> bool { * self == RTCSR_A :: RTCSR_0 } # [ doc = "Checks if the value of the field is `RTCSR_1`" ] # [ inline ( always ) ] pub fn is_rtcsr_1 ( & self ) -> bool { * self == RTCSR_A :: RTCSR_1 } }
# [ doc = "Write proxy for field `RTCSR`" ] pub struct RTCSR_W < 'a > { w : & 'a mut W , } impl < 'a > RTCSR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RTCSR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Write 0 has no effect" ] # [ inline ( always ) ] pub fn rtcsr_0 ( self ) -> & 'a mut W { self . variant ( RTCSR_A :: RTCSR_0 ) } # [ doc = "Write 1 to this bit clears the counter value and reloads the shadow register value from the modulo register at the next tick of the selected source clock. No overflow event or interrupt is generated." ] # [ inline ( always ) ] pub fn rtcsr_1 ( self ) -> & 'a mut W { self . variant ( RTCSR_A :: RTCSR_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Real-time clock pre-divider select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum RTCPS_A { # [ doc = "0: /1" ] _1 = 0 , # [ doc = "1: /10" ] _10 = 1 , # [ doc = "2: /100" ] _100 = 2 , # [ doc = "3: /1000" ] _1000 = 3 , # [ doc = "4: /16" ] _16 = 4 , # [ doc = "5: /64" ] _64 = 5 , # [ doc = "6: /256" ] _256 = 6 , # [ doc = "7: /1024" ] _1024 = 7 } impl From < RTCPS_A > for u8 { # [ inline ( always ) ] fn from ( variant : RTCPS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `RTCPS`" ] pub type RTCPS_R = crate :: R < u8 , RTCPS_A > ; impl RTCPS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RTCPS_A { match self . bits { 0 => RTCPS_A :: _1 , 1 => RTCPS_A :: _10 , 2 => RTCPS_A :: _100 , 3 => RTCPS_A :: _1000 , 4 => RTCPS_A :: _16 , 5 => RTCPS_A :: _64 , 6 => RTCPS_A :: _256 , 7 => RTCPS_A :: _1024 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == RTCPS_A :: _1 } # [ doc = "Checks if the value of the field is `_10`" ] # [ inline ( always ) ] pub fn is_10 ( & self ) -> bool { * self == RTCPS_A :: _10 } # [ doc = "Checks if the value of the field is `_100`" ] # [ inline ( always ) ] pub fn is_100 ( & self ) -> bool { * self == RTCPS_A :: _100 } # [ doc = "Checks if the value of the field is `_1000`" ] # [ inline ( always ) ] pub fn is_1000 ( & self ) -> bool { * self == RTCPS_A :: _1000 } # [ doc = "Checks if the value of the field is `_16`" ] # [ inline ( always ) ] pub fn is_16 ( & self ) -> bool { * self == RTCPS_A :: _16 } # [ doc = "Checks if the value of the field is `_64`" ] # [ inline ( always ) ] pub fn is_64 ( & self ) -> bool { * self == RTCPS_A :: _64 } # [ doc = "Checks if the value of the field is `_256`" ] # [ inline ( always ) ] pub fn is_256 ( & self ) -> bool { * self == RTCPS_A :: _256 } # [ doc = "Checks if the value of the field is `_1024`" ] # [ inline ( always ) ] pub fn is_1024 ( & self ) -> bool { * self == RTCPS_A :: _1024 } }
# [ doc = "Write proxy for field `RTCPS`" ] pub struct RTCPS_W < 'a > { w : & 'a mut W , } impl < 'a > RTCPS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RTCPS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "/1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( RTCPS_A :: _1 ) } # [ doc = "/10" ] # [ inline ( always ) ] pub fn _10 ( self ) -> & 'a mut W { self . variant ( RTCPS_A :: _10 ) } # [ doc = "/100" ] # [ inline ( always ) ] pub fn _100 ( self ) -> & 'a mut W { self . variant ( RTCPS_A :: _100 ) } # [ doc = "/1000" ] # [ inline ( always ) ] pub fn _1000 ( self ) -> & 'a mut W { self . variant ( RTCPS_A :: _1000 ) } # [ doc = "/16" ] # [ inline ( always ) ] pub fn _16 ( self ) -> & 'a mut W { self . variant ( RTCPS_A :: _16 ) } # [ doc = "/64" ] # [ inline ( always ) ] pub fn _64 ( self ) -> & 'a mut W { self . variant ( RTCPS_A :: _64 ) } # [ doc = "/256" ] # [ inline ( always ) ] pub fn _256 ( self ) -> & 'a mut W { self . variant ( RTCPS_A :: _256 ) } # [ doc = "/1024" ] # [ inline ( always ) ] pub fn _1024 ( self ) -> & 'a mut W { self . variant ( RTCPS_A :: _1024 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 8 ) ) | ( ( ( value as u16 ) & 0x07 ) << 8 ) ; self . w } }
# [ doc = "Real-time clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum RTCSS_A { # [ doc = "0: Disabled" ] DISABLED = 0 , # [ doc = "1: SMCLK" ] SMCLK = 1 , # [ doc = "2: XT1CLK" ] XT1CLK = 2 , # [ doc = "3: VLOCLK" ] VLOCLK = 3 } impl From < RTCSS_A > for u8 { # [ inline ( always ) ] fn from ( variant : RTCSS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `RTCSS`" ] pub type RTCSS_R = crate :: R < u8 , RTCSS_A > ; impl RTCSS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RTCSS_A { match self . bits { 0 => RTCSS_A :: DISABLED , 1 => RTCSS_A :: SMCLK , 2 => RTCSS_A :: XT1CLK , 3 => RTCSS_A :: VLOCLK , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ( always ) ] pub fn is_disabled ( & self ) -> bool { * self == RTCSS_A :: DISABLED } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == RTCSS_A :: SMCLK } # [ doc = "Checks if the value of the field is `XT1CLK`" ] # [ inline ( always ) ] pub fn is_xt1clk ( & self ) -> bool { * self == RTCSS_A :: XT1CLK } # [ doc = "Checks if the value of the field is `VLOCLK`" ] # [ inline ( always ) ] pub fn is_vloclk ( & self ) -> bool { * self == RTCSS_A :: VLOCLK } }
# [ doc = "Write proxy for field `RTCSS`" ] pub struct RTCSS_W < 'a > { w : & 'a mut W , } impl < 'a > RTCSS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RTCSS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( RTCSS_A :: DISABLED ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( RTCSS_A :: SMCLK ) } # [ doc = "XT1CLK" ] # [ inline ( always ) ] pub fn xt1clk ( self ) -> & 'a mut W { self . variant ( RTCSS_A :: XT1CLK ) } # [ doc = "VLOCLK" ] # [ inline ( always ) ] pub fn vloclk ( self ) -> & 'a mut W { self . variant ( RTCSS_A :: VLOCLK ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Real-time interrupt flag. This bit reports the status of a pending interrupt. This read only bit can be cleared by reading RTCIV register." ] # [ inline ( always ) ] pub fn rtcifg ( & self ) -> RTCIFG_R { RTCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Real-time interrupt enable" ] # [ inline ( always ) ] pub fn rtcie ( & self ) -> RTCIE_R { RTCIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Real-time software reset. This is a write only bit and is always read with logic 0. 0b = Write 0 has no effect" ] # [ inline ( always ) ] pub fn rtcsr ( & self ) -> RTCSR_R { RTCSR_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:10 - Real-time clock pre-divider select" ] # [ inline ( always ) ] pub fn rtcps ( & self ) -> RTCPS_R { RTCPS_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) }
# [ doc = "Bits 12:13 - Real-time clock source select" ] # [ inline ( always ) ] pub fn rtcss ( & self ) -> RTCSS_R { RTCSS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 1 - Real-time interrupt enable" ] # [ inline ( always ) ] pub fn rtcie ( & mut self ) -> RTCIE_W { RTCIE_W { w : self } }
# [ doc = "Bit 6 - Real-time software reset. This is a write only bit and is always read with logic 0. 0b = Write 0 has no effect" ] # [ inline ( always ) ] pub fn rtcsr ( & mut self ) -> RTCSR_W { RTCSR_W { w : self } }
# [ doc = "Bits 8:10 - Real-time clock pre-divider select" ] # [ inline ( always ) ] pub fn rtcps ( & mut self ) -> RTCPS_W { RTCPS_W { w : self } }
# [ doc = "Bits 12:13 - Real-time clock source select" ] # [ inline ( always ) ] pub fn rtcss ( & mut self ) -> RTCSS_W { RTCSS_W { w : self } }
}
}
# [ doc = "Real-Time Clock Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rtciv](rtciv) module" ] pub type RTCIV = crate :: Reg < u16 , _RTCIV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RTCIV ;
# [ doc = "`read()` method returns [rtciv::R](rtciv::R) reader structure" ] impl crate :: Readable for RTCIV { }
# [ doc = "Real-Time Clock Interrupt Vector Register" ] pub mod rtciv {
# [ doc = "Reader of register RTCIV" ] pub type R = crate :: R < u16 , super :: RTCIV > ;
# [ doc = "Real-time clock interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum RTCIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: upt Source: RTC Counter Overflow; Interrupt Flag: RTCIFG" ] RTCIFG = 2 } impl From < RTCIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : RTCIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `RTCIV`" ] pub type RTCIV_R = crate :: R < u16 , RTCIV_A > ; impl RTCIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , RTCIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( RTCIV_A :: NONE ) , 2 => Val ( RTCIV_A :: RTCIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == RTCIV_A :: NONE } # [ doc = "Checks if the value of the field is `RTCIFG`" ] # [ inline ( always ) ] pub fn is_rtcifg ( & self ) -> bool { * self == RTCIV_A :: RTCIFG } }
impl R {
# [ doc = "Bits 0:15 - Real-time clock interrupt vector value" ] # [ inline ( always ) ] pub fn rtciv ( & self ) -> RTCIV_R { RTCIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
# [ doc = "RTC Counter Modulo Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rtcmod](rtcmod) module" ] pub type RTCMOD = crate :: Reg < u16 , _RTCMOD > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RTCMOD ;
# [ doc = "`read()` method returns [rtcmod::R](rtcmod::R) reader structure" ] impl crate :: Readable for RTCMOD { }
# [ doc = "`write(|w| ..)` method takes [rtcmod::W](rtcmod::W) writer structure" ] impl crate :: Writable for RTCMOD { }
# [ doc = "RTC Counter Modulo Register" ] pub mod rtcmod {
# [ doc = "Reader of register RTCMOD" ] pub type R = crate :: R < u16 , super :: RTCMOD > ;
# [ doc = "Writer for register RTCMOD" ] pub type W = crate :: W < u16 , super :: RTCMOD > ;
# [ doc = "Register RTCMOD `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RTCMOD { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "RTC Counter Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rtccnt](rtccnt) module" ] pub type RTCCNT = crate :: Reg < u16 , _RTCCNT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RTCCNT ;
# [ doc = "`read()` method returns [rtccnt::R](rtccnt::R) reader structure" ] impl crate :: Readable for RTCCNT { }
# [ doc = "`write(|w| ..)` method takes [rtccnt::W](rtccnt::W) writer structure" ] impl crate :: Writable for RTCCNT { }
# [ doc = "RTC Counter Register" ] pub mod rtccnt {
# [ doc = "Reader of register RTCCNT" ] pub type R = crate :: R < u16 , super :: RTCCNT > ;
# [ doc = "Writer for register RTCCNT" ] pub type W = crate :: W < u16 , super :: RTCCNT > ;
# [ doc = "Register RTCCNT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RTCCNT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
}
# [ doc = "TB0" ] pub struct TB0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TB0 { } impl TB0 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const tb0 :: RegisterBlock { 0x0380 as * const _ } } impl Deref for TB0 { type Target = tb0 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * TB0 :: ptr ( ) } } }
# [ doc = "TB0" ] pub mod tb0 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Timer_B Control Register" ] pub tb0ctl : TB0CTL , # [ doc = "0x02 - Timer_B Capture/Compare Control Register" ] pub tb0cctl0 : TB0CCTL0 , # [ doc = "0x04 - Timer_B Capture/Compare Control Register" ] pub tb0cctl1 : TB0CCTL1 , # [ doc = "0x06 - Timer_B Capture/Compare Control Register" ] pub tb0cctl2 : TB0CCTL2 , _reserved4 : [ u8 ; 8usize ] , # [ doc = "0x10 - Timer_B count register" ] pub tb0r : TB0R , # [ doc = "0x12 - Timer_B Capture/Compare Register" ] pub tb0ccr0 : TB0CCR0 , # [ doc = "0x14 - Timer_B Capture/Compare Register" ] pub tb0ccr1 : TB0CCR1 , # [ doc = "0x16 - Timer_B Capture/Compare Register" ] pub tb0ccr2 : TB0CCR2 , _reserved8 : [ u8 ; 8usize ] , # [ doc = "0x20 - Timer_Bx Expansion Register 0" ] pub tb0ex0 : TB0EX0 , _reserved9 : [ u8 ; 12usize ] , # [ doc = "0x2e - Timer_Bx Interrupt Vector Register" ] pub tb0iv : TB0IV , }
# [ doc = "Timer_B Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb0ctl](tb0ctl) module" ] pub type TB0CTL = crate :: Reg < u16 , _TB0CTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB0CTL ;
# [ doc = "`read()` method returns [tb0ctl::R](tb0ctl::R) reader structure" ] impl crate :: Readable for TB0CTL { }
# [ doc = "`write(|w| ..)` method takes [tb0ctl::W](tb0ctl::W) writer structure" ] impl crate :: Writable for TB0CTL { }
# [ doc = "Timer_B Control Register" ] pub mod tb0ctl {
# [ doc = "Reader of register TB0CTL" ] pub type R = crate :: R < u16 , super :: TB0CTL > ;
# [ doc = "Writer for register TB0CTL" ] pub type W = crate :: W < u16 , super :: TB0CTL > ;
# [ doc = "Register TB0CTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB0CTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "TimerB interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TBIFG_A { # [ doc = "0: No interrupt pending" ] TBIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] TBIFG_1 = 1 } impl From < TBIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : TBIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `TBIFG`" ] pub type TBIFG_R = crate :: R < bool , TBIFG_A > ; impl TBIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIFG_A { match self . bits { false => TBIFG_A :: TBIFG_0 , true => TBIFG_A :: TBIFG_1 } } # [ doc = "Checks if the value of the field is `TBIFG_0`" ] # [ inline ( always ) ] pub fn is_tbifg_0 ( & self ) -> bool { * self == TBIFG_A :: TBIFG_0 } # [ doc = "Checks if the value of the field is `TBIFG_1`" ] # [ inline ( always ) ] pub fn is_tbifg_1 ( & self ) -> bool { * self == TBIFG_A :: TBIFG_1 } }
# [ doc = "Write proxy for field `TBIFG`" ] pub struct TBIFG_W < 'a > { w : & 'a mut W , } impl < 'a > TBIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn tbifg_0 ( self ) -> & 'a mut W { self . variant ( TBIFG_A :: TBIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn tbifg_1 ( self ) -> & 'a mut W { self . variant ( TBIFG_A :: TBIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "TimerB interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TBIE_A { # [ doc = "0: Interrupt disabled" ] TBIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] TBIE_1 = 1 } impl From < TBIE_A > for bool { # [ inline ( always ) ] fn from ( variant : TBIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `TBIE`" ] pub type TBIE_R = crate :: R < bool , TBIE_A > ; impl TBIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIE_A { match self . bits { false => TBIE_A :: TBIE_0 , true => TBIE_A :: TBIE_1 } } # [ doc = "Checks if the value of the field is `TBIE_0`" ] # [ inline ( always ) ] pub fn is_tbie_0 ( & self ) -> bool { * self == TBIE_A :: TBIE_0 } # [ doc = "Checks if the value of the field is `TBIE_1`" ] # [ inline ( always ) ] pub fn is_tbie_1 ( & self ) -> bool { * self == TBIE_A :: TBIE_1 } }
# [ doc = "Write proxy for field `TBIE`" ] pub struct TBIE_W < 'a > { w : & 'a mut W , } impl < 'a > TBIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn tbie_0 ( self ) -> & 'a mut W { self . variant ( TBIE_A :: TBIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn tbie_1 ( self ) -> & 'a mut W { self . variant ( TBIE_A :: TBIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `TBCLR`" ] pub type TBCLR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TBCLR`" ] pub struct TBCLR_W < 'a > { w : & 'a mut W , } impl < 'a > TBCLR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Mode control\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum MC_A { # [ doc = "0: Stop mode: Timer is halted" ] STOP = 0 , # [ doc = "1: Up mode: Timer counts up to TBxCL0" ] UP = 1 , # [ doc = "2: Continuous mode: Timer counts up to the value set by CNTL" ] CONTINUOUS = 2 , # [ doc = "3: Up/down mode: Timer counts up to TBxCL0 then down to 0000h" ] UPDOWN = 3 } impl From < MC_A > for u8 { # [ inline ( always ) ] fn from ( variant : MC_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `MC`" ] pub type MC_R = crate :: R < u8 , MC_A > ; impl MC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MC_A { match self . bits { 0 => MC_A :: STOP , 1 => MC_A :: UP , 2 => MC_A :: CONTINUOUS , 3 => MC_A :: UPDOWN , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `STOP`" ] # [ inline ( always ) ] pub fn is_stop ( & self ) -> bool { * self == MC_A :: STOP } # [ doc = "Checks if the value of the field is `UP`" ] # [ inline ( always ) ] pub fn is_up ( & self ) -> bool { * self == MC_A :: UP } # [ doc = "Checks if the value of the field is `CONTINUOUS`" ] # [ inline ( always ) ] pub fn is_continuous ( & self ) -> bool { * self == MC_A :: CONTINUOUS } # [ doc = "Checks if the value of the field is `UPDOWN`" ] # [ inline ( always ) ] pub fn is_updown ( & self ) -> bool { * self == MC_A :: UPDOWN } }
# [ doc = "Write proxy for field `MC`" ] pub struct MC_W < 'a > { w : & 'a mut W , } impl < 'a > MC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MC_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Stop mode: Timer is halted" ] # [ inline ( always ) ] pub fn stop ( self ) -> & 'a mut W { self . variant ( MC_A :: STOP ) } # [ doc = "Up mode: Timer counts up to TBxCL0" ] # [ inline ( always ) ] pub fn up ( self ) -> & 'a mut W { self . variant ( MC_A :: UP ) } # [ doc = "Continuous mode: Timer counts up to the value set by CNTL" ] # [ inline ( always ) ] pub fn continuous ( self ) -> & 'a mut W { self . variant ( MC_A :: CONTINUOUS ) } # [ doc = "Up/down mode: Timer counts up to TBxCL0 then down to 0000h" ] # [ inline ( always ) ] pub fn updown ( self ) -> & 'a mut W { self . variant ( MC_A :: UPDOWN ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Input divider\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ID_A { # [ doc = "0: /1" ] _1 = 0 , # [ doc = "1: /2" ] _2 = 1 , # [ doc = "2: /4" ] _4 = 2 , # [ doc = "3: /8" ] _8 = 3 } impl From < ID_A > for u8 { # [ inline ( always ) ] fn from ( variant : ID_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ID`" ] pub type ID_R = crate :: R < u8 , ID_A > ; impl ID_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ID_A { match self . bits { 0 => ID_A :: _1 , 1 => ID_A :: _2 , 2 => ID_A :: _4 , 3 => ID_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == ID_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == ID_A :: _2 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == ID_A :: _4 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == ID_A :: _8 } }
# [ doc = "Write proxy for field `ID`" ] pub struct ID_W < 'a > { w : & 'a mut W , } impl < 'a > ID_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ID_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "/1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( ID_A :: _1 ) } # [ doc = "/2" ] # [ inline ( always ) ] pub fn _2 ( self ) -> & 'a mut W { self . variant ( ID_A :: _2 ) } # [ doc = "/4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( ID_A :: _4 ) } # [ doc = "/8" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( ID_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "TimerB clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBSSEL_A { # [ doc = "0: TBxCLK" ] TBCLK = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: INCLK" ] INCLK = 3 } impl From < TBSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBSSEL`" ] pub type TBSSEL_R = crate :: R < u8 , TBSSEL_A > ; impl TBSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBSSEL_A { match self . bits { 0 => TBSSEL_A :: TBCLK , 1 => TBSSEL_A :: ACLK , 2 => TBSSEL_A :: SMCLK , 3 => TBSSEL_A :: INCLK , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `TBCLK`" ] # [ inline ( always ) ] pub fn is_tbclk ( & self ) -> bool { * self == TBSSEL_A :: TBCLK } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == TBSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == TBSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `INCLK`" ] # [ inline ( always ) ] pub fn is_inclk ( & self ) -> bool { * self == TBSSEL_A :: INCLK } }
# [ doc = "Write proxy for field `TBSSEL`" ] pub struct TBSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > TBSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLK" ] # [ inline ( always ) ] pub fn tbclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: TBCLK ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: SMCLK ) } # [ doc = "INCLK" ] # [ inline ( always ) ] pub fn inclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: INCLK ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Counter length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CNTL_A { # [ doc = "0: 16-bit, TBxR(max) = 0FFFFh" ] _16 = 0 , # [ doc = "1: 12-bit, TBxR(max) = 0FFFh" ] _12 = 1 , # [ doc = "2: 10-bit, TBxR(max) = 03FFh" ] _10 = 2 , # [ doc = "3: 8-bit, TBxR(max) = 0FFh" ] _8 = 3 } impl From < CNTL_A > for u8 { # [ inline ( always ) ] fn from ( variant : CNTL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CNTL`" ] pub type CNTL_R = crate :: R < u8 , CNTL_A > ; impl CNTL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CNTL_A { match self . bits { 0 => CNTL_A :: _16 , 1 => CNTL_A :: _12 , 2 => CNTL_A :: _10 , 3 => CNTL_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_16`" ] # [ inline ( always ) ] pub fn is_16 ( & self ) -> bool { * self == CNTL_A :: _16 } # [ doc = "Checks if the value of the field is `_12`" ] # [ inline ( always ) ] pub fn is_12 ( & self ) -> bool { * self == CNTL_A :: _12 } # [ doc = "Checks if the value of the field is `_10`" ] # [ inline ( always ) ] pub fn is_10 ( & self ) -> bool { * self == CNTL_A :: _10 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == CNTL_A :: _8 } }
# [ doc = "Write proxy for field `CNTL`" ] pub struct CNTL_W < 'a > { w : & 'a mut W , } impl < 'a > CNTL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CNTL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "16-bit, TBxR(max) = 0FFFFh" ] # [ inline ( always ) ] pub fn _16 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _16 ) } # [ doc = "12-bit, TBxR(max) = 0FFFh" ] # [ inline ( always ) ] pub fn _12 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _12 ) } # [ doc = "10-bit, TBxR(max) = 03FFh" ] # [ inline ( always ) ] pub fn _10 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _10 ) } # [ doc = "8-bit, TBxR(max) = 0FFh" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 11 ) ) | ( ( ( value as u16 ) & 0x03 ) << 11 ) ; self . w } }
# [ doc = "TBxCLn group\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBCLGRP_A { # [ doc = "0: Each TBxCLn latch loads independently" ] TBCLGRP_0 = 0 , # [ doc = "1: TBxCL1+TBxCL2 (TBxCCR1 CLLD bits control the update); TBxCL3+TBxCL4 (TBxCCR3 CLLD bits control the update); TBxCL5+TBxCL6 (TBxCCR5 CLLD bits control the update); TBxCL0 independent" ] TBCLGRP_1 = 1 , # [ doc = "2: TBxCL1+TBxCL2+TBxCL3 (TBxCCR1 CLLD bits control the update); TBxCL4+TBxCL5+TBxCL6 (TBxCCR4 CLLD bits control the update); TBxCL0 independent" ] TBCLGRP_2 = 2 , # [ doc = "3: TBxCL0+TBxCL1+TBxCL2+TBxCL3+TBxCL4+TBxCL5+TBxCL6 (TBxCCR1 CLLD bits control the update)" ] TBCLGRP_3 = 3 } impl From < TBCLGRP_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBCLGRP_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBCLGRP`" ] pub type TBCLGRP_R = crate :: R < u8 , TBCLGRP_A > ; impl TBCLGRP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBCLGRP_A { match self . bits { 0 => TBCLGRP_A :: TBCLGRP_0 , 1 => TBCLGRP_A :: TBCLGRP_1 , 2 => TBCLGRP_A :: TBCLGRP_2 , 3 => TBCLGRP_A :: TBCLGRP_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `TBCLGRP_0`" ] # [ inline ( always ) ] pub fn is_tbclgrp_0 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_0 } # [ doc = "Checks if the value of the field is `TBCLGRP_1`" ] # [ inline ( always ) ] pub fn is_tbclgrp_1 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_1 } # [ doc = "Checks if the value of the field is `TBCLGRP_2`" ] # [ inline ( always ) ] pub fn is_tbclgrp_2 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_2 } # [ doc = "Checks if the value of the field is `TBCLGRP_3`" ] # [ inline ( always ) ] pub fn is_tbclgrp_3 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_3 } }
# [ doc = "Write proxy for field `TBCLGRP`" ] pub struct TBCLGRP_W < 'a > { w : & 'a mut W , } impl < 'a > TBCLGRP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBCLGRP_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Each TBxCLn latch loads independently" ] # [ inline ( always ) ] pub fn tbclgrp_0 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_0 ) } # [ doc = "TBxCL1+TBxCL2 (TBxCCR1 CLLD bits control the update); TBxCL3+TBxCL4 (TBxCCR3 CLLD bits control the update); TBxCL5+TBxCL6 (TBxCCR5 CLLD bits control the update); TBxCL0 independent" ] # [ inline ( always ) ] pub fn tbclgrp_1 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_1 ) } # [ doc = "TBxCL1+TBxCL2+TBxCL3 (TBxCCR1 CLLD bits control the update); TBxCL4+TBxCL5+TBxCL6 (TBxCCR4 CLLD bits control the update); TBxCL0 independent" ] # [ inline ( always ) ] pub fn tbclgrp_2 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_2 ) } # [ doc = "TBxCL0+TBxCL1+TBxCL2+TBxCL3+TBxCL4+TBxCL5+TBxCL6 (TBxCCR1 CLLD bits control the update)" ] # [ inline ( always ) ] pub fn tbclgrp_3 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 13 ) ) | ( ( ( value as u16 ) & 0x03 ) << 13 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - TimerB interrupt flag" ] # [ inline ( always ) ] pub fn tbifg ( & self ) -> TBIFG_R { TBIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - TimerB interrupt enable" ] # [ inline ( always ) ] pub fn tbie ( & self ) -> TBIE_R { TBIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - TimerB clear" ] # [ inline ( always ) ] pub fn tbclr ( & self ) -> TBCLR_R { TBCLR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - Mode control" ] # [ inline ( always ) ] pub fn mc ( & self ) -> MC_R { MC_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 6:7 - Input divider" ] # [ inline ( always ) ] pub fn id ( & self ) -> ID_R { ID_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:9 - TimerB clock source select" ] # [ inline ( always ) ] pub fn tbssel ( & self ) -> TBSSEL_R { TBSSEL_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 11:12 - Counter length" ] # [ inline ( always ) ] pub fn cntl ( & self ) -> CNTL_R { CNTL_R :: new ( ( ( self . bits >> 11 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 13:14 - TBxCLn group" ] # [ inline ( always ) ] pub fn tbclgrp ( & self ) -> TBCLGRP_R { TBCLGRP_R :: new ( ( ( self . bits >> 13 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - TimerB interrupt flag" ] # [ inline ( always ) ] pub fn tbifg ( & mut self ) -> TBIFG_W { TBIFG_W { w : self } }
# [ doc = "Bit 1 - TimerB interrupt enable" ] # [ inline ( always ) ] pub fn tbie ( & mut self ) -> TBIE_W { TBIE_W { w : self } }
# [ doc = "Bit 2 - TimerB clear" ] # [ inline ( always ) ] pub fn tbclr ( & mut self ) -> TBCLR_W { TBCLR_W { w : self } }
# [ doc = "Bits 4:5 - Mode control" ] # [ inline ( always ) ] pub fn mc ( & mut self ) -> MC_W { MC_W { w : self } }
# [ doc = "Bits 6:7 - Input divider" ] # [ inline ( always ) ] pub fn id ( & mut self ) -> ID_W { ID_W { w : self } }
# [ doc = "Bits 8:9 - TimerB clock source select" ] # [ inline ( always ) ] pub fn tbssel ( & mut self ) -> TBSSEL_W { TBSSEL_W { w : self } }
# [ doc = "Bits 11:12 - Counter length" ] # [ inline ( always ) ] pub fn cntl ( & mut self ) -> CNTL_W { CNTL_W { w : self } }
# [ doc = "Bits 13:14 - TBxCLn group" ] # [ inline ( always ) ] pub fn tbclgrp ( & mut self ) -> TBCLGRP_W { TBCLGRP_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb0cctl0](tb0cctl0) module" ] pub type TB0CCTL0 = crate :: Reg < u16 , _TB0CCTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB0CCTL0 ;
# [ doc = "`read()` method returns [tb0cctl0::R](tb0cctl0::R) reader structure" ] impl crate :: Readable for TB0CCTL0 { }
# [ doc = "`write(|w| ..)` method takes [tb0cctl0::W](tb0cctl0::W) writer structure" ] impl crate :: Writable for TB0CCTL0 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb0cctl0 {
# [ doc = "Reader of register TB0CCTL0" ] pub type R = crate :: R < u16 , super :: TB0CCTL0 > ;
# [ doc = "Writer for register TB0CCTL0" ] pub type W = crate :: W < u16 , super :: TB0CCTL0 > ;
# [ doc = "Register TB0CCTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB0CCTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb0cctl1](tb0cctl1) module" ] pub type TB0CCTL1 = crate :: Reg < u16 , _TB0CCTL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB0CCTL1 ;
# [ doc = "`read()` method returns [tb0cctl1::R](tb0cctl1::R) reader structure" ] impl crate :: Readable for TB0CCTL1 { }
# [ doc = "`write(|w| ..)` method takes [tb0cctl1::W](tb0cctl1::W) writer structure" ] impl crate :: Writable for TB0CCTL1 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb0cctl1 {
# [ doc = "Reader of register TB0CCTL1" ] pub type R = crate :: R < u16 , super :: TB0CCTL1 > ;
# [ doc = "Writer for register TB0CCTL1" ] pub type W = crate :: W < u16 , super :: TB0CCTL1 > ;
# [ doc = "Register TB0CCTL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB0CCTL1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb0cctl2](tb0cctl2) module" ] pub type TB0CCTL2 = crate :: Reg < u16 , _TB0CCTL2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB0CCTL2 ;
# [ doc = "`read()` method returns [tb0cctl2::R](tb0cctl2::R) reader structure" ] impl crate :: Readable for TB0CCTL2 { }
# [ doc = "`write(|w| ..)` method takes [tb0cctl2::W](tb0cctl2::W) writer structure" ] impl crate :: Writable for TB0CCTL2 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb0cctl2 {
# [ doc = "Reader of register TB0CCTL2" ] pub type R = crate :: R < u16 , super :: TB0CCTL2 > ;
# [ doc = "Writer for register TB0CCTL2" ] pub type W = crate :: W < u16 , super :: TB0CCTL2 > ;
# [ doc = "Register TB0CCTL2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB0CCTL2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B count register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb0r](tb0r) module" ] pub type TB0R = crate :: Reg < u16 , _TB0R > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB0R ;
# [ doc = "`read()` method returns [tb0r::R](tb0r::R) reader structure" ] impl crate :: Readable for TB0R { }
# [ doc = "`write(|w| ..)` method takes [tb0r::W](tb0r::W) writer structure" ] impl crate :: Writable for TB0R { }
# [ doc = "Timer_B count register" ] pub mod tb0r {
# [ doc = "Reader of register TB0R" ] pub type R = crate :: R < u16 , super :: TB0R > ;
# [ doc = "Writer for register TB0R" ] pub type W = crate :: W < u16 , super :: TB0R > ;
# [ doc = "Register TB0R `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB0R { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb0ccr0](tb0ccr0) module" ] pub type TB0CCR0 = crate :: Reg < u16 , _TB0CCR0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB0CCR0 ;
# [ doc = "`read()` method returns [tb0ccr0::R](tb0ccr0::R) reader structure" ] impl crate :: Readable for TB0CCR0 { }
# [ doc = "`write(|w| ..)` method takes [tb0ccr0::W](tb0ccr0::W) writer structure" ] impl crate :: Writable for TB0CCR0 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb0ccr0 {
# [ doc = "Reader of register TB0CCR0" ] pub type R = crate :: R < u16 , super :: TB0CCR0 > ;
# [ doc = "Writer for register TB0CCR0" ] pub type W = crate :: W < u16 , super :: TB0CCR0 > ;
# [ doc = "Register TB0CCR0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB0CCR0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb0ccr1](tb0ccr1) module" ] pub type TB0CCR1 = crate :: Reg < u16 , _TB0CCR1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB0CCR1 ;
# [ doc = "`read()` method returns [tb0ccr1::R](tb0ccr1::R) reader structure" ] impl crate :: Readable for TB0CCR1 { }
# [ doc = "`write(|w| ..)` method takes [tb0ccr1::W](tb0ccr1::W) writer structure" ] impl crate :: Writable for TB0CCR1 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb0ccr1 {
# [ doc = "Reader of register TB0CCR1" ] pub type R = crate :: R < u16 , super :: TB0CCR1 > ;
# [ doc = "Writer for register TB0CCR1" ] pub type W = crate :: W < u16 , super :: TB0CCR1 > ;
# [ doc = "Register TB0CCR1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB0CCR1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb0ccr2](tb0ccr2) module" ] pub type TB0CCR2 = crate :: Reg < u16 , _TB0CCR2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB0CCR2 ;
# [ doc = "`read()` method returns [tb0ccr2::R](tb0ccr2::R) reader structure" ] impl crate :: Readable for TB0CCR2 { }
# [ doc = "`write(|w| ..)` method takes [tb0ccr2::W](tb0ccr2::W) writer structure" ] impl crate :: Writable for TB0CCR2 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb0ccr2 {
# [ doc = "Reader of register TB0CCR2" ] pub type R = crate :: R < u16 , super :: TB0CCR2 > ;
# [ doc = "Writer for register TB0CCR2" ] pub type W = crate :: W < u16 , super :: TB0CCR2 > ;
# [ doc = "Register TB0CCR2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB0CCR2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_Bx Expansion Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb0ex0](tb0ex0) module" ] pub type TB0EX0 = crate :: Reg < u16 , _TB0EX0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB0EX0 ;
# [ doc = "`read()` method returns [tb0ex0::R](tb0ex0::R) reader structure" ] impl crate :: Readable for TB0EX0 { }
# [ doc = "`write(|w| ..)` method takes [tb0ex0::W](tb0ex0::W) writer structure" ] impl crate :: Writable for TB0EX0 { }
# [ doc = "Timer_Bx Expansion Register 0" ] pub mod tb0ex0 {
# [ doc = "Reader of register TB0EX0" ] pub type R = crate :: R < u16 , super :: TB0EX0 > ;
# [ doc = "Writer for register TB0EX0" ] pub type W = crate :: W < u16 , super :: TB0EX0 > ;
# [ doc = "Register TB0EX0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB0EX0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Input divider expansion\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBIDEX_A { # [ doc = "0: Divide by 1" ] _1 = 0 , # [ doc = "1: Divide by 2" ] _2 = 1 , # [ doc = "2: Divide by 3" ] _3 = 2 , # [ doc = "3: Divide by 4" ] _4 = 3 , # [ doc = "4: Divide by 5" ] _5 = 4 , # [ doc = "5: Divide by 6" ] _6 = 5 , # [ doc = "6: Divide by 7" ] _7 = 6 , # [ doc = "7: Divide by 8" ] _8 = 7 } impl From < TBIDEX_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBIDEX_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBIDEX`" ] pub type TBIDEX_R = crate :: R < u8 , TBIDEX_A > ; impl TBIDEX_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIDEX_A { match self . bits { 0 => TBIDEX_A :: _1 , 1 => TBIDEX_A :: _2 , 2 => TBIDEX_A :: _3 , 3 => TBIDEX_A :: _4 , 4 => TBIDEX_A :: _5 , 5 => TBIDEX_A :: _6 , 6 => TBIDEX_A :: _7 , 7 => TBIDEX_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == TBIDEX_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == TBIDEX_A :: _2 } # [ doc = "Checks if the value of the field is `_3`" ] # [ inline ( always ) ] pub fn is_3 ( & self ) -> bool { * self == TBIDEX_A :: _3 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == TBIDEX_A :: _4 } # [ doc = "Checks if the value of the field is `_5`" ] # [ inline ( always ) ] pub fn is_5 ( & self ) -> bool { * self == TBIDEX_A :: _5 } # [ doc = "Checks if the value of the field is `_6`" ] # [ inline ( always ) ] pub fn is_6 ( & self ) -> bool { * self == TBIDEX_A :: _6 } # [ doc = "Checks if the value of the field is `_7`" ] # [ inline ( always ) ] pub fn is_7 ( & self ) -> bool { * self == TBIDEX_A :: _7 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == TBIDEX_A :: _8 } }
# [ doc = "Write proxy for field `TBIDEX`" ] pub struct TBIDEX_W < 'a > { w : & 'a mut W , } impl < 'a > TBIDEX_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIDEX_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Divide by 1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _1 ) } # [ doc = "Divide by 2" ] # [ inline ( always ) ] pub fn _2 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _2 ) } # [ doc = "Divide by 3" ] # [ inline ( always ) ] pub fn _3 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _3 ) } # [ doc = "Divide by 4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _4 ) } # [ doc = "Divide by 5" ] # [ inline ( always ) ] pub fn _5 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _5 ) } # [ doc = "Divide by 6" ] # [ inline ( always ) ] pub fn _6 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _6 ) } # [ doc = "Divide by 7" ] # [ inline ( always ) ] pub fn _7 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _7 ) } # [ doc = "Divide by 8" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u16 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Input divider expansion" ] # [ inline ( always ) ] pub fn tbidex ( & self ) -> TBIDEX_R { TBIDEX_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Input divider expansion" ] # [ inline ( always ) ] pub fn tbidex ( & mut self ) -> TBIDEX_W { TBIDEX_W { w : self } }
}
}
# [ doc = "Timer_Bx Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb0iv](tb0iv) module" ] pub type TB0IV = crate :: Reg < u16 , _TB0IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB0IV ;
# [ doc = "`read()` method returns [tb0iv::R](tb0iv::R) reader structure" ] impl crate :: Readable for TB0IV { }
# [ doc = "Timer_Bx Interrupt Vector Register" ] pub mod tb0iv {
# [ doc = "Reader of register TB0IV" ] pub type R = crate :: R < u16 , super :: TB0IV > ;
# [ doc = "Timer_B interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum TBIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Capture/compare 1; Interrupt Flag: TBxCCR1 CCIFG; Interrupt Priority: Highest" ] TBCCR1 = 2 , # [ doc = "4: Interrupt Source: Capture/compare 2; Interrupt Flag: TBxCCR2 CCIFG" ] TBCCR2 = 4 , # [ doc = "6: Interrupt Source: Capture/compare 3; Interrupt Flag: TBxCCR3 CCIFG" ] TBCCR3 = 6 , # [ doc = "8: Interrupt Source: Capture/compare 4; Interrupt Flag: TBxCCR4 CCIFG" ] TBCCR4 = 8 , # [ doc = "10: Interrupt Source: Capture/compare 5; Interrupt Flag: TBxCCR5 CCIFG" ] TBCCR5 = 10 , # [ doc = "12: Interrupt Source: Capture/compare 6; Interrupt Flag: TBxCCR6 CCIFG" ] TBCCR6 = 12 , # [ doc = "14: Interrupt Source: Timer overflow; Interrupt Flag: TBxCTL TBIFG; Interrupt Priority: Lowest" ] TBIFG = 14 } impl From < TBIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : TBIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBIV`" ] pub type TBIV_R = crate :: R < u16 , TBIV_A > ; impl TBIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , TBIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( TBIV_A :: NONE ) , 2 => Val ( TBIV_A :: TBCCR1 ) , 4 => Val ( TBIV_A :: TBCCR2 ) , 6 => Val ( TBIV_A :: TBCCR3 ) , 8 => Val ( TBIV_A :: TBCCR4 ) , 10 => Val ( TBIV_A :: TBCCR5 ) , 12 => Val ( TBIV_A :: TBCCR6 ) , 14 => Val ( TBIV_A :: TBIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == TBIV_A :: NONE } # [ doc = "Checks if the value of the field is `TBCCR1`" ] # [ inline ( always ) ] pub fn is_tbccr1 ( & self ) -> bool { * self == TBIV_A :: TBCCR1 } # [ doc = "Checks if the value of the field is `TBCCR2`" ] # [ inline ( always ) ] pub fn is_tbccr2 ( & self ) -> bool { * self == TBIV_A :: TBCCR2 } # [ doc = "Checks if the value of the field is `TBCCR3`" ] # [ inline ( always ) ] pub fn is_tbccr3 ( & self ) -> bool { * self == TBIV_A :: TBCCR3 } # [ doc = "Checks if the value of the field is `TBCCR4`" ] # [ inline ( always ) ] pub fn is_tbccr4 ( & self ) -> bool { * self == TBIV_A :: TBCCR4 } # [ doc = "Checks if the value of the field is `TBCCR5`" ] # [ inline ( always ) ] pub fn is_tbccr5 ( & self ) -> bool { * self == TBIV_A :: TBCCR5 } # [ doc = "Checks if the value of the field is `TBCCR6`" ] # [ inline ( always ) ] pub fn is_tbccr6 ( & self ) -> bool { * self == TBIV_A :: TBCCR6 } # [ doc = "Checks if the value of the field is `TBIFG`" ] # [ inline ( always ) ] pub fn is_tbifg ( & self ) -> bool { * self == TBIV_A :: TBIFG } }
impl R {
# [ doc = "Bits 0:15 - Timer_B interrupt vector value" ] # [ inline ( always ) ] pub fn tbiv ( & self ) -> TBIV_R { TBIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "TB1" ] pub struct TB1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TB1 { } impl TB1 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const tb1 :: RegisterBlock { 0x03c0 as * const _ } } impl Deref for TB1 { type Target = tb1 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * TB1 :: ptr ( ) } } }
# [ doc = "TB1" ] pub mod tb1 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Timer_B Control Register" ] pub tb1ctl : TB1CTL , # [ doc = "0x02 - Timer_B Capture/Compare Control Register" ] pub tb1cctl0 : TB1CCTL0 , # [ doc = "0x04 - Timer_B Capture/Compare Control Register" ] pub tb1cctl1 : TB1CCTL1 , # [ doc = "0x06 - Timer_B Capture/Compare Control Register" ] pub tb1cctl2 : TB1CCTL2 , _reserved4 : [ u8 ; 8usize ] , # [ doc = "0x10 - Timer_B count register" ] pub tb1r : TB1R , # [ doc = "0x12 - Timer_B Capture/Compare Register" ] pub tb1ccr0 : TB1CCR0 , # [ doc = "0x14 - Timer_B Capture/Compare Register" ] pub tb1ccr1 : TB1CCR1 , # [ doc = "0x16 - Timer_B Capture/Compare Register" ] pub tb1ccr2 : TB1CCR2 , _reserved8 : [ u8 ; 8usize ] , # [ doc = "0x20 - Timer_Bx Expansion Register 0" ] pub tb1ex0 : TB1EX0 , _reserved9 : [ u8 ; 12usize ] , # [ doc = "0x2e - Timer_Bx Interrupt Vector Register" ] pub tb1iv : TB1IV , }
# [ doc = "Timer_B Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb1ctl](tb1ctl) module" ] pub type TB1CTL = crate :: Reg < u16 , _TB1CTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB1CTL ;
# [ doc = "`read()` method returns [tb1ctl::R](tb1ctl::R) reader structure" ] impl crate :: Readable for TB1CTL { }
# [ doc = "`write(|w| ..)` method takes [tb1ctl::W](tb1ctl::W) writer structure" ] impl crate :: Writable for TB1CTL { }
# [ doc = "Timer_B Control Register" ] pub mod tb1ctl {
# [ doc = "Reader of register TB1CTL" ] pub type R = crate :: R < u16 , super :: TB1CTL > ;
# [ doc = "Writer for register TB1CTL" ] pub type W = crate :: W < u16 , super :: TB1CTL > ;
# [ doc = "Register TB1CTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB1CTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "TimerB interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TBIFG_A { # [ doc = "0: No interrupt pending" ] TBIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] TBIFG_1 = 1 } impl From < TBIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : TBIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `TBIFG`" ] pub type TBIFG_R = crate :: R < bool , TBIFG_A > ; impl TBIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIFG_A { match self . bits { false => TBIFG_A :: TBIFG_0 , true => TBIFG_A :: TBIFG_1 } } # [ doc = "Checks if the value of the field is `TBIFG_0`" ] # [ inline ( always ) ] pub fn is_tbifg_0 ( & self ) -> bool { * self == TBIFG_A :: TBIFG_0 } # [ doc = "Checks if the value of the field is `TBIFG_1`" ] # [ inline ( always ) ] pub fn is_tbifg_1 ( & self ) -> bool { * self == TBIFG_A :: TBIFG_1 } }
# [ doc = "Write proxy for field `TBIFG`" ] pub struct TBIFG_W < 'a > { w : & 'a mut W , } impl < 'a > TBIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn tbifg_0 ( self ) -> & 'a mut W { self . variant ( TBIFG_A :: TBIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn tbifg_1 ( self ) -> & 'a mut W { self . variant ( TBIFG_A :: TBIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "TimerB interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TBIE_A { # [ doc = "0: Interrupt disabled" ] TBIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] TBIE_1 = 1 } impl From < TBIE_A > for bool { # [ inline ( always ) ] fn from ( variant : TBIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `TBIE`" ] pub type TBIE_R = crate :: R < bool , TBIE_A > ; impl TBIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIE_A { match self . bits { false => TBIE_A :: TBIE_0 , true => TBIE_A :: TBIE_1 } } # [ doc = "Checks if the value of the field is `TBIE_0`" ] # [ inline ( always ) ] pub fn is_tbie_0 ( & self ) -> bool { * self == TBIE_A :: TBIE_0 } # [ doc = "Checks if the value of the field is `TBIE_1`" ] # [ inline ( always ) ] pub fn is_tbie_1 ( & self ) -> bool { * self == TBIE_A :: TBIE_1 } }
# [ doc = "Write proxy for field `TBIE`" ] pub struct TBIE_W < 'a > { w : & 'a mut W , } impl < 'a > TBIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn tbie_0 ( self ) -> & 'a mut W { self . variant ( TBIE_A :: TBIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn tbie_1 ( self ) -> & 'a mut W { self . variant ( TBIE_A :: TBIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `TBCLR`" ] pub type TBCLR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TBCLR`" ] pub struct TBCLR_W < 'a > { w : & 'a mut W , } impl < 'a > TBCLR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Mode control\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum MC_A { # [ doc = "0: Stop mode: Timer is halted" ] STOP = 0 , # [ doc = "1: Up mode: Timer counts up to TBxCL0" ] UP = 1 , # [ doc = "2: Continuous mode: Timer counts up to the value set by CNTL" ] CONTINUOUS = 2 , # [ doc = "3: Up/down mode: Timer counts up to TBxCL0 then down to 0000h" ] UPDOWN = 3 } impl From < MC_A > for u8 { # [ inline ( always ) ] fn from ( variant : MC_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `MC`" ] pub type MC_R = crate :: R < u8 , MC_A > ; impl MC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MC_A { match self . bits { 0 => MC_A :: STOP , 1 => MC_A :: UP , 2 => MC_A :: CONTINUOUS , 3 => MC_A :: UPDOWN , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `STOP`" ] # [ inline ( always ) ] pub fn is_stop ( & self ) -> bool { * self == MC_A :: STOP } # [ doc = "Checks if the value of the field is `UP`" ] # [ inline ( always ) ] pub fn is_up ( & self ) -> bool { * self == MC_A :: UP } # [ doc = "Checks if the value of the field is `CONTINUOUS`" ] # [ inline ( always ) ] pub fn is_continuous ( & self ) -> bool { * self == MC_A :: CONTINUOUS } # [ doc = "Checks if the value of the field is `UPDOWN`" ] # [ inline ( always ) ] pub fn is_updown ( & self ) -> bool { * self == MC_A :: UPDOWN } }
# [ doc = "Write proxy for field `MC`" ] pub struct MC_W < 'a > { w : & 'a mut W , } impl < 'a > MC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MC_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Stop mode: Timer is halted" ] # [ inline ( always ) ] pub fn stop ( self ) -> & 'a mut W { self . variant ( MC_A :: STOP ) } # [ doc = "Up mode: Timer counts up to TBxCL0" ] # [ inline ( always ) ] pub fn up ( self ) -> & 'a mut W { self . variant ( MC_A :: UP ) } # [ doc = "Continuous mode: Timer counts up to the value set by CNTL" ] # [ inline ( always ) ] pub fn continuous ( self ) -> & 'a mut W { self . variant ( MC_A :: CONTINUOUS ) } # [ doc = "Up/down mode: Timer counts up to TBxCL0 then down to 0000h" ] # [ inline ( always ) ] pub fn updown ( self ) -> & 'a mut W { self . variant ( MC_A :: UPDOWN ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Input divider\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ID_A { # [ doc = "0: /1" ] _1 = 0 , # [ doc = "1: /2" ] _2 = 1 , # [ doc = "2: /4" ] _4 = 2 , # [ doc = "3: /8" ] _8 = 3 } impl From < ID_A > for u8 { # [ inline ( always ) ] fn from ( variant : ID_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ID`" ] pub type ID_R = crate :: R < u8 , ID_A > ; impl ID_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ID_A { match self . bits { 0 => ID_A :: _1 , 1 => ID_A :: _2 , 2 => ID_A :: _4 , 3 => ID_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == ID_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == ID_A :: _2 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == ID_A :: _4 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == ID_A :: _8 } }
# [ doc = "Write proxy for field `ID`" ] pub struct ID_W < 'a > { w : & 'a mut W , } impl < 'a > ID_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ID_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "/1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( ID_A :: _1 ) } # [ doc = "/2" ] # [ inline ( always ) ] pub fn _2 ( self ) -> & 'a mut W { self . variant ( ID_A :: _2 ) } # [ doc = "/4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( ID_A :: _4 ) } # [ doc = "/8" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( ID_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "TimerB clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBSSEL_A { # [ doc = "0: TBxCLK" ] TBCLK = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: INCLK" ] INCLK = 3 } impl From < TBSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBSSEL`" ] pub type TBSSEL_R = crate :: R < u8 , TBSSEL_A > ; impl TBSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBSSEL_A { match self . bits { 0 => TBSSEL_A :: TBCLK , 1 => TBSSEL_A :: ACLK , 2 => TBSSEL_A :: SMCLK , 3 => TBSSEL_A :: INCLK , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `TBCLK`" ] # [ inline ( always ) ] pub fn is_tbclk ( & self ) -> bool { * self == TBSSEL_A :: TBCLK } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == TBSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == TBSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `INCLK`" ] # [ inline ( always ) ] pub fn is_inclk ( & self ) -> bool { * self == TBSSEL_A :: INCLK } }
# [ doc = "Write proxy for field `TBSSEL`" ] pub struct TBSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > TBSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLK" ] # [ inline ( always ) ] pub fn tbclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: TBCLK ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: SMCLK ) } # [ doc = "INCLK" ] # [ inline ( always ) ] pub fn inclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: INCLK ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Counter length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CNTL_A { # [ doc = "0: 16-bit, TBxR(max) = 0FFFFh" ] _16 = 0 , # [ doc = "1: 12-bit, TBxR(max) = 0FFFh" ] _12 = 1 , # [ doc = "2: 10-bit, TBxR(max) = 03FFh" ] _10 = 2 , # [ doc = "3: 8-bit, TBxR(max) = 0FFh" ] _8 = 3 } impl From < CNTL_A > for u8 { # [ inline ( always ) ] fn from ( variant : CNTL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CNTL`" ] pub type CNTL_R = crate :: R < u8 , CNTL_A > ; impl CNTL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CNTL_A { match self . bits { 0 => CNTL_A :: _16 , 1 => CNTL_A :: _12 , 2 => CNTL_A :: _10 , 3 => CNTL_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_16`" ] # [ inline ( always ) ] pub fn is_16 ( & self ) -> bool { * self == CNTL_A :: _16 } # [ doc = "Checks if the value of the field is `_12`" ] # [ inline ( always ) ] pub fn is_12 ( & self ) -> bool { * self == CNTL_A :: _12 } # [ doc = "Checks if the value of the field is `_10`" ] # [ inline ( always ) ] pub fn is_10 ( & self ) -> bool { * self == CNTL_A :: _10 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == CNTL_A :: _8 } }
# [ doc = "Write proxy for field `CNTL`" ] pub struct CNTL_W < 'a > { w : & 'a mut W , } impl < 'a > CNTL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CNTL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "16-bit, TBxR(max) = 0FFFFh" ] # [ inline ( always ) ] pub fn _16 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _16 ) } # [ doc = "12-bit, TBxR(max) = 0FFFh" ] # [ inline ( always ) ] pub fn _12 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _12 ) } # [ doc = "10-bit, TBxR(max) = 03FFh" ] # [ inline ( always ) ] pub fn _10 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _10 ) } # [ doc = "8-bit, TBxR(max) = 0FFh" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 11 ) ) | ( ( ( value as u16 ) & 0x03 ) << 11 ) ; self . w } }
# [ doc = "TBxCLn group\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBCLGRP_A { # [ doc = "0: Each TBxCLn latch loads independently" ] TBCLGRP_0 = 0 , # [ doc = "1: TBxCL1+TBxCL2 (TBxCCR1 CLLD bits control the update); TBxCL3+TBxCL4 (TBxCCR3 CLLD bits control the update); TBxCL5+TBxCL6 (TBxCCR5 CLLD bits control the update); TBxCL0 independent" ] TBCLGRP_1 = 1 , # [ doc = "2: TBxCL1+TBxCL2+TBxCL3 (TBxCCR1 CLLD bits control the update); TBxCL4+TBxCL5+TBxCL6 (TBxCCR4 CLLD bits control the update); TBxCL0 independent" ] TBCLGRP_2 = 2 , # [ doc = "3: TBxCL0+TBxCL1+TBxCL2+TBxCL3+TBxCL4+TBxCL5+TBxCL6 (TBxCCR1 CLLD bits control the update)" ] TBCLGRP_3 = 3 } impl From < TBCLGRP_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBCLGRP_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBCLGRP`" ] pub type TBCLGRP_R = crate :: R < u8 , TBCLGRP_A > ; impl TBCLGRP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBCLGRP_A { match self . bits { 0 => TBCLGRP_A :: TBCLGRP_0 , 1 => TBCLGRP_A :: TBCLGRP_1 , 2 => TBCLGRP_A :: TBCLGRP_2 , 3 => TBCLGRP_A :: TBCLGRP_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `TBCLGRP_0`" ] # [ inline ( always ) ] pub fn is_tbclgrp_0 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_0 } # [ doc = "Checks if the value of the field is `TBCLGRP_1`" ] # [ inline ( always ) ] pub fn is_tbclgrp_1 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_1 } # [ doc = "Checks if the value of the field is `TBCLGRP_2`" ] # [ inline ( always ) ] pub fn is_tbclgrp_2 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_2 } # [ doc = "Checks if the value of the field is `TBCLGRP_3`" ] # [ inline ( always ) ] pub fn is_tbclgrp_3 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_3 } }
# [ doc = "Write proxy for field `TBCLGRP`" ] pub struct TBCLGRP_W < 'a > { w : & 'a mut W , } impl < 'a > TBCLGRP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBCLGRP_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Each TBxCLn latch loads independently" ] # [ inline ( always ) ] pub fn tbclgrp_0 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_0 ) } # [ doc = "TBxCL1+TBxCL2 (TBxCCR1 CLLD bits control the update); TBxCL3+TBxCL4 (TBxCCR3 CLLD bits control the update); TBxCL5+TBxCL6 (TBxCCR5 CLLD bits control the update); TBxCL0 independent" ] # [ inline ( always ) ] pub fn tbclgrp_1 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_1 ) } # [ doc = "TBxCL1+TBxCL2+TBxCL3 (TBxCCR1 CLLD bits control the update); TBxCL4+TBxCL5+TBxCL6 (TBxCCR4 CLLD bits control the update); TBxCL0 independent" ] # [ inline ( always ) ] pub fn tbclgrp_2 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_2 ) } # [ doc = "TBxCL0+TBxCL1+TBxCL2+TBxCL3+TBxCL4+TBxCL5+TBxCL6 (TBxCCR1 CLLD bits control the update)" ] # [ inline ( always ) ] pub fn tbclgrp_3 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 13 ) ) | ( ( ( value as u16 ) & 0x03 ) << 13 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - TimerB interrupt flag" ] # [ inline ( always ) ] pub fn tbifg ( & self ) -> TBIFG_R { TBIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - TimerB interrupt enable" ] # [ inline ( always ) ] pub fn tbie ( & self ) -> TBIE_R { TBIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - TimerB clear" ] # [ inline ( always ) ] pub fn tbclr ( & self ) -> TBCLR_R { TBCLR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - Mode control" ] # [ inline ( always ) ] pub fn mc ( & self ) -> MC_R { MC_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 6:7 - Input divider" ] # [ inline ( always ) ] pub fn id ( & self ) -> ID_R { ID_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:9 - TimerB clock source select" ] # [ inline ( always ) ] pub fn tbssel ( & self ) -> TBSSEL_R { TBSSEL_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 11:12 - Counter length" ] # [ inline ( always ) ] pub fn cntl ( & self ) -> CNTL_R { CNTL_R :: new ( ( ( self . bits >> 11 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 13:14 - TBxCLn group" ] # [ inline ( always ) ] pub fn tbclgrp ( & self ) -> TBCLGRP_R { TBCLGRP_R :: new ( ( ( self . bits >> 13 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - TimerB interrupt flag" ] # [ inline ( always ) ] pub fn tbifg ( & mut self ) -> TBIFG_W { TBIFG_W { w : self } }
# [ doc = "Bit 1 - TimerB interrupt enable" ] # [ inline ( always ) ] pub fn tbie ( & mut self ) -> TBIE_W { TBIE_W { w : self } }
# [ doc = "Bit 2 - TimerB clear" ] # [ inline ( always ) ] pub fn tbclr ( & mut self ) -> TBCLR_W { TBCLR_W { w : self } }
# [ doc = "Bits 4:5 - Mode control" ] # [ inline ( always ) ] pub fn mc ( & mut self ) -> MC_W { MC_W { w : self } }
# [ doc = "Bits 6:7 - Input divider" ] # [ inline ( always ) ] pub fn id ( & mut self ) -> ID_W { ID_W { w : self } }
# [ doc = "Bits 8:9 - TimerB clock source select" ] # [ inline ( always ) ] pub fn tbssel ( & mut self ) -> TBSSEL_W { TBSSEL_W { w : self } }
# [ doc = "Bits 11:12 - Counter length" ] # [ inline ( always ) ] pub fn cntl ( & mut self ) -> CNTL_W { CNTL_W { w : self } }
# [ doc = "Bits 13:14 - TBxCLn group" ] # [ inline ( always ) ] pub fn tbclgrp ( & mut self ) -> TBCLGRP_W { TBCLGRP_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb1cctl0](tb1cctl0) module" ] pub type TB1CCTL0 = crate :: Reg < u16 , _TB1CCTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB1CCTL0 ;
# [ doc = "`read()` method returns [tb1cctl0::R](tb1cctl0::R) reader structure" ] impl crate :: Readable for TB1CCTL0 { }
# [ doc = "`write(|w| ..)` method takes [tb1cctl0::W](tb1cctl0::W) writer structure" ] impl crate :: Writable for TB1CCTL0 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb1cctl0 {
# [ doc = "Reader of register TB1CCTL0" ] pub type R = crate :: R < u16 , super :: TB1CCTL0 > ;
# [ doc = "Writer for register TB1CCTL0" ] pub type W = crate :: W < u16 , super :: TB1CCTL0 > ;
# [ doc = "Register TB1CCTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB1CCTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb1cctl1](tb1cctl1) module" ] pub type TB1CCTL1 = crate :: Reg < u16 , _TB1CCTL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB1CCTL1 ;
# [ doc = "`read()` method returns [tb1cctl1::R](tb1cctl1::R) reader structure" ] impl crate :: Readable for TB1CCTL1 { }
# [ doc = "`write(|w| ..)` method takes [tb1cctl1::W](tb1cctl1::W) writer structure" ] impl crate :: Writable for TB1CCTL1 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb1cctl1 {
# [ doc = "Reader of register TB1CCTL1" ] pub type R = crate :: R < u16 , super :: TB1CCTL1 > ;
# [ doc = "Writer for register TB1CCTL1" ] pub type W = crate :: W < u16 , super :: TB1CCTL1 > ;
# [ doc = "Register TB1CCTL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB1CCTL1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb1cctl2](tb1cctl2) module" ] pub type TB1CCTL2 = crate :: Reg < u16 , _TB1CCTL2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB1CCTL2 ;
# [ doc = "`read()` method returns [tb1cctl2::R](tb1cctl2::R) reader structure" ] impl crate :: Readable for TB1CCTL2 { }
# [ doc = "`write(|w| ..)` method takes [tb1cctl2::W](tb1cctl2::W) writer structure" ] impl crate :: Writable for TB1CCTL2 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb1cctl2 {
# [ doc = "Reader of register TB1CCTL2" ] pub type R = crate :: R < u16 , super :: TB1CCTL2 > ;
# [ doc = "Writer for register TB1CCTL2" ] pub type W = crate :: W < u16 , super :: TB1CCTL2 > ;
# [ doc = "Register TB1CCTL2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB1CCTL2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B count register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb1r](tb1r) module" ] pub type TB1R = crate :: Reg < u16 , _TB1R > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB1R ;
# [ doc = "`read()` method returns [tb1r::R](tb1r::R) reader structure" ] impl crate :: Readable for TB1R { }
# [ doc = "`write(|w| ..)` method takes [tb1r::W](tb1r::W) writer structure" ] impl crate :: Writable for TB1R { }
# [ doc = "Timer_B count register" ] pub mod tb1r {
# [ doc = "Reader of register TB1R" ] pub type R = crate :: R < u16 , super :: TB1R > ;
# [ doc = "Writer for register TB1R" ] pub type W = crate :: W < u16 , super :: TB1R > ;
# [ doc = "Register TB1R `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB1R { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb1ccr0](tb1ccr0) module" ] pub type TB1CCR0 = crate :: Reg < u16 , _TB1CCR0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB1CCR0 ;
# [ doc = "`read()` method returns [tb1ccr0::R](tb1ccr0::R) reader structure" ] impl crate :: Readable for TB1CCR0 { }
# [ doc = "`write(|w| ..)` method takes [tb1ccr0::W](tb1ccr0::W) writer structure" ] impl crate :: Writable for TB1CCR0 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb1ccr0 {
# [ doc = "Reader of register TB1CCR0" ] pub type R = crate :: R < u16 , super :: TB1CCR0 > ;
# [ doc = "Writer for register TB1CCR0" ] pub type W = crate :: W < u16 , super :: TB1CCR0 > ;
# [ doc = "Register TB1CCR0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB1CCR0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb1ccr1](tb1ccr1) module" ] pub type TB1CCR1 = crate :: Reg < u16 , _TB1CCR1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB1CCR1 ;
# [ doc = "`read()` method returns [tb1ccr1::R](tb1ccr1::R) reader structure" ] impl crate :: Readable for TB1CCR1 { }
# [ doc = "`write(|w| ..)` method takes [tb1ccr1::W](tb1ccr1::W) writer structure" ] impl crate :: Writable for TB1CCR1 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb1ccr1 {
# [ doc = "Reader of register TB1CCR1" ] pub type R = crate :: R < u16 , super :: TB1CCR1 > ;
# [ doc = "Writer for register TB1CCR1" ] pub type W = crate :: W < u16 , super :: TB1CCR1 > ;
# [ doc = "Register TB1CCR1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB1CCR1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb1ccr2](tb1ccr2) module" ] pub type TB1CCR2 = crate :: Reg < u16 , _TB1CCR2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB1CCR2 ;
# [ doc = "`read()` method returns [tb1ccr2::R](tb1ccr2::R) reader structure" ] impl crate :: Readable for TB1CCR2 { }
# [ doc = "`write(|w| ..)` method takes [tb1ccr2::W](tb1ccr2::W) writer structure" ] impl crate :: Writable for TB1CCR2 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb1ccr2 {
# [ doc = "Reader of register TB1CCR2" ] pub type R = crate :: R < u16 , super :: TB1CCR2 > ;
# [ doc = "Writer for register TB1CCR2" ] pub type W = crate :: W < u16 , super :: TB1CCR2 > ;
# [ doc = "Register TB1CCR2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB1CCR2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_Bx Expansion Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb1ex0](tb1ex0) module" ] pub type TB1EX0 = crate :: Reg < u16 , _TB1EX0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB1EX0 ;
# [ doc = "`read()` method returns [tb1ex0::R](tb1ex0::R) reader structure" ] impl crate :: Readable for TB1EX0 { }
# [ doc = "`write(|w| ..)` method takes [tb1ex0::W](tb1ex0::W) writer structure" ] impl crate :: Writable for TB1EX0 { }
# [ doc = "Timer_Bx Expansion Register 0" ] pub mod tb1ex0 {
# [ doc = "Reader of register TB1EX0" ] pub type R = crate :: R < u16 , super :: TB1EX0 > ;
# [ doc = "Writer for register TB1EX0" ] pub type W = crate :: W < u16 , super :: TB1EX0 > ;
# [ doc = "Register TB1EX0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB1EX0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Input divider expansion\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBIDEX_A { # [ doc = "0: Divide by 1" ] _1 = 0 , # [ doc = "1: Divide by 2" ] _2 = 1 , # [ doc = "2: Divide by 3" ] _3 = 2 , # [ doc = "3: Divide by 4" ] _4 = 3 , # [ doc = "4: Divide by 5" ] _5 = 4 , # [ doc = "5: Divide by 6" ] _6 = 5 , # [ doc = "6: Divide by 7" ] _7 = 6 , # [ doc = "7: Divide by 8" ] _8 = 7 } impl From < TBIDEX_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBIDEX_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBIDEX`" ] pub type TBIDEX_R = crate :: R < u8 , TBIDEX_A > ; impl TBIDEX_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIDEX_A { match self . bits { 0 => TBIDEX_A :: _1 , 1 => TBIDEX_A :: _2 , 2 => TBIDEX_A :: _3 , 3 => TBIDEX_A :: _4 , 4 => TBIDEX_A :: _5 , 5 => TBIDEX_A :: _6 , 6 => TBIDEX_A :: _7 , 7 => TBIDEX_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == TBIDEX_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == TBIDEX_A :: _2 } # [ doc = "Checks if the value of the field is `_3`" ] # [ inline ( always ) ] pub fn is_3 ( & self ) -> bool { * self == TBIDEX_A :: _3 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == TBIDEX_A :: _4 } # [ doc = "Checks if the value of the field is `_5`" ] # [ inline ( always ) ] pub fn is_5 ( & self ) -> bool { * self == TBIDEX_A :: _5 } # [ doc = "Checks if the value of the field is `_6`" ] # [ inline ( always ) ] pub fn is_6 ( & self ) -> bool { * self == TBIDEX_A :: _6 } # [ doc = "Checks if the value of the field is `_7`" ] # [ inline ( always ) ] pub fn is_7 ( & self ) -> bool { * self == TBIDEX_A :: _7 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == TBIDEX_A :: _8 } }
# [ doc = "Write proxy for field `TBIDEX`" ] pub struct TBIDEX_W < 'a > { w : & 'a mut W , } impl < 'a > TBIDEX_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIDEX_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Divide by 1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _1 ) } # [ doc = "Divide by 2" ] # [ inline ( always ) ] pub fn _2 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _2 ) } # [ doc = "Divide by 3" ] # [ inline ( always ) ] pub fn _3 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _3 ) } # [ doc = "Divide by 4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _4 ) } # [ doc = "Divide by 5" ] # [ inline ( always ) ] pub fn _5 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _5 ) } # [ doc = "Divide by 6" ] # [ inline ( always ) ] pub fn _6 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _6 ) } # [ doc = "Divide by 7" ] # [ inline ( always ) ] pub fn _7 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _7 ) } # [ doc = "Divide by 8" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u16 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Input divider expansion" ] # [ inline ( always ) ] pub fn tbidex ( & self ) -> TBIDEX_R { TBIDEX_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Input divider expansion" ] # [ inline ( always ) ] pub fn tbidex ( & mut self ) -> TBIDEX_W { TBIDEX_W { w : self } }
}
}
# [ doc = "Timer_Bx Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb1iv](tb1iv) module" ] pub type TB1IV = crate :: Reg < u16 , _TB1IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB1IV ;
# [ doc = "`read()` method returns [tb1iv::R](tb1iv::R) reader structure" ] impl crate :: Readable for TB1IV { }
# [ doc = "Timer_Bx Interrupt Vector Register" ] pub mod tb1iv {
# [ doc = "Reader of register TB1IV" ] pub type R = crate :: R < u16 , super :: TB1IV > ;
# [ doc = "Timer_B interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum TBIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Capture/compare 1; Interrupt Flag: TBxCCR1 CCIFG; Interrupt Priority: Highest" ] TBCCR1 = 2 , # [ doc = "4: Interrupt Source: Capture/compare 2; Interrupt Flag: TBxCCR2 CCIFG" ] TBCCR2 = 4 , # [ doc = "6: Interrupt Source: Capture/compare 3; Interrupt Flag: TBxCCR3 CCIFG" ] TBCCR3 = 6 , # [ doc = "8: Interrupt Source: Capture/compare 4; Interrupt Flag: TBxCCR4 CCIFG" ] TBCCR4 = 8 , # [ doc = "10: Interrupt Source: Capture/compare 5; Interrupt Flag: TBxCCR5 CCIFG" ] TBCCR5 = 10 , # [ doc = "12: Interrupt Source: Capture/compare 6; Interrupt Flag: TBxCCR6 CCIFG" ] TBCCR6 = 12 , # [ doc = "14: Interrupt Source: Timer overflow; Interrupt Flag: TBxCTL TBIFG; Interrupt Priority: Lowest" ] TBIFG = 14 } impl From < TBIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : TBIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBIV`" ] pub type TBIV_R = crate :: R < u16 , TBIV_A > ; impl TBIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , TBIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( TBIV_A :: NONE ) , 2 => Val ( TBIV_A :: TBCCR1 ) , 4 => Val ( TBIV_A :: TBCCR2 ) , 6 => Val ( TBIV_A :: TBCCR3 ) , 8 => Val ( TBIV_A :: TBCCR4 ) , 10 => Val ( TBIV_A :: TBCCR5 ) , 12 => Val ( TBIV_A :: TBCCR6 ) , 14 => Val ( TBIV_A :: TBIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == TBIV_A :: NONE } # [ doc = "Checks if the value of the field is `TBCCR1`" ] # [ inline ( always ) ] pub fn is_tbccr1 ( & self ) -> bool { * self == TBIV_A :: TBCCR1 } # [ doc = "Checks if the value of the field is `TBCCR2`" ] # [ inline ( always ) ] pub fn is_tbccr2 ( & self ) -> bool { * self == TBIV_A :: TBCCR2 } # [ doc = "Checks if the value of the field is `TBCCR3`" ] # [ inline ( always ) ] pub fn is_tbccr3 ( & self ) -> bool { * self == TBIV_A :: TBCCR3 } # [ doc = "Checks if the value of the field is `TBCCR4`" ] # [ inline ( always ) ] pub fn is_tbccr4 ( & self ) -> bool { * self == TBIV_A :: TBCCR4 } # [ doc = "Checks if the value of the field is `TBCCR5`" ] # [ inline ( always ) ] pub fn is_tbccr5 ( & self ) -> bool { * self == TBIV_A :: TBCCR5 } # [ doc = "Checks if the value of the field is `TBCCR6`" ] # [ inline ( always ) ] pub fn is_tbccr6 ( & self ) -> bool { * self == TBIV_A :: TBCCR6 } # [ doc = "Checks if the value of the field is `TBIFG`" ] # [ inline ( always ) ] pub fn is_tbifg ( & self ) -> bool { * self == TBIV_A :: TBIFG } }
impl R {
# [ doc = "Bits 0:15 - Timer_B interrupt vector value" ] # [ inline ( always ) ] pub fn tbiv ( & self ) -> TBIV_R { TBIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "TB2" ] pub struct TB2 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TB2 { } impl TB2 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const tb2 :: RegisterBlock { 0x0400 as * const _ } } impl Deref for TB2 { type Target = tb2 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * TB2 :: ptr ( ) } } }
# [ doc = "TB2" ] pub mod tb2 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Timer_B Control Register" ] pub tb2ctl : TB2CTL , # [ doc = "0x02 - Timer_B Capture/Compare Control Register" ] pub tb2cctl0 : TB2CCTL0 , # [ doc = "0x04 - Timer_B Capture/Compare Control Register" ] pub tb2cctl1 : TB2CCTL1 , # [ doc = "0x06 - Timer_B Capture/Compare Control Register" ] pub tb2cctl2 : TB2CCTL2 , _reserved4 : [ u8 ; 8usize ] , # [ doc = "0x10 - Timer_B count register" ] pub tb2r : TB2R , # [ doc = "0x12 - Timer_B Capture/Compare Register" ] pub tb2ccr0 : TB2CCR0 , # [ doc = "0x14 - Timer_B Capture/Compare Register" ] pub tb2ccr1 : TB2CCR1 , # [ doc = "0x16 - Timer_B Capture/Compare Register" ] pub tb2ccr2 : TB2CCR2 , _reserved8 : [ u8 ; 8usize ] , # [ doc = "0x20 - Timer_Bx Expansion Register 0" ] pub tb2ex0 : TB2EX0 , _reserved9 : [ u8 ; 12usize ] , # [ doc = "0x2e - Timer_Bx Interrupt Vector Register" ] pub tb2iv : TB2IV , }
# [ doc = "Timer_B Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb2ctl](tb2ctl) module" ] pub type TB2CTL = crate :: Reg < u16 , _TB2CTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB2CTL ;
# [ doc = "`read()` method returns [tb2ctl::R](tb2ctl::R) reader structure" ] impl crate :: Readable for TB2CTL { }
# [ doc = "`write(|w| ..)` method takes [tb2ctl::W](tb2ctl::W) writer structure" ] impl crate :: Writable for TB2CTL { }
# [ doc = "Timer_B Control Register" ] pub mod tb2ctl {
# [ doc = "Reader of register TB2CTL" ] pub type R = crate :: R < u16 , super :: TB2CTL > ;
# [ doc = "Writer for register TB2CTL" ] pub type W = crate :: W < u16 , super :: TB2CTL > ;
# [ doc = "Register TB2CTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB2CTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "TimerB interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TBIFG_A { # [ doc = "0: No interrupt pending" ] TBIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] TBIFG_1 = 1 } impl From < TBIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : TBIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `TBIFG`" ] pub type TBIFG_R = crate :: R < bool , TBIFG_A > ; impl TBIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIFG_A { match self . bits { false => TBIFG_A :: TBIFG_0 , true => TBIFG_A :: TBIFG_1 } } # [ doc = "Checks if the value of the field is `TBIFG_0`" ] # [ inline ( always ) ] pub fn is_tbifg_0 ( & self ) -> bool { * self == TBIFG_A :: TBIFG_0 } # [ doc = "Checks if the value of the field is `TBIFG_1`" ] # [ inline ( always ) ] pub fn is_tbifg_1 ( & self ) -> bool { * self == TBIFG_A :: TBIFG_1 } }
# [ doc = "Write proxy for field `TBIFG`" ] pub struct TBIFG_W < 'a > { w : & 'a mut W , } impl < 'a > TBIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn tbifg_0 ( self ) -> & 'a mut W { self . variant ( TBIFG_A :: TBIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn tbifg_1 ( self ) -> & 'a mut W { self . variant ( TBIFG_A :: TBIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "TimerB interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TBIE_A { # [ doc = "0: Interrupt disabled" ] TBIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] TBIE_1 = 1 } impl From < TBIE_A > for bool { # [ inline ( always ) ] fn from ( variant : TBIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `TBIE`" ] pub type TBIE_R = crate :: R < bool , TBIE_A > ; impl TBIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIE_A { match self . bits { false => TBIE_A :: TBIE_0 , true => TBIE_A :: TBIE_1 } } # [ doc = "Checks if the value of the field is `TBIE_0`" ] # [ inline ( always ) ] pub fn is_tbie_0 ( & self ) -> bool { * self == TBIE_A :: TBIE_0 } # [ doc = "Checks if the value of the field is `TBIE_1`" ] # [ inline ( always ) ] pub fn is_tbie_1 ( & self ) -> bool { * self == TBIE_A :: TBIE_1 } }
# [ doc = "Write proxy for field `TBIE`" ] pub struct TBIE_W < 'a > { w : & 'a mut W , } impl < 'a > TBIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn tbie_0 ( self ) -> & 'a mut W { self . variant ( TBIE_A :: TBIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn tbie_1 ( self ) -> & 'a mut W { self . variant ( TBIE_A :: TBIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `TBCLR`" ] pub type TBCLR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TBCLR`" ] pub struct TBCLR_W < 'a > { w : & 'a mut W , } impl < 'a > TBCLR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Mode control\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum MC_A { # [ doc = "0: Stop mode: Timer is halted" ] STOP = 0 , # [ doc = "1: Up mode: Timer counts up to TBxCL0" ] UP = 1 , # [ doc = "2: Continuous mode: Timer counts up to the value set by CNTL" ] CONTINUOUS = 2 , # [ doc = "3: Up/down mode: Timer counts up to TBxCL0 then down to 0000h" ] UPDOWN = 3 } impl From < MC_A > for u8 { # [ inline ( always ) ] fn from ( variant : MC_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `MC`" ] pub type MC_R = crate :: R < u8 , MC_A > ; impl MC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MC_A { match self . bits { 0 => MC_A :: STOP , 1 => MC_A :: UP , 2 => MC_A :: CONTINUOUS , 3 => MC_A :: UPDOWN , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `STOP`" ] # [ inline ( always ) ] pub fn is_stop ( & self ) -> bool { * self == MC_A :: STOP } # [ doc = "Checks if the value of the field is `UP`" ] # [ inline ( always ) ] pub fn is_up ( & self ) -> bool { * self == MC_A :: UP } # [ doc = "Checks if the value of the field is `CONTINUOUS`" ] # [ inline ( always ) ] pub fn is_continuous ( & self ) -> bool { * self == MC_A :: CONTINUOUS } # [ doc = "Checks if the value of the field is `UPDOWN`" ] # [ inline ( always ) ] pub fn is_updown ( & self ) -> bool { * self == MC_A :: UPDOWN } }
# [ doc = "Write proxy for field `MC`" ] pub struct MC_W < 'a > { w : & 'a mut W , } impl < 'a > MC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MC_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Stop mode: Timer is halted" ] # [ inline ( always ) ] pub fn stop ( self ) -> & 'a mut W { self . variant ( MC_A :: STOP ) } # [ doc = "Up mode: Timer counts up to TBxCL0" ] # [ inline ( always ) ] pub fn up ( self ) -> & 'a mut W { self . variant ( MC_A :: UP ) } # [ doc = "Continuous mode: Timer counts up to the value set by CNTL" ] # [ inline ( always ) ] pub fn continuous ( self ) -> & 'a mut W { self . variant ( MC_A :: CONTINUOUS ) } # [ doc = "Up/down mode: Timer counts up to TBxCL0 then down to 0000h" ] # [ inline ( always ) ] pub fn updown ( self ) -> & 'a mut W { self . variant ( MC_A :: UPDOWN ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Input divider\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ID_A { # [ doc = "0: /1" ] _1 = 0 , # [ doc = "1: /2" ] _2 = 1 , # [ doc = "2: /4" ] _4 = 2 , # [ doc = "3: /8" ] _8 = 3 } impl From < ID_A > for u8 { # [ inline ( always ) ] fn from ( variant : ID_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ID`" ] pub type ID_R = crate :: R < u8 , ID_A > ; impl ID_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ID_A { match self . bits { 0 => ID_A :: _1 , 1 => ID_A :: _2 , 2 => ID_A :: _4 , 3 => ID_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == ID_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == ID_A :: _2 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == ID_A :: _4 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == ID_A :: _8 } }
# [ doc = "Write proxy for field `ID`" ] pub struct ID_W < 'a > { w : & 'a mut W , } impl < 'a > ID_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ID_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "/1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( ID_A :: _1 ) } # [ doc = "/2" ] # [ inline ( always ) ] pub fn _2 ( self ) -> & 'a mut W { self . variant ( ID_A :: _2 ) } # [ doc = "/4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( ID_A :: _4 ) } # [ doc = "/8" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( ID_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "TimerB clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBSSEL_A { # [ doc = "0: TBxCLK" ] TBCLK = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: INCLK" ] INCLK = 3 } impl From < TBSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBSSEL`" ] pub type TBSSEL_R = crate :: R < u8 , TBSSEL_A > ; impl TBSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBSSEL_A { match self . bits { 0 => TBSSEL_A :: TBCLK , 1 => TBSSEL_A :: ACLK , 2 => TBSSEL_A :: SMCLK , 3 => TBSSEL_A :: INCLK , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `TBCLK`" ] # [ inline ( always ) ] pub fn is_tbclk ( & self ) -> bool { * self == TBSSEL_A :: TBCLK } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == TBSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == TBSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `INCLK`" ] # [ inline ( always ) ] pub fn is_inclk ( & self ) -> bool { * self == TBSSEL_A :: INCLK } }
# [ doc = "Write proxy for field `TBSSEL`" ] pub struct TBSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > TBSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLK" ] # [ inline ( always ) ] pub fn tbclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: TBCLK ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: SMCLK ) } # [ doc = "INCLK" ] # [ inline ( always ) ] pub fn inclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: INCLK ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Counter length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CNTL_A { # [ doc = "0: 16-bit, TBxR(max) = 0FFFFh" ] _16 = 0 , # [ doc = "1: 12-bit, TBxR(max) = 0FFFh" ] _12 = 1 , # [ doc = "2: 10-bit, TBxR(max) = 03FFh" ] _10 = 2 , # [ doc = "3: 8-bit, TBxR(max) = 0FFh" ] _8 = 3 } impl From < CNTL_A > for u8 { # [ inline ( always ) ] fn from ( variant : CNTL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CNTL`" ] pub type CNTL_R = crate :: R < u8 , CNTL_A > ; impl CNTL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CNTL_A { match self . bits { 0 => CNTL_A :: _16 , 1 => CNTL_A :: _12 , 2 => CNTL_A :: _10 , 3 => CNTL_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_16`" ] # [ inline ( always ) ] pub fn is_16 ( & self ) -> bool { * self == CNTL_A :: _16 } # [ doc = "Checks if the value of the field is `_12`" ] # [ inline ( always ) ] pub fn is_12 ( & self ) -> bool { * self == CNTL_A :: _12 } # [ doc = "Checks if the value of the field is `_10`" ] # [ inline ( always ) ] pub fn is_10 ( & self ) -> bool { * self == CNTL_A :: _10 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == CNTL_A :: _8 } }
# [ doc = "Write proxy for field `CNTL`" ] pub struct CNTL_W < 'a > { w : & 'a mut W , } impl < 'a > CNTL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CNTL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "16-bit, TBxR(max) = 0FFFFh" ] # [ inline ( always ) ] pub fn _16 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _16 ) } # [ doc = "12-bit, TBxR(max) = 0FFFh" ] # [ inline ( always ) ] pub fn _12 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _12 ) } # [ doc = "10-bit, TBxR(max) = 03FFh" ] # [ inline ( always ) ] pub fn _10 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _10 ) } # [ doc = "8-bit, TBxR(max) = 0FFh" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 11 ) ) | ( ( ( value as u16 ) & 0x03 ) << 11 ) ; self . w } }
# [ doc = "TBxCLn group\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBCLGRP_A { # [ doc = "0: Each TBxCLn latch loads independently" ] TBCLGRP_0 = 0 , # [ doc = "1: TBxCL1+TBxCL2 (TBxCCR1 CLLD bits control the update); TBxCL3+TBxCL4 (TBxCCR3 CLLD bits control the update); TBxCL5+TBxCL6 (TBxCCR5 CLLD bits control the update); TBxCL0 independent" ] TBCLGRP_1 = 1 , # [ doc = "2: TBxCL1+TBxCL2+TBxCL3 (TBxCCR1 CLLD bits control the update); TBxCL4+TBxCL5+TBxCL6 (TBxCCR4 CLLD bits control the update); TBxCL0 independent" ] TBCLGRP_2 = 2 , # [ doc = "3: TBxCL0+TBxCL1+TBxCL2+TBxCL3+TBxCL4+TBxCL5+TBxCL6 (TBxCCR1 CLLD bits control the update)" ] TBCLGRP_3 = 3 } impl From < TBCLGRP_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBCLGRP_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBCLGRP`" ] pub type TBCLGRP_R = crate :: R < u8 , TBCLGRP_A > ; impl TBCLGRP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBCLGRP_A { match self . bits { 0 => TBCLGRP_A :: TBCLGRP_0 , 1 => TBCLGRP_A :: TBCLGRP_1 , 2 => TBCLGRP_A :: TBCLGRP_2 , 3 => TBCLGRP_A :: TBCLGRP_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `TBCLGRP_0`" ] # [ inline ( always ) ] pub fn is_tbclgrp_0 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_0 } # [ doc = "Checks if the value of the field is `TBCLGRP_1`" ] # [ inline ( always ) ] pub fn is_tbclgrp_1 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_1 } # [ doc = "Checks if the value of the field is `TBCLGRP_2`" ] # [ inline ( always ) ] pub fn is_tbclgrp_2 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_2 } # [ doc = "Checks if the value of the field is `TBCLGRP_3`" ] # [ inline ( always ) ] pub fn is_tbclgrp_3 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_3 } }
# [ doc = "Write proxy for field `TBCLGRP`" ] pub struct TBCLGRP_W < 'a > { w : & 'a mut W , } impl < 'a > TBCLGRP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBCLGRP_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Each TBxCLn latch loads independently" ] # [ inline ( always ) ] pub fn tbclgrp_0 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_0 ) } # [ doc = "TBxCL1+TBxCL2 (TBxCCR1 CLLD bits control the update); TBxCL3+TBxCL4 (TBxCCR3 CLLD bits control the update); TBxCL5+TBxCL6 (TBxCCR5 CLLD bits control the update); TBxCL0 independent" ] # [ inline ( always ) ] pub fn tbclgrp_1 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_1 ) } # [ doc = "TBxCL1+TBxCL2+TBxCL3 (TBxCCR1 CLLD bits control the update); TBxCL4+TBxCL5+TBxCL6 (TBxCCR4 CLLD bits control the update); TBxCL0 independent" ] # [ inline ( always ) ] pub fn tbclgrp_2 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_2 ) } # [ doc = "TBxCL0+TBxCL1+TBxCL2+TBxCL3+TBxCL4+TBxCL5+TBxCL6 (TBxCCR1 CLLD bits control the update)" ] # [ inline ( always ) ] pub fn tbclgrp_3 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 13 ) ) | ( ( ( value as u16 ) & 0x03 ) << 13 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - TimerB interrupt flag" ] # [ inline ( always ) ] pub fn tbifg ( & self ) -> TBIFG_R { TBIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - TimerB interrupt enable" ] # [ inline ( always ) ] pub fn tbie ( & self ) -> TBIE_R { TBIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - TimerB clear" ] # [ inline ( always ) ] pub fn tbclr ( & self ) -> TBCLR_R { TBCLR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - Mode control" ] # [ inline ( always ) ] pub fn mc ( & self ) -> MC_R { MC_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 6:7 - Input divider" ] # [ inline ( always ) ] pub fn id ( & self ) -> ID_R { ID_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:9 - TimerB clock source select" ] # [ inline ( always ) ] pub fn tbssel ( & self ) -> TBSSEL_R { TBSSEL_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 11:12 - Counter length" ] # [ inline ( always ) ] pub fn cntl ( & self ) -> CNTL_R { CNTL_R :: new ( ( ( self . bits >> 11 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 13:14 - TBxCLn group" ] # [ inline ( always ) ] pub fn tbclgrp ( & self ) -> TBCLGRP_R { TBCLGRP_R :: new ( ( ( self . bits >> 13 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - TimerB interrupt flag" ] # [ inline ( always ) ] pub fn tbifg ( & mut self ) -> TBIFG_W { TBIFG_W { w : self } }
# [ doc = "Bit 1 - TimerB interrupt enable" ] # [ inline ( always ) ] pub fn tbie ( & mut self ) -> TBIE_W { TBIE_W { w : self } }
# [ doc = "Bit 2 - TimerB clear" ] # [ inline ( always ) ] pub fn tbclr ( & mut self ) -> TBCLR_W { TBCLR_W { w : self } }
# [ doc = "Bits 4:5 - Mode control" ] # [ inline ( always ) ] pub fn mc ( & mut self ) -> MC_W { MC_W { w : self } }
# [ doc = "Bits 6:7 - Input divider" ] # [ inline ( always ) ] pub fn id ( & mut self ) -> ID_W { ID_W { w : self } }
# [ doc = "Bits 8:9 - TimerB clock source select" ] # [ inline ( always ) ] pub fn tbssel ( & mut self ) -> TBSSEL_W { TBSSEL_W { w : self } }
# [ doc = "Bits 11:12 - Counter length" ] # [ inline ( always ) ] pub fn cntl ( & mut self ) -> CNTL_W { CNTL_W { w : self } }
# [ doc = "Bits 13:14 - TBxCLn group" ] # [ inline ( always ) ] pub fn tbclgrp ( & mut self ) -> TBCLGRP_W { TBCLGRP_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb2cctl0](tb2cctl0) module" ] pub type TB2CCTL0 = crate :: Reg < u16 , _TB2CCTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB2CCTL0 ;
# [ doc = "`read()` method returns [tb2cctl0::R](tb2cctl0::R) reader structure" ] impl crate :: Readable for TB2CCTL0 { }
# [ doc = "`write(|w| ..)` method takes [tb2cctl0::W](tb2cctl0::W) writer structure" ] impl crate :: Writable for TB2CCTL0 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb2cctl0 {
# [ doc = "Reader of register TB2CCTL0" ] pub type R = crate :: R < u16 , super :: TB2CCTL0 > ;
# [ doc = "Writer for register TB2CCTL0" ] pub type W = crate :: W < u16 , super :: TB2CCTL0 > ;
# [ doc = "Register TB2CCTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB2CCTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb2cctl1](tb2cctl1) module" ] pub type TB2CCTL1 = crate :: Reg < u16 , _TB2CCTL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB2CCTL1 ;
# [ doc = "`read()` method returns [tb2cctl1::R](tb2cctl1::R) reader structure" ] impl crate :: Readable for TB2CCTL1 { }
# [ doc = "`write(|w| ..)` method takes [tb2cctl1::W](tb2cctl1::W) writer structure" ] impl crate :: Writable for TB2CCTL1 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb2cctl1 {
# [ doc = "Reader of register TB2CCTL1" ] pub type R = crate :: R < u16 , super :: TB2CCTL1 > ;
# [ doc = "Writer for register TB2CCTL1" ] pub type W = crate :: W < u16 , super :: TB2CCTL1 > ;
# [ doc = "Register TB2CCTL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB2CCTL1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb2cctl2](tb2cctl2) module" ] pub type TB2CCTL2 = crate :: Reg < u16 , _TB2CCTL2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB2CCTL2 ;
# [ doc = "`read()` method returns [tb2cctl2::R](tb2cctl2::R) reader structure" ] impl crate :: Readable for TB2CCTL2 { }
# [ doc = "`write(|w| ..)` method takes [tb2cctl2::W](tb2cctl2::W) writer structure" ] impl crate :: Writable for TB2CCTL2 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb2cctl2 {
# [ doc = "Reader of register TB2CCTL2" ] pub type R = crate :: R < u16 , super :: TB2CCTL2 > ;
# [ doc = "Writer for register TB2CCTL2" ] pub type W = crate :: W < u16 , super :: TB2CCTL2 > ;
# [ doc = "Register TB2CCTL2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB2CCTL2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B count register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb2r](tb2r) module" ] pub type TB2R = crate :: Reg < u16 , _TB2R > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB2R ;
# [ doc = "`read()` method returns [tb2r::R](tb2r::R) reader structure" ] impl crate :: Readable for TB2R { }
# [ doc = "`write(|w| ..)` method takes [tb2r::W](tb2r::W) writer structure" ] impl crate :: Writable for TB2R { }
# [ doc = "Timer_B count register" ] pub mod tb2r {
# [ doc = "Reader of register TB2R" ] pub type R = crate :: R < u16 , super :: TB2R > ;
# [ doc = "Writer for register TB2R" ] pub type W = crate :: W < u16 , super :: TB2R > ;
# [ doc = "Register TB2R `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB2R { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb2ccr0](tb2ccr0) module" ] pub type TB2CCR0 = crate :: Reg < u16 , _TB2CCR0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB2CCR0 ;
# [ doc = "`read()` method returns [tb2ccr0::R](tb2ccr0::R) reader structure" ] impl crate :: Readable for TB2CCR0 { }
# [ doc = "`write(|w| ..)` method takes [tb2ccr0::W](tb2ccr0::W) writer structure" ] impl crate :: Writable for TB2CCR0 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb2ccr0 {
# [ doc = "Reader of register TB2CCR0" ] pub type R = crate :: R < u16 , super :: TB2CCR0 > ;
# [ doc = "Writer for register TB2CCR0" ] pub type W = crate :: W < u16 , super :: TB2CCR0 > ;
# [ doc = "Register TB2CCR0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB2CCR0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb2ccr1](tb2ccr1) module" ] pub type TB2CCR1 = crate :: Reg < u16 , _TB2CCR1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB2CCR1 ;
# [ doc = "`read()` method returns [tb2ccr1::R](tb2ccr1::R) reader structure" ] impl crate :: Readable for TB2CCR1 { }
# [ doc = "`write(|w| ..)` method takes [tb2ccr1::W](tb2ccr1::W) writer structure" ] impl crate :: Writable for TB2CCR1 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb2ccr1 {
# [ doc = "Reader of register TB2CCR1" ] pub type R = crate :: R < u16 , super :: TB2CCR1 > ;
# [ doc = "Writer for register TB2CCR1" ] pub type W = crate :: W < u16 , super :: TB2CCR1 > ;
# [ doc = "Register TB2CCR1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB2CCR1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb2ccr2](tb2ccr2) module" ] pub type TB2CCR2 = crate :: Reg < u16 , _TB2CCR2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB2CCR2 ;
# [ doc = "`read()` method returns [tb2ccr2::R](tb2ccr2::R) reader structure" ] impl crate :: Readable for TB2CCR2 { }
# [ doc = "`write(|w| ..)` method takes [tb2ccr2::W](tb2ccr2::W) writer structure" ] impl crate :: Writable for TB2CCR2 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb2ccr2 {
# [ doc = "Reader of register TB2CCR2" ] pub type R = crate :: R < u16 , super :: TB2CCR2 > ;
# [ doc = "Writer for register TB2CCR2" ] pub type W = crate :: W < u16 , super :: TB2CCR2 > ;
# [ doc = "Register TB2CCR2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB2CCR2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_Bx Expansion Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb2ex0](tb2ex0) module" ] pub type TB2EX0 = crate :: Reg < u16 , _TB2EX0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB2EX0 ;
# [ doc = "`read()` method returns [tb2ex0::R](tb2ex0::R) reader structure" ] impl crate :: Readable for TB2EX0 { }
# [ doc = "`write(|w| ..)` method takes [tb2ex0::W](tb2ex0::W) writer structure" ] impl crate :: Writable for TB2EX0 { }
# [ doc = "Timer_Bx Expansion Register 0" ] pub mod tb2ex0 {
# [ doc = "Reader of register TB2EX0" ] pub type R = crate :: R < u16 , super :: TB2EX0 > ;
# [ doc = "Writer for register TB2EX0" ] pub type W = crate :: W < u16 , super :: TB2EX0 > ;
# [ doc = "Register TB2EX0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB2EX0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Input divider expansion\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBIDEX_A { # [ doc = "0: Divide by 1" ] _1 = 0 , # [ doc = "1: Divide by 2" ] _2 = 1 , # [ doc = "2: Divide by 3" ] _3 = 2 , # [ doc = "3: Divide by 4" ] _4 = 3 , # [ doc = "4: Divide by 5" ] _5 = 4 , # [ doc = "5: Divide by 6" ] _6 = 5 , # [ doc = "6: Divide by 7" ] _7 = 6 , # [ doc = "7: Divide by 8" ] _8 = 7 } impl From < TBIDEX_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBIDEX_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBIDEX`" ] pub type TBIDEX_R = crate :: R < u8 , TBIDEX_A > ; impl TBIDEX_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIDEX_A { match self . bits { 0 => TBIDEX_A :: _1 , 1 => TBIDEX_A :: _2 , 2 => TBIDEX_A :: _3 , 3 => TBIDEX_A :: _4 , 4 => TBIDEX_A :: _5 , 5 => TBIDEX_A :: _6 , 6 => TBIDEX_A :: _7 , 7 => TBIDEX_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == TBIDEX_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == TBIDEX_A :: _2 } # [ doc = "Checks if the value of the field is `_3`" ] # [ inline ( always ) ] pub fn is_3 ( & self ) -> bool { * self == TBIDEX_A :: _3 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == TBIDEX_A :: _4 } # [ doc = "Checks if the value of the field is `_5`" ] # [ inline ( always ) ] pub fn is_5 ( & self ) -> bool { * self == TBIDEX_A :: _5 } # [ doc = "Checks if the value of the field is `_6`" ] # [ inline ( always ) ] pub fn is_6 ( & self ) -> bool { * self == TBIDEX_A :: _6 } # [ doc = "Checks if the value of the field is `_7`" ] # [ inline ( always ) ] pub fn is_7 ( & self ) -> bool { * self == TBIDEX_A :: _7 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == TBIDEX_A :: _8 } }
# [ doc = "Write proxy for field `TBIDEX`" ] pub struct TBIDEX_W < 'a > { w : & 'a mut W , } impl < 'a > TBIDEX_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIDEX_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Divide by 1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _1 ) } # [ doc = "Divide by 2" ] # [ inline ( always ) ] pub fn _2 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _2 ) } # [ doc = "Divide by 3" ] # [ inline ( always ) ] pub fn _3 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _3 ) } # [ doc = "Divide by 4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _4 ) } # [ doc = "Divide by 5" ] # [ inline ( always ) ] pub fn _5 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _5 ) } # [ doc = "Divide by 6" ] # [ inline ( always ) ] pub fn _6 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _6 ) } # [ doc = "Divide by 7" ] # [ inline ( always ) ] pub fn _7 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _7 ) } # [ doc = "Divide by 8" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u16 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Input divider expansion" ] # [ inline ( always ) ] pub fn tbidex ( & self ) -> TBIDEX_R { TBIDEX_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Input divider expansion" ] # [ inline ( always ) ] pub fn tbidex ( & mut self ) -> TBIDEX_W { TBIDEX_W { w : self } }
}
}
# [ doc = "Timer_Bx Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb2iv](tb2iv) module" ] pub type TB2IV = crate :: Reg < u16 , _TB2IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB2IV ;
# [ doc = "`read()` method returns [tb2iv::R](tb2iv::R) reader structure" ] impl crate :: Readable for TB2IV { }
# [ doc = "Timer_Bx Interrupt Vector Register" ] pub mod tb2iv {
# [ doc = "Reader of register TB2IV" ] pub type R = crate :: R < u16 , super :: TB2IV > ;
# [ doc = "Timer_B interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum TBIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Capture/compare 1; Interrupt Flag: TBxCCR1 CCIFG; Interrupt Priority: Highest" ] TBCCR1 = 2 , # [ doc = "4: Interrupt Source: Capture/compare 2; Interrupt Flag: TBxCCR2 CCIFG" ] TBCCR2 = 4 , # [ doc = "6: Interrupt Source: Capture/compare 3; Interrupt Flag: TBxCCR3 CCIFG" ] TBCCR3 = 6 , # [ doc = "8: Interrupt Source: Capture/compare 4; Interrupt Flag: TBxCCR4 CCIFG" ] TBCCR4 = 8 , # [ doc = "10: Interrupt Source: Capture/compare 5; Interrupt Flag: TBxCCR5 CCIFG" ] TBCCR5 = 10 , # [ doc = "12: Interrupt Source: Capture/compare 6; Interrupt Flag: TBxCCR6 CCIFG" ] TBCCR6 = 12 , # [ doc = "14: Interrupt Source: Timer overflow; Interrupt Flag: TBxCTL TBIFG; Interrupt Priority: Lowest" ] TBIFG = 14 } impl From < TBIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : TBIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBIV`" ] pub type TBIV_R = crate :: R < u16 , TBIV_A > ; impl TBIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , TBIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( TBIV_A :: NONE ) , 2 => Val ( TBIV_A :: TBCCR1 ) , 4 => Val ( TBIV_A :: TBCCR2 ) , 6 => Val ( TBIV_A :: TBCCR3 ) , 8 => Val ( TBIV_A :: TBCCR4 ) , 10 => Val ( TBIV_A :: TBCCR5 ) , 12 => Val ( TBIV_A :: TBCCR6 ) , 14 => Val ( TBIV_A :: TBIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == TBIV_A :: NONE } # [ doc = "Checks if the value of the field is `TBCCR1`" ] # [ inline ( always ) ] pub fn is_tbccr1 ( & self ) -> bool { * self == TBIV_A :: TBCCR1 } # [ doc = "Checks if the value of the field is `TBCCR2`" ] # [ inline ( always ) ] pub fn is_tbccr2 ( & self ) -> bool { * self == TBIV_A :: TBCCR2 } # [ doc = "Checks if the value of the field is `TBCCR3`" ] # [ inline ( always ) ] pub fn is_tbccr3 ( & self ) -> bool { * self == TBIV_A :: TBCCR3 } # [ doc = "Checks if the value of the field is `TBCCR4`" ] # [ inline ( always ) ] pub fn is_tbccr4 ( & self ) -> bool { * self == TBIV_A :: TBCCR4 } # [ doc = "Checks if the value of the field is `TBCCR5`" ] # [ inline ( always ) ] pub fn is_tbccr5 ( & self ) -> bool { * self == TBIV_A :: TBCCR5 } # [ doc = "Checks if the value of the field is `TBCCR6`" ] # [ inline ( always ) ] pub fn is_tbccr6 ( & self ) -> bool { * self == TBIV_A :: TBCCR6 } # [ doc = "Checks if the value of the field is `TBIFG`" ] # [ inline ( always ) ] pub fn is_tbifg ( & self ) -> bool { * self == TBIV_A :: TBIFG } }
impl R {
# [ doc = "Bits 0:15 - Timer_B interrupt vector value" ] # [ inline ( always ) ] pub fn tbiv ( & self ) -> TBIV_R { TBIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "TB3" ] pub struct TB3 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TB3 { } impl TB3 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const tb3 :: RegisterBlock { 0x0440 as * const _ } } impl Deref for TB3 { type Target = tb3 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * TB3 :: ptr ( ) } } }
# [ doc = "TB3" ] pub mod tb3 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Timer_B Control Register" ] pub tb3ctl : TB3CTL , # [ doc = "0x02 - Timer_B Capture/Compare Control Register" ] pub tb3cctl0 : TB3CCTL0 , # [ doc = "0x04 - Timer_B Capture/Compare Control Register" ] pub tb3cctl1 : TB3CCTL1 , # [ doc = "0x06 - Timer_B Capture/Compare Control Register" ] pub tb3cctl2 : TB3CCTL2 , # [ doc = "0x08 - Timer_B Capture/Compare Control Register" ] pub tb3cctl3 : TB3CCTL3 , # [ doc = "0x0a - Timer_B Capture/Compare Control Register" ] pub tb3cctl4 : TB3CCTL4 , # [ doc = "0x0c - Timer_B Capture/Compare Control Register" ] pub tb3cctl5 : TB3CCTL5 , # [ doc = "0x0e - Timer_B Capture/Compare Control Register" ] pub tb3cctl6 : TB3CCTL6 , # [ doc = "0x10 - Timer_B count register" ] pub tb3r : TB3R , # [ doc = "0x12 - Timer_B Capture/Compare Register" ] pub tb3ccr0 : TB3CCR0 , # [ doc = "0x14 - Timer_B Capture/Compare Register" ] pub tb3ccr1 : TB3CCR1 , # [ doc = "0x16 - Timer_B Capture/Compare Register" ] pub tb3ccr2 : TB3CCR2 , # [ doc = "0x18 - Timer_B Capture/Compare Register" ] pub tb3ccr3 : TB3CCR3 , # [ doc = "0x1a - Timer_B Capture/Compare Register" ] pub tb3ccr4 : TB3CCR4 , # [ doc = "0x1c - Timer_B Capture/Compare Register" ] pub tb3ccr5 : TB3CCR5 , # [ doc = "0x1e - Timer_B Capture/Compare Register" ] pub tb3ccr6 : TB3CCR6 , # [ doc = "0x20 - Timer_Bx Expansion Register 0" ] pub tb3ex0 : TB3EX0 , _reserved17 : [ u8 ; 12usize ] , # [ doc = "0x2e - Timer_Bx Interrupt Vector Register" ] pub tb3iv : TB3IV , }
# [ doc = "Timer_B Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3ctl](tb3ctl) module" ] pub type TB3CTL = crate :: Reg < u16 , _TB3CTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CTL ;
# [ doc = "`read()` method returns [tb3ctl::R](tb3ctl::R) reader structure" ] impl crate :: Readable for TB3CTL { }
# [ doc = "`write(|w| ..)` method takes [tb3ctl::W](tb3ctl::W) writer structure" ] impl crate :: Writable for TB3CTL { }
# [ doc = "Timer_B Control Register" ] pub mod tb3ctl {
# [ doc = "Reader of register TB3CTL" ] pub type R = crate :: R < u16 , super :: TB3CTL > ;
# [ doc = "Writer for register TB3CTL" ] pub type W = crate :: W < u16 , super :: TB3CTL > ;
# [ doc = "Register TB3CTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "TimerB interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TBIFG_A { # [ doc = "0: No interrupt pending" ] TBIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] TBIFG_1 = 1 } impl From < TBIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : TBIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `TBIFG`" ] pub type TBIFG_R = crate :: R < bool , TBIFG_A > ; impl TBIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIFG_A { match self . bits { false => TBIFG_A :: TBIFG_0 , true => TBIFG_A :: TBIFG_1 } } # [ doc = "Checks if the value of the field is `TBIFG_0`" ] # [ inline ( always ) ] pub fn is_tbifg_0 ( & self ) -> bool { * self == TBIFG_A :: TBIFG_0 } # [ doc = "Checks if the value of the field is `TBIFG_1`" ] # [ inline ( always ) ] pub fn is_tbifg_1 ( & self ) -> bool { * self == TBIFG_A :: TBIFG_1 } }
# [ doc = "Write proxy for field `TBIFG`" ] pub struct TBIFG_W < 'a > { w : & 'a mut W , } impl < 'a > TBIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn tbifg_0 ( self ) -> & 'a mut W { self . variant ( TBIFG_A :: TBIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn tbifg_1 ( self ) -> & 'a mut W { self . variant ( TBIFG_A :: TBIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "TimerB interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TBIE_A { # [ doc = "0: Interrupt disabled" ] TBIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] TBIE_1 = 1 } impl From < TBIE_A > for bool { # [ inline ( always ) ] fn from ( variant : TBIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `TBIE`" ] pub type TBIE_R = crate :: R < bool , TBIE_A > ; impl TBIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIE_A { match self . bits { false => TBIE_A :: TBIE_0 , true => TBIE_A :: TBIE_1 } } # [ doc = "Checks if the value of the field is `TBIE_0`" ] # [ inline ( always ) ] pub fn is_tbie_0 ( & self ) -> bool { * self == TBIE_A :: TBIE_0 } # [ doc = "Checks if the value of the field is `TBIE_1`" ] # [ inline ( always ) ] pub fn is_tbie_1 ( & self ) -> bool { * self == TBIE_A :: TBIE_1 } }
# [ doc = "Write proxy for field `TBIE`" ] pub struct TBIE_W < 'a > { w : & 'a mut W , } impl < 'a > TBIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn tbie_0 ( self ) -> & 'a mut W { self . variant ( TBIE_A :: TBIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn tbie_1 ( self ) -> & 'a mut W { self . variant ( TBIE_A :: TBIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `TBCLR`" ] pub type TBCLR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TBCLR`" ] pub struct TBCLR_W < 'a > { w : & 'a mut W , } impl < 'a > TBCLR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Mode control\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum MC_A { # [ doc = "0: Stop mode: Timer is halted" ] STOP = 0 , # [ doc = "1: Up mode: Timer counts up to TBxCL0" ] UP = 1 , # [ doc = "2: Continuous mode: Timer counts up to the value set by CNTL" ] CONTINUOUS = 2 , # [ doc = "3: Up/down mode: Timer counts up to TBxCL0 then down to 0000h" ] UPDOWN = 3 } impl From < MC_A > for u8 { # [ inline ( always ) ] fn from ( variant : MC_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `MC`" ] pub type MC_R = crate :: R < u8 , MC_A > ; impl MC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MC_A { match self . bits { 0 => MC_A :: STOP , 1 => MC_A :: UP , 2 => MC_A :: CONTINUOUS , 3 => MC_A :: UPDOWN , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `STOP`" ] # [ inline ( always ) ] pub fn is_stop ( & self ) -> bool { * self == MC_A :: STOP } # [ doc = "Checks if the value of the field is `UP`" ] # [ inline ( always ) ] pub fn is_up ( & self ) -> bool { * self == MC_A :: UP } # [ doc = "Checks if the value of the field is `CONTINUOUS`" ] # [ inline ( always ) ] pub fn is_continuous ( & self ) -> bool { * self == MC_A :: CONTINUOUS } # [ doc = "Checks if the value of the field is `UPDOWN`" ] # [ inline ( always ) ] pub fn is_updown ( & self ) -> bool { * self == MC_A :: UPDOWN } }
# [ doc = "Write proxy for field `MC`" ] pub struct MC_W < 'a > { w : & 'a mut W , } impl < 'a > MC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MC_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Stop mode: Timer is halted" ] # [ inline ( always ) ] pub fn stop ( self ) -> & 'a mut W { self . variant ( MC_A :: STOP ) } # [ doc = "Up mode: Timer counts up to TBxCL0" ] # [ inline ( always ) ] pub fn up ( self ) -> & 'a mut W { self . variant ( MC_A :: UP ) } # [ doc = "Continuous mode: Timer counts up to the value set by CNTL" ] # [ inline ( always ) ] pub fn continuous ( self ) -> & 'a mut W { self . variant ( MC_A :: CONTINUOUS ) } # [ doc = "Up/down mode: Timer counts up to TBxCL0 then down to 0000h" ] # [ inline ( always ) ] pub fn updown ( self ) -> & 'a mut W { self . variant ( MC_A :: UPDOWN ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Input divider\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ID_A { # [ doc = "0: /1" ] _1 = 0 , # [ doc = "1: /2" ] _2 = 1 , # [ doc = "2: /4" ] _4 = 2 , # [ doc = "3: /8" ] _8 = 3 } impl From < ID_A > for u8 { # [ inline ( always ) ] fn from ( variant : ID_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ID`" ] pub type ID_R = crate :: R < u8 , ID_A > ; impl ID_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ID_A { match self . bits { 0 => ID_A :: _1 , 1 => ID_A :: _2 , 2 => ID_A :: _4 , 3 => ID_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == ID_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == ID_A :: _2 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == ID_A :: _4 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == ID_A :: _8 } }
# [ doc = "Write proxy for field `ID`" ] pub struct ID_W < 'a > { w : & 'a mut W , } impl < 'a > ID_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ID_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "/1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( ID_A :: _1 ) } # [ doc = "/2" ] # [ inline ( always ) ] pub fn _2 ( self ) -> & 'a mut W { self . variant ( ID_A :: _2 ) } # [ doc = "/4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( ID_A :: _4 ) } # [ doc = "/8" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( ID_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "TimerB clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBSSEL_A { # [ doc = "0: TBxCLK" ] TBCLK = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: INCLK" ] INCLK = 3 } impl From < TBSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBSSEL`" ] pub type TBSSEL_R = crate :: R < u8 , TBSSEL_A > ; impl TBSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBSSEL_A { match self . bits { 0 => TBSSEL_A :: TBCLK , 1 => TBSSEL_A :: ACLK , 2 => TBSSEL_A :: SMCLK , 3 => TBSSEL_A :: INCLK , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `TBCLK`" ] # [ inline ( always ) ] pub fn is_tbclk ( & self ) -> bool { * self == TBSSEL_A :: TBCLK } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == TBSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == TBSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `INCLK`" ] # [ inline ( always ) ] pub fn is_inclk ( & self ) -> bool { * self == TBSSEL_A :: INCLK } }
# [ doc = "Write proxy for field `TBSSEL`" ] pub struct TBSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > TBSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLK" ] # [ inline ( always ) ] pub fn tbclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: TBCLK ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: SMCLK ) } # [ doc = "INCLK" ] # [ inline ( always ) ] pub fn inclk ( self ) -> & 'a mut W { self . variant ( TBSSEL_A :: INCLK ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Counter length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CNTL_A { # [ doc = "0: 16-bit, TBxR(max) = 0FFFFh" ] _16 = 0 , # [ doc = "1: 12-bit, TBxR(max) = 0FFFh" ] _12 = 1 , # [ doc = "2: 10-bit, TBxR(max) = 03FFh" ] _10 = 2 , # [ doc = "3: 8-bit, TBxR(max) = 0FFh" ] _8 = 3 } impl From < CNTL_A > for u8 { # [ inline ( always ) ] fn from ( variant : CNTL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CNTL`" ] pub type CNTL_R = crate :: R < u8 , CNTL_A > ; impl CNTL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CNTL_A { match self . bits { 0 => CNTL_A :: _16 , 1 => CNTL_A :: _12 , 2 => CNTL_A :: _10 , 3 => CNTL_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_16`" ] # [ inline ( always ) ] pub fn is_16 ( & self ) -> bool { * self == CNTL_A :: _16 } # [ doc = "Checks if the value of the field is `_12`" ] # [ inline ( always ) ] pub fn is_12 ( & self ) -> bool { * self == CNTL_A :: _12 } # [ doc = "Checks if the value of the field is `_10`" ] # [ inline ( always ) ] pub fn is_10 ( & self ) -> bool { * self == CNTL_A :: _10 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == CNTL_A :: _8 } }
# [ doc = "Write proxy for field `CNTL`" ] pub struct CNTL_W < 'a > { w : & 'a mut W , } impl < 'a > CNTL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CNTL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "16-bit, TBxR(max) = 0FFFFh" ] # [ inline ( always ) ] pub fn _16 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _16 ) } # [ doc = "12-bit, TBxR(max) = 0FFFh" ] # [ inline ( always ) ] pub fn _12 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _12 ) } # [ doc = "10-bit, TBxR(max) = 03FFh" ] # [ inline ( always ) ] pub fn _10 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _10 ) } # [ doc = "8-bit, TBxR(max) = 0FFh" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( CNTL_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 11 ) ) | ( ( ( value as u16 ) & 0x03 ) << 11 ) ; self . w } }
# [ doc = "TBxCLn group\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBCLGRP_A { # [ doc = "0: Each TBxCLn latch loads independently" ] TBCLGRP_0 = 0 , # [ doc = "1: TBxCL1+TBxCL2 (TBxCCR1 CLLD bits control the update); TBxCL3+TBxCL4 (TBxCCR3 CLLD bits control the update); TBxCL5+TBxCL6 (TBxCCR5 CLLD bits control the update); TBxCL0 independent" ] TBCLGRP_1 = 1 , # [ doc = "2: TBxCL1+TBxCL2+TBxCL3 (TBxCCR1 CLLD bits control the update); TBxCL4+TBxCL5+TBxCL6 (TBxCCR4 CLLD bits control the update); TBxCL0 independent" ] TBCLGRP_2 = 2 , # [ doc = "3: TBxCL0+TBxCL1+TBxCL2+TBxCL3+TBxCL4+TBxCL5+TBxCL6 (TBxCCR1 CLLD bits control the update)" ] TBCLGRP_3 = 3 } impl From < TBCLGRP_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBCLGRP_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBCLGRP`" ] pub type TBCLGRP_R = crate :: R < u8 , TBCLGRP_A > ; impl TBCLGRP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBCLGRP_A { match self . bits { 0 => TBCLGRP_A :: TBCLGRP_0 , 1 => TBCLGRP_A :: TBCLGRP_1 , 2 => TBCLGRP_A :: TBCLGRP_2 , 3 => TBCLGRP_A :: TBCLGRP_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `TBCLGRP_0`" ] # [ inline ( always ) ] pub fn is_tbclgrp_0 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_0 } # [ doc = "Checks if the value of the field is `TBCLGRP_1`" ] # [ inline ( always ) ] pub fn is_tbclgrp_1 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_1 } # [ doc = "Checks if the value of the field is `TBCLGRP_2`" ] # [ inline ( always ) ] pub fn is_tbclgrp_2 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_2 } # [ doc = "Checks if the value of the field is `TBCLGRP_3`" ] # [ inline ( always ) ] pub fn is_tbclgrp_3 ( & self ) -> bool { * self == TBCLGRP_A :: TBCLGRP_3 } }
# [ doc = "Write proxy for field `TBCLGRP`" ] pub struct TBCLGRP_W < 'a > { w : & 'a mut W , } impl < 'a > TBCLGRP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBCLGRP_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Each TBxCLn latch loads independently" ] # [ inline ( always ) ] pub fn tbclgrp_0 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_0 ) } # [ doc = "TBxCL1+TBxCL2 (TBxCCR1 CLLD bits control the update); TBxCL3+TBxCL4 (TBxCCR3 CLLD bits control the update); TBxCL5+TBxCL6 (TBxCCR5 CLLD bits control the update); TBxCL0 independent" ] # [ inline ( always ) ] pub fn tbclgrp_1 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_1 ) } # [ doc = "TBxCL1+TBxCL2+TBxCL3 (TBxCCR1 CLLD bits control the update); TBxCL4+TBxCL5+TBxCL6 (TBxCCR4 CLLD bits control the update); TBxCL0 independent" ] # [ inline ( always ) ] pub fn tbclgrp_2 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_2 ) } # [ doc = "TBxCL0+TBxCL1+TBxCL2+TBxCL3+TBxCL4+TBxCL5+TBxCL6 (TBxCCR1 CLLD bits control the update)" ] # [ inline ( always ) ] pub fn tbclgrp_3 ( self ) -> & 'a mut W { self . variant ( TBCLGRP_A :: TBCLGRP_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 13 ) ) | ( ( ( value as u16 ) & 0x03 ) << 13 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - TimerB interrupt flag" ] # [ inline ( always ) ] pub fn tbifg ( & self ) -> TBIFG_R { TBIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - TimerB interrupt enable" ] # [ inline ( always ) ] pub fn tbie ( & self ) -> TBIE_R { TBIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - TimerB clear" ] # [ inline ( always ) ] pub fn tbclr ( & self ) -> TBCLR_R { TBCLR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - Mode control" ] # [ inline ( always ) ] pub fn mc ( & self ) -> MC_R { MC_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 6:7 - Input divider" ] # [ inline ( always ) ] pub fn id ( & self ) -> ID_R { ID_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:9 - TimerB clock source select" ] # [ inline ( always ) ] pub fn tbssel ( & self ) -> TBSSEL_R { TBSSEL_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 11:12 - Counter length" ] # [ inline ( always ) ] pub fn cntl ( & self ) -> CNTL_R { CNTL_R :: new ( ( ( self . bits >> 11 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 13:14 - TBxCLn group" ] # [ inline ( always ) ] pub fn tbclgrp ( & self ) -> TBCLGRP_R { TBCLGRP_R :: new ( ( ( self . bits >> 13 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - TimerB interrupt flag" ] # [ inline ( always ) ] pub fn tbifg ( & mut self ) -> TBIFG_W { TBIFG_W { w : self } }
# [ doc = "Bit 1 - TimerB interrupt enable" ] # [ inline ( always ) ] pub fn tbie ( & mut self ) -> TBIE_W { TBIE_W { w : self } }
# [ doc = "Bit 2 - TimerB clear" ] # [ inline ( always ) ] pub fn tbclr ( & mut self ) -> TBCLR_W { TBCLR_W { w : self } }
# [ doc = "Bits 4:5 - Mode control" ] # [ inline ( always ) ] pub fn mc ( & mut self ) -> MC_W { MC_W { w : self } }
# [ doc = "Bits 6:7 - Input divider" ] # [ inline ( always ) ] pub fn id ( & mut self ) -> ID_W { ID_W { w : self } }
# [ doc = "Bits 8:9 - TimerB clock source select" ] # [ inline ( always ) ] pub fn tbssel ( & mut self ) -> TBSSEL_W { TBSSEL_W { w : self } }
# [ doc = "Bits 11:12 - Counter length" ] # [ inline ( always ) ] pub fn cntl ( & mut self ) -> CNTL_W { CNTL_W { w : self } }
# [ doc = "Bits 13:14 - TBxCLn group" ] # [ inline ( always ) ] pub fn tbclgrp ( & mut self ) -> TBCLGRP_W { TBCLGRP_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3cctl0](tb3cctl0) module" ] pub type TB3CCTL0 = crate :: Reg < u16 , _TB3CCTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCTL0 ;
# [ doc = "`read()` method returns [tb3cctl0::R](tb3cctl0::R) reader structure" ] impl crate :: Readable for TB3CCTL0 { }
# [ doc = "`write(|w| ..)` method takes [tb3cctl0::W](tb3cctl0::W) writer structure" ] impl crate :: Writable for TB3CCTL0 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb3cctl0 {
# [ doc = "Reader of register TB3CCTL0" ] pub type R = crate :: R < u16 , super :: TB3CCTL0 > ;
# [ doc = "Writer for register TB3CCTL0" ] pub type W = crate :: W < u16 , super :: TB3CCTL0 > ;
# [ doc = "Register TB3CCTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3cctl1](tb3cctl1) module" ] pub type TB3CCTL1 = crate :: Reg < u16 , _TB3CCTL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCTL1 ;
# [ doc = "`read()` method returns [tb3cctl1::R](tb3cctl1::R) reader structure" ] impl crate :: Readable for TB3CCTL1 { }
# [ doc = "`write(|w| ..)` method takes [tb3cctl1::W](tb3cctl1::W) writer structure" ] impl crate :: Writable for TB3CCTL1 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb3cctl1 {
# [ doc = "Reader of register TB3CCTL1" ] pub type R = crate :: R < u16 , super :: TB3CCTL1 > ;
# [ doc = "Writer for register TB3CCTL1" ] pub type W = crate :: W < u16 , super :: TB3CCTL1 > ;
# [ doc = "Register TB3CCTL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCTL1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3cctl2](tb3cctl2) module" ] pub type TB3CCTL2 = crate :: Reg < u16 , _TB3CCTL2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCTL2 ;
# [ doc = "`read()` method returns [tb3cctl2::R](tb3cctl2::R) reader structure" ] impl crate :: Readable for TB3CCTL2 { }
# [ doc = "`write(|w| ..)` method takes [tb3cctl2::W](tb3cctl2::W) writer structure" ] impl crate :: Writable for TB3CCTL2 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb3cctl2 {
# [ doc = "Reader of register TB3CCTL2" ] pub type R = crate :: R < u16 , super :: TB3CCTL2 > ;
# [ doc = "Writer for register TB3CCTL2" ] pub type W = crate :: W < u16 , super :: TB3CCTL2 > ;
# [ doc = "Register TB3CCTL2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCTL2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3cctl3](tb3cctl3) module" ] pub type TB3CCTL3 = crate :: Reg < u16 , _TB3CCTL3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCTL3 ;
# [ doc = "`read()` method returns [tb3cctl3::R](tb3cctl3::R) reader structure" ] impl crate :: Readable for TB3CCTL3 { }
# [ doc = "`write(|w| ..)` method takes [tb3cctl3::W](tb3cctl3::W) writer structure" ] impl crate :: Writable for TB3CCTL3 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb3cctl3 {
# [ doc = "Reader of register TB3CCTL3" ] pub type R = crate :: R < u16 , super :: TB3CCTL3 > ;
# [ doc = "Writer for register TB3CCTL3" ] pub type W = crate :: W < u16 , super :: TB3CCTL3 > ;
# [ doc = "Register TB3CCTL3 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCTL3 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3cctl4](tb3cctl4) module" ] pub type TB3CCTL4 = crate :: Reg < u16 , _TB3CCTL4 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCTL4 ;
# [ doc = "`read()` method returns [tb3cctl4::R](tb3cctl4::R) reader structure" ] impl crate :: Readable for TB3CCTL4 { }
# [ doc = "`write(|w| ..)` method takes [tb3cctl4::W](tb3cctl4::W) writer structure" ] impl crate :: Writable for TB3CCTL4 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb3cctl4 {
# [ doc = "Reader of register TB3CCTL4" ] pub type R = crate :: R < u16 , super :: TB3CCTL4 > ;
# [ doc = "Writer for register TB3CCTL4" ] pub type W = crate :: W < u16 , super :: TB3CCTL4 > ;
# [ doc = "Register TB3CCTL4 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCTL4 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3cctl5](tb3cctl5) module" ] pub type TB3CCTL5 = crate :: Reg < u16 , _TB3CCTL5 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCTL5 ;
# [ doc = "`read()` method returns [tb3cctl5::R](tb3cctl5::R) reader structure" ] impl crate :: Readable for TB3CCTL5 { }
# [ doc = "`write(|w| ..)` method takes [tb3cctl5::W](tb3cctl5::W) writer structure" ] impl crate :: Writable for TB3CCTL5 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb3cctl5 {
# [ doc = "Reader of register TB3CCTL5" ] pub type R = crate :: R < u16 , super :: TB3CCTL5 > ;
# [ doc = "Writer for register TB3CCTL5" ] pub type W = crate :: W < u16 , super :: TB3CCTL5 > ;
# [ doc = "Register TB3CCTL5 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCTL5 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B Capture/Compare Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3cctl6](tb3cctl6) module" ] pub type TB3CCTL6 = crate :: Reg < u16 , _TB3CCTL6 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCTL6 ;
# [ doc = "`read()` method returns [tb3cctl6::R](tb3cctl6::R) reader structure" ] impl crate :: Readable for TB3CCTL6 { }
# [ doc = "`write(|w| ..)` method takes [tb3cctl6::W](tb3cctl6::W) writer structure" ] impl crate :: Writable for TB3CCTL6 { }
# [ doc = "Timer_B Capture/Compare Control Register" ] pub mod tb3cctl6 {
# [ doc = "Reader of register TB3CCTL6" ] pub type R = crate :: R < u16 , super :: TB3CCTL6 > ;
# [ doc = "Writer for register TB3CCTL6" ] pub type W = crate :: W < u16 , super :: TB3CCTL6 > ;
# [ doc = "Register TB3CCTL6 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCTL6 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Capture/compare interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIFG_A { # [ doc = "0: No interrupt pending" ] CCIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] CCIFG_1 = 1 } impl From < CCIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIFG`" ] pub type CCIFG_R = crate :: R < bool , CCIFG_A > ; impl CCIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIFG_A { match self . bits { false => CCIFG_A :: CCIFG_0 , true => CCIFG_A :: CCIFG_1 } } # [ doc = "Checks if the value of the field is `CCIFG_0`" ] # [ inline ( always ) ] pub fn is_ccifg_0 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_0 } # [ doc = "Checks if the value of the field is `CCIFG_1`" ] # [ inline ( always ) ] pub fn is_ccifg_1 ( & self ) -> bool { * self == CCIFG_A :: CCIFG_1 } }
# [ doc = "Write proxy for field `CCIFG`" ] pub struct CCIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CCIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_0 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ccifg_1 ( self ) -> & 'a mut W { self . variant ( CCIFG_A :: CCIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Capture overflow\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum COV_A { # [ doc = "0: No capture overflow occurred" ] COV_0 = 0 , # [ doc = "1: Capture overflow occurred" ] COV_1 = 1 } impl From < COV_A > for bool { # [ inline ( always ) ] fn from ( variant : COV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `COV`" ] pub type COV_R = crate :: R < bool , COV_A > ; impl COV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> COV_A { match self . bits { false => COV_A :: COV_0 , true => COV_A :: COV_1 } } # [ doc = "Checks if the value of the field is `COV_0`" ] # [ inline ( always ) ] pub fn is_cov_0 ( & self ) -> bool { * self == COV_A :: COV_0 } # [ doc = "Checks if the value of the field is `COV_1`" ] # [ inline ( always ) ] pub fn is_cov_1 ( & self ) -> bool { * self == COV_A :: COV_1 } }
# [ doc = "Write proxy for field `COV`" ] pub struct COV_W < 'a > { w : & 'a mut W , } impl < 'a > COV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : COV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_0 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_0 ) } # [ doc = "Capture overflow occurred" ] # [ inline ( always ) ] pub fn cov_1 ( self ) -> & 'a mut W { self . variant ( COV_A :: COV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Output\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "0: Output low" ] LOW = 0 , # [ doc = "1: Output high" ] HIGH = 1 } impl From < OUT_A > for bool { # [ inline ( always ) ] fn from ( variant : OUT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < bool , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUT_A { match self . bits { false => OUT_A :: LOW , true => OUT_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == OUT_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == OUT_A :: HIGH } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Output low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( OUT_A :: LOW ) } # [ doc = "Output high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( OUT_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CCI`" ] pub type CCI_R = crate :: R < bool , bool > ;
# [ doc = "Capture/compare interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CCIE_A { # [ doc = "0: Interrupt disabled" ] CCIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] CCIE_1 = 1 } impl From < CCIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CCIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CCIE`" ] pub type CCIE_R = crate :: R < bool , CCIE_A > ; impl CCIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIE_A { match self . bits { false => CCIE_A :: CCIE_0 , true => CCIE_A :: CCIE_1 } } # [ doc = "Checks if the value of the field is `CCIE_0`" ] # [ inline ( always ) ] pub fn is_ccie_0 ( & self ) -> bool { * self == CCIE_A :: CCIE_0 } # [ doc = "Checks if the value of the field is `CCIE_1`" ] # [ inline ( always ) ] pub fn is_ccie_1 ( & self ) -> bool { * self == CCIE_A :: CCIE_1 } }
# [ doc = "Write proxy for field `CCIE`" ] pub struct CCIE_W < 'a > { w : & 'a mut W , } impl < 'a > CCIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ccie_0 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ccie_1 ( self ) -> & 'a mut W { self . variant ( CCIE_A :: CCIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Output mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum OUTMOD_A { # [ doc = "0: OUT bit value" ] OUTMOD_0 = 0 , # [ doc = "1: Set" ] OUTMOD_1 = 1 , # [ doc = "2: Toggle/reset" ] OUTMOD_2 = 2 , # [ doc = "3: Set/reset" ] OUTMOD_3 = 3 , # [ doc = "4: Toggle" ] OUTMOD_4 = 4 , # [ doc = "5: Reset" ] OUTMOD_5 = 5 , # [ doc = "6: Toggle/set" ] OUTMOD_6 = 6 , # [ doc = "7: Reset/set" ] OUTMOD_7 = 7 } impl From < OUTMOD_A > for u8 { # [ inline ( always ) ] fn from ( variant : OUTMOD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `OUTMOD`" ] pub type OUTMOD_R = crate :: R < u8 , OUTMOD_A > ; impl OUTMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUTMOD_0`" ] # [ inline ( always ) ] pub fn is_outmod_0 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [ doc = "Checks if the value of the field is `OUTMOD_1`" ] # [ inline ( always ) ] pub fn is_outmod_1 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [ doc = "Checks if the value of the field is `OUTMOD_2`" ] # [ inline ( always ) ] pub fn is_outmod_2 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [ doc = "Checks if the value of the field is `OUTMOD_3`" ] # [ inline ( always ) ] pub fn is_outmod_3 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [ doc = "Checks if the value of the field is `OUTMOD_4`" ] # [ inline ( always ) ] pub fn is_outmod_4 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [ doc = "Checks if the value of the field is `OUTMOD_5`" ] # [ inline ( always ) ] pub fn is_outmod_5 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [ doc = "Checks if the value of the field is `OUTMOD_6`" ] # [ inline ( always ) ] pub fn is_outmod_6 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [ doc = "Checks if the value of the field is `OUTMOD_7`" ] # [ inline ( always ) ] pub fn is_outmod_7 ( & self ) -> bool { * self == OUTMOD_A :: OUTMOD_7 } }
# [ doc = "Write proxy for field `OUTMOD`" ] pub struct OUTMOD_W < 'a > { w : & 'a mut W , } impl < 'a > OUTMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUTMOD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "OUT bit value" ] # [ inline ( always ) ] pub fn outmod_0 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_0 ) } # [ doc = "Set" ] # [ inline ( always ) ] pub fn outmod_1 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_1 ) } # [ doc = "Toggle/reset" ] # [ inline ( always ) ] pub fn outmod_2 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_2 ) } # [ doc = "Set/reset" ] # [ inline ( always ) ] pub fn outmod_3 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_3 ) } # [ doc = "Toggle" ] # [ inline ( always ) ] pub fn outmod_4 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_4 ) } # [ doc = "Reset" ] # [ inline ( always ) ] pub fn outmod_5 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_5 ) } # [ doc = "Toggle/set" ] # [ inline ( always ) ] pub fn outmod_6 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_6 ) } # [ doc = "Reset/set" ] # [ inline ( always ) ] pub fn outmod_7 ( self ) -> & 'a mut W { self . variant ( OUTMOD_A :: OUTMOD_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAP_A { # [ doc = "0: Compare mode" ] COMPARE = 0 , # [ doc = "1: Capture mode" ] CAPTURE = 1 } impl From < CAP_A > for bool { # [ inline ( always ) ] fn from ( variant : CAP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CAP`" ] pub type CAP_R = crate :: R < bool , CAP_A > ; impl CAP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAP_A { match self . bits { false => CAP_A :: COMPARE , true => CAP_A :: CAPTURE } } # [ doc = "Checks if the value of the field is `COMPARE`" ] # [ inline ( always ) ] pub fn is_compare ( & self ) -> bool { * self == CAP_A :: COMPARE } # [ doc = "Checks if the value of the field is `CAPTURE`" ] # [ inline ( always ) ] pub fn is_capture ( & self ) -> bool { * self == CAP_A :: CAPTURE } }
# [ doc = "Write proxy for field `CAP`" ] pub struct CAP_W < 'a > { w : & 'a mut W , } impl < 'a > CAP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Compare mode" ] # [ inline ( always ) ] pub fn compare ( self ) -> & 'a mut W { self . variant ( CAP_A :: COMPARE ) } # [ doc = "Capture mode" ] # [ inline ( always ) ] pub fn capture ( self ) -> & 'a mut W { self . variant ( CAP_A :: CAPTURE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Compare latch load\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CLLD_A { # [ doc = "0: TBxCLn loads on write to TBxCCRn" ] CLLD_0 = 0 , # [ doc = "1: TBxCLn loads when TBxR counts to 0" ] CLLD_1 = 1 , # [ doc = "2: TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] CLLD_2 = 2 , # [ doc = "3: TBxCLn loads when TBxR counts to TBxCLn" ] CLLD_3 = 3 } impl From < CLLD_A > for u8 { # [ inline ( always ) ] fn from ( variant : CLLD_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CLLD`" ] pub type CLLD_R = crate :: R < u8 , CLLD_A > ; impl CLLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLLD_A { match self . bits { 0 => CLLD_A :: CLLD_0 , 1 => CLLD_A :: CLLD_1 , 2 => CLLD_A :: CLLD_2 , 3 => CLLD_A :: CLLD_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CLLD_0`" ] # [ inline ( always ) ] pub fn is_clld_0 ( & self ) -> bool { * self == CLLD_A :: CLLD_0 } # [ doc = "Checks if the value of the field is `CLLD_1`" ] # [ inline ( always ) ] pub fn is_clld_1 ( & self ) -> bool { * self == CLLD_A :: CLLD_1 } # [ doc = "Checks if the value of the field is `CLLD_2`" ] # [ inline ( always ) ] pub fn is_clld_2 ( & self ) -> bool { * self == CLLD_A :: CLLD_2 } # [ doc = "Checks if the value of the field is `CLLD_3`" ] # [ inline ( always ) ] pub fn is_clld_3 ( & self ) -> bool { * self == CLLD_A :: CLLD_3 } }
# [ doc = "Write proxy for field `CLLD`" ] pub struct CLLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLLD_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "TBxCLn loads on write to TBxCCRn" ] # [ inline ( always ) ] pub fn clld_0 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_0 ) } # [ doc = "TBxCLn loads when TBxR counts to 0" ] # [ inline ( always ) ] pub fn clld_1 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_1 ) } # [ doc = "TBxCLn loads when TBxR counts to 0 (up or continuous mode). TBxCLn loads when TBxR counts to TBxCL0 or to 0 (up/down mode)." ] # [ inline ( always ) ] pub fn clld_2 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_2 ) } # [ doc = "TBxCLn loads when TBxR counts to TBxCLn" ] # [ inline ( always ) ] pub fn clld_3 ( self ) -> & 'a mut W { self . variant ( CLLD_A :: CLLD_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Synchronize capture source\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SCS_A { # [ doc = "0: Asynchronous capture" ] ASYNC = 0 , # [ doc = "1: Synchronous capture" ] SYNC = 1 } impl From < SCS_A > for bool { # [ inline ( always ) ] fn from ( variant : SCS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SCS`" ] pub type SCS_R = crate :: R < bool , SCS_A > ; impl SCS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SCS_A { match self . bits { false => SCS_A :: ASYNC , true => SCS_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == SCS_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == SCS_A :: SYNC } }
# [ doc = "Write proxy for field `SCS`" ] pub struct SCS_W < 'a > { w : & 'a mut W , } impl < 'a > SCS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SCS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous capture" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( SCS_A :: ASYNC ) } # [ doc = "Synchronous capture" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( SCS_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Capture/compare input select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CCIS_A { # [ doc = "0: CCIxA" ] CCIA = 0 , # [ doc = "1: CCIxB" ] CCIB = 1 , # [ doc = "2: GND" ] GND = 2 , # [ doc = "3: VCC" ] VCC = 3 } impl From < CCIS_A > for u8 { # [ inline ( always ) ] fn from ( variant : CCIS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CCIS`" ] pub type CCIS_R = crate :: R < u8 , CCIS_A > ; impl CCIS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIA , 1 => CCIS_A :: CCIB , 2 => CCIS_A :: GND , 3 => CCIS_A :: VCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CCIA`" ] # [ inline ( always ) ] pub fn is_ccia ( & self ) -> bool { * self == CCIS_A :: CCIA } # [ doc = "Checks if the value of the field is `CCIB`" ] # [ inline ( always ) ] pub fn is_ccib ( & self ) -> bool { * self == CCIS_A :: CCIB } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == CCIS_A :: GND } # [ doc = "Checks if the value of the field is `VCC`" ] # [ inline ( always ) ] pub fn is_vcc ( & self ) -> bool { * self == CCIS_A :: VCC } }
# [ doc = "Write proxy for field `CCIS`" ] pub struct CCIS_W < 'a > { w : & 'a mut W , } impl < 'a > CCIS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CCIS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "CCIxA" ] # [ inline ( always ) ] pub fn ccia ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIA ) } # [ doc = "CCIxB" ] # [ inline ( always ) ] pub fn ccib ( self ) -> & 'a mut W { self . variant ( CCIS_A :: CCIB ) } # [ doc = "GND" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( CCIS_A :: GND ) } # [ doc = "VCC" ] # [ inline ( always ) ] pub fn vcc ( self ) -> & 'a mut W { self . variant ( CCIS_A :: VCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Capture mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CM_A { # [ doc = "0: No capture" ] NONE = 0 , # [ doc = "1: Capture on rising edge" ] RISING = 1 , # [ doc = "2: Capture on falling edge" ] FALLING = 2 , # [ doc = "3: Capture on both rising and falling edges" ] BOTH = 3 } impl From < CM_A > for u8 { # [ inline ( always ) ] fn from ( variant : CM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CM`" ] pub type CM_R = crate :: R < u8 , CM_A > ; impl CM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CM_A { match self . bits { 0 => CM_A :: NONE , 1 => CM_A :: RISING , 2 => CM_A :: FALLING , 3 => CM_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CM_A :: NONE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == CM_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == CM_A :: FALLING } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == CM_A :: BOTH } }
# [ doc = "Write proxy for field `CM`" ] pub struct CM_W < 'a > { w : & 'a mut W , } impl < 'a > CM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CM_A :: NONE ) } # [ doc = "Capture on rising edge" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( CM_A :: RISING ) } # [ doc = "Capture on falling edge" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( CM_A :: FALLING ) } # [ doc = "Capture on both rising and falling edges" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( CM_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & self ) -> CCIFG_R { CCIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & self ) -> COV_R { COV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Capture/compare input" ] # [ inline ( always ) ] pub fn cci ( & self ) -> CCI_R { CCI_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & self ) -> CCIE_R { CCIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & self ) -> OUTMOD_R { OUTMOD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & self ) -> CAP_R { CAP_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & self ) -> CLLD_R { CLLD_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & self ) -> SCS_R { SCS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & self ) -> CCIS_R { CCIS_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & self ) -> CM_R { CM_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Capture/compare interrupt flag" ] # [ inline ( always ) ] pub fn ccifg ( & mut self ) -> CCIFG_W { CCIFG_W { w : self } }
# [ doc = "Bit 1 - Capture overflow" ] # [ inline ( always ) ] pub fn cov ( & mut self ) -> COV_W { COV_W { w : self } }
# [ doc = "Bit 2 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
# [ doc = "Bit 4 - Capture/compare interrupt enable" ] # [ inline ( always ) ] pub fn ccie ( & mut self ) -> CCIE_W { CCIE_W { w : self } }
# [ doc = "Bits 5:7 - Output mode" ] # [ inline ( always ) ] pub fn outmod ( & mut self ) -> OUTMOD_W { OUTMOD_W { w : self } }
# [ doc = "Bit 8 - Capture mode" ] # [ inline ( always ) ] pub fn cap ( & mut self ) -> CAP_W { CAP_W { w : self } }
# [ doc = "Bits 9:10 - Compare latch load" ] # [ inline ( always ) ] pub fn clld ( & mut self ) -> CLLD_W { CLLD_W { w : self } }
# [ doc = "Bit 11 - Synchronize capture source" ] # [ inline ( always ) ] pub fn scs ( & mut self ) -> SCS_W { SCS_W { w : self } }
# [ doc = "Bits 12:13 - Capture/compare input select" ] # [ inline ( always ) ] pub fn ccis ( & mut self ) -> CCIS_W { CCIS_W { w : self } }
# [ doc = "Bits 14:15 - Capture mode" ] # [ inline ( always ) ] pub fn cm ( & mut self ) -> CM_W { CM_W { w : self } }
}
}
# [ doc = "Timer_B count register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3r](tb3r) module" ] pub type TB3R = crate :: Reg < u16 , _TB3R > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3R ;
# [ doc = "`read()` method returns [tb3r::R](tb3r::R) reader structure" ] impl crate :: Readable for TB3R { }
# [ doc = "`write(|w| ..)` method takes [tb3r::W](tb3r::W) writer structure" ] impl crate :: Writable for TB3R { }
# [ doc = "Timer_B count register" ] pub mod tb3r {
# [ doc = "Reader of register TB3R" ] pub type R = crate :: R < u16 , super :: TB3R > ;
# [ doc = "Writer for register TB3R" ] pub type W = crate :: W < u16 , super :: TB3R > ;
# [ doc = "Register TB3R `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3R { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3ccr0](tb3ccr0) module" ] pub type TB3CCR0 = crate :: Reg < u16 , _TB3CCR0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCR0 ;
# [ doc = "`read()` method returns [tb3ccr0::R](tb3ccr0::R) reader structure" ] impl crate :: Readable for TB3CCR0 { }
# [ doc = "`write(|w| ..)` method takes [tb3ccr0::W](tb3ccr0::W) writer structure" ] impl crate :: Writable for TB3CCR0 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb3ccr0 {
# [ doc = "Reader of register TB3CCR0" ] pub type R = crate :: R < u16 , super :: TB3CCR0 > ;
# [ doc = "Writer for register TB3CCR0" ] pub type W = crate :: W < u16 , super :: TB3CCR0 > ;
# [ doc = "Register TB3CCR0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCR0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3ccr1](tb3ccr1) module" ] pub type TB3CCR1 = crate :: Reg < u16 , _TB3CCR1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCR1 ;
# [ doc = "`read()` method returns [tb3ccr1::R](tb3ccr1::R) reader structure" ] impl crate :: Readable for TB3CCR1 { }
# [ doc = "`write(|w| ..)` method takes [tb3ccr1::W](tb3ccr1::W) writer structure" ] impl crate :: Writable for TB3CCR1 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb3ccr1 {
# [ doc = "Reader of register TB3CCR1" ] pub type R = crate :: R < u16 , super :: TB3CCR1 > ;
# [ doc = "Writer for register TB3CCR1" ] pub type W = crate :: W < u16 , super :: TB3CCR1 > ;
# [ doc = "Register TB3CCR1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCR1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3ccr2](tb3ccr2) module" ] pub type TB3CCR2 = crate :: Reg < u16 , _TB3CCR2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCR2 ;
# [ doc = "`read()` method returns [tb3ccr2::R](tb3ccr2::R) reader structure" ] impl crate :: Readable for TB3CCR2 { }
# [ doc = "`write(|w| ..)` method takes [tb3ccr2::W](tb3ccr2::W) writer structure" ] impl crate :: Writable for TB3CCR2 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb3ccr2 {
# [ doc = "Reader of register TB3CCR2" ] pub type R = crate :: R < u16 , super :: TB3CCR2 > ;
# [ doc = "Writer for register TB3CCR2" ] pub type W = crate :: W < u16 , super :: TB3CCR2 > ;
# [ doc = "Register TB3CCR2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCR2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3ccr3](tb3ccr3) module" ] pub type TB3CCR3 = crate :: Reg < u16 , _TB3CCR3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCR3 ;
# [ doc = "`read()` method returns [tb3ccr3::R](tb3ccr3::R) reader structure" ] impl crate :: Readable for TB3CCR3 { }
# [ doc = "`write(|w| ..)` method takes [tb3ccr3::W](tb3ccr3::W) writer structure" ] impl crate :: Writable for TB3CCR3 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb3ccr3 {
# [ doc = "Reader of register TB3CCR3" ] pub type R = crate :: R < u16 , super :: TB3CCR3 > ;
# [ doc = "Writer for register TB3CCR3" ] pub type W = crate :: W < u16 , super :: TB3CCR3 > ;
# [ doc = "Register TB3CCR3 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCR3 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3ccr4](tb3ccr4) module" ] pub type TB3CCR4 = crate :: Reg < u16 , _TB3CCR4 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCR4 ;
# [ doc = "`read()` method returns [tb3ccr4::R](tb3ccr4::R) reader structure" ] impl crate :: Readable for TB3CCR4 { }
# [ doc = "`write(|w| ..)` method takes [tb3ccr4::W](tb3ccr4::W) writer structure" ] impl crate :: Writable for TB3CCR4 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb3ccr4 {
# [ doc = "Reader of register TB3CCR4" ] pub type R = crate :: R < u16 , super :: TB3CCR4 > ;
# [ doc = "Writer for register TB3CCR4" ] pub type W = crate :: W < u16 , super :: TB3CCR4 > ;
# [ doc = "Register TB3CCR4 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCR4 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3ccr5](tb3ccr5) module" ] pub type TB3CCR5 = crate :: Reg < u16 , _TB3CCR5 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCR5 ;
# [ doc = "`read()` method returns [tb3ccr5::R](tb3ccr5::R) reader structure" ] impl crate :: Readable for TB3CCR5 { }
# [ doc = "`write(|w| ..)` method takes [tb3ccr5::W](tb3ccr5::W) writer structure" ] impl crate :: Writable for TB3CCR5 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb3ccr5 {
# [ doc = "Reader of register TB3CCR5" ] pub type R = crate :: R < u16 , super :: TB3CCR5 > ;
# [ doc = "Writer for register TB3CCR5" ] pub type W = crate :: W < u16 , super :: TB3CCR5 > ;
# [ doc = "Register TB3CCR5 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCR5 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_B Capture/Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3ccr6](tb3ccr6) module" ] pub type TB3CCR6 = crate :: Reg < u16 , _TB3CCR6 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3CCR6 ;
# [ doc = "`read()` method returns [tb3ccr6::R](tb3ccr6::R) reader structure" ] impl crate :: Readable for TB3CCR6 { }
# [ doc = "`write(|w| ..)` method takes [tb3ccr6::W](tb3ccr6::W) writer structure" ] impl crate :: Writable for TB3CCR6 { }
# [ doc = "Timer_B Capture/Compare Register" ] pub mod tb3ccr6 {
# [ doc = "Reader of register TB3CCR6" ] pub type R = crate :: R < u16 , super :: TB3CCR6 > ;
# [ doc = "Writer for register TB3CCR6" ] pub type W = crate :: W < u16 , super :: TB3CCR6 > ;
# [ doc = "Register TB3CCR6 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3CCR6 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Timer_Bx Expansion Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3ex0](tb3ex0) module" ] pub type TB3EX0 = crate :: Reg < u16 , _TB3EX0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3EX0 ;
# [ doc = "`read()` method returns [tb3ex0::R](tb3ex0::R) reader structure" ] impl crate :: Readable for TB3EX0 { }
# [ doc = "`write(|w| ..)` method takes [tb3ex0::W](tb3ex0::W) writer structure" ] impl crate :: Writable for TB3EX0 { }
# [ doc = "Timer_Bx Expansion Register 0" ] pub mod tb3ex0 {
# [ doc = "Reader of register TB3EX0" ] pub type R = crate :: R < u16 , super :: TB3EX0 > ;
# [ doc = "Writer for register TB3EX0" ] pub type W = crate :: W < u16 , super :: TB3EX0 > ;
# [ doc = "Register TB3EX0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TB3EX0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Input divider expansion\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum TBIDEX_A { # [ doc = "0: Divide by 1" ] _1 = 0 , # [ doc = "1: Divide by 2" ] _2 = 1 , # [ doc = "2: Divide by 3" ] _3 = 2 , # [ doc = "3: Divide by 4" ] _4 = 3 , # [ doc = "4: Divide by 5" ] _5 = 4 , # [ doc = "5: Divide by 6" ] _6 = 5 , # [ doc = "6: Divide by 7" ] _7 = 6 , # [ doc = "7: Divide by 8" ] _8 = 7 } impl From < TBIDEX_A > for u8 { # [ inline ( always ) ] fn from ( variant : TBIDEX_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBIDEX`" ] pub type TBIDEX_R = crate :: R < u8 , TBIDEX_A > ; impl TBIDEX_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBIDEX_A { match self . bits { 0 => TBIDEX_A :: _1 , 1 => TBIDEX_A :: _2 , 2 => TBIDEX_A :: _3 , 3 => TBIDEX_A :: _4 , 4 => TBIDEX_A :: _5 , 5 => TBIDEX_A :: _6 , 6 => TBIDEX_A :: _7 , 7 => TBIDEX_A :: _8 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == TBIDEX_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == TBIDEX_A :: _2 } # [ doc = "Checks if the value of the field is `_3`" ] # [ inline ( always ) ] pub fn is_3 ( & self ) -> bool { * self == TBIDEX_A :: _3 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == TBIDEX_A :: _4 } # [ doc = "Checks if the value of the field is `_5`" ] # [ inline ( always ) ] pub fn is_5 ( & self ) -> bool { * self == TBIDEX_A :: _5 } # [ doc = "Checks if the value of the field is `_6`" ] # [ inline ( always ) ] pub fn is_6 ( & self ) -> bool { * self == TBIDEX_A :: _6 } # [ doc = "Checks if the value of the field is `_7`" ] # [ inline ( always ) ] pub fn is_7 ( & self ) -> bool { * self == TBIDEX_A :: _7 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == TBIDEX_A :: _8 } }
# [ doc = "Write proxy for field `TBIDEX`" ] pub struct TBIDEX_W < 'a > { w : & 'a mut W , } impl < 'a > TBIDEX_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBIDEX_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Divide by 1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _1 ) } # [ doc = "Divide by 2" ] # [ inline ( always ) ] pub fn _2 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _2 ) } # [ doc = "Divide by 3" ] # [ inline ( always ) ] pub fn _3 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _3 ) } # [ doc = "Divide by 4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _4 ) } # [ doc = "Divide by 5" ] # [ inline ( always ) ] pub fn _5 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _5 ) } # [ doc = "Divide by 6" ] # [ inline ( always ) ] pub fn _6 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _6 ) } # [ doc = "Divide by 7" ] # [ inline ( always ) ] pub fn _7 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _7 ) } # [ doc = "Divide by 8" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( TBIDEX_A :: _8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u16 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Input divider expansion" ] # [ inline ( always ) ] pub fn tbidex ( & self ) -> TBIDEX_R { TBIDEX_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Input divider expansion" ] # [ inline ( always ) ] pub fn tbidex ( & mut self ) -> TBIDEX_W { TBIDEX_W { w : self } }
}
}
# [ doc = "Timer_Bx Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tb3iv](tb3iv) module" ] pub type TB3IV = crate :: Reg < u16 , _TB3IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TB3IV ;
# [ doc = "`read()` method returns [tb3iv::R](tb3iv::R) reader structure" ] impl crate :: Readable for TB3IV { }
# [ doc = "Timer_Bx Interrupt Vector Register" ] pub mod tb3iv {
# [ doc = "Reader of register TB3IV" ] pub type R = crate :: R < u16 , super :: TB3IV > ;
# [ doc = "Timer_B interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum TBIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Capture/compare 1; Interrupt Flag: TBxCCR1 CCIFG; Interrupt Priority: Highest" ] TBCCR1 = 2 , # [ doc = "4: Interrupt Source: Capture/compare 2; Interrupt Flag: TBxCCR2 CCIFG" ] TBCCR2 = 4 , # [ doc = "6: Interrupt Source: Capture/compare 3; Interrupt Flag: TBxCCR3 CCIFG" ] TBCCR3 = 6 , # [ doc = "8: Interrupt Source: Capture/compare 4; Interrupt Flag: TBxCCR4 CCIFG" ] TBCCR4 = 8 , # [ doc = "10: Interrupt Source: Capture/compare 5; Interrupt Flag: TBxCCR5 CCIFG" ] TBCCR5 = 10 , # [ doc = "12: Interrupt Source: Capture/compare 6; Interrupt Flag: TBxCCR6 CCIFG" ] TBCCR6 = 12 , # [ doc = "14: Interrupt Source: Timer overflow; Interrupt Flag: TBxCTL TBIFG; Interrupt Priority: Lowest" ] TBIFG = 14 } impl From < TBIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : TBIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `TBIV`" ] pub type TBIV_R = crate :: R < u16 , TBIV_A > ; impl TBIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , TBIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( TBIV_A :: NONE ) , 2 => Val ( TBIV_A :: TBCCR1 ) , 4 => Val ( TBIV_A :: TBCCR2 ) , 6 => Val ( TBIV_A :: TBCCR3 ) , 8 => Val ( TBIV_A :: TBCCR4 ) , 10 => Val ( TBIV_A :: TBCCR5 ) , 12 => Val ( TBIV_A :: TBCCR6 ) , 14 => Val ( TBIV_A :: TBIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == TBIV_A :: NONE } # [ doc = "Checks if the value of the field is `TBCCR1`" ] # [ inline ( always ) ] pub fn is_tbccr1 ( & self ) -> bool { * self == TBIV_A :: TBCCR1 } # [ doc = "Checks if the value of the field is `TBCCR2`" ] # [ inline ( always ) ] pub fn is_tbccr2 ( & self ) -> bool { * self == TBIV_A :: TBCCR2 } # [ doc = "Checks if the value of the field is `TBCCR3`" ] # [ inline ( always ) ] pub fn is_tbccr3 ( & self ) -> bool { * self == TBIV_A :: TBCCR3 } # [ doc = "Checks if the value of the field is `TBCCR4`" ] # [ inline ( always ) ] pub fn is_tbccr4 ( & self ) -> bool { * self == TBIV_A :: TBCCR4 } # [ doc = "Checks if the value of the field is `TBCCR5`" ] # [ inline ( always ) ] pub fn is_tbccr5 ( & self ) -> bool { * self == TBIV_A :: TBCCR5 } # [ doc = "Checks if the value of the field is `TBCCR6`" ] # [ inline ( always ) ] pub fn is_tbccr6 ( & self ) -> bool { * self == TBIV_A :: TBCCR6 } # [ doc = "Checks if the value of the field is `TBIFG`" ] # [ inline ( always ) ] pub fn is_tbifg ( & self ) -> bool { * self == TBIV_A :: TBIFG } }
impl R {
# [ doc = "Bits 0:15 - Timer_B interrupt vector value" ] # [ inline ( always ) ] pub fn tbiv ( & self ) -> TBIV_R { TBIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "MPY32" ] pub struct MPY32 { _marker : PhantomData < * const ( ) > } unsafe impl Send for MPY32 { } impl MPY32 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const mpy32 :: RegisterBlock { 0x04c0 as * const _ } } impl Deref for MPY32 { type Target = mpy32 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * MPY32 :: ptr ( ) } } }
# [ doc = "MPY32" ] pub mod mpy32 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - 16-bit operand one multiply" ] pub mpy : MPY , # [ doc = "0x02 - 16-bit operand one signed multiply" ] pub mpys : MPYS , # [ doc = "0x04 - 16-bit operand one multiply accumulate" ] pub mac : MAC , # [ doc = "0x06 - 16-bit operand one signed multiply accumulate" ] pub macs : MACS , # [ doc = "0x08 - 16-bit operand two" ] pub op2 : OP2 , # [ doc = "0x0a - 16x16-bit result low word" ] pub reslo : RESLO , # [ doc = "0x0c - 16x16-bit result high word" ] pub reshi : RESHI , # [ doc = "0x0e - 16x16-bit sum extension register" ] pub sumext : SUMEXT , # [ doc = "0x10 - 32-bit operand 1 multiply low word" ] pub mpy32l : MPY32L , # [ doc = "0x12 - 32-bit operand 1 multiply high word" ] pub mpy32h : MPY32H , # [ doc = "0x14 - 32-bit operand 1 signed multiply low word" ] pub mpys32l : MPYS32L , # [ doc = "0x16 - 32-bit operand 1 signed multiply high word" ] pub mpys32h : MPYS32H , # [ doc = "0x18 - 32-bit operand 1 multiply accumulate low word" ] pub mac32l : MAC32L , # [ doc = "0x1a - 32-bit operand 1 multiply accumulate high word" ] pub mac32h : MAC32H , # [ doc = "0x1c - 32-bit operand 1 signed multiply accumulate low word" ] pub macs32l : MACS32L , # [ doc = "0x1e - 32-bit operand 1 signed multiply accumulate high word" ] pub macs32h : MACS32H , # [ doc = "0x20 - 32-bit operand 2 low word" ] pub op2l : OP2L , # [ doc = "0x22 - 32-bit operand 2 high word" ] pub op2h : OP2H , # [ doc = "0x24 - 32x32-bit result 0 least significant word" ] pub res0 : RES0 , # [ doc = "0x26 - 32x32-bit result 1" ] pub res1 : RES1 , # [ doc = "0x28 - 32x32-bit result 2" ] pub res2 : RES2 , # [ doc = "0x2a - 32x32-bit result 3 most significant word" ] pub res3 : RES3 , # [ doc = "0x2c - MPY32 control register 0" ] pub mpy32ctl0 : MPY32CTL0 , }
# [ doc = "16-bit operand one multiply\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpy](mpy) module" ] pub type MPY = crate :: Reg < u16 , _MPY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MPY ;
# [ doc = "`read()` method returns [mpy::R](mpy::R) reader structure" ] impl crate :: Readable for MPY { }
# [ doc = "`write(|w| ..)` method takes [mpy::W](mpy::W) writer structure" ] impl crate :: Writable for MPY { }
# [ doc = "16-bit operand one multiply" ] pub mod mpy {
# [ doc = "Reader of register MPY" ] pub type R = crate :: R < u16 , super :: MPY > ;
# [ doc = "Writer for register MPY" ] pub type W = crate :: W < u16 , super :: MPY > ;
# [ doc = "Register MPY `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MPY { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "16-bit operand one signed multiply\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpys](mpys) module" ] pub type MPYS = crate :: Reg < u16 , _MPYS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MPYS ;
# [ doc = "`read()` method returns [mpys::R](mpys::R) reader structure" ] impl crate :: Readable for MPYS { }
# [ doc = "`write(|w| ..)` method takes [mpys::W](mpys::W) writer structure" ] impl crate :: Writable for MPYS { }
# [ doc = "16-bit operand one signed multiply" ] pub mod mpys {
# [ doc = "Reader of register MPYS" ] pub type R = crate :: R < u16 , super :: MPYS > ;
# [ doc = "Writer for register MPYS" ] pub type W = crate :: W < u16 , super :: MPYS > ;
# [ doc = "Register MPYS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MPYS { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "16-bit operand one multiply accumulate\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mac](mac) module" ] pub type MAC = crate :: Reg < u16 , _MAC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MAC ;
# [ doc = "`read()` method returns [mac::R](mac::R) reader structure" ] impl crate :: Readable for MAC { }
# [ doc = "`write(|w| ..)` method takes [mac::W](mac::W) writer structure" ] impl crate :: Writable for MAC { }
# [ doc = "16-bit operand one multiply accumulate" ] pub mod mac {
# [ doc = "Reader of register MAC" ] pub type R = crate :: R < u16 , super :: MAC > ;
# [ doc = "Writer for register MAC" ] pub type W = crate :: W < u16 , super :: MAC > ;
# [ doc = "Register MAC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MAC { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "16-bit operand one signed multiply accumulate\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [macs](macs) module" ] pub type MACS = crate :: Reg < u16 , _MACS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MACS ;
# [ doc = "`read()` method returns [macs::R](macs::R) reader structure" ] impl crate :: Readable for MACS { }
# [ doc = "`write(|w| ..)` method takes [macs::W](macs::W) writer structure" ] impl crate :: Writable for MACS { }
# [ doc = "16-bit operand one signed multiply accumulate" ] pub mod macs {
# [ doc = "Reader of register MACS" ] pub type R = crate :: R < u16 , super :: MACS > ;
# [ doc = "Writer for register MACS" ] pub type W = crate :: W < u16 , super :: MACS > ;
# [ doc = "Register MACS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MACS { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "16-bit operand two\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [op2](op2) module" ] pub type OP2 = crate :: Reg < u16 , _OP2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _OP2 ;
# [ doc = "`read()` method returns [op2::R](op2::R) reader structure" ] impl crate :: Readable for OP2 { }
# [ doc = "`write(|w| ..)` method takes [op2::W](op2::W) writer structure" ] impl crate :: Writable for OP2 { }
# [ doc = "16-bit operand two" ] pub mod op2 {
# [ doc = "Reader of register OP2" ] pub type R = crate :: R < u16 , super :: OP2 > ;
# [ doc = "Writer for register OP2" ] pub type W = crate :: W < u16 , super :: OP2 > ;
# [ doc = "Register OP2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: OP2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "16x16-bit result low word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [reslo](reslo) module" ] pub type RESLO = crate :: Reg < u16 , _RESLO > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RESLO ;
# [ doc = "`read()` method returns [reslo::R](reslo::R) reader structure" ] impl crate :: Readable for RESLO { }
# [ doc = "`write(|w| ..)` method takes [reslo::W](reslo::W) writer structure" ] impl crate :: Writable for RESLO { }
# [ doc = "16x16-bit result low word" ] pub mod reslo {
# [ doc = "Reader of register RESLO" ] pub type R = crate :: R < u16 , super :: RESLO > ;
# [ doc = "Writer for register RESLO" ] pub type W = crate :: W < u16 , super :: RESLO > ;
# [ doc = "Register RESLO `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RESLO { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "16x16-bit result high word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [reshi](reshi) module" ] pub type RESHI = crate :: Reg < u16 , _RESHI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RESHI ;
# [ doc = "`read()` method returns [reshi::R](reshi::R) reader structure" ] impl crate :: Readable for RESHI { }
# [ doc = "`write(|w| ..)` method takes [reshi::W](reshi::W) writer structure" ] impl crate :: Writable for RESHI { }
# [ doc = "16x16-bit result high word" ] pub mod reshi {
# [ doc = "Reader of register RESHI" ] pub type R = crate :: R < u16 , super :: RESHI > ;
# [ doc = "Writer for register RESHI" ] pub type W = crate :: W < u16 , super :: RESHI > ;
# [ doc = "Register RESHI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RESHI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "16x16-bit sum extension register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sumext](sumext) module" ] pub type SUMEXT = crate :: Reg < u16 , _SUMEXT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SUMEXT ;
# [ doc = "`read()` method returns [sumext::R](sumext::R) reader structure" ] impl crate :: Readable for SUMEXT { }
# [ doc = "`write(|w| ..)` method takes [sumext::W](sumext::W) writer structure" ] impl crate :: Writable for SUMEXT { }
# [ doc = "16x16-bit sum extension register" ] pub mod sumext {
# [ doc = "Reader of register SUMEXT" ] pub type R = crate :: R < u16 , super :: SUMEXT > ;
# [ doc = "Writer for register SUMEXT" ] pub type W = crate :: W < u16 , super :: SUMEXT > ;
# [ doc = "Register SUMEXT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SUMEXT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32-bit operand 1 multiply low word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpy32l](mpy32l) module" ] pub type MPY32L = crate :: Reg < u16 , _MPY32L > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MPY32L ;
# [ doc = "`read()` method returns [mpy32l::R](mpy32l::R) reader structure" ] impl crate :: Readable for MPY32L { }
# [ doc = "`write(|w| ..)` method takes [mpy32l::W](mpy32l::W) writer structure" ] impl crate :: Writable for MPY32L { }
# [ doc = "32-bit operand 1 multiply low word" ] pub mod mpy32l {
# [ doc = "Reader of register MPY32L" ] pub type R = crate :: R < u16 , super :: MPY32L > ;
# [ doc = "Writer for register MPY32L" ] pub type W = crate :: W < u16 , super :: MPY32L > ;
# [ doc = "Register MPY32L `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MPY32L { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32-bit operand 1 multiply high word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpy32h](mpy32h) module" ] pub type MPY32H = crate :: Reg < u16 , _MPY32H > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MPY32H ;
# [ doc = "`read()` method returns [mpy32h::R](mpy32h::R) reader structure" ] impl crate :: Readable for MPY32H { }
# [ doc = "`write(|w| ..)` method takes [mpy32h::W](mpy32h::W) writer structure" ] impl crate :: Writable for MPY32H { }
# [ doc = "32-bit operand 1 multiply high word" ] pub mod mpy32h {
# [ doc = "Reader of register MPY32H" ] pub type R = crate :: R < u16 , super :: MPY32H > ;
# [ doc = "Writer for register MPY32H" ] pub type W = crate :: W < u16 , super :: MPY32H > ;
# [ doc = "Register MPY32H `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MPY32H { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32-bit operand 1 signed multiply low word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpys32l](mpys32l) module" ] pub type MPYS32L = crate :: Reg < u16 , _MPYS32L > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MPYS32L ;
# [ doc = "`read()` method returns [mpys32l::R](mpys32l::R) reader structure" ] impl crate :: Readable for MPYS32L { }
# [ doc = "`write(|w| ..)` method takes [mpys32l::W](mpys32l::W) writer structure" ] impl crate :: Writable for MPYS32L { }
# [ doc = "32-bit operand 1 signed multiply low word" ] pub mod mpys32l {
# [ doc = "Reader of register MPYS32L" ] pub type R = crate :: R < u16 , super :: MPYS32L > ;
# [ doc = "Writer for register MPYS32L" ] pub type W = crate :: W < u16 , super :: MPYS32L > ;
# [ doc = "Register MPYS32L `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MPYS32L { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32-bit operand 1 signed multiply high word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpys32h](mpys32h) module" ] pub type MPYS32H = crate :: Reg < u16 , _MPYS32H > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MPYS32H ;
# [ doc = "`read()` method returns [mpys32h::R](mpys32h::R) reader structure" ] impl crate :: Readable for MPYS32H { }
# [ doc = "`write(|w| ..)` method takes [mpys32h::W](mpys32h::W) writer structure" ] impl crate :: Writable for MPYS32H { }
# [ doc = "32-bit operand 1 signed multiply high word" ] pub mod mpys32h {
# [ doc = "Reader of register MPYS32H" ] pub type R = crate :: R < u16 , super :: MPYS32H > ;
# [ doc = "Writer for register MPYS32H" ] pub type W = crate :: W < u16 , super :: MPYS32H > ;
# [ doc = "Register MPYS32H `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MPYS32H { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32-bit operand 1 multiply accumulate low word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mac32l](mac32l) module" ] pub type MAC32L = crate :: Reg < u16 , _MAC32L > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MAC32L ;
# [ doc = "`read()` method returns [mac32l::R](mac32l::R) reader structure" ] impl crate :: Readable for MAC32L { }
# [ doc = "`write(|w| ..)` method takes [mac32l::W](mac32l::W) writer structure" ] impl crate :: Writable for MAC32L { }
# [ doc = "32-bit operand 1 multiply accumulate low word" ] pub mod mac32l {
# [ doc = "Reader of register MAC32L" ] pub type R = crate :: R < u16 , super :: MAC32L > ;
# [ doc = "Writer for register MAC32L" ] pub type W = crate :: W < u16 , super :: MAC32L > ;
# [ doc = "Register MAC32L `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MAC32L { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32-bit operand 1 multiply accumulate high word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mac32h](mac32h) module" ] pub type MAC32H = crate :: Reg < u16 , _MAC32H > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MAC32H ;
# [ doc = "`read()` method returns [mac32h::R](mac32h::R) reader structure" ] impl crate :: Readable for MAC32H { }
# [ doc = "`write(|w| ..)` method takes [mac32h::W](mac32h::W) writer structure" ] impl crate :: Writable for MAC32H { }
# [ doc = "32-bit operand 1 multiply accumulate high word" ] pub mod mac32h {
# [ doc = "Reader of register MAC32H" ] pub type R = crate :: R < u16 , super :: MAC32H > ;
# [ doc = "Writer for register MAC32H" ] pub type W = crate :: W < u16 , super :: MAC32H > ;
# [ doc = "Register MAC32H `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MAC32H { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32-bit operand 1 signed multiply accumulate low word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [macs32l](macs32l) module" ] pub type MACS32L = crate :: Reg < u16 , _MACS32L > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MACS32L ;
# [ doc = "`read()` method returns [macs32l::R](macs32l::R) reader structure" ] impl crate :: Readable for MACS32L { }
# [ doc = "`write(|w| ..)` method takes [macs32l::W](macs32l::W) writer structure" ] impl crate :: Writable for MACS32L { }
# [ doc = "32-bit operand 1 signed multiply accumulate low word" ] pub mod macs32l {
# [ doc = "Reader of register MACS32L" ] pub type R = crate :: R < u16 , super :: MACS32L > ;
# [ doc = "Writer for register MACS32L" ] pub type W = crate :: W < u16 , super :: MACS32L > ;
# [ doc = "Register MACS32L `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MACS32L { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32-bit operand 1 signed multiply accumulate high word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [macs32h](macs32h) module" ] pub type MACS32H = crate :: Reg < u16 , _MACS32H > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MACS32H ;
# [ doc = "`read()` method returns [macs32h::R](macs32h::R) reader structure" ] impl crate :: Readable for MACS32H { }
# [ doc = "`write(|w| ..)` method takes [macs32h::W](macs32h::W) writer structure" ] impl crate :: Writable for MACS32H { }
# [ doc = "32-bit operand 1 signed multiply accumulate high word" ] pub mod macs32h {
# [ doc = "Reader of register MACS32H" ] pub type R = crate :: R < u16 , super :: MACS32H > ;
# [ doc = "Writer for register MACS32H" ] pub type W = crate :: W < u16 , super :: MACS32H > ;
# [ doc = "Register MACS32H `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MACS32H { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `MACS32H`" ] pub type MACS32H_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `MACS32H`" ] pub struct MACS32H_W < 'a > { w : & 'a mut W , } impl < 'a > MACS32H_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 8 ) ) | ( ( ( value as u16 ) & 0xff ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 8:15 - 32-bit operand 1 signed multiply accumulate high word" ] # [ inline ( always ) ] pub fn macs32h ( & self ) -> MACS32H_R { MACS32H_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 8:15 - 32-bit operand 1 signed multiply accumulate high word" ] # [ inline ( always ) ] pub fn macs32h ( & mut self ) -> MACS32H_W { MACS32H_W { w : self } }
}
}
# [ doc = "32-bit operand 2 low word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [op2l](op2l) module" ] pub type OP2L = crate :: Reg < u16 , _OP2L > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _OP2L ;
# [ doc = "`read()` method returns [op2l::R](op2l::R) reader structure" ] impl crate :: Readable for OP2L { }
# [ doc = "`write(|w| ..)` method takes [op2l::W](op2l::W) writer structure" ] impl crate :: Writable for OP2L { }
# [ doc = "32-bit operand 2 low word" ] pub mod op2l {
# [ doc = "Reader of register OP2L" ] pub type R = crate :: R < u16 , super :: OP2L > ;
# [ doc = "Writer for register OP2L" ] pub type W = crate :: W < u16 , super :: OP2L > ;
# [ doc = "Register OP2L `reset()`'s with value 0" ] impl crate :: ResetValue for super :: OP2L { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32-bit operand 2 high word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [op2h](op2h) module" ] pub type OP2H = crate :: Reg < u16 , _OP2H > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _OP2H ;
# [ doc = "`read()` method returns [op2h::R](op2h::R) reader structure" ] impl crate :: Readable for OP2H { }
# [ doc = "`write(|w| ..)` method takes [op2h::W](op2h::W) writer structure" ] impl crate :: Writable for OP2H { }
# [ doc = "32-bit operand 2 high word" ] pub mod op2h {
# [ doc = "Reader of register OP2H" ] pub type R = crate :: R < u16 , super :: OP2H > ;
# [ doc = "Writer for register OP2H" ] pub type W = crate :: W < u16 , super :: OP2H > ;
# [ doc = "Register OP2H `reset()`'s with value 0" ] impl crate :: ResetValue for super :: OP2H { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32x32-bit result 0 least significant word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [res0](res0) module" ] pub type RES0 = crate :: Reg < u16 , _RES0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RES0 ;
# [ doc = "`read()` method returns [res0::R](res0::R) reader structure" ] impl crate :: Readable for RES0 { }
# [ doc = "`write(|w| ..)` method takes [res0::W](res0::W) writer structure" ] impl crate :: Writable for RES0 { }
# [ doc = "32x32-bit result 0 least significant word" ] pub mod res0 {
# [ doc = "Reader of register RES0" ] pub type R = crate :: R < u16 , super :: RES0 > ;
# [ doc = "Writer for register RES0" ] pub type W = crate :: W < u16 , super :: RES0 > ;
# [ doc = "Register RES0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RES0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32x32-bit result 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [res1](res1) module" ] pub type RES1 = crate :: Reg < u16 , _RES1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RES1 ;
# [ doc = "`read()` method returns [res1::R](res1::R) reader structure" ] impl crate :: Readable for RES1 { }
# [ doc = "`write(|w| ..)` method takes [res1::W](res1::W) writer structure" ] impl crate :: Writable for RES1 { }
# [ doc = "32x32-bit result 1" ] pub mod res1 {
# [ doc = "Reader of register RES1" ] pub type R = crate :: R < u16 , super :: RES1 > ;
# [ doc = "Writer for register RES1" ] pub type W = crate :: W < u16 , super :: RES1 > ;
# [ doc = "Register RES1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RES1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32x32-bit result 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [res2](res2) module" ] pub type RES2 = crate :: Reg < u16 , _RES2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RES2 ;
# [ doc = "`read()` method returns [res2::R](res2::R) reader structure" ] impl crate :: Readable for RES2 { }
# [ doc = "`write(|w| ..)` method takes [res2::W](res2::W) writer structure" ] impl crate :: Writable for RES2 { }
# [ doc = "32x32-bit result 2" ] pub mod res2 {
# [ doc = "Reader of register RES2" ] pub type R = crate :: R < u16 , super :: RES2 > ;
# [ doc = "Writer for register RES2" ] pub type W = crate :: W < u16 , super :: RES2 > ;
# [ doc = "Register RES2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RES2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "32x32-bit result 3 most significant word\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [res3](res3) module" ] pub type RES3 = crate :: Reg < u16 , _RES3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RES3 ;
# [ doc = "`read()` method returns [res3::R](res3::R) reader structure" ] impl crate :: Readable for RES3 { }
# [ doc = "`write(|w| ..)` method takes [res3::W](res3::W) writer structure" ] impl crate :: Writable for RES3 { }
# [ doc = "32x32-bit result 3 most significant word" ] pub mod res3 {
# [ doc = "Reader of register RES3" ] pub type R = crate :: R < u16 , super :: RES3 > ;
# [ doc = "Writer for register RES3" ] pub type W = crate :: W < u16 , super :: RES3 > ;
# [ doc = "Register RES3 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RES3 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "MPY32 control register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpy32ctl0](mpy32ctl0) module" ] pub type MPY32CTL0 = crate :: Reg < u16 , _MPY32CTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MPY32CTL0 ;
# [ doc = "`read()` method returns [mpy32ctl0::R](mpy32ctl0::R) reader structure" ] impl crate :: Readable for MPY32CTL0 { }
# [ doc = "`write(|w| ..)` method takes [mpy32ctl0::W](mpy32ctl0::W) writer structure" ] impl crate :: Writable for MPY32CTL0 { }
# [ doc = "MPY32 control register 0" ] pub mod mpy32ctl0 {
# [ doc = "Reader of register MPY32CTL0" ] pub type R = crate :: R < u16 , super :: MPY32CTL0 > ;
# [ doc = "Writer for register MPY32CTL0" ] pub type W = crate :: W < u16 , super :: MPY32CTL0 > ;
# [ doc = "Register MPY32CTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MPY32CTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Delayed write mode.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MPYDLY32_A { # [ doc = "0: Writes are delayed until 64-bit result (RES0 to RES3) is available." ] MPYDLY32_0 = 0 , # [ doc = "1: Writes are delayed until 32-bit result (RES0 to RES1) is available. 8 MPYDLYWRTEN" ] MPYDLY32_1 = 1 } impl From < MPYDLY32_A > for bool { # [ inline ( always ) ] fn from ( variant : MPYDLY32_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `MPYDLY32`" ] pub type MPYDLY32_R = crate :: R < bool , MPYDLY32_A > ; impl MPYDLY32_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MPYDLY32_A { match self . bits { false => MPYDLY32_A :: MPYDLY32_0 , true => MPYDLY32_A :: MPYDLY32_1 } } # [ doc = "Checks if the value of the field is `MPYDLY32_0`" ] # [ inline ( always ) ] pub fn is_mpydly32_0 ( & self ) -> bool { * self == MPYDLY32_A :: MPYDLY32_0 } # [ doc = "Checks if the value of the field is `MPYDLY32_1`" ] # [ inline ( always ) ] pub fn is_mpydly32_1 ( & self ) -> bool { * self == MPYDLY32_A :: MPYDLY32_1 } }
# [ doc = "Write proxy for field `MPYDLY32`" ] pub struct MPYDLY32_W < 'a > { w : & 'a mut W , } impl < 'a > MPYDLY32_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MPYDLY32_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Writes are delayed until 64-bit result (RES0 to RES3) is available." ] # [ inline ( always ) ] pub fn mpydly32_0 ( self ) -> & 'a mut W { self . variant ( MPYDLY32_A :: MPYDLY32_0 ) } # [ doc = "Writes are delayed until 32-bit result (RES0 to RES1) is available. 8 MPYDLYWRTEN" ] # [ inline ( always ) ] pub fn mpydly32_1 ( self ) -> & 'a mut W { self . variant ( MPYDLY32_A :: MPYDLY32_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Delayed write enable.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MPYDLYWRTEN_A { # [ doc = "0: Writes are not delayed." ] MPYDLYWRTEN_0 = 0 , # [ doc = "1: Writes are delayed." ] MPYDLYWRTEN_1 = 1 } impl From < MPYDLYWRTEN_A > for bool { # [ inline ( always ) ] fn from ( variant : MPYDLYWRTEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `MPYDLYWRTEN`" ] pub type MPYDLYWRTEN_R = crate :: R < bool , MPYDLYWRTEN_A > ; impl MPYDLYWRTEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MPYDLYWRTEN_A { match self . bits { false => MPYDLYWRTEN_A :: MPYDLYWRTEN_0 , true => MPYDLYWRTEN_A :: MPYDLYWRTEN_1 } } # [ doc = "Checks if the value of the field is `MPYDLYWRTEN_0`" ] # [ inline ( always ) ] pub fn is_mpydlywrten_0 ( & self ) -> bool { * self == MPYDLYWRTEN_A :: MPYDLYWRTEN_0 } # [ doc = "Checks if the value of the field is `MPYDLYWRTEN_1`" ] # [ inline ( always ) ] pub fn is_mpydlywrten_1 ( & self ) -> bool { * self == MPYDLYWRTEN_A :: MPYDLYWRTEN_1 } }
# [ doc = "Write proxy for field `MPYDLYWRTEN`" ] pub struct MPYDLYWRTEN_W < 'a > { w : & 'a mut W , } impl < 'a > MPYDLYWRTEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MPYDLYWRTEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Writes are not delayed." ] # [ inline ( always ) ] pub fn mpydlywrten_0 ( self ) -> & 'a mut W { self . variant ( MPYDLYWRTEN_A :: MPYDLYWRTEN_0 ) } # [ doc = "Writes are delayed." ] # [ inline ( always ) ] pub fn mpydlywrten_1 ( self ) -> & 'a mut W { self . variant ( MPYDLYWRTEN_A :: MPYDLYWRTEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Multiplier bit width of operand 2\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MPYOP2_32_A { # [ doc = "0: 16 bits." ] _16 = 0 , # [ doc = "1: 32 bits." ] _32 = 1 } impl From < MPYOP2_32_A > for bool { # [ inline ( always ) ] fn from ( variant : MPYOP2_32_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `MPYOP2_32`" ] pub type MPYOP2_32_R = crate :: R < bool , MPYOP2_32_A > ; impl MPYOP2_32_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MPYOP2_32_A { match self . bits { false => MPYOP2_32_A :: _16 , true => MPYOP2_32_A :: _32 } } # [ doc = "Checks if the value of the field is `_16`" ] # [ inline ( always ) ] pub fn is_16 ( & self ) -> bool { * self == MPYOP2_32_A :: _16 } # [ doc = "Checks if the value of the field is `_32`" ] # [ inline ( always ) ] pub fn is_32 ( & self ) -> bool { * self == MPYOP2_32_A :: _32 } }
# [ doc = "Write proxy for field `MPYOP2_32`" ] pub struct MPYOP2_32_W < 'a > { w : & 'a mut W , } impl < 'a > MPYOP2_32_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MPYOP2_32_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "16 bits." ] # [ inline ( always ) ] pub fn _16 ( self ) -> & 'a mut W { self . variant ( MPYOP2_32_A :: _16 ) } # [ doc = "32 bits." ] # [ inline ( always ) ] pub fn _32 ( self ) -> & 'a mut W { self . variant ( MPYOP2_32_A :: _32 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Multiplier bit width of operand 1\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MPYOP1_32_A { # [ doc = "0: 16 bits." ] _16 = 0 , # [ doc = "1: 32 bits." ] _32 = 1 } impl From < MPYOP1_32_A > for bool { # [ inline ( always ) ] fn from ( variant : MPYOP1_32_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `MPYOP1_32`" ] pub type MPYOP1_32_R = crate :: R < bool , MPYOP1_32_A > ; impl MPYOP1_32_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MPYOP1_32_A { match self . bits { false => MPYOP1_32_A :: _16 , true => MPYOP1_32_A :: _32 } } # [ doc = "Checks if the value of the field is `_16`" ] # [ inline ( always ) ] pub fn is_16 ( & self ) -> bool { * self == MPYOP1_32_A :: _16 } # [ doc = "Checks if the value of the field is `_32`" ] # [ inline ( always ) ] pub fn is_32 ( & self ) -> bool { * self == MPYOP1_32_A :: _32 } }
# [ doc = "Write proxy for field `MPYOP1_32`" ] pub struct MPYOP1_32_W < 'a > { w : & 'a mut W , } impl < 'a > MPYOP1_32_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MPYOP1_32_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "16 bits." ] # [ inline ( always ) ] pub fn _16 ( self ) -> & 'a mut W { self . variant ( MPYOP1_32_A :: _16 ) } # [ doc = "32 bits." ] # [ inline ( always ) ] pub fn _32 ( self ) -> & 'a mut W { self . variant ( MPYOP1_32_A :: _32 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Multiplier mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum MPYM_A { # [ doc = "0: MPY  Multiply" ] MPY = 0 , # [ doc = "1: MPYS  Signed multiply" ] MPYS = 1 , # [ doc = "2: MAC  Multiply accumulate" ] MAC = 2 , # [ doc = "3: MACS  Signed multiply accumulate" ] MACS = 3 } impl From < MPYM_A > for u8 { # [ inline ( always ) ] fn from ( variant : MPYM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `MPYM`" ] pub type MPYM_R = crate :: R < u8 , MPYM_A > ; impl MPYM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MPYM_A { match self . bits { 0 => MPYM_A :: MPY , 1 => MPYM_A :: MPYS , 2 => MPYM_A :: MAC , 3 => MPYM_A :: MACS , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `MPY`" ] # [ inline ( always ) ] pub fn is_mpy ( & self ) -> bool { * self == MPYM_A :: MPY } # [ doc = "Checks if the value of the field is `MPYS`" ] # [ inline ( always ) ] pub fn is_mpys ( & self ) -> bool { * self == MPYM_A :: MPYS } # [ doc = "Checks if the value of the field is `MAC`" ] # [ inline ( always ) ] pub fn is_mac ( & self ) -> bool { * self == MPYM_A :: MAC } # [ doc = "Checks if the value of the field is `MACS`" ] # [ inline ( always ) ] pub fn is_macs ( & self ) -> bool { * self == MPYM_A :: MACS } }
# [ doc = "Write proxy for field `MPYM`" ] pub struct MPYM_W < 'a > { w : & 'a mut W , } impl < 'a > MPYM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MPYM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "MPY Multiply" ] # [ inline ( always ) ] pub fn mpy ( self ) -> & 'a mut W { self . variant ( MPYM_A :: MPY ) } # [ doc = "MPYS Signed multiply" ] # [ inline ( always ) ] pub fn mpys ( self ) -> & 'a mut W { self . variant ( MPYM_A :: MPYS ) } # [ doc = "MAC Multiply accumulate" ] # [ inline ( always ) ] pub fn mac ( self ) -> & 'a mut W { self . variant ( MPYM_A :: MAC ) } # [ doc = "MACS Signed multiply accumulate" ] # [ inline ( always ) ] pub fn macs ( self ) -> & 'a mut W { self . variant ( MPYM_A :: MACS ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Saturation mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MPYSAT_A { # [ doc = "0: Saturation mode disabled." ] DISABLE = 0 , # [ doc = "1: Saturation mode enabled." ] ENABLE = 1 } impl From < MPYSAT_A > for bool { # [ inline ( always ) ] fn from ( variant : MPYSAT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `MPYSAT`" ] pub type MPYSAT_R = crate :: R < bool , MPYSAT_A > ; impl MPYSAT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MPYSAT_A { match self . bits { false => MPYSAT_A :: DISABLE , true => MPYSAT_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == MPYSAT_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == MPYSAT_A :: ENABLE } }
# [ doc = "Write proxy for field `MPYSAT`" ] pub struct MPYSAT_W < 'a > { w : & 'a mut W , } impl < 'a > MPYSAT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MPYSAT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Saturation mode disabled." ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( MPYSAT_A :: DISABLE ) } # [ doc = "Saturation mode enabled." ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( MPYSAT_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Fractional mode.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MPYFRAC_A { # [ doc = "0: Fractional mode disabled." ] DISABLE = 0 , # [ doc = "1: Fractional mode enabled." ] ENABLE = 1 } impl From < MPYFRAC_A > for bool { # [ inline ( always ) ] fn from ( variant : MPYFRAC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `MPYFRAC`" ] pub type MPYFRAC_R = crate :: R < bool , MPYFRAC_A > ; impl MPYFRAC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MPYFRAC_A { match self . bits { false => MPYFRAC_A :: DISABLE , true => MPYFRAC_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == MPYFRAC_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == MPYFRAC_A :: ENABLE } }
# [ doc = "Write proxy for field `MPYFRAC`" ] pub struct MPYFRAC_W < 'a > { w : & 'a mut W , } impl < 'a > MPYFRAC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MPYFRAC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Fractional mode disabled." ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( MPYFRAC_A :: DISABLE ) } # [ doc = "Fractional mode enabled." ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( MPYFRAC_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Carry of the multiplier\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MPYC_A { # [ doc = "0: No carry for result." ] MPYC_0 = 0 , # [ doc = "1: Result has a carry." ] MPYC_1 = 1 } impl From < MPYC_A > for bool { # [ inline ( always ) ] fn from ( variant : MPYC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `MPYC`" ] pub type MPYC_R = crate :: R < bool , MPYC_A > ; impl MPYC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MPYC_A { match self . bits { false => MPYC_A :: MPYC_0 , true => MPYC_A :: MPYC_1 } } # [ doc = "Checks if the value of the field is `MPYC_0`" ] # [ inline ( always ) ] pub fn is_mpyc_0 ( & self ) -> bool { * self == MPYC_A :: MPYC_0 } # [ doc = "Checks if the value of the field is `MPYC_1`" ] # [ inline ( always ) ] pub fn is_mpyc_1 ( & self ) -> bool { * self == MPYC_A :: MPYC_1 } }
# [ doc = "Write proxy for field `MPYC`" ] pub struct MPYC_W < 'a > { w : & 'a mut W , } impl < 'a > MPYC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MPYC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No carry for result." ] # [ inline ( always ) ] pub fn mpyc_0 ( self ) -> & 'a mut W { self . variant ( MPYC_A :: MPYC_0 ) } # [ doc = "Result has a carry." ] # [ inline ( always ) ] pub fn mpyc_1 ( self ) -> & 'a mut W { self . variant ( MPYC_A :: MPYC_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 9 - Delayed write mode." ] # [ inline ( always ) ] pub fn mpydly32 ( & self ) -> MPYDLY32_R { MPYDLY32_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Delayed write enable." ] # [ inline ( always ) ] pub fn mpydlywrten ( & self ) -> MPYDLYWRTEN_R { MPYDLYWRTEN_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Multiplier bit width of operand 2" ] # [ inline ( always ) ] pub fn mpyop2_32 ( & self ) -> MPYOP2_32_R { MPYOP2_32_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Multiplier bit width of operand 1" ] # [ inline ( always ) ] pub fn mpyop1_32 ( & self ) -> MPYOP1_32_R { MPYOP1_32_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - Multiplier mode" ] # [ inline ( always ) ] pub fn mpym ( & self ) -> MPYM_R { MPYM_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 3 - Saturation mode" ] # [ inline ( always ) ] pub fn mpysat ( & self ) -> MPYSAT_R { MPYSAT_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Fractional mode." ] # [ inline ( always ) ] pub fn mpyfrac ( & self ) -> MPYFRAC_R { MPYFRAC_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 0 - Carry of the multiplier" ] # [ inline ( always ) ] pub fn mpyc ( & self ) -> MPYC_R { MPYC_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 9 - Delayed write mode." ] # [ inline ( always ) ] pub fn mpydly32 ( & mut self ) -> MPYDLY32_W { MPYDLY32_W { w : self } }
# [ doc = "Bit 8 - Delayed write enable." ] # [ inline ( always ) ] pub fn mpydlywrten ( & mut self ) -> MPYDLYWRTEN_W { MPYDLYWRTEN_W { w : self } }
# [ doc = "Bit 7 - Multiplier bit width of operand 2" ] # [ inline ( always ) ] pub fn mpyop2_32 ( & mut self ) -> MPYOP2_32_W { MPYOP2_32_W { w : self } }
# [ doc = "Bit 6 - Multiplier bit width of operand 1" ] # [ inline ( always ) ] pub fn mpyop1_32 ( & mut self ) -> MPYOP1_32_W { MPYOP1_32_W { w : self } }
# [ doc = "Bits 4:5 - Multiplier mode" ] # [ inline ( always ) ] pub fn mpym ( & mut self ) -> MPYM_W { MPYM_W { w : self } }
# [ doc = "Bit 3 - Saturation mode" ] # [ inline ( always ) ] pub fn mpysat ( & mut self ) -> MPYSAT_W { MPYSAT_W { w : self } }
# [ doc = "Bit 2 - Fractional mode." ] # [ inline ( always ) ] pub fn mpyfrac ( & mut self ) -> MPYFRAC_W { MPYFRAC_W { w : self } }
# [ doc = "Bit 0 - Carry of the multiplier" ] # [ inline ( always ) ] pub fn mpyc ( & mut self ) -> MPYC_W { MPYC_W { w : self } }
}
}
}
# [ doc = "eUSCI_A0" ] pub struct E_USCI_A0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for E_USCI_A0 { } impl E_USCI_A0 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const e_usci_a0 :: RegisterBlock { 0x0500 as * const _ } } impl Deref for E_USCI_A0 { type Target = e_usci_a0 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * E_USCI_A0 :: ptr ( ) } } }
# [ doc = "eUSCI_A0" ] pub mod e_usci_a0 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved_0_uca0ctlw : [ u8 ; 2usize ] , # [ doc = "0x02 - eUSCI_Ax Control Word Register 1" ] pub uca0ctlw1 : UCA0CTLW1 , _reserved2 : [ u8 ; 2usize ] , _reserved_2_uca0 : [ u8 ; 2usize ] , # [ doc = "0x08 - eUSCI_Ax Modulation Control Word Register" ] pub uca0mctlw : UCA0MCTLW , _reserved_4_uca0 : [ u8 ; 2usize ] , _reserved_5_uca0 : [ u8 ; 2usize ] , _reserved_6_uca0 : [ u8 ; 2usize ] , # [ doc = "0x10 - eUSCI_Ax Auto Baud Rate Control Register" ] pub uca0abctl : UCA0ABCTL , # [ doc = "0x12 - eUSCI_Ax IrDA Control Word Register" ] pub uca0irctl : UCA0IRCTL , _reserved9 : [ u8 ; 6usize ] , _reserved_9_uca0 : [ u8 ; 2usize ] , _reserved_10_uca0 : [ u8 ; 2usize ] , _reserved_11_uca0 : [ u8 ; 2usize ] , } impl RegisterBlock { # [ doc = "0x00 - eUSCI_Ax Control Word Register 0" ] # [ inline ( always ) ] pub fn uca0ctlw0_spi ( & self ) -> & UCA0CTLW0_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const UCA0CTLW0_SPI ) } } # [ doc = "0x00 - eUSCI_Ax Control Word Register 0" ] # [ inline ( always ) ] pub fn uca0ctlw0_spi_mut ( & self ) -> & mut UCA0CTLW0_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut UCA0CTLW0_SPI ) } } # [ doc = "0x00 - eUSCI_Ax Control Word Register 0" ] # [ inline ( always ) ] pub fn uca0ctlw0 ( & self ) -> & UCA0CTLW0 { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const UCA0CTLW0 ) } } # [ doc = "0x00 - eUSCI_Ax Control Word Register 0" ] # [ inline ( always ) ] pub fn uca0ctlw0_mut ( & self ) -> & mut UCA0CTLW0 { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut UCA0CTLW0 ) } } # [ doc = "0x06 - eUSCI_Ax Bit Rate Control Register 1" ] # [ inline ( always ) ] pub fn uca0brw_spi ( & self ) -> & UCA0BRW_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 6usize ) as * const UCA0BRW_SPI ) } } # [ doc = "0x06 - eUSCI_Ax Bit Rate Control Register 1" ] # [ inline ( always ) ] pub fn uca0brw_spi_mut ( & self ) -> & mut UCA0BRW_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 6usize ) as * mut UCA0BRW_SPI ) } } # [ doc = "0x06 - eUSCI_Ax Baud Rate Control Word Register" ] # [ inline ( always ) ] pub fn uca0brw ( & self ) -> & UCA0BRW { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 6usize ) as * const UCA0BRW ) } } # [ doc = "0x06 - eUSCI_Ax Baud Rate Control Word Register" ] # [ inline ( always ) ] pub fn uca0brw_mut ( & self ) -> & mut UCA0BRW { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 6usize ) as * mut UCA0BRW ) } } # [ doc = "0x0a - UCA0STATW_SPI" ] # [ inline ( always ) ] pub fn uca0statw_spi ( & self ) -> & UCA0STATW_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 10usize ) as * const UCA0STATW_SPI ) } } # [ doc = "0x0a - UCA0STATW_SPI" ] # [ inline ( always ) ] pub fn uca0statw_spi_mut ( & self ) -> & mut UCA0STATW_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 10usize ) as * mut UCA0STATW_SPI ) } } # [ doc = "0x0a - eUSCI_Ax Status Register" ] # [ inline ( always ) ] pub fn uca0statw ( & self ) -> & UCA0STATW { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 10usize ) as * const UCA0STATW ) } } # [ doc = "0x0a - eUSCI_Ax Status Register" ] # [ inline ( always ) ] pub fn uca0statw_mut ( & self ) -> & mut UCA0STATW { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 10usize ) as * mut UCA0STATW ) } } # [ doc = "0x0c - eUSCI_Ax Receive Buffer Register" ] # [ inline ( always ) ] pub fn uca0rxbuf_spi ( & self ) -> & UCA0RXBUF_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const UCA0RXBUF_SPI ) } } # [ doc = "0x0c - eUSCI_Ax Receive Buffer Register" ] # [ inline ( always ) ] pub fn uca0rxbuf_spi_mut ( & self ) -> & mut UCA0RXBUF_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut UCA0RXBUF_SPI ) } } # [ doc = "0x0c - eUSCI_Ax Receive Buffer Register" ] # [ inline ( always ) ] pub fn uca0rxbuf ( & self ) -> & UCA0RXBUF { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const UCA0RXBUF ) } } # [ doc = "0x0c - eUSCI_Ax Receive Buffer Register" ] # [ inline ( always ) ] pub fn uca0rxbuf_mut ( & self ) -> & mut UCA0RXBUF { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut UCA0RXBUF ) } } # [ doc = "0x0e - eUSCI_Ax Transmit Buffer Register" ] # [ inline ( always ) ] pub fn uca0txbuf_spi ( & self ) -> & UCA0TXBUF_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 14usize ) as * const UCA0TXBUF_SPI ) } } # [ doc = "0x0e - eUSCI_Ax Transmit Buffer Register" ] # [ inline ( always ) ] pub fn uca0txbuf_spi_mut ( & self ) -> & mut UCA0TXBUF_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 14usize ) as * mut UCA0TXBUF_SPI ) } } # [ doc = "0x0e - eUSCI_Ax Transmit Buffer Register" ] # [ inline ( always ) ] pub fn uca0txbuf ( & self ) -> & UCA0TXBUF { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 14usize ) as * const UCA0TXBUF ) } } # [ doc = "0x0e - eUSCI_Ax Transmit Buffer Register" ] # [ inline ( always ) ] pub fn uca0txbuf_mut ( & self ) -> & mut UCA0TXBUF { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 14usize ) as * mut UCA0TXBUF ) } } # [ doc = "0x1a - eUSCI_Ax Interrupt Enable Register" ] # [ inline ( always ) ] pub fn uca0ie_spi ( & self ) -> & UCA0IE_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 26usize ) as * const UCA0IE_SPI ) } } # [ doc = "0x1a - eUSCI_Ax Interrupt Enable Register" ] # [ inline ( always ) ] pub fn uca0ie_spi_mut ( & self ) -> & mut UCA0IE_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 26usize ) as * mut UCA0IE_SPI ) } } # [ doc = "0x1a - eUSCI_Ax Interrupt Enable Register" ] # [ inline ( always ) ] pub fn uca0ie ( & self ) -> & UCA0IE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 26usize ) as * const UCA0IE ) } } # [ doc = "0x1a - eUSCI_Ax Interrupt Enable Register" ] # [ inline ( always ) ] pub fn uca0ie_mut ( & self ) -> & mut UCA0IE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 26usize ) as * mut UCA0IE ) } } # [ doc = "0x1c - eUSCI_Ax Interrupt Flag Register" ] # [ inline ( always ) ] pub fn uca0ifg_spi ( & self ) -> & UCA0IFG_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 28usize ) as * const UCA0IFG_SPI ) } } # [ doc = "0x1c - eUSCI_Ax Interrupt Flag Register" ] # [ inline ( always ) ] pub fn uca0ifg_spi_mut ( & self ) -> & mut UCA0IFG_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 28usize ) as * mut UCA0IFG_SPI ) } } # [ doc = "0x1c - eUSCI_Ax Interrupt Flag Register" ] # [ inline ( always ) ] pub fn uca0ifg ( & self ) -> & UCA0IFG { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 28usize ) as * const UCA0IFG ) } } # [ doc = "0x1c - eUSCI_Ax Interrupt Flag Register" ] # [ inline ( always ) ] pub fn uca0ifg_mut ( & self ) -> & mut UCA0IFG { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 28usize ) as * mut UCA0IFG ) } } # [ doc = "0x1e - eUSCI_Ax Interrupt Vector Register" ] # [ inline ( always ) ] pub fn uca0iv_spi ( & self ) -> & UCA0IV_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 30usize ) as * const UCA0IV_SPI ) } } # [ doc = "0x1e - eUSCI_Ax Interrupt Vector Register" ] # [ inline ( always ) ] pub fn uca0iv_spi_mut ( & self ) -> & mut UCA0IV_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 30usize ) as * mut UCA0IV_SPI ) } } # [ doc = "0x1e - eUSCI_Ax Interrupt Vector Register" ] # [ inline ( always ) ] pub fn uca0iv ( & self ) -> & UCA0IV { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 30usize ) as * const UCA0IV ) } } # [ doc = "0x1e - eUSCI_Ax Interrupt Vector Register" ] # [ inline ( always ) ] pub fn uca0iv_mut ( & self ) -> & mut UCA0IV { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 30usize ) as * mut UCA0IV ) } } }
# [ doc = "eUSCI_Ax Control Word Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ctlw0](uca0ctlw0) module" ] pub type UCA0CTLW0 = crate :: Reg < u16 , _UCA0CTLW0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0CTLW0 ;
# [ doc = "`read()` method returns [uca0ctlw0::R](uca0ctlw0::R) reader structure" ] impl crate :: Readable for UCA0CTLW0 { }
# [ doc = "`write(|w| ..)` method takes [uca0ctlw0::W](uca0ctlw0::W) writer structure" ] impl crate :: Writable for UCA0CTLW0 { }
# [ doc = "eUSCI_Ax Control Word Register 0" ] pub mod uca0ctlw0 {
# [ doc = "Reader of register UCA0CTLW0" ] pub type R = crate :: R < u16 , super :: UCA0CTLW0 > ;
# [ doc = "Writer for register UCA0CTLW0" ] pub type W = crate :: W < u16 , super :: UCA0CTLW0 > ;
# [ doc = "Register UCA0CTLW0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0CTLW0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Software reset enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSWRST_A { # [ doc = "0: Disabled. eUSCI_A reset released for operation" ] DISABLE = 0 , # [ doc = "1: Enabled. eUSCI_A logic held in reset state" ] ENABLE = 1 } impl From < UCSWRST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSWRST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSWRST`" ] pub type UCSWRST_R = crate :: R < bool , UCSWRST_A > ; impl UCSWRST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSWRST_A { match self . bits { false => UCSWRST_A :: DISABLE , true => UCSWRST_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCSWRST_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCSWRST_A :: ENABLE } }
# [ doc = "Write proxy for field `UCSWRST`" ] pub struct UCSWRST_W < 'a > { w : & 'a mut W , } impl < 'a > UCSWRST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSWRST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled. eUSCI_A reset released for operation" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: DISABLE ) } # [ doc = "Enabled. eUSCI_A logic held in reset state" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit break\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXBRK_A { # [ doc = "0: Next frame transmitted is not a break" ] UCTXBRK_0 = 0 , # [ doc = "1: Next frame transmitted is a break or a break/synch" ] UCTXBRK_1 = 1 } impl From < UCTXBRK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXBRK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXBRK`" ] pub type UCTXBRK_R = crate :: R < bool , UCTXBRK_A > ; impl UCTXBRK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXBRK_A { match self . bits { false => UCTXBRK_A :: UCTXBRK_0 , true => UCTXBRK_A :: UCTXBRK_1 } } # [ doc = "Checks if the value of the field is `UCTXBRK_0`" ] # [ inline ( always ) ] pub fn is_uctxbrk_0 ( & self ) -> bool { * self == UCTXBRK_A :: UCTXBRK_0 } # [ doc = "Checks if the value of the field is `UCTXBRK_1`" ] # [ inline ( always ) ] pub fn is_uctxbrk_1 ( & self ) -> bool { * self == UCTXBRK_A :: UCTXBRK_1 } }
# [ doc = "Write proxy for field `UCTXBRK`" ] pub struct UCTXBRK_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXBRK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXBRK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Next frame transmitted is not a break" ] # [ inline ( always ) ] pub fn uctxbrk_0 ( self ) -> & 'a mut W { self . variant ( UCTXBRK_A :: UCTXBRK_0 ) } # [ doc = "Next frame transmitted is a break or a break/synch" ] # [ inline ( always ) ] pub fn uctxbrk_1 ( self ) -> & 'a mut W { self . variant ( UCTXBRK_A :: UCTXBRK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Transmit address\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXADDR_A { # [ doc = "0: Next frame transmitted is data" ] UCTXADDR_0 = 0 , # [ doc = "1: Next frame transmitted is an address" ] UCTXADDR_1 = 1 } impl From < UCTXADDR_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXADDR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXADDR`" ] pub type UCTXADDR_R = crate :: R < bool , UCTXADDR_A > ; impl UCTXADDR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXADDR_A { match self . bits { false => UCTXADDR_A :: UCTXADDR_0 , true => UCTXADDR_A :: UCTXADDR_1 } } # [ doc = "Checks if the value of the field is `UCTXADDR_0`" ] # [ inline ( always ) ] pub fn is_uctxaddr_0 ( & self ) -> bool { * self == UCTXADDR_A :: UCTXADDR_0 } # [ doc = "Checks if the value of the field is `UCTXADDR_1`" ] # [ inline ( always ) ] pub fn is_uctxaddr_1 ( & self ) -> bool { * self == UCTXADDR_A :: UCTXADDR_1 } }
# [ doc = "Write proxy for field `UCTXADDR`" ] pub struct UCTXADDR_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXADDR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXADDR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Next frame transmitted is data" ] # [ inline ( always ) ] pub fn uctxaddr_0 ( self ) -> & 'a mut W { self . variant ( UCTXADDR_A :: UCTXADDR_0 ) } # [ doc = "Next frame transmitted is an address" ] # [ inline ( always ) ] pub fn uctxaddr_1 ( self ) -> & 'a mut W { self . variant ( UCTXADDR_A :: UCTXADDR_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Dormant\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCDORM_A { # [ doc = "0: Not dormant. All received characters set UCRXIFG." ] UCDORM_0 = 0 , # [ doc = "1: Dormant. Only characters that are preceded by an idle-line or with address bit set UCRXIFG. In UART mode with automatic baud-rate detection, only the combination of a break and synch field sets UCRXIFG." ] UCDORM_1 = 1 } impl From < UCDORM_A > for bool { # [ inline ( always ) ] fn from ( variant : UCDORM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCDORM`" ] pub type UCDORM_R = crate :: R < bool , UCDORM_A > ; impl UCDORM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCDORM_A { match self . bits { false => UCDORM_A :: UCDORM_0 , true => UCDORM_A :: UCDORM_1 } } # [ doc = "Checks if the value of the field is `UCDORM_0`" ] # [ inline ( always ) ] pub fn is_ucdorm_0 ( & self ) -> bool { * self == UCDORM_A :: UCDORM_0 } # [ doc = "Checks if the value of the field is `UCDORM_1`" ] # [ inline ( always ) ] pub fn is_ucdorm_1 ( & self ) -> bool { * self == UCDORM_A :: UCDORM_1 } }
# [ doc = "Write proxy for field `UCDORM`" ] pub struct UCDORM_W < 'a > { w : & 'a mut W , } impl < 'a > UCDORM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCDORM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Not dormant. All received characters set UCRXIFG." ] # [ inline ( always ) ] pub fn ucdorm_0 ( self ) -> & 'a mut W { self . variant ( UCDORM_A :: UCDORM_0 ) } # [ doc = "Dormant. Only characters that are preceded by an idle-line or with address bit set UCRXIFG. In UART mode with automatic baud-rate detection, only the combination of a break and synch field sets UCRXIFG." ] # [ inline ( always ) ] pub fn ucdorm_1 ( self ) -> & 'a mut W { self . variant ( UCDORM_A :: UCDORM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Receive break character interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBRKIE_A { # [ doc = "0: Received break characters do not set UCRXIFG" ] UCBRKIE_0 = 0 , # [ doc = "1: Received break characters set UCRXIFG" ] UCBRKIE_1 = 1 } impl From < UCBRKIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBRKIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBRKIE`" ] pub type UCBRKIE_R = crate :: R < bool , UCBRKIE_A > ; impl UCBRKIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBRKIE_A { match self . bits { false => UCBRKIE_A :: UCBRKIE_0 , true => UCBRKIE_A :: UCBRKIE_1 } } # [ doc = "Checks if the value of the field is `UCBRKIE_0`" ] # [ inline ( always ) ] pub fn is_ucbrkie_0 ( & self ) -> bool { * self == UCBRKIE_A :: UCBRKIE_0 } # [ doc = "Checks if the value of the field is `UCBRKIE_1`" ] # [ inline ( always ) ] pub fn is_ucbrkie_1 ( & self ) -> bool { * self == UCBRKIE_A :: UCBRKIE_1 } }
# [ doc = "Write proxy for field `UCBRKIE`" ] pub struct UCBRKIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCBRKIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBRKIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Received break characters do not set UCRXIFG" ] # [ inline ( always ) ] pub fn ucbrkie_0 ( self ) -> & 'a mut W { self . variant ( UCBRKIE_A :: UCBRKIE_0 ) } # [ doc = "Received break characters set UCRXIFG" ] # [ inline ( always ) ] pub fn ucbrkie_1 ( self ) -> & 'a mut W { self . variant ( UCBRKIE_A :: UCBRKIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Receive erroneous-character interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXEIE_A { # [ doc = "0: Erroneous characters rejected and UCRXIFG is not set" ] UCRXEIE_0 = 0 , # [ doc = "1: Erroneous characters received set UCRXIFG" ] UCRXEIE_1 = 1 } impl From < UCRXEIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXEIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXEIE`" ] pub type UCRXEIE_R = crate :: R < bool , UCRXEIE_A > ; impl UCRXEIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXEIE_A { match self . bits { false => UCRXEIE_A :: UCRXEIE_0 , true => UCRXEIE_A :: UCRXEIE_1 } } # [ doc = "Checks if the value of the field is `UCRXEIE_0`" ] # [ inline ( always ) ] pub fn is_ucrxeie_0 ( & self ) -> bool { * self == UCRXEIE_A :: UCRXEIE_0 } # [ doc = "Checks if the value of the field is `UCRXEIE_1`" ] # [ inline ( always ) ] pub fn is_ucrxeie_1 ( & self ) -> bool { * self == UCRXEIE_A :: UCRXEIE_1 } }
# [ doc = "Write proxy for field `UCRXEIE`" ] pub struct UCRXEIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXEIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXEIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Erroneous characters rejected and UCRXIFG is not set" ] # [ inline ( always ) ] pub fn ucrxeie_0 ( self ) -> & 'a mut W { self . variant ( UCRXEIE_A :: UCRXEIE_0 ) } # [ doc = "Erroneous characters received set UCRXIFG" ] # [ inline ( always ) ] pub fn ucrxeie_1 ( self ) -> & 'a mut W { self . variant ( UCRXEIE_A :: UCRXEIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "eUSCI_A clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCSSEL_A { # [ doc = "0: UCLK" ] UCLK = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: SMCLK" ] UCSSEL_3 = 3 } impl From < UCSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCSSEL`" ] pub type UCSSEL_R = crate :: R < u8 , UCSSEL_A > ; impl UCSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSSEL_A { match self . bits { 0 => UCSSEL_A :: UCLK , 1 => UCSSEL_A :: ACLK , 2 => UCSSEL_A :: SMCLK , 3 => UCSSEL_A :: UCSSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCLK`" ] # [ inline ( always ) ] pub fn is_uclk ( & self ) -> bool { * self == UCSSEL_A :: UCLK } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == UCSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == UCSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `UCSSEL_3`" ] # [ inline ( always ) ] pub fn is_ucssel_3 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_3 } }
# [ doc = "Write proxy for field `UCSSEL`" ] pub struct UCSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > UCSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "UCLK" ] # [ inline ( always ) ] pub fn uclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCLK ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: SMCLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn ucssel_3 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Synchronous mode enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSYNC_A { # [ doc = "0: Asynchronous mode" ] ASYNC = 0 , # [ doc = "1: Synchronous mode" ] SYNC = 1 } impl From < UCSYNC_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSYNC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSYNC`" ] pub type UCSYNC_R = crate :: R < bool , UCSYNC_A > ; impl UCSYNC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSYNC_A { match self . bits { false => UCSYNC_A :: ASYNC , true => UCSYNC_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == UCSYNC_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == UCSYNC_A :: SYNC } }
# [ doc = "Write proxy for field `UCSYNC`" ] pub struct UCSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > UCSYNC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSYNC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous mode" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: ASYNC ) } # [ doc = "Synchronous mode" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "eUSCI_A mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCMODE_A { # [ doc = "0: UART mode" ] UCMODE_0 = 0 , # [ doc = "1: Idle-line multiprocessor mode" ] UCMODE_1 = 1 , # [ doc = "2: Address-bit multiprocessor mode" ] UCMODE_2 = 2 , # [ doc = "3: UART mode with automatic baud-rate detection" ] UCMODE_3 = 3 } impl From < UCMODE_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCMODE_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCMODE`" ] pub type UCMODE_R = crate :: R < u8 , UCMODE_A > ; impl UCMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMODE_A { match self . bits { 0 => UCMODE_A :: UCMODE_0 , 1 => UCMODE_A :: UCMODE_1 , 2 => UCMODE_A :: UCMODE_2 , 3 => UCMODE_A :: UCMODE_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCMODE_0`" ] # [ inline ( always ) ] pub fn is_ucmode_0 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_0 } # [ doc = "Checks if the value of the field is `UCMODE_1`" ] # [ inline ( always ) ] pub fn is_ucmode_1 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_1 } # [ doc = "Checks if the value of the field is `UCMODE_2`" ] # [ inline ( always ) ] pub fn is_ucmode_2 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_2 } # [ doc = "Checks if the value of the field is `UCMODE_3`" ] # [ inline ( always ) ] pub fn is_ucmode_3 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_3 } }
# [ doc = "Write proxy for field `UCMODE`" ] pub struct UCMODE_W < 'a > { w : & 'a mut W , } impl < 'a > UCMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMODE_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "UART mode" ] # [ inline ( always ) ] pub fn ucmode_0 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_0 ) } # [ doc = "Idle-line multiprocessor mode" ] # [ inline ( always ) ] pub fn ucmode_1 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_1 ) } # [ doc = "Address-bit multiprocessor mode" ] # [ inline ( always ) ] pub fn ucmode_2 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_2 ) } # [ doc = "UART mode with automatic baud-rate detection" ] # [ inline ( always ) ] pub fn ucmode_3 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Stop bit select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSPB_A { # [ doc = "0: One stop bit" ] UCSPB_0 = 0 , # [ doc = "1: Two stop bits" ] UCSPB_1 = 1 } impl From < UCSPB_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSPB_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSPB`" ] pub type UCSPB_R = crate :: R < bool , UCSPB_A > ; impl UCSPB_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSPB_A { match self . bits { false => UCSPB_A :: UCSPB_0 , true => UCSPB_A :: UCSPB_1 } } # [ doc = "Checks if the value of the field is `UCSPB_0`" ] # [ inline ( always ) ] pub fn is_ucspb_0 ( & self ) -> bool { * self == UCSPB_A :: UCSPB_0 } # [ doc = "Checks if the value of the field is `UCSPB_1`" ] # [ inline ( always ) ] pub fn is_ucspb_1 ( & self ) -> bool { * self == UCSPB_A :: UCSPB_1 } }
# [ doc = "Write proxy for field `UCSPB`" ] pub struct UCSPB_W < 'a > { w : & 'a mut W , } impl < 'a > UCSPB_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSPB_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "One stop bit" ] # [ inline ( always ) ] pub fn ucspb_0 ( self ) -> & 'a mut W { self . variant ( UCSPB_A :: UCSPB_0 ) } # [ doc = "Two stop bits" ] # [ inline ( always ) ] pub fn ucspb_1 ( self ) -> & 'a mut W { self . variant ( UCSPB_A :: UCSPB_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Character length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UC7BIT_A { # [ doc = "0: 8-bit data" ] _8BIT = 0 , # [ doc = "1: 7-bit data" ] _7BIT = 1 } impl From < UC7BIT_A > for bool { # [ inline ( always ) ] fn from ( variant : UC7BIT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UC7BIT`" ] pub type UC7BIT_R = crate :: R < bool , UC7BIT_A > ; impl UC7BIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UC7BIT_A { match self . bits { false => UC7BIT_A :: _8BIT , true => UC7BIT_A :: _7BIT } } # [ doc = "Checks if the value of the field is `_8BIT`" ] # [ inline ( always ) ] pub fn is_8bit ( & self ) -> bool { * self == UC7BIT_A :: _8BIT } # [ doc = "Checks if the value of the field is `_7BIT`" ] # [ inline ( always ) ] pub fn is_7bit ( & self ) -> bool { * self == UC7BIT_A :: _7BIT } }
# [ doc = "Write proxy for field `UC7BIT`" ] pub struct UC7BIT_W < 'a > { w : & 'a mut W , } impl < 'a > UC7BIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UC7BIT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "8-bit data" ] # [ inline ( always ) ] pub fn _8bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _8BIT ) } # [ doc = "7-bit data" ] # [ inline ( always ) ] pub fn _7bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _7BIT ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "MSB first select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMSB_A { # [ doc = "0: LSB first" ] UCMSB_0 = 0 , # [ doc = "1: MSB first" ] UCMSB_1 = 1 } impl From < UCMSB_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMSB_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMSB`" ] pub type UCMSB_R = crate :: R < bool , UCMSB_A > ; impl UCMSB_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMSB_A { match self . bits { false => UCMSB_A :: UCMSB_0 , true => UCMSB_A :: UCMSB_1 } } # [ doc = "Checks if the value of the field is `UCMSB_0`" ] # [ inline ( always ) ] pub fn is_ucmsb_0 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_0 } # [ doc = "Checks if the value of the field is `UCMSB_1`" ] # [ inline ( always ) ] pub fn is_ucmsb_1 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_1 } }
# [ doc = "Write proxy for field `UCMSB`" ] pub struct UCMSB_W < 'a > { w : & 'a mut W , } impl < 'a > UCMSB_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMSB_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "LSB first" ] # [ inline ( always ) ] pub fn ucmsb_0 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_0 ) } # [ doc = "MSB first" ] # [ inline ( always ) ] pub fn ucmsb_1 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Parity select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCPAR_A { # [ doc = "0: Odd parity" ] ODD = 0 , # [ doc = "1: Even parity" ] EVEN = 1 } impl From < UCPAR_A > for bool { # [ inline ( always ) ] fn from ( variant : UCPAR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCPAR`" ] pub type UCPAR_R = crate :: R < bool , UCPAR_A > ; impl UCPAR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCPAR_A { match self . bits { false => UCPAR_A :: ODD , true => UCPAR_A :: EVEN } } # [ doc = "Checks if the value of the field is `ODD`" ] # [ inline ( always ) ] pub fn is_odd ( & self ) -> bool { * self == UCPAR_A :: ODD } # [ doc = "Checks if the value of the field is `EVEN`" ] # [ inline ( always ) ] pub fn is_even ( & self ) -> bool { * self == UCPAR_A :: EVEN } }
# [ doc = "Write proxy for field `UCPAR`" ] pub struct UCPAR_W < 'a > { w : & 'a mut W , } impl < 'a > UCPAR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCPAR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Odd parity" ] # [ inline ( always ) ] pub fn odd ( self ) -> & 'a mut W { self . variant ( UCPAR_A :: ODD ) } # [ doc = "Even parity" ] # [ inline ( always ) ] pub fn even ( self ) -> & 'a mut W { self . variant ( UCPAR_A :: EVEN ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Parity enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCPEN_A { # [ doc = "0: Parity disabled" ] UCPEN_0 = 0 , # [ doc = "1: Parity enabled. Parity bit is generated (UCAxTXD) and expected (UCAxRXD). In address-bit multiprocessor mode, the address bit is included in the parity calculation." ] UCPEN_1 = 1 } impl From < UCPEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCPEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCPEN`" ] pub type UCPEN_R = crate :: R < bool , UCPEN_A > ; impl UCPEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCPEN_A { match self . bits { false => UCPEN_A :: UCPEN_0 , true => UCPEN_A :: UCPEN_1 } } # [ doc = "Checks if the value of the field is `UCPEN_0`" ] # [ inline ( always ) ] pub fn is_ucpen_0 ( & self ) -> bool { * self == UCPEN_A :: UCPEN_0 } # [ doc = "Checks if the value of the field is `UCPEN_1`" ] # [ inline ( always ) ] pub fn is_ucpen_1 ( & self ) -> bool { * self == UCPEN_A :: UCPEN_1 } }
# [ doc = "Write proxy for field `UCPEN`" ] pub struct UCPEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCPEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCPEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Parity disabled" ] # [ inline ( always ) ] pub fn ucpen_0 ( self ) -> & 'a mut W { self . variant ( UCPEN_A :: UCPEN_0 ) } # [ doc = "Parity enabled. Parity bit is generated (UCAxTXD) and expected (UCAxRXD). In address-bit multiprocessor mode, the address bit is included in the parity calculation." ] # [ inline ( always ) ] pub fn ucpen_1 ( self ) -> & 'a mut W { self . variant ( UCPEN_A :: UCPEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & self ) -> UCSWRST_R { UCSWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit break" ] # [ inline ( always ) ] pub fn uctxbrk ( & self ) -> UCTXBRK_R { UCTXBRK_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Transmit address" ] # [ inline ( always ) ] pub fn uctxaddr ( & self ) -> UCTXADDR_R { UCTXADDR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Dormant" ] # [ inline ( always ) ] pub fn ucdorm ( & self ) -> UCDORM_R { UCDORM_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Receive break character interrupt enable" ] # [ inline ( always ) ] pub fn ucbrkie ( & self ) -> UCBRKIE_R { UCBRKIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Receive erroneous-character interrupt enable" ] # [ inline ( always ) ] pub fn ucrxeie ( & self ) -> UCRXEIE_R { UCRXEIE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - eUSCI_A clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & self ) -> UCSSEL_R { UCSSEL_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & self ) -> UCSYNC_R { UCSYNC_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - eUSCI_A mode" ] # [ inline ( always ) ] pub fn ucmode ( & self ) -> UCMODE_R { UCMODE_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Stop bit select" ] # [ inline ( always ) ] pub fn ucspb ( & self ) -> UCSPB_R { UCSPB_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & self ) -> UC7BIT_R { UC7BIT_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & self ) -> UCMSB_R { UCMSB_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Parity select" ] # [ inline ( always ) ] pub fn ucpar ( & self ) -> UCPAR_R { UCPAR_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Parity enable" ] # [ inline ( always ) ] pub fn ucpen ( & self ) -> UCPEN_R { UCPEN_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & mut self ) -> UCSWRST_W { UCSWRST_W { w : self } }
# [ doc = "Bit 1 - Transmit break" ] # [ inline ( always ) ] pub fn uctxbrk ( & mut self ) -> UCTXBRK_W { UCTXBRK_W { w : self } }
# [ doc = "Bit 2 - Transmit address" ] # [ inline ( always ) ] pub fn uctxaddr ( & mut self ) -> UCTXADDR_W { UCTXADDR_W { w : self } }
# [ doc = "Bit 3 - Dormant" ] # [ inline ( always ) ] pub fn ucdorm ( & mut self ) -> UCDORM_W { UCDORM_W { w : self } }
# [ doc = "Bit 4 - Receive break character interrupt enable" ] # [ inline ( always ) ] pub fn ucbrkie ( & mut self ) -> UCBRKIE_W { UCBRKIE_W { w : self } }
# [ doc = "Bit 5 - Receive erroneous-character interrupt enable" ] # [ inline ( always ) ] pub fn ucrxeie ( & mut self ) -> UCRXEIE_W { UCRXEIE_W { w : self } }
# [ doc = "Bits 6:7 - eUSCI_A clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & mut self ) -> UCSSEL_W { UCSSEL_W { w : self } }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & mut self ) -> UCSYNC_W { UCSYNC_W { w : self } }
# [ doc = "Bits 9:10 - eUSCI_A mode" ] # [ inline ( always ) ] pub fn ucmode ( & mut self ) -> UCMODE_W { UCMODE_W { w : self } }
# [ doc = "Bit 11 - Stop bit select" ] # [ inline ( always ) ] pub fn ucspb ( & mut self ) -> UCSPB_W { UCSPB_W { w : self } }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & mut self ) -> UC7BIT_W { UC7BIT_W { w : self } }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & mut self ) -> UCMSB_W { UCMSB_W { w : self } }
# [ doc = "Bit 14 - Parity select" ] # [ inline ( always ) ] pub fn ucpar ( & mut self ) -> UCPAR_W { UCPAR_W { w : self } }
# [ doc = "Bit 15 - Parity enable" ] # [ inline ( always ) ] pub fn ucpen ( & mut self ) -> UCPEN_W { UCPEN_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Control Word Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ctlw0_spi](uca0ctlw0_spi) module" ] pub type UCA0CTLW0_SPI = crate :: Reg < u16 , _UCA0CTLW0_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0CTLW0_SPI ;
# [ doc = "`read()` method returns [uca0ctlw0_spi::R](uca0ctlw0_spi::R) reader structure" ] impl crate :: Readable for UCA0CTLW0_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca0ctlw0_spi::W](uca0ctlw0_spi::W) writer structure" ] impl crate :: Writable for UCA0CTLW0_SPI { }
# [ doc = "eUSCI_Ax Control Word Register 0" ] pub mod uca0ctlw0_spi {
# [ doc = "Reader of register UCA0CTLW0_SPI" ] pub type R = crate :: R < u16 , super :: UCA0CTLW0_SPI > ;
# [ doc = "Writer for register UCA0CTLW0_SPI" ] pub type W = crate :: W < u16 , super :: UCA0CTLW0_SPI > ;
# [ doc = "Register UCA0CTLW0_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0CTLW0_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Software reset enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSWRST_A { # [ doc = "0: Disabled. eUSCI_A reset released for operation" ] DISABLE = 0 , # [ doc = "1: Enabled. eUSCI_A logic held in reset state" ] ENABLE = 1 } impl From < UCSWRST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSWRST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSWRST`" ] pub type UCSWRST_R = crate :: R < bool , UCSWRST_A > ; impl UCSWRST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSWRST_A { match self . bits { false => UCSWRST_A :: DISABLE , true => UCSWRST_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCSWRST_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCSWRST_A :: ENABLE } }
# [ doc = "Write proxy for field `UCSWRST`" ] pub struct UCSWRST_W < 'a > { w : & 'a mut W , } impl < 'a > UCSWRST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSWRST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled. eUSCI_A reset released for operation" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: DISABLE ) } # [ doc = "Enabled. eUSCI_A logic held in reset state" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "STE mode select in master mode.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTEM_A { # [ doc = "0: STE pin is used to prevent conflicts with other masters" ] UCSTEM_0 = 0 , # [ doc = "1: STE pin is used to generate the enable signal for a 4-wire slave" ] UCSTEM_1 = 1 } impl From < UCSTEM_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTEM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTEM`" ] pub type UCSTEM_R = crate :: R < bool , UCSTEM_A > ; impl UCSTEM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTEM_A { match self . bits { false => UCSTEM_A :: UCSTEM_0 , true => UCSTEM_A :: UCSTEM_1 } } # [ doc = "Checks if the value of the field is `UCSTEM_0`" ] # [ inline ( always ) ] pub fn is_ucstem_0 ( & self ) -> bool { * self == UCSTEM_A :: UCSTEM_0 } # [ doc = "Checks if the value of the field is `UCSTEM_1`" ] # [ inline ( always ) ] pub fn is_ucstem_1 ( & self ) -> bool { * self == UCSTEM_A :: UCSTEM_1 } }
# [ doc = "Write proxy for field `UCSTEM`" ] pub struct UCSTEM_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTEM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTEM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "STE pin is used to prevent conflicts with other masters" ] # [ inline ( always ) ] pub fn ucstem_0 ( self ) -> & 'a mut W { self . variant ( UCSTEM_A :: UCSTEM_0 ) } # [ doc = "STE pin is used to generate the enable signal for a 4-wire slave" ] # [ inline ( always ) ] pub fn ucstem_1 ( self ) -> & 'a mut W { self . variant ( UCSTEM_A :: UCSTEM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "eUSCI_A clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCSSEL_A { # [ doc = "0: Reserved" ] UCSSEL_0 = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: SMCLK" ] UCSSEL_3 = 3 } impl From < UCSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCSSEL`" ] pub type UCSSEL_R = crate :: R < u8 , UCSSEL_A > ; impl UCSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSSEL_A { match self . bits { 0 => UCSSEL_A :: UCSSEL_0 , 1 => UCSSEL_A :: ACLK , 2 => UCSSEL_A :: SMCLK , 3 => UCSSEL_A :: UCSSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCSSEL_0`" ] # [ inline ( always ) ] pub fn is_ucssel_0 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_0 } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == UCSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == UCSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `UCSSEL_3`" ] # [ inline ( always ) ] pub fn is_ucssel_3 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_3 } }
# [ doc = "Write proxy for field `UCSSEL`" ] pub struct UCSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > UCSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn ucssel_0 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_0 ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: SMCLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn ucssel_3 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Synchronous mode enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSYNC_A { # [ doc = "0: Asynchronous mode" ] ASYNC = 0 , # [ doc = "1: Synchronous mode" ] SYNC = 1 } impl From < UCSYNC_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSYNC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSYNC`" ] pub type UCSYNC_R = crate :: R < bool , UCSYNC_A > ; impl UCSYNC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSYNC_A { match self . bits { false => UCSYNC_A :: ASYNC , true => UCSYNC_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == UCSYNC_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == UCSYNC_A :: SYNC } }
# [ doc = "Write proxy for field `UCSYNC`" ] pub struct UCSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > UCSYNC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSYNC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous mode" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: ASYNC ) } # [ doc = "Synchronous mode" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "eUSCI mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCMODE_A { # [ doc = "0: 3-pin SPI" ] UCMODE_0 = 0 , # [ doc = "1: 4-pin SPI with UCxSTE active high: Slave enabled when UCxSTE = 1" ] UCMODE_1 = 1 , # [ doc = "2: 4-pin SPI with UCxSTE active low: Slave enabled when UCxSTE = 0" ] UCMODE_2 = 2 , # [ doc = "3: I2C mode" ] UCMODE_3 = 3 } impl From < UCMODE_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCMODE_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCMODE`" ] pub type UCMODE_R = crate :: R < u8 , UCMODE_A > ; impl UCMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMODE_A { match self . bits { 0 => UCMODE_A :: UCMODE_0 , 1 => UCMODE_A :: UCMODE_1 , 2 => UCMODE_A :: UCMODE_2 , 3 => UCMODE_A :: UCMODE_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCMODE_0`" ] # [ inline ( always ) ] pub fn is_ucmode_0 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_0 } # [ doc = "Checks if the value of the field is `UCMODE_1`" ] # [ inline ( always ) ] pub fn is_ucmode_1 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_1 } # [ doc = "Checks if the value of the field is `UCMODE_2`" ] # [ inline ( always ) ] pub fn is_ucmode_2 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_2 } # [ doc = "Checks if the value of the field is `UCMODE_3`" ] # [ inline ( always ) ] pub fn is_ucmode_3 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_3 } }
# [ doc = "Write proxy for field `UCMODE`" ] pub struct UCMODE_W < 'a > { w : & 'a mut W , } impl < 'a > UCMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMODE_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "3-pin SPI" ] # [ inline ( always ) ] pub fn ucmode_0 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_0 ) } # [ doc = "4-pin SPI with UCxSTE active high: Slave enabled when UCxSTE = 1" ] # [ inline ( always ) ] pub fn ucmode_1 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_1 ) } # [ doc = "4-pin SPI with UCxSTE active low: Slave enabled when UCxSTE = 0" ] # [ inline ( always ) ] pub fn ucmode_2 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_2 ) } # [ doc = "I2C mode" ] # [ inline ( always ) ] pub fn ucmode_3 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Master mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMST_A { # [ doc = "0: Slave mode" ] SLAVE = 0 , # [ doc = "1: Master mode" ] MASTER = 1 } impl From < UCMST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMST`" ] pub type UCMST_R = crate :: R < bool , UCMST_A > ; impl UCMST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMST_A { match self . bits { false => UCMST_A :: SLAVE , true => UCMST_A :: MASTER } } # [ doc = "Checks if the value of the field is `SLAVE`" ] # [ inline ( always ) ] pub fn is_slave ( & self ) -> bool { * self == UCMST_A :: SLAVE } # [ doc = "Checks if the value of the field is `MASTER`" ] # [ inline ( always ) ] pub fn is_master ( & self ) -> bool { * self == UCMST_A :: MASTER } }
# [ doc = "Write proxy for field `UCMST`" ] pub struct UCMST_W < 'a > { w : & 'a mut W , } impl < 'a > UCMST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Slave mode" ] # [ inline ( always ) ] pub fn slave ( self ) -> & 'a mut W { self . variant ( UCMST_A :: SLAVE ) } # [ doc = "Master mode" ] # [ inline ( always ) ] pub fn master ( self ) -> & 'a mut W { self . variant ( UCMST_A :: MASTER ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Character length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UC7BIT_A { # [ doc = "0: 8-bit data" ] _8BIT = 0 , # [ doc = "1: 7-bit data" ] _7BIT = 1 } impl From < UC7BIT_A > for bool { # [ inline ( always ) ] fn from ( variant : UC7BIT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UC7BIT`" ] pub type UC7BIT_R = crate :: R < bool , UC7BIT_A > ; impl UC7BIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UC7BIT_A { match self . bits { false => UC7BIT_A :: _8BIT , true => UC7BIT_A :: _7BIT } } # [ doc = "Checks if the value of the field is `_8BIT`" ] # [ inline ( always ) ] pub fn is_8bit ( & self ) -> bool { * self == UC7BIT_A :: _8BIT } # [ doc = "Checks if the value of the field is `_7BIT`" ] # [ inline ( always ) ] pub fn is_7bit ( & self ) -> bool { * self == UC7BIT_A :: _7BIT } }
# [ doc = "Write proxy for field `UC7BIT`" ] pub struct UC7BIT_W < 'a > { w : & 'a mut W , } impl < 'a > UC7BIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UC7BIT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "8-bit data" ] # [ inline ( always ) ] pub fn _8bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _8BIT ) } # [ doc = "7-bit data" ] # [ inline ( always ) ] pub fn _7bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _7BIT ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "MSB first select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMSB_A { # [ doc = "0: LSB first" ] UCMSB_0 = 0 , # [ doc = "1: MSB first" ] UCMSB_1 = 1 } impl From < UCMSB_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMSB_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMSB`" ] pub type UCMSB_R = crate :: R < bool , UCMSB_A > ; impl UCMSB_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMSB_A { match self . bits { false => UCMSB_A :: UCMSB_0 , true => UCMSB_A :: UCMSB_1 } } # [ doc = "Checks if the value of the field is `UCMSB_0`" ] # [ inline ( always ) ] pub fn is_ucmsb_0 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_0 } # [ doc = "Checks if the value of the field is `UCMSB_1`" ] # [ inline ( always ) ] pub fn is_ucmsb_1 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_1 } }
# [ doc = "Write proxy for field `UCMSB`" ] pub struct UCMSB_W < 'a > { w : & 'a mut W , } impl < 'a > UCMSB_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMSB_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "LSB first" ] # [ inline ( always ) ] pub fn ucmsb_0 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_0 ) } # [ doc = "MSB first" ] # [ inline ( always ) ] pub fn ucmsb_1 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Clock polarity select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCKPL_A { # [ doc = "0: The inactive state is low" ] LOW = 0 , # [ doc = "1: The inactive state is high" ] HIGH = 1 } impl From < UCCKPL_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCKPL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCKPL`" ] pub type UCCKPL_R = crate :: R < bool , UCCKPL_A > ; impl UCCKPL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCKPL_A { match self . bits { false => UCCKPL_A :: LOW , true => UCCKPL_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == UCCKPL_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == UCCKPL_A :: HIGH } }
# [ doc = "Write proxy for field `UCCKPL`" ] pub struct UCCKPL_W < 'a > { w : & 'a mut W , } impl < 'a > UCCKPL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCKPL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The inactive state is low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( UCCKPL_A :: LOW ) } # [ doc = "The inactive state is high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( UCCKPL_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Clock phase select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCKPH_A { # [ doc = "0: Data is changed on the first UCLK edge and captured on the following edge." ] UCCKPH_0 = 0 , # [ doc = "1: Data is captured on the first UCLK edge and changed on the following edge." ] UCCKPH_1 = 1 } impl From < UCCKPH_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCKPH_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCKPH`" ] pub type UCCKPH_R = crate :: R < bool , UCCKPH_A > ; impl UCCKPH_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCKPH_A { match self . bits { false => UCCKPH_A :: UCCKPH_0 , true => UCCKPH_A :: UCCKPH_1 } } # [ doc = "Checks if the value of the field is `UCCKPH_0`" ] # [ inline ( always ) ] pub fn is_ucckph_0 ( & self ) -> bool { * self == UCCKPH_A :: UCCKPH_0 } # [ doc = "Checks if the value of the field is `UCCKPH_1`" ] # [ inline ( always ) ] pub fn is_ucckph_1 ( & self ) -> bool { * self == UCCKPH_A :: UCCKPH_1 } }
# [ doc = "Write proxy for field `UCCKPH`" ] pub struct UCCKPH_W < 'a > { w : & 'a mut W , } impl < 'a > UCCKPH_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCKPH_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Data is changed on the first UCLK edge and captured on the following edge." ] # [ inline ( always ) ] pub fn ucckph_0 ( self ) -> & 'a mut W { self . variant ( UCCKPH_A :: UCCKPH_0 ) } # [ doc = "Data is captured on the first UCLK edge and changed on the following edge." ] # [ inline ( always ) ] pub fn ucckph_1 ( self ) -> & 'a mut W { self . variant ( UCCKPH_A :: UCCKPH_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & self ) -> UCSWRST_R { UCSWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - STE mode select in master mode." ] # [ inline ( always ) ] pub fn ucstem ( & self ) -> UCSTEM_R { UCSTEM_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - eUSCI_A clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & self ) -> UCSSEL_R { UCSSEL_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & self ) -> UCSYNC_R { UCSYNC_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - eUSCI mode" ] # [ inline ( always ) ] pub fn ucmode ( & self ) -> UCMODE_R { UCMODE_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & self ) -> UCMST_R { UCMST_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & self ) -> UC7BIT_R { UC7BIT_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & self ) -> UCMSB_R { UCMSB_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Clock polarity select" ] # [ inline ( always ) ] pub fn ucckpl ( & self ) -> UCCKPL_R { UCCKPL_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Clock phase select" ] # [ inline ( always ) ] pub fn ucckph ( & self ) -> UCCKPH_R { UCCKPH_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & mut self ) -> UCSWRST_W { UCSWRST_W { w : self } }
# [ doc = "Bit 1 - STE mode select in master mode." ] # [ inline ( always ) ] pub fn ucstem ( & mut self ) -> UCSTEM_W { UCSTEM_W { w : self } }
# [ doc = "Bits 6:7 - eUSCI_A clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & mut self ) -> UCSSEL_W { UCSSEL_W { w : self } }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & mut self ) -> UCSYNC_W { UCSYNC_W { w : self } }
# [ doc = "Bits 9:10 - eUSCI mode" ] # [ inline ( always ) ] pub fn ucmode ( & mut self ) -> UCMODE_W { UCMODE_W { w : self } }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & mut self ) -> UCMST_W { UCMST_W { w : self } }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & mut self ) -> UC7BIT_W { UC7BIT_W { w : self } }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & mut self ) -> UCMSB_W { UCMSB_W { w : self } }
# [ doc = "Bit 14 - Clock polarity select" ] # [ inline ( always ) ] pub fn ucckpl ( & mut self ) -> UCCKPL_W { UCCKPL_W { w : self } }
# [ doc = "Bit 15 - Clock phase select" ] # [ inline ( always ) ] pub fn ucckph ( & mut self ) -> UCCKPH_W { UCCKPH_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Control Word Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ctlw1](uca0ctlw1) module" ] pub type UCA0CTLW1 = crate :: Reg < u16 , _UCA0CTLW1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0CTLW1 ;
# [ doc = "`read()` method returns [uca0ctlw1::R](uca0ctlw1::R) reader structure" ] impl crate :: Readable for UCA0CTLW1 { }
# [ doc = "`write(|w| ..)` method takes [uca0ctlw1::W](uca0ctlw1::W) writer structure" ] impl crate :: Writable for UCA0CTLW1 { }
# [ doc = "eUSCI_Ax Control Word Register 1" ] pub mod uca0ctlw1 {
# [ doc = "Reader of register UCA0CTLW1" ] pub type R = crate :: R < u16 , super :: UCA0CTLW1 > ;
# [ doc = "Writer for register UCA0CTLW1" ] pub type W = crate :: W < u16 , super :: UCA0CTLW1 > ;
# [ doc = "Register UCA0CTLW1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0CTLW1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Deglitch time\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCGLIT_A { # [ doc = "0: Approximately 2 ns (equivalent of 1 delay element)" ] UCGLIT_0 = 0 , # [ doc = "1: Approximately 50 ns" ] UCGLIT_1 = 1 , # [ doc = "2: Approximately 100 ns" ] UCGLIT_2 = 2 , # [ doc = "3: Approximately 200 ns" ] UCGLIT_3 = 3 } impl From < UCGLIT_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCGLIT_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCGLIT`" ] pub type UCGLIT_R = crate :: R < u8 , UCGLIT_A > ; impl UCGLIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCGLIT_A { match self . bits { 0 => UCGLIT_A :: UCGLIT_0 , 1 => UCGLIT_A :: UCGLIT_1 , 2 => UCGLIT_A :: UCGLIT_2 , 3 => UCGLIT_A :: UCGLIT_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCGLIT_0`" ] # [ inline ( always ) ] pub fn is_ucglit_0 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_0 } # [ doc = "Checks if the value of the field is `UCGLIT_1`" ] # [ inline ( always ) ] pub fn is_ucglit_1 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_1 } # [ doc = "Checks if the value of the field is `UCGLIT_2`" ] # [ inline ( always ) ] pub fn is_ucglit_2 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_2 } # [ doc = "Checks if the value of the field is `UCGLIT_3`" ] # [ inline ( always ) ] pub fn is_ucglit_3 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_3 } }
# [ doc = "Write proxy for field `UCGLIT`" ] pub struct UCGLIT_W < 'a > { w : & 'a mut W , } impl < 'a > UCGLIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCGLIT_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Approximately 2 ns (equivalent of 1 delay element)" ] # [ inline ( always ) ] pub fn ucglit_0 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_0 ) } # [ doc = "Approximately 50 ns" ] # [ inline ( always ) ] pub fn ucglit_1 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_1 ) } # [ doc = "Approximately 100 ns" ] # [ inline ( always ) ] pub fn ucglit_2 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_2 ) } # [ doc = "Approximately 200 ns" ] # [ inline ( always ) ] pub fn ucglit_3 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Deglitch time" ] # [ inline ( always ) ] pub fn ucglit ( & self ) -> UCGLIT_R { UCGLIT_R :: new ( ( self . bits & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - Deglitch time" ] # [ inline ( always ) ] pub fn ucglit ( & mut self ) -> UCGLIT_W { UCGLIT_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Baud Rate Control Word Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0brw](uca0brw) module" ] pub type UCA0BRW = crate :: Reg < u16 , _UCA0BRW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0BRW ;
# [ doc = "`read()` method returns [uca0brw::R](uca0brw::R) reader structure" ] impl crate :: Readable for UCA0BRW { }
# [ doc = "`write(|w| ..)` method takes [uca0brw::W](uca0brw::W) writer structure" ] impl crate :: Writable for UCA0BRW { }
# [ doc = "eUSCI_Ax Baud Rate Control Word Register" ] pub mod uca0brw {
# [ doc = "Reader of register UCA0BRW" ] pub type R = crate :: R < u16 , super :: UCA0BRW > ;
# [ doc = "Writer for register UCA0BRW" ] pub type W = crate :: W < u16 , super :: UCA0BRW > ;
# [ doc = "Register UCA0BRW `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0BRW { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "eUSCI_Ax Bit Rate Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0brw_spi](uca0brw_spi) module" ] pub type UCA0BRW_SPI = crate :: Reg < u16 , _UCA0BRW_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0BRW_SPI ;
# [ doc = "`read()` method returns [uca0brw_spi::R](uca0brw_spi::R) reader structure" ] impl crate :: Readable for UCA0BRW_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca0brw_spi::W](uca0brw_spi::W) writer structure" ] impl crate :: Writable for UCA0BRW_SPI { }
# [ doc = "eUSCI_Ax Bit Rate Control Register 1" ] pub mod uca0brw_spi {
# [ doc = "Reader of register UCA0BRW_SPI" ] pub type R = crate :: R < u16 , super :: UCA0BRW_SPI > ;
# [ doc = "Writer for register UCA0BRW_SPI" ] pub type W = crate :: W < u16 , super :: UCA0BRW_SPI > ;
# [ doc = "Register UCA0BRW_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0BRW_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "eUSCI_Ax Modulation Control Word Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0mctlw](uca0mctlw) module" ] pub type UCA0MCTLW = crate :: Reg < u16 , _UCA0MCTLW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0MCTLW ;
# [ doc = "`read()` method returns [uca0mctlw::R](uca0mctlw::R) reader structure" ] impl crate :: Readable for UCA0MCTLW { }
# [ doc = "`write(|w| ..)` method takes [uca0mctlw::W](uca0mctlw::W) writer structure" ] impl crate :: Writable for UCA0MCTLW { }
# [ doc = "eUSCI_Ax Modulation Control Word Register" ] pub mod uca0mctlw {
# [ doc = "Reader of register UCA0MCTLW" ] pub type R = crate :: R < u16 , super :: UCA0MCTLW > ;
# [ doc = "Writer for register UCA0MCTLW" ] pub type W = crate :: W < u16 , super :: UCA0MCTLW > ;
# [ doc = "Register UCA0MCTLW `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0MCTLW { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Oversampling mode enabled\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOS16_A { # [ doc = "0: Disabled" ] UCOS16_0 = 0 , # [ doc = "1: Enabled" ] UCOS16_1 = 1 } impl From < UCOS16_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOS16_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOS16`" ] pub type UCOS16_R = crate :: R < bool , UCOS16_A > ; impl UCOS16_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOS16_A { match self . bits { false => UCOS16_A :: UCOS16_0 , true => UCOS16_A :: UCOS16_1 } } # [ doc = "Checks if the value of the field is `UCOS16_0`" ] # [ inline ( always ) ] pub fn is_ucos16_0 ( & self ) -> bool { * self == UCOS16_A :: UCOS16_0 } # [ doc = "Checks if the value of the field is `UCOS16_1`" ] # [ inline ( always ) ] pub fn is_ucos16_1 ( & self ) -> bool { * self == UCOS16_A :: UCOS16_1 } }
# [ doc = "Write proxy for field `UCOS16`" ] pub struct UCOS16_W < 'a > { w : & 'a mut W , } impl < 'a > UCOS16_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOS16_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn ucos16_0 ( self ) -> & 'a mut W { self . variant ( UCOS16_A :: UCOS16_0 ) } # [ doc = "Enabled" ] # [ inline ( always ) ] pub fn ucos16_1 ( self ) -> & 'a mut W { self . variant ( UCOS16_A :: UCOS16_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `UCBRF`" ] pub type UCBRF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCBRF`" ] pub struct UCBRF_W < 'a > { w : & 'a mut W , } impl < 'a > UCBRF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 4 ) ) | ( ( ( value as u16 ) & 0x0f ) << 4 ) ; self . w } }
# [ doc = "Reader of field `UCBRS`" ] pub type UCBRS_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCBRS`" ] pub struct UCBRS_W < 'a > { w : & 'a mut W , } impl < 'a > UCBRS_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 8 ) ) | ( ( ( value as u16 ) & 0xff ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Oversampling mode enabled" ] # [ inline ( always ) ] pub fn ucos16 ( & self ) -> UCOS16_R { UCOS16_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bits 4:7 - First modulation stage select" ] # [ inline ( always ) ] pub fn ucbrf ( & self ) -> UCBRF_R { UCBRF_R :: new ( ( ( self . bits >> 4 ) & 0x0f ) as u8 ) }
# [ doc = "Bits 8:15 - Second modulation stage select" ] # [ inline ( always ) ] pub fn ucbrs ( & self ) -> UCBRS_R { UCBRS_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Oversampling mode enabled" ] # [ inline ( always ) ] pub fn ucos16 ( & mut self ) -> UCOS16_W { UCOS16_W { w : self } }
# [ doc = "Bits 4:7 - First modulation stage select" ] # [ inline ( always ) ] pub fn ucbrf ( & mut self ) -> UCBRF_W { UCBRF_W { w : self } }
# [ doc = "Bits 8:15 - Second modulation stage select" ] # [ inline ( always ) ] pub fn ucbrs ( & mut self ) -> UCBRS_W { UCBRS_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0statw](uca0statw) module" ] pub type UCA0STATW = crate :: Reg < u16 , _UCA0STATW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0STATW ;
# [ doc = "`read()` method returns [uca0statw::R](uca0statw::R) reader structure" ] impl crate :: Readable for UCA0STATW { }
# [ doc = "`write(|w| ..)` method takes [uca0statw::W](uca0statw::W) writer structure" ] impl crate :: Writable for UCA0STATW { }
# [ doc = "eUSCI_Ax Status Register" ] pub mod uca0statw {
# [ doc = "Reader of register UCA0STATW" ] pub type R = crate :: R < u16 , super :: UCA0STATW > ;
# [ doc = "Writer for register UCA0STATW" ] pub type W = crate :: W < u16 , super :: UCA0STATW > ;
# [ doc = "Register UCA0STATW `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0STATW { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "eUSCI_A busy\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBUSY_A { # [ doc = "0: eUSCI_A inactive" ] IDLE = 0 , # [ doc = "1: eUSCI_A transmitting or receiving" ] BUSY = 1 } impl From < UCBUSY_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBUSY_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBUSY`" ] pub type UCBUSY_R = crate :: R < bool , UCBUSY_A > ; impl UCBUSY_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBUSY_A { match self . bits { false => UCBUSY_A :: IDLE , true => UCBUSY_A :: BUSY } } # [ doc = "Checks if the value of the field is `IDLE`" ] # [ inline ( always ) ] pub fn is_idle ( & self ) -> bool { * self == UCBUSY_A :: IDLE } # [ doc = "Checks if the value of the field is `BUSY`" ] # [ inline ( always ) ] pub fn is_busy ( & self ) -> bool { * self == UCBUSY_A :: BUSY } }
# [ doc = "Address received / Idle line detected\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCADDR_UCIDLE_A { # [ doc = "0: UCADDR: Received character is data. UCIDLE: No idle line detected" ] UCADDR_UCIDLE_0 = 0 , # [ doc = "1: UCADDR: Received character is an address. UCIDLE: Idle line detected" ] UCADDR_UCIDLE_1 = 1 } impl From < UCADDR_UCIDLE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCADDR_UCIDLE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCADDR_UCIDLE`" ] pub type UCADDR_UCIDLE_R = crate :: R < bool , UCADDR_UCIDLE_A > ; impl UCADDR_UCIDLE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCADDR_UCIDLE_A { match self . bits { false => UCADDR_UCIDLE_A :: UCADDR_UCIDLE_0 , true => UCADDR_UCIDLE_A :: UCADDR_UCIDLE_1 } } # [ doc = "Checks if the value of the field is `UCADDR_UCIDLE_0`" ] # [ inline ( always ) ] pub fn is_ucaddr_ucidle_0 ( & self ) -> bool { * self == UCADDR_UCIDLE_A :: UCADDR_UCIDLE_0 } # [ doc = "Checks if the value of the field is `UCADDR_UCIDLE_1`" ] # [ inline ( always ) ] pub fn is_ucaddr_ucidle_1 ( & self ) -> bool { * self == UCADDR_UCIDLE_A :: UCADDR_UCIDLE_1 } }
# [ doc = "Write proxy for field `UCADDR_UCIDLE`" ] pub struct UCADDR_UCIDLE_W < 'a > { w : & 'a mut W , } impl < 'a > UCADDR_UCIDLE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCADDR_UCIDLE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "UCADDR: Received character is data. UCIDLE: No idle line detected" ] # [ inline ( always ) ] pub fn ucaddr_ucidle_0 ( self ) -> & 'a mut W { self . variant ( UCADDR_UCIDLE_A :: UCADDR_UCIDLE_0 ) } # [ doc = "UCADDR: Received character is an address. UCIDLE: Idle line detected" ] # [ inline ( always ) ] pub fn ucaddr_ucidle_1 ( self ) -> & 'a mut W { self . variant ( UCADDR_UCIDLE_A :: UCADDR_UCIDLE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Receive error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXERR_A { # [ doc = "0: No receive errors detected" ] UCRXERR_0 = 0 , # [ doc = "1: Receive error detected" ] UCRXERR_1 = 1 } impl From < UCRXERR_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXERR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXERR`" ] pub type UCRXERR_R = crate :: R < bool , UCRXERR_A > ; impl UCRXERR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXERR_A { match self . bits { false => UCRXERR_A :: UCRXERR_0 , true => UCRXERR_A :: UCRXERR_1 } } # [ doc = "Checks if the value of the field is `UCRXERR_0`" ] # [ inline ( always ) ] pub fn is_ucrxerr_0 ( & self ) -> bool { * self == UCRXERR_A :: UCRXERR_0 } # [ doc = "Checks if the value of the field is `UCRXERR_1`" ] # [ inline ( always ) ] pub fn is_ucrxerr_1 ( & self ) -> bool { * self == UCRXERR_A :: UCRXERR_1 } }
# [ doc = "Write proxy for field `UCRXERR`" ] pub struct UCRXERR_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXERR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXERR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No receive errors detected" ] # [ inline ( always ) ] pub fn ucrxerr_0 ( self ) -> & 'a mut W { self . variant ( UCRXERR_A :: UCRXERR_0 ) } # [ doc = "Receive error detected" ] # [ inline ( always ) ] pub fn ucrxerr_1 ( self ) -> & 'a mut W { self . variant ( UCRXERR_A :: UCRXERR_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Break detect flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBRK_A { # [ doc = "0: No break condition" ] UCBRK_0 = 0 , # [ doc = "1: Break condition occurred" ] UCBRK_1 = 1 } impl From < UCBRK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBRK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBRK`" ] pub type UCBRK_R = crate :: R < bool , UCBRK_A > ; impl UCBRK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBRK_A { match self . bits { false => UCBRK_A :: UCBRK_0 , true => UCBRK_A :: UCBRK_1 } } # [ doc = "Checks if the value of the field is `UCBRK_0`" ] # [ inline ( always ) ] pub fn is_ucbrk_0 ( & self ) -> bool { * self == UCBRK_A :: UCBRK_0 } # [ doc = "Checks if the value of the field is `UCBRK_1`" ] # [ inline ( always ) ] pub fn is_ucbrk_1 ( & self ) -> bool { * self == UCBRK_A :: UCBRK_1 } }
# [ doc = "Write proxy for field `UCBRK`" ] pub struct UCBRK_W < 'a > { w : & 'a mut W , } impl < 'a > UCBRK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBRK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No break condition" ] # [ inline ( always ) ] pub fn ucbrk_0 ( self ) -> & 'a mut W { self . variant ( UCBRK_A :: UCBRK_0 ) } # [ doc = "Break condition occurred" ] # [ inline ( always ) ] pub fn ucbrk_1 ( self ) -> & 'a mut W { self . variant ( UCBRK_A :: UCBRK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Parity error flag. When UCPEN = 0, UCPE is read as 0. UCPE is cleared when UCAxRXBUF is read.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCPE_A { # [ doc = "0: No error" ] UCPE_0 = 0 , # [ doc = "1: Character received with parity error" ] UCPE_1 = 1 } impl From < UCPE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCPE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCPE`" ] pub type UCPE_R = crate :: R < bool , UCPE_A > ; impl UCPE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCPE_A { match self . bits { false => UCPE_A :: UCPE_0 , true => UCPE_A :: UCPE_1 } } # [ doc = "Checks if the value of the field is `UCPE_0`" ] # [ inline ( always ) ] pub fn is_ucpe_0 ( & self ) -> bool { * self == UCPE_A :: UCPE_0 } # [ doc = "Checks if the value of the field is `UCPE_1`" ] # [ inline ( always ) ] pub fn is_ucpe_1 ( & self ) -> bool { * self == UCPE_A :: UCPE_1 } }
# [ doc = "Write proxy for field `UCPE`" ] pub struct UCPE_W < 'a > { w : & 'a mut W , } impl < 'a > UCPE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCPE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucpe_0 ( self ) -> & 'a mut W { self . variant ( UCPE_A :: UCPE_0 ) } # [ doc = "Character received with parity error" ] # [ inline ( always ) ] pub fn ucpe_1 ( self ) -> & 'a mut W { self . variant ( UCPE_A :: UCPE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Overrun error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOE_A { # [ doc = "0: No error" ] UCOE_0 = 0 , # [ doc = "1: Overrun error occurred" ] UCOE_1 = 1 } impl From < UCOE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOE`" ] pub type UCOE_R = crate :: R < bool , UCOE_A > ; impl UCOE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOE_A { match self . bits { false => UCOE_A :: UCOE_0 , true => UCOE_A :: UCOE_1 } } # [ doc = "Checks if the value of the field is `UCOE_0`" ] # [ inline ( always ) ] pub fn is_ucoe_0 ( & self ) -> bool { * self == UCOE_A :: UCOE_0 } # [ doc = "Checks if the value of the field is `UCOE_1`" ] # [ inline ( always ) ] pub fn is_ucoe_1 ( & self ) -> bool { * self == UCOE_A :: UCOE_1 } }
# [ doc = "Write proxy for field `UCOE`" ] pub struct UCOE_W < 'a > { w : & 'a mut W , } impl < 'a > UCOE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucoe_0 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_0 ) } # [ doc = "Overrun error occurred" ] # [ inline ( always ) ] pub fn ucoe_1 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Framing error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCFE_A { # [ doc = "0: No error" ] UCFE_0 = 0 , # [ doc = "1: Character received with low stop bit" ] UCFE_1 = 1 } impl From < UCFE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCFE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCFE`" ] pub type UCFE_R = crate :: R < bool , UCFE_A > ; impl UCFE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCFE_A { match self . bits { false => UCFE_A :: UCFE_0 , true => UCFE_A :: UCFE_1 } } # [ doc = "Checks if the value of the field is `UCFE_0`" ] # [ inline ( always ) ] pub fn is_ucfe_0 ( & self ) -> bool { * self == UCFE_A :: UCFE_0 } # [ doc = "Checks if the value of the field is `UCFE_1`" ] # [ inline ( always ) ] pub fn is_ucfe_1 ( & self ) -> bool { * self == UCFE_A :: UCFE_1 } }
# [ doc = "Write proxy for field `UCFE`" ] pub struct UCFE_W < 'a > { w : & 'a mut W , } impl < 'a > UCFE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCFE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucfe_0 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_0 ) } # [ doc = "Character received with low stop bit" ] # [ inline ( always ) ] pub fn ucfe_1 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Listen enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCLISTEN_A { # [ doc = "0: Disabled" ] UCLISTEN_0 = 0 , # [ doc = "1: Enabled. UCAxTXD is internally fed back to the receiver" ] UCLISTEN_1 = 1 } impl From < UCLISTEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCLISTEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCLISTEN`" ] pub type UCLISTEN_R = crate :: R < bool , UCLISTEN_A > ; impl UCLISTEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCLISTEN_A { match self . bits { false => UCLISTEN_A :: UCLISTEN_0 , true => UCLISTEN_A :: UCLISTEN_1 } } # [ doc = "Checks if the value of the field is `UCLISTEN_0`" ] # [ inline ( always ) ] pub fn is_uclisten_0 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_0 } # [ doc = "Checks if the value of the field is `UCLISTEN_1`" ] # [ inline ( always ) ] pub fn is_uclisten_1 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_1 } }
# [ doc = "Write proxy for field `UCLISTEN`" ] pub struct UCLISTEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCLISTEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCLISTEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn uclisten_0 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_0 ) } # [ doc = "Enabled. UCAxTXD is internally fed back to the receiver" ] # [ inline ( always ) ] pub fn uclisten_1 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - eUSCI_A busy" ] # [ inline ( always ) ] pub fn ucbusy ( & self ) -> UCBUSY_R { UCBUSY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Address received / Idle line detected" ] # [ inline ( always ) ] pub fn ucaddr_ucidle ( & self ) -> UCADDR_UCIDLE_R { UCADDR_UCIDLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Receive error flag" ] # [ inline ( always ) ] pub fn ucrxerr ( & self ) -> UCRXERR_R { UCRXERR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Break detect flag" ] # [ inline ( always ) ] pub fn ucbrk ( & self ) -> UCBRK_R { UCBRK_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Parity error flag. When UCPEN = 0, UCPE is read as 0. UCPE is cleared when UCAxRXBUF is read." ] # [ inline ( always ) ] pub fn ucpe ( & self ) -> UCPE_R { UCPE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & self ) -> UCOE_R { UCOE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & self ) -> UCFE_R { UCFE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & self ) -> UCLISTEN_R { UCLISTEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 1 - Address received / Idle line detected" ] # [ inline ( always ) ] pub fn ucaddr_ucidle ( & mut self ) -> UCADDR_UCIDLE_W { UCADDR_UCIDLE_W { w : self } }
# [ doc = "Bit 2 - Receive error flag" ] # [ inline ( always ) ] pub fn ucrxerr ( & mut self ) -> UCRXERR_W { UCRXERR_W { w : self } }
# [ doc = "Bit 3 - Break detect flag" ] # [ inline ( always ) ] pub fn ucbrk ( & mut self ) -> UCBRK_W { UCBRK_W { w : self } }
# [ doc = "Bit 4 - Parity error flag. When UCPEN = 0, UCPE is read as 0. UCPE is cleared when UCAxRXBUF is read." ] # [ inline ( always ) ] pub fn ucpe ( & mut self ) -> UCPE_W { UCPE_W { w : self } }
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & mut self ) -> UCOE_W { UCOE_W { w : self } }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & mut self ) -> UCFE_W { UCFE_W { w : self } }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & mut self ) -> UCLISTEN_W { UCLISTEN_W { w : self } }
}
}
# [ doc = "UCA0STATW_SPI\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0statw_spi](uca0statw_spi) module" ] pub type UCA0STATW_SPI = crate :: Reg < u16 , _UCA0STATW_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0STATW_SPI ;
# [ doc = "`read()` method returns [uca0statw_spi::R](uca0statw_spi::R) reader structure" ] impl crate :: Readable for UCA0STATW_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca0statw_spi::W](uca0statw_spi::W) writer structure" ] impl crate :: Writable for UCA0STATW_SPI { }
# [ doc = "UCA0STATW_SPI" ] pub mod uca0statw_spi {
# [ doc = "Reader of register UCA0STATW_SPI" ] pub type R = crate :: R < u16 , super :: UCA0STATW_SPI > ;
# [ doc = "Writer for register UCA0STATW_SPI" ] pub type W = crate :: W < u16 , super :: UCA0STATW_SPI > ;
# [ doc = "Register UCA0STATW_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0STATW_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Overrun error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOE_A { # [ doc = "0: No error" ] UCOE_0 = 0 , # [ doc = "1: Overrun error occurred" ] UCOE_1 = 1 } impl From < UCOE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOE`" ] pub type UCOE_R = crate :: R < bool , UCOE_A > ; impl UCOE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOE_A { match self . bits { false => UCOE_A :: UCOE_0 , true => UCOE_A :: UCOE_1 } } # [ doc = "Checks if the value of the field is `UCOE_0`" ] # [ inline ( always ) ] pub fn is_ucoe_0 ( & self ) -> bool { * self == UCOE_A :: UCOE_0 } # [ doc = "Checks if the value of the field is `UCOE_1`" ] # [ inline ( always ) ] pub fn is_ucoe_1 ( & self ) -> bool { * self == UCOE_A :: UCOE_1 } }
# [ doc = "Write proxy for field `UCOE`" ] pub struct UCOE_W < 'a > { w : & 'a mut W , } impl < 'a > UCOE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucoe_0 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_0 ) } # [ doc = "Overrun error occurred" ] # [ inline ( always ) ] pub fn ucoe_1 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Framing error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCFE_A { # [ doc = "0: No error" ] UCFE_0 = 0 , # [ doc = "1: Bus conflict occurred" ] UCFE_1 = 1 } impl From < UCFE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCFE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCFE`" ] pub type UCFE_R = crate :: R < bool , UCFE_A > ; impl UCFE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCFE_A { match self . bits { false => UCFE_A :: UCFE_0 , true => UCFE_A :: UCFE_1 } } # [ doc = "Checks if the value of the field is `UCFE_0`" ] # [ inline ( always ) ] pub fn is_ucfe_0 ( & self ) -> bool { * self == UCFE_A :: UCFE_0 } # [ doc = "Checks if the value of the field is `UCFE_1`" ] # [ inline ( always ) ] pub fn is_ucfe_1 ( & self ) -> bool { * self == UCFE_A :: UCFE_1 } }
# [ doc = "Write proxy for field `UCFE`" ] pub struct UCFE_W < 'a > { w : & 'a mut W , } impl < 'a > UCFE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCFE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucfe_0 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_0 ) } # [ doc = "Bus conflict occurred" ] # [ inline ( always ) ] pub fn ucfe_1 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Listen enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCLISTEN_A { # [ doc = "0: Disabled" ] UCLISTEN_0 = 0 , # [ doc = "1: Enabled. UCAxTXD is internally fed back to the receiver" ] UCLISTEN_1 = 1 } impl From < UCLISTEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCLISTEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCLISTEN`" ] pub type UCLISTEN_R = crate :: R < bool , UCLISTEN_A > ; impl UCLISTEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCLISTEN_A { match self . bits { false => UCLISTEN_A :: UCLISTEN_0 , true => UCLISTEN_A :: UCLISTEN_1 } } # [ doc = "Checks if the value of the field is `UCLISTEN_0`" ] # [ inline ( always ) ] pub fn is_uclisten_0 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_0 } # [ doc = "Checks if the value of the field is `UCLISTEN_1`" ] # [ inline ( always ) ] pub fn is_uclisten_1 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_1 } }
# [ doc = "Write proxy for field `UCLISTEN`" ] pub struct UCLISTEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCLISTEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCLISTEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn uclisten_0 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_0 ) } # [ doc = "Enabled. UCAxTXD is internally fed back to the receiver" ] # [ inline ( always ) ] pub fn uclisten_1 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & self ) -> UCOE_R { UCOE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & self ) -> UCFE_R { UCFE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & self ) -> UCLISTEN_R { UCLISTEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & mut self ) -> UCOE_W { UCOE_W { w : self } }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & mut self ) -> UCFE_W { UCFE_W { w : self } }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & mut self ) -> UCLISTEN_W { UCLISTEN_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Receive Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0rxbuf](uca0rxbuf) module" ] pub type UCA0RXBUF = crate :: Reg < u16 , _UCA0RXBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0RXBUF ;
# [ doc = "`read()` method returns [uca0rxbuf::R](uca0rxbuf::R) reader structure" ] impl crate :: Readable for UCA0RXBUF { }
# [ doc = "eUSCI_Ax Receive Buffer Register" ] pub mod uca0rxbuf {
# [ doc = "Reader of register UCA0RXBUF" ] pub type R = crate :: R < u16 , super :: UCA0RXBUF > ;
# [ doc = "Reader of field `UCRXBUF`" ] pub type UCRXBUF_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Receive data buffer" ] # [ inline ( always ) ] pub fn ucrxbuf ( & self ) -> UCRXBUF_R { UCRXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
}
# [ doc = "eUSCI_Ax Receive Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0rxbuf_spi](uca0rxbuf_spi) module" ] pub type UCA0RXBUF_SPI = crate :: Reg < u16 , _UCA0RXBUF_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0RXBUF_SPI ;
# [ doc = "`read()` method returns [uca0rxbuf_spi::R](uca0rxbuf_spi::R) reader structure" ] impl crate :: Readable for UCA0RXBUF_SPI { }
# [ doc = "eUSCI_Ax Receive Buffer Register" ] pub mod uca0rxbuf_spi {
# [ doc = "Reader of register UCA0RXBUF_SPI" ] pub type R = crate :: R < u16 , super :: UCA0RXBUF_SPI > ;
# [ doc = "Reader of field `UCRXBUF`" ] pub type UCRXBUF_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Receive data buffer" ] # [ inline ( always ) ] pub fn ucrxbuf ( & self ) -> UCRXBUF_R { UCRXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
}
# [ doc = "eUSCI_Ax Transmit Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0txbuf](uca0txbuf) module" ] pub type UCA0TXBUF = crate :: Reg < u16 , _UCA0TXBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0TXBUF ;
# [ doc = "`read()` method returns [uca0txbuf::R](uca0txbuf::R) reader structure" ] impl crate :: Readable for UCA0TXBUF { }
# [ doc = "`write(|w| ..)` method takes [uca0txbuf::W](uca0txbuf::W) writer structure" ] impl crate :: Writable for UCA0TXBUF { }
# [ doc = "eUSCI_Ax Transmit Buffer Register" ] pub mod uca0txbuf {
# [ doc = "Reader of register UCA0TXBUF" ] pub type R = crate :: R < u16 , super :: UCA0TXBUF > ;
# [ doc = "Writer for register UCA0TXBUF" ] pub type W = crate :: W < u16 , super :: UCA0TXBUF > ;
# [ doc = "Register UCA0TXBUF `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0TXBUF { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UCTXBUF`" ] pub type UCTXBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCTXBUF`" ] pub struct UCTXBUF_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & self ) -> UCTXBUF_R { UCTXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & mut self ) -> UCTXBUF_W { UCTXBUF_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Transmit Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0txbuf_spi](uca0txbuf_spi) module" ] pub type UCA0TXBUF_SPI = crate :: Reg < u16 , _UCA0TXBUF_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0TXBUF_SPI ;
# [ doc = "`read()` method returns [uca0txbuf_spi::R](uca0txbuf_spi::R) reader structure" ] impl crate :: Readable for UCA0TXBUF_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca0txbuf_spi::W](uca0txbuf_spi::W) writer structure" ] impl crate :: Writable for UCA0TXBUF_SPI { }
# [ doc = "eUSCI_Ax Transmit Buffer Register" ] pub mod uca0txbuf_spi {
# [ doc = "Reader of register UCA0TXBUF_SPI" ] pub type R = crate :: R < u16 , super :: UCA0TXBUF_SPI > ;
# [ doc = "Writer for register UCA0TXBUF_SPI" ] pub type W = crate :: W < u16 , super :: UCA0TXBUF_SPI > ;
# [ doc = "Register UCA0TXBUF_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0TXBUF_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UCTXBUF`" ] pub type UCTXBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCTXBUF`" ] pub struct UCTXBUF_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & self ) -> UCTXBUF_R { UCTXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & mut self ) -> UCTXBUF_W { UCTXBUF_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Auto Baud Rate Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0abctl](uca0abctl) module" ] pub type UCA0ABCTL = crate :: Reg < u16 , _UCA0ABCTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0ABCTL ;
# [ doc = "`read()` method returns [uca0abctl::R](uca0abctl::R) reader structure" ] impl crate :: Readable for UCA0ABCTL { }
# [ doc = "`write(|w| ..)` method takes [uca0abctl::W](uca0abctl::W) writer structure" ] impl crate :: Writable for UCA0ABCTL { }
# [ doc = "eUSCI_Ax Auto Baud Rate Control Register" ] pub mod uca0abctl {
# [ doc = "Reader of register UCA0ABCTL" ] pub type R = crate :: R < u16 , super :: UCA0ABCTL > ;
# [ doc = "Writer for register UCA0ABCTL" ] pub type W = crate :: W < u16 , super :: UCA0ABCTL > ;
# [ doc = "Register UCA0ABCTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0ABCTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Automatic baud-rate detect enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCABDEN_A { # [ doc = "0: Baud-rate detection disabled. Length of break and synch field is not measured." ] UCABDEN_0 = 0 , # [ doc = "1: Baud-rate detection enabled. Length of break and synch field is measured and baud-rate settings are changed accordingly." ] UCABDEN_1 = 1 } impl From < UCABDEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCABDEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCABDEN`" ] pub type UCABDEN_R = crate :: R < bool , UCABDEN_A > ; impl UCABDEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCABDEN_A { match self . bits { false => UCABDEN_A :: UCABDEN_0 , true => UCABDEN_A :: UCABDEN_1 } } # [ doc = "Checks if the value of the field is `UCABDEN_0`" ] # [ inline ( always ) ] pub fn is_ucabden_0 ( & self ) -> bool { * self == UCABDEN_A :: UCABDEN_0 } # [ doc = "Checks if the value of the field is `UCABDEN_1`" ] # [ inline ( always ) ] pub fn is_ucabden_1 ( & self ) -> bool { * self == UCABDEN_A :: UCABDEN_1 } }
# [ doc = "Write proxy for field `UCABDEN`" ] pub struct UCABDEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCABDEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCABDEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Baud-rate detection disabled. Length of break and synch field is not measured." ] # [ inline ( always ) ] pub fn ucabden_0 ( self ) -> & 'a mut W { self . variant ( UCABDEN_A :: UCABDEN_0 ) } # [ doc = "Baud-rate detection enabled. Length of break and synch field is measured and baud-rate settings are changed accordingly." ] # [ inline ( always ) ] pub fn ucabden_1 ( self ) -> & 'a mut W { self . variant ( UCABDEN_A :: UCABDEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Break time out error\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBTOE_A { # [ doc = "0: No error" ] UCBTOE_0 = 0 , # [ doc = "1: Length of break field exceeded 22 bit times" ] UCBTOE_1 = 1 } impl From < UCBTOE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBTOE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBTOE`" ] pub type UCBTOE_R = crate :: R < bool , UCBTOE_A > ; impl UCBTOE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBTOE_A { match self . bits { false => UCBTOE_A :: UCBTOE_0 , true => UCBTOE_A :: UCBTOE_1 } } # [ doc = "Checks if the value of the field is `UCBTOE_0`" ] # [ inline ( always ) ] pub fn is_ucbtoe_0 ( & self ) -> bool { * self == UCBTOE_A :: UCBTOE_0 } # [ doc = "Checks if the value of the field is `UCBTOE_1`" ] # [ inline ( always ) ] pub fn is_ucbtoe_1 ( & self ) -> bool { * self == UCBTOE_A :: UCBTOE_1 } }
# [ doc = "Write proxy for field `UCBTOE`" ] pub struct UCBTOE_W < 'a > { w : & 'a mut W , } impl < 'a > UCBTOE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBTOE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucbtoe_0 ( self ) -> & 'a mut W { self . variant ( UCBTOE_A :: UCBTOE_0 ) } # [ doc = "Length of break field exceeded 22 bit times" ] # [ inline ( always ) ] pub fn ucbtoe_1 ( self ) -> & 'a mut W { self . variant ( UCBTOE_A :: UCBTOE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Synch field time out error\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTOE_A { # [ doc = "0: No error" ] UCSTOE_0 = 0 , # [ doc = "1: Length of synch field exceeded measurable time" ] UCSTOE_1 = 1 } impl From < UCSTOE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTOE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTOE`" ] pub type UCSTOE_R = crate :: R < bool , UCSTOE_A > ; impl UCSTOE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTOE_A { match self . bits { false => UCSTOE_A :: UCSTOE_0 , true => UCSTOE_A :: UCSTOE_1 } } # [ doc = "Checks if the value of the field is `UCSTOE_0`" ] # [ inline ( always ) ] pub fn is_ucstoe_0 ( & self ) -> bool { * self == UCSTOE_A :: UCSTOE_0 } # [ doc = "Checks if the value of the field is `UCSTOE_1`" ] # [ inline ( always ) ] pub fn is_ucstoe_1 ( & self ) -> bool { * self == UCSTOE_A :: UCSTOE_1 } }
# [ doc = "Write proxy for field `UCSTOE`" ] pub struct UCSTOE_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTOE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTOE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucstoe_0 ( self ) -> & 'a mut W { self . variant ( UCSTOE_A :: UCSTOE_0 ) } # [ doc = "Length of synch field exceeded measurable time" ] # [ inline ( always ) ] pub fn ucstoe_1 ( self ) -> & 'a mut W { self . variant ( UCSTOE_A :: UCSTOE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Break/synch delimiter length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCDELIM_A { # [ doc = "0: 1 bit time" ] UCDELIM_0 = 0 , # [ doc = "1: 2 bit times" ] UCDELIM_1 = 1 , # [ doc = "2: 3 bit times" ] UCDELIM_2 = 2 , # [ doc = "3: 4 bit times" ] UCDELIM_3 = 3 } impl From < UCDELIM_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCDELIM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCDELIM`" ] pub type UCDELIM_R = crate :: R < u8 , UCDELIM_A > ; impl UCDELIM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCDELIM_A { match self . bits { 0 => UCDELIM_A :: UCDELIM_0 , 1 => UCDELIM_A :: UCDELIM_1 , 2 => UCDELIM_A :: UCDELIM_2 , 3 => UCDELIM_A :: UCDELIM_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCDELIM_0`" ] # [ inline ( always ) ] pub fn is_ucdelim_0 ( & self ) -> bool { * self == UCDELIM_A :: UCDELIM_0 } # [ doc = "Checks if the value of the field is `UCDELIM_1`" ] # [ inline ( always ) ] pub fn is_ucdelim_1 ( & self ) -> bool { * self == UCDELIM_A :: UCDELIM_1 } # [ doc = "Checks if the value of the field is `UCDELIM_2`" ] # [ inline ( always ) ] pub fn is_ucdelim_2 ( & self ) -> bool { * self == UCDELIM_A :: UCDELIM_2 } # [ doc = "Checks if the value of the field is `UCDELIM_3`" ] # [ inline ( always ) ] pub fn is_ucdelim_3 ( & self ) -> bool { * self == UCDELIM_A :: UCDELIM_3 } }
# [ doc = "Write proxy for field `UCDELIM`" ] pub struct UCDELIM_W < 'a > { w : & 'a mut W , } impl < 'a > UCDELIM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCDELIM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "1 bit time" ] # [ inline ( always ) ] pub fn ucdelim_0 ( self ) -> & 'a mut W { self . variant ( UCDELIM_A :: UCDELIM_0 ) } # [ doc = "2 bit times" ] # [ inline ( always ) ] pub fn ucdelim_1 ( self ) -> & 'a mut W { self . variant ( UCDELIM_A :: UCDELIM_1 ) } # [ doc = "3 bit times" ] # [ inline ( always ) ] pub fn ucdelim_2 ( self ) -> & 'a mut W { self . variant ( UCDELIM_A :: UCDELIM_2 ) } # [ doc = "4 bit times" ] # [ inline ( always ) ] pub fn ucdelim_3 ( self ) -> & 'a mut W { self . variant ( UCDELIM_A :: UCDELIM_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Automatic baud-rate detect enable" ] # [ inline ( always ) ] pub fn ucabden ( & self ) -> UCABDEN_R { UCABDEN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Break time out error" ] # [ inline ( always ) ] pub fn ucbtoe ( & self ) -> UCBTOE_R { UCBTOE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Synch field time out error" ] # [ inline ( always ) ] pub fn ucstoe ( & self ) -> UCSTOE_R { UCSTOE_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - Break/synch delimiter length" ] # [ inline ( always ) ] pub fn ucdelim ( & self ) -> UCDELIM_R { UCDELIM_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Automatic baud-rate detect enable" ] # [ inline ( always ) ] pub fn ucabden ( & mut self ) -> UCABDEN_W { UCABDEN_W { w : self } }
# [ doc = "Bit 2 - Break time out error" ] # [ inline ( always ) ] pub fn ucbtoe ( & mut self ) -> UCBTOE_W { UCBTOE_W { w : self } }
# [ doc = "Bit 3 - Synch field time out error" ] # [ inline ( always ) ] pub fn ucstoe ( & mut self ) -> UCSTOE_W { UCSTOE_W { w : self } }
# [ doc = "Bits 4:5 - Break/synch delimiter length" ] # [ inline ( always ) ] pub fn ucdelim ( & mut self ) -> UCDELIM_W { UCDELIM_W { w : self } }
}
}
# [ doc = "eUSCI_Ax IrDA Control Word Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0irctl](uca0irctl) module" ] pub type UCA0IRCTL = crate :: Reg < u16 , _UCA0IRCTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0IRCTL ;
# [ doc = "`read()` method returns [uca0irctl::R](uca0irctl::R) reader structure" ] impl crate :: Readable for UCA0IRCTL { }
# [ doc = "`write(|w| ..)` method takes [uca0irctl::W](uca0irctl::W) writer structure" ] impl crate :: Writable for UCA0IRCTL { }
# [ doc = "eUSCI_Ax IrDA Control Word Register" ] pub mod uca0irctl {
# [ doc = "Reader of register UCA0IRCTL" ] pub type R = crate :: R < u16 , super :: UCA0IRCTL > ;
# [ doc = "Writer for register UCA0IRCTL" ] pub type W = crate :: W < u16 , super :: UCA0IRCTL > ;
# [ doc = "Register UCA0IRCTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0IRCTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "IrDA encoder/decoder enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCIREN_A { # [ doc = "0: IrDA encoder/decoder disabled" ] UCIREN_0 = 0 , # [ doc = "1: IrDA encoder/decoder enabled" ] UCIREN_1 = 1 } impl From < UCIREN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCIREN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCIREN`" ] pub type UCIREN_R = crate :: R < bool , UCIREN_A > ; impl UCIREN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCIREN_A { match self . bits { false => UCIREN_A :: UCIREN_0 , true => UCIREN_A :: UCIREN_1 } } # [ doc = "Checks if the value of the field is `UCIREN_0`" ] # [ inline ( always ) ] pub fn is_uciren_0 ( & self ) -> bool { * self == UCIREN_A :: UCIREN_0 } # [ doc = "Checks if the value of the field is `UCIREN_1`" ] # [ inline ( always ) ] pub fn is_uciren_1 ( & self ) -> bool { * self == UCIREN_A :: UCIREN_1 } }
# [ doc = "Write proxy for field `UCIREN`" ] pub struct UCIREN_W < 'a > { w : & 'a mut W , } impl < 'a > UCIREN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCIREN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "IrDA encoder/decoder disabled" ] # [ inline ( always ) ] pub fn uciren_0 ( self ) -> & 'a mut W { self . variant ( UCIREN_A :: UCIREN_0 ) } # [ doc = "IrDA encoder/decoder enabled" ] # [ inline ( always ) ] pub fn uciren_1 ( self ) -> & 'a mut W { self . variant ( UCIREN_A :: UCIREN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "IrDA transmit pulse clock select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCIRTXCLK_A { # [ doc = "0: BRCLK" ] UCIRTXCLK_0 = 0 , # [ doc = "1: BITCLK16 when UCOS16 = 1. Otherwise, BRCLK." ] UCIRTXCLK_1 = 1 } impl From < UCIRTXCLK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCIRTXCLK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCIRTXCLK`" ] pub type UCIRTXCLK_R = crate :: R < bool , UCIRTXCLK_A > ; impl UCIRTXCLK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCIRTXCLK_A { match self . bits { false => UCIRTXCLK_A :: UCIRTXCLK_0 , true => UCIRTXCLK_A :: UCIRTXCLK_1 } } # [ doc = "Checks if the value of the field is `UCIRTXCLK_0`" ] # [ inline ( always ) ] pub fn is_ucirtxclk_0 ( & self ) -> bool { * self == UCIRTXCLK_A :: UCIRTXCLK_0 } # [ doc = "Checks if the value of the field is `UCIRTXCLK_1`" ] # [ inline ( always ) ] pub fn is_ucirtxclk_1 ( & self ) -> bool { * self == UCIRTXCLK_A :: UCIRTXCLK_1 } }
# [ doc = "Write proxy for field `UCIRTXCLK`" ] pub struct UCIRTXCLK_W < 'a > { w : & 'a mut W , } impl < 'a > UCIRTXCLK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCIRTXCLK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "BRCLK" ] # [ inline ( always ) ] pub fn ucirtxclk_0 ( self ) -> & 'a mut W { self . variant ( UCIRTXCLK_A :: UCIRTXCLK_0 ) } # [ doc = "BITCLK16 when UCOS16 = 1. Otherwise, BRCLK." ] # [ inline ( always ) ] pub fn ucirtxclk_1 ( self ) -> & 'a mut W { self . variant ( UCIRTXCLK_A :: UCIRTXCLK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `UCIRTXPL`" ] pub type UCIRTXPL_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCIRTXPL`" ] pub struct UCIRTXPL_W < 'a > { w : & 'a mut W , } impl < 'a > UCIRTXPL_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 2 ) ) | ( ( ( value as u16 ) & 0x3f ) << 2 ) ; self . w } }
# [ doc = "IrDA receive filter enabled\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCIRRXFE_A { # [ doc = "0: Receive filter disabled" ] UCIRRXFE_0 = 0 , # [ doc = "1: Receive filter enabled" ] UCIRRXFE_1 = 1 } impl From < UCIRRXFE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCIRRXFE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCIRRXFE`" ] pub type UCIRRXFE_R = crate :: R < bool , UCIRRXFE_A > ; impl UCIRRXFE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCIRRXFE_A { match self . bits { false => UCIRRXFE_A :: UCIRRXFE_0 , true => UCIRRXFE_A :: UCIRRXFE_1 } } # [ doc = "Checks if the value of the field is `UCIRRXFE_0`" ] # [ inline ( always ) ] pub fn is_ucirrxfe_0 ( & self ) -> bool { * self == UCIRRXFE_A :: UCIRRXFE_0 } # [ doc = "Checks if the value of the field is `UCIRRXFE_1`" ] # [ inline ( always ) ] pub fn is_ucirrxfe_1 ( & self ) -> bool { * self == UCIRRXFE_A :: UCIRRXFE_1 } }
# [ doc = "Write proxy for field `UCIRRXFE`" ] pub struct UCIRRXFE_W < 'a > { w : & 'a mut W , } impl < 'a > UCIRRXFE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCIRRXFE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Receive filter disabled" ] # [ inline ( always ) ] pub fn ucirrxfe_0 ( self ) -> & 'a mut W { self . variant ( UCIRRXFE_A :: UCIRRXFE_0 ) } # [ doc = "Receive filter enabled" ] # [ inline ( always ) ] pub fn ucirrxfe_1 ( self ) -> & 'a mut W { self . variant ( UCIRRXFE_A :: UCIRRXFE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "IrDA receive input UCAxRXD polarity\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCIRRXPL_A { # [ doc = "0: IrDA transceiver delivers a high pulse when a light pulse is seen" ] HIGH = 0 , # [ doc = "1: IrDA transceiver delivers a low pulse when a light pulse is seen" ] LOW = 1 } impl From < UCIRRXPL_A > for bool { # [ inline ( always ) ] fn from ( variant : UCIRRXPL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCIRRXPL`" ] pub type UCIRRXPL_R = crate :: R < bool , UCIRRXPL_A > ; impl UCIRRXPL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCIRRXPL_A { match self . bits { false => UCIRRXPL_A :: HIGH , true => UCIRRXPL_A :: LOW } } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == UCIRRXPL_A :: HIGH } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == UCIRRXPL_A :: LOW } }
# [ doc = "Write proxy for field `UCIRRXPL`" ] pub struct UCIRRXPL_W < 'a > { w : & 'a mut W , } impl < 'a > UCIRRXPL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCIRRXPL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "IrDA transceiver delivers a high pulse when a light pulse is seen" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( UCIRRXPL_A :: HIGH ) } # [ doc = "IrDA transceiver delivers a low pulse when a light pulse is seen" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( UCIRRXPL_A :: LOW ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `UCIRRXFL`" ] pub type UCIRRXFL_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCIRRXFL`" ] pub struct UCIRRXFL_W < 'a > { w : & 'a mut W , } impl < 'a > UCIRRXFL_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 10 ) ) | ( ( ( value as u16 ) & 0x3f ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - IrDA encoder/decoder enable" ] # [ inline ( always ) ] pub fn uciren ( & self ) -> UCIREN_R { UCIREN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - IrDA transmit pulse clock select" ] # [ inline ( always ) ] pub fn ucirtxclk ( & self ) -> UCIRTXCLK_R { UCIRTXCLK_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 2:7 - Transmit pulse length" ] # [ inline ( always ) ] pub fn ucirtxpl ( & self ) -> UCIRTXPL_R { UCIRTXPL_R :: new ( ( ( self . bits >> 2 ) & 0x3f ) as u8 ) }
# [ doc = "Bit 8 - IrDA receive filter enabled" ] # [ inline ( always ) ] pub fn ucirrxfe ( & self ) -> UCIRRXFE_R { UCIRRXFE_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - IrDA receive input UCAxRXD polarity" ] # [ inline ( always ) ] pub fn ucirrxpl ( & self ) -> UCIRRXPL_R { UCIRRXPL_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 10:15 - Receive filter length" ] # [ inline ( always ) ] pub fn ucirrxfl ( & self ) -> UCIRRXFL_R { UCIRRXFL_R :: new ( ( ( self . bits >> 10 ) & 0x3f ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - IrDA encoder/decoder enable" ] # [ inline ( always ) ] pub fn uciren ( & mut self ) -> UCIREN_W { UCIREN_W { w : self } }
# [ doc = "Bit 1 - IrDA transmit pulse clock select" ] # [ inline ( always ) ] pub fn ucirtxclk ( & mut self ) -> UCIRTXCLK_W { UCIRTXCLK_W { w : self } }
# [ doc = "Bits 2:7 - Transmit pulse length" ] # [ inline ( always ) ] pub fn ucirtxpl ( & mut self ) -> UCIRTXPL_W { UCIRTXPL_W { w : self } }
# [ doc = "Bit 8 - IrDA receive filter enabled" ] # [ inline ( always ) ] pub fn ucirrxfe ( & mut self ) -> UCIRRXFE_W { UCIRRXFE_W { w : self } }
# [ doc = "Bit 9 - IrDA receive input UCAxRXD polarity" ] # [ inline ( always ) ] pub fn ucirrxpl ( & mut self ) -> UCIRRXPL_W { UCIRRXPL_W { w : self } }
# [ doc = "Bits 10:15 - Receive filter length" ] # [ inline ( always ) ] pub fn ucirrxfl ( & mut self ) -> UCIRRXFL_W { UCIRRXFL_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ie](uca0ie) module" ] pub type UCA0IE = crate :: Reg < u16 , _UCA0IE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0IE ;
# [ doc = "`read()` method returns [uca0ie::R](uca0ie::R) reader structure" ] impl crate :: Readable for UCA0IE { }
# [ doc = "`write(|w| ..)` method takes [uca0ie::W](uca0ie::W) writer structure" ] impl crate :: Writable for UCA0IE { }
# [ doc = "eUSCI_Ax Interrupt Enable Register" ] pub mod uca0ie {
# [ doc = "Reader of register UCA0IE" ] pub type R = crate :: R < u16 , super :: UCA0IE > ;
# [ doc = "Writer for register UCA0IE" ] pub type W = crate :: W < u16 , super :: UCA0IE > ;
# [ doc = "Register UCA0IE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0IE { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE_A { # [ doc = "0: Interrupt disabled" ] UCRXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE_1 = 1 } impl From < UCRXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE`" ] pub type UCRXIE_R = crate :: R < bool , UCRXIE_A > ; impl UCRXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE_A { match self . bits { false => UCRXIE_A :: UCRXIE_0 , true => UCRXIE_A :: UCRXIE_1 } } # [ doc = "Checks if the value of the field is `UCRXIE_0`" ] # [ inline ( always ) ] pub fn is_ucrxie_0 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_0 } # [ doc = "Checks if the value of the field is `UCRXIE_1`" ] # [ inline ( always ) ] pub fn is_ucrxie_1 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_1 } }
# [ doc = "Write proxy for field `UCRXIE`" ] pub struct UCRXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE_A { # [ doc = "0: Interrupt disabled" ] UCTXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE_1 = 1 } impl From < UCTXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE`" ] pub type UCTXIE_R = crate :: R < bool , UCTXIE_A > ; impl UCTXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE_A { match self . bits { false => UCTXIE_A :: UCTXIE_0 , true => UCTXIE_A :: UCTXIE_1 } } # [ doc = "Checks if the value of the field is `UCTXIE_0`" ] # [ inline ( always ) ] pub fn is_uctxie_0 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_0 } # [ doc = "Checks if the value of the field is `UCTXIE_1`" ] # [ inline ( always ) ] pub fn is_uctxie_1 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_1 } }
# [ doc = "Write proxy for field `UCTXIE`" ] pub struct UCTXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Start bit interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTTIE_A { # [ doc = "0: Interrupt disabled" ] UCSTTIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCSTTIE_1 = 1 } impl From < UCSTTIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTTIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTTIE`" ] pub type UCSTTIE_R = crate :: R < bool , UCSTTIE_A > ; impl UCSTTIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTTIE_A { match self . bits { false => UCSTTIE_A :: UCSTTIE_0 , true => UCSTTIE_A :: UCSTTIE_1 } } # [ doc = "Checks if the value of the field is `UCSTTIE_0`" ] # [ inline ( always ) ] pub fn is_ucsttie_0 ( & self ) -> bool { * self == UCSTTIE_A :: UCSTTIE_0 } # [ doc = "Checks if the value of the field is `UCSTTIE_1`" ] # [ inline ( always ) ] pub fn is_ucsttie_1 ( & self ) -> bool { * self == UCSTTIE_A :: UCSTTIE_1 } }
# [ doc = "Write proxy for field `UCSTTIE`" ] pub struct UCSTTIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTTIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTTIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucsttie_0 ( self ) -> & 'a mut W { self . variant ( UCSTTIE_A :: UCSTTIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucsttie_1 ( self ) -> & 'a mut W { self . variant ( UCSTTIE_A :: UCSTTIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Transmit complete interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXCPTIE_A { # [ doc = "0: Interrupt disabled" ] UCTXCPTIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXCPTIE_1 = 1 } impl From < UCTXCPTIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXCPTIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXCPTIE`" ] pub type UCTXCPTIE_R = crate :: R < bool , UCTXCPTIE_A > ; impl UCTXCPTIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXCPTIE_A { match self . bits { false => UCTXCPTIE_A :: UCTXCPTIE_0 , true => UCTXCPTIE_A :: UCTXCPTIE_1 } } # [ doc = "Checks if the value of the field is `UCTXCPTIE_0`" ] # [ inline ( always ) ] pub fn is_uctxcptie_0 ( & self ) -> bool { * self == UCTXCPTIE_A :: UCTXCPTIE_0 } # [ doc = "Checks if the value of the field is `UCTXCPTIE_1`" ] # [ inline ( always ) ] pub fn is_uctxcptie_1 ( & self ) -> bool { * self == UCTXCPTIE_A :: UCTXCPTIE_1 } }
# [ doc = "Write proxy for field `UCTXCPTIE`" ] pub struct UCTXCPTIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXCPTIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXCPTIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxcptie_0 ( self ) -> & 'a mut W { self . variant ( UCTXCPTIE_A :: UCTXCPTIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxcptie_1 ( self ) -> & 'a mut W { self . variant ( UCTXCPTIE_A :: UCTXCPTIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & self ) -> UCRXIE_R { UCRXIE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & self ) -> UCTXIE_R { UCTXIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Start bit interrupt enable" ] # [ inline ( always ) ] pub fn ucsttie ( & self ) -> UCSTTIE_R { UCSTTIE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Transmit complete interrupt enable" ] # [ inline ( always ) ] pub fn uctxcptie ( & self ) -> UCTXCPTIE_R { UCTXCPTIE_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & mut self ) -> UCRXIE_W { UCRXIE_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & mut self ) -> UCTXIE_W { UCTXIE_W { w : self } }
# [ doc = "Bit 2 - Start bit interrupt enable" ] # [ inline ( always ) ] pub fn ucsttie ( & mut self ) -> UCSTTIE_W { UCSTTIE_W { w : self } }
# [ doc = "Bit 3 - Transmit complete interrupt enable" ] # [ inline ( always ) ] pub fn uctxcptie ( & mut self ) -> UCTXCPTIE_W { UCTXCPTIE_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ie_spi](uca0ie_spi) module" ] pub type UCA0IE_SPI = crate :: Reg < u16 , _UCA0IE_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0IE_SPI ;
# [ doc = "`read()` method returns [uca0ie_spi::R](uca0ie_spi::R) reader structure" ] impl crate :: Readable for UCA0IE_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca0ie_spi::W](uca0ie_spi::W) writer structure" ] impl crate :: Writable for UCA0IE_SPI { }
# [ doc = "eUSCI_Ax Interrupt Enable Register" ] pub mod uca0ie_spi {
# [ doc = "Reader of register UCA0IE_SPI" ] pub type R = crate :: R < u16 , super :: UCA0IE_SPI > ;
# [ doc = "Writer for register UCA0IE_SPI" ] pub type W = crate :: W < u16 , super :: UCA0IE_SPI > ;
# [ doc = "Register UCA0IE_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0IE_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE_A { # [ doc = "0: Interrupt disabled" ] UCRXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE_1 = 1 } impl From < UCRXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE`" ] pub type UCRXIE_R = crate :: R < bool , UCRXIE_A > ; impl UCRXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE_A { match self . bits { false => UCRXIE_A :: UCRXIE_0 , true => UCRXIE_A :: UCRXIE_1 } } # [ doc = "Checks if the value of the field is `UCRXIE_0`" ] # [ inline ( always ) ] pub fn is_ucrxie_0 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_0 } # [ doc = "Checks if the value of the field is `UCRXIE_1`" ] # [ inline ( always ) ] pub fn is_ucrxie_1 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_1 } }
# [ doc = "Write proxy for field `UCRXIE`" ] pub struct UCRXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE_A { # [ doc = "0: Interrupt disabled" ] UCTXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE_1 = 1 } impl From < UCTXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE`" ] pub type UCTXIE_R = crate :: R < bool , UCTXIE_A > ; impl UCTXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE_A { match self . bits { false => UCTXIE_A :: UCTXIE_0 , true => UCTXIE_A :: UCTXIE_1 } } # [ doc = "Checks if the value of the field is `UCTXIE_0`" ] # [ inline ( always ) ] pub fn is_uctxie_0 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_0 } # [ doc = "Checks if the value of the field is `UCTXIE_1`" ] # [ inline ( always ) ] pub fn is_uctxie_1 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_1 } }
# [ doc = "Write proxy for field `UCTXIE`" ] pub struct UCTXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & self ) -> UCRXIE_R { UCRXIE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & self ) -> UCTXIE_R { UCTXIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & mut self ) -> UCRXIE_W { UCRXIE_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & mut self ) -> UCTXIE_W { UCTXIE_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ifg](uca0ifg) module" ] pub type UCA0IFG = crate :: Reg < u16 , _UCA0IFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0IFG ;
# [ doc = "`read()` method returns [uca0ifg::R](uca0ifg::R) reader structure" ] impl crate :: Readable for UCA0IFG { }
# [ doc = "`write(|w| ..)` method takes [uca0ifg::W](uca0ifg::W) writer structure" ] impl crate :: Writable for UCA0IFG { }
# [ doc = "eUSCI_Ax Interrupt Flag Register" ] pub mod uca0ifg {
# [ doc = "Reader of register UCA0IFG" ] pub type R = crate :: R < u16 , super :: UCA0IFG > ;
# [ doc = "Writer for register UCA0IFG" ] pub type W = crate :: W < u16 , super :: UCA0IFG > ;
# [ doc = "Register UCA0IFG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0IFG { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG_A { # [ doc = "0: No interrupt pending" ] UCRXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG_1 = 1 } impl From < UCRXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG`" ] pub type UCRXIFG_R = crate :: R < bool , UCRXIFG_A > ; impl UCRXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG_A { match self . bits { false => UCRXIFG_A :: UCRXIFG_0 , true => UCRXIFG_A :: UCRXIFG_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg_0 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_0 } # [ doc = "Checks if the value of the field is `UCRXIFG_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg_1 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_1 } }
# [ doc = "Write proxy for field `UCRXIFG`" ] pub struct UCRXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG_A { # [ doc = "0: No interrupt pending" ] UCTXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG_1 = 1 } impl From < UCTXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG`" ] pub type UCTXIFG_R = crate :: R < bool , UCTXIFG_A > ; impl UCTXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG_A { match self . bits { false => UCTXIFG_A :: UCTXIFG_0 , true => UCTXIFG_A :: UCTXIFG_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG_0`" ] # [ inline ( always ) ] pub fn is_uctxifg_0 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_0 } # [ doc = "Checks if the value of the field is `UCTXIFG_1`" ] # [ inline ( always ) ] pub fn is_uctxifg_1 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_1 } }
# [ doc = "Write proxy for field `UCTXIFG`" ] pub struct UCTXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Start bit interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTTIFG_A { # [ doc = "0: No interrupt pending" ] UCSTTIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCSTTIFG_1 = 1 } impl From < UCSTTIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTTIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTTIFG`" ] pub type UCSTTIFG_R = crate :: R < bool , UCSTTIFG_A > ; impl UCSTTIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTTIFG_A { match self . bits { false => UCSTTIFG_A :: UCSTTIFG_0 , true => UCSTTIFG_A :: UCSTTIFG_1 } } # [ doc = "Checks if the value of the field is `UCSTTIFG_0`" ] # [ inline ( always ) ] pub fn is_ucsttifg_0 ( & self ) -> bool { * self == UCSTTIFG_A :: UCSTTIFG_0 } # [ doc = "Checks if the value of the field is `UCSTTIFG_1`" ] # [ inline ( always ) ] pub fn is_ucsttifg_1 ( & self ) -> bool { * self == UCSTTIFG_A :: UCSTTIFG_1 } }
# [ doc = "Write proxy for field `UCSTTIFG`" ] pub struct UCSTTIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTTIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTTIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucsttifg_0 ( self ) -> & 'a mut W { self . variant ( UCSTTIFG_A :: UCSTTIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucsttifg_1 ( self ) -> & 'a mut W { self . variant ( UCSTTIFG_A :: UCSTTIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Transmit ready interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXCPTIFG_A { # [ doc = "0: No interrupt pending" ] UCTXCPTIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXCPTIFG_1 = 1 } impl From < UCTXCPTIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXCPTIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXCPTIFG`" ] pub type UCTXCPTIFG_R = crate :: R < bool , UCTXCPTIFG_A > ; impl UCTXCPTIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXCPTIFG_A { match self . bits { false => UCTXCPTIFG_A :: UCTXCPTIFG_0 , true => UCTXCPTIFG_A :: UCTXCPTIFG_1 } } # [ doc = "Checks if the value of the field is `UCTXCPTIFG_0`" ] # [ inline ( always ) ] pub fn is_uctxcptifg_0 ( & self ) -> bool { * self == UCTXCPTIFG_A :: UCTXCPTIFG_0 } # [ doc = "Checks if the value of the field is `UCTXCPTIFG_1`" ] # [ inline ( always ) ] pub fn is_uctxcptifg_1 ( & self ) -> bool { * self == UCTXCPTIFG_A :: UCTXCPTIFG_1 } }
# [ doc = "Write proxy for field `UCTXCPTIFG`" ] pub struct UCTXCPTIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXCPTIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXCPTIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxcptifg_0 ( self ) -> & 'a mut W { self . variant ( UCTXCPTIFG_A :: UCTXCPTIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxcptifg_1 ( self ) -> & 'a mut W { self . variant ( UCTXCPTIFG_A :: UCTXCPTIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & self ) -> UCRXIFG_R { UCRXIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & self ) -> UCTXIFG_R { UCTXIFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Start bit interrupt flag" ] # [ inline ( always ) ] pub fn ucsttifg ( & self ) -> UCSTTIFG_R { UCSTTIFG_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Transmit ready interrupt enable" ] # [ inline ( always ) ] pub fn uctxcptifg ( & self ) -> UCTXCPTIFG_R { UCTXCPTIFG_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & mut self ) -> UCRXIFG_W { UCRXIFG_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & mut self ) -> UCTXIFG_W { UCTXIFG_W { w : self } }
# [ doc = "Bit 2 - Start bit interrupt flag" ] # [ inline ( always ) ] pub fn ucsttifg ( & mut self ) -> UCSTTIFG_W { UCSTTIFG_W { w : self } }
# [ doc = "Bit 3 - Transmit ready interrupt enable" ] # [ inline ( always ) ] pub fn uctxcptifg ( & mut self ) -> UCTXCPTIFG_W { UCTXCPTIFG_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ifg_spi](uca0ifg_spi) module" ] pub type UCA0IFG_SPI = crate :: Reg < u16 , _UCA0IFG_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0IFG_SPI ;
# [ doc = "`read()` method returns [uca0ifg_spi::R](uca0ifg_spi::R) reader structure" ] impl crate :: Readable for UCA0IFG_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca0ifg_spi::W](uca0ifg_spi::W) writer structure" ] impl crate :: Writable for UCA0IFG_SPI { }
# [ doc = "eUSCI_Ax Interrupt Flag Register" ] pub mod uca0ifg_spi {
# [ doc = "Reader of register UCA0IFG_SPI" ] pub type R = crate :: R < u16 , super :: UCA0IFG_SPI > ;
# [ doc = "Writer for register UCA0IFG_SPI" ] pub type W = crate :: W < u16 , super :: UCA0IFG_SPI > ;
# [ doc = "Register UCA0IFG_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA0IFG_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG_A { # [ doc = "0: No interrupt pending" ] UCRXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG_1 = 1 } impl From < UCRXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG`" ] pub type UCRXIFG_R = crate :: R < bool , UCRXIFG_A > ; impl UCRXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG_A { match self . bits { false => UCRXIFG_A :: UCRXIFG_0 , true => UCRXIFG_A :: UCRXIFG_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg_0 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_0 } # [ doc = "Checks if the value of the field is `UCRXIFG_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg_1 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_1 } }
# [ doc = "Write proxy for field `UCRXIFG`" ] pub struct UCRXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG_A { # [ doc = "0: No interrupt pending" ] UCTXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG_1 = 1 } impl From < UCTXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG`" ] pub type UCTXIFG_R = crate :: R < bool , UCTXIFG_A > ; impl UCTXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG_A { match self . bits { false => UCTXIFG_A :: UCTXIFG_0 , true => UCTXIFG_A :: UCTXIFG_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG_0`" ] # [ inline ( always ) ] pub fn is_uctxifg_0 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_0 } # [ doc = "Checks if the value of the field is `UCTXIFG_1`" ] # [ inline ( always ) ] pub fn is_uctxifg_1 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_1 } }
# [ doc = "Write proxy for field `UCTXIFG`" ] pub struct UCTXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & self ) -> UCRXIFG_R { UCRXIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & self ) -> UCTXIFG_R { UCTXIFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & mut self ) -> UCRXIFG_W { UCRXIFG_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & mut self ) -> UCTXIFG_W { UCTXIFG_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0iv](uca0iv) module" ] pub type UCA0IV = crate :: Reg < u16 , _UCA0IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0IV ;
# [ doc = "`read()` method returns [uca0iv::R](uca0iv::R) reader structure" ] impl crate :: Readable for UCA0IV { }
# [ doc = "eUSCI_Ax Interrupt Vector Register" ] pub mod uca0iv {
# [ doc = "Reader of register UCA0IV" ] pub type R = crate :: R < u16 , super :: UCA0IV > ;
# [ doc = "eUSCI_A interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum UCIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Receive buffer full; Interrupt Flag: UCRXIFG; Interrupt Priority: Highest" ] UCRXIFG = 2 , # [ doc = "4: Interrupt Source: Transmit buffer empty; Interrupt Flag: UCTXIFG" ] UCTXIFG = 4 , # [ doc = "6: Interrupt Source: Start bit received; Interrupt Flag: UCSTTIFG" ] UCSTTIFG = 6 , # [ doc = "8: Interrupt Source: Transmit complete; Interrupt Flag: UCTXCPTIFG; Interrupt Priority: Lowest" ] UCTXCPTIFG = 8 } impl From < UCIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : UCIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCIV`" ] pub type UCIV_R = crate :: R < u16 , UCIV_A > ; impl UCIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , UCIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( UCIV_A :: NONE ) , 2 => Val ( UCIV_A :: UCRXIFG ) , 4 => Val ( UCIV_A :: UCTXIFG ) , 6 => Val ( UCIV_A :: UCSTTIFG ) , 8 => Val ( UCIV_A :: UCTXCPTIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == UCIV_A :: NONE } # [ doc = "Checks if the value of the field is `UCRXIFG`" ] # [ inline ( always ) ] pub fn is_ucrxifg ( & self ) -> bool { * self == UCIV_A :: UCRXIFG } # [ doc = "Checks if the value of the field is `UCTXIFG`" ] # [ inline ( always ) ] pub fn is_uctxifg ( & self ) -> bool { * self == UCIV_A :: UCTXIFG } # [ doc = "Checks if the value of the field is `UCSTTIFG`" ] # [ inline ( always ) ] pub fn is_ucsttifg ( & self ) -> bool { * self == UCIV_A :: UCSTTIFG } # [ doc = "Checks if the value of the field is `UCTXCPTIFG`" ] # [ inline ( always ) ] pub fn is_uctxcptifg ( & self ) -> bool { * self == UCIV_A :: UCTXCPTIFG } }
impl R {
# [ doc = "Bits 0:15 - eUSCI_A interrupt vector value" ] # [ inline ( always ) ] pub fn uciv ( & self ) -> UCIV_R { UCIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
# [ doc = "eUSCI_Ax Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0iv_spi](uca0iv_spi) module" ] pub type UCA0IV_SPI = crate :: Reg < u16 , _UCA0IV_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA0IV_SPI ;
# [ doc = "`read()` method returns [uca0iv_spi::R](uca0iv_spi::R) reader structure" ] impl crate :: Readable for UCA0IV_SPI { }
# [ doc = "eUSCI_Ax Interrupt Vector Register" ] pub mod uca0iv_spi {
# [ doc = "Reader of register UCA0IV_SPI" ] pub type R = crate :: R < u16 , super :: UCA0IV_SPI > ;
# [ doc = "eUSCI_A interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum UCIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Data received; Interrupt Flag: UCRXIFG; Interrupt Priority: Highest" ] UCRXIFG = 2 , # [ doc = "4: Interrupt Source: Transmit buffer empty; Interrupt Flag: UCTXIFG; Interrupt Priority: Lowest" ] UCTXIFG = 4 } impl From < UCIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : UCIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCIV`" ] pub type UCIV_R = crate :: R < u16 , UCIV_A > ; impl UCIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , UCIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( UCIV_A :: NONE ) , 2 => Val ( UCIV_A :: UCRXIFG ) , 4 => Val ( UCIV_A :: UCTXIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == UCIV_A :: NONE } # [ doc = "Checks if the value of the field is `UCRXIFG`" ] # [ inline ( always ) ] pub fn is_ucrxifg ( & self ) -> bool { * self == UCIV_A :: UCRXIFG } # [ doc = "Checks if the value of the field is `UCTXIFG`" ] # [ inline ( always ) ] pub fn is_uctxifg ( & self ) -> bool { * self == UCIV_A :: UCTXIFG } }
impl R {
# [ doc = "Bits 0:15 - eUSCI_A interrupt vector value" ] # [ inline ( always ) ] pub fn uciv ( & self ) -> UCIV_R { UCIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "eUSCI_B0" ] pub struct E_USCI_B0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for E_USCI_B0 { } impl E_USCI_B0 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const e_usci_b0 :: RegisterBlock { 0x0540 as * const _ } } impl Deref for E_USCI_B0 { type Target = e_usci_b0 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * E_USCI_B0 :: ptr ( ) } } }
# [ doc = "eUSCI_B0" ] pub mod e_usci_b0 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved_0_ucb0ctlw : [ u8 ; 2usize ] , # [ doc = "0x02 - eUSCI_Bx Control Word Register 1" ] pub ucb0ctlw1 : UCB0CTLW1 , _reserved2 : [ u8 ; 2usize ] , _reserved_2_ucb0 : [ u8 ; 2usize ] , _reserved_3_ucb0 : [ u8 ; 2usize ] , # [ doc = "0x0a - eUSCI_Bx Byte Counter Threshold Register" ] pub ucb0tbcnt : UCB0TBCNT , _reserved_5_ucb0 : [ u8 ; 2usize ] , _reserved_6_ucb0 : [ u8 ; 2usize ] , _reserved7 : [ u8 ; 4usize ] , # [ doc = "0x14 - eUSCI_Bx I2C Own Address 0 Register" ] pub ucb0i2coa0 : UCB0I2COA0 , # [ doc = "0x16 - eUSCI_Bx I2C Own Address 1 Register" ] pub ucb0i2coa1 : UCB0I2COA1 , # [ doc = "0x18 - eUSCI_Bx I2C Own Address 2 Register" ] pub ucb0i2coa2 : UCB0I2COA2 , # [ doc = "0x1a - eUSCI_Bx I2C Own Address 3 Register" ] pub ucb0i2coa3 : UCB0I2COA3 , # [ doc = "0x1c - eUSCI_Bx I2C Received Address Register" ] pub ucb0addrx : UCB0ADDRX , # [ doc = "0x1e - eUSCI_Bx I2C Address Mask Register" ] pub ucb0addmask : UCB0ADDMASK , # [ doc = "0x20 - eUSCI_Bx I2C Slave Address Register" ] pub ucb0i2csa : UCB0I2CSA , _reserved14 : [ u8 ; 8usize ] , _reserved_14_ucb0 : [ u8 ; 2usize ] , _reserved_15_ucb0 : [ u8 ; 2usize ] , _reserved_16_ucb0 : [ u8 ; 2usize ] , } impl RegisterBlock { # [ doc = "0x00 - eUSCI_Bx Control Word Register 0" ] # [ inline ( always ) ] pub fn ucb0ctlw0_spi ( & self ) -> & UCB0CTLW0_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const UCB0CTLW0_SPI ) } } # [ doc = "0x00 - eUSCI_Bx Control Word Register 0" ] # [ inline ( always ) ] pub fn ucb0ctlw0_spi_mut ( & self ) -> & mut UCB0CTLW0_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut UCB0CTLW0_SPI ) } } # [ doc = "0x00 - eUSCI_Bx Control Word Register 0" ] # [ inline ( always ) ] pub fn ucb0ctlw0 ( & self ) -> & UCB0CTLW0 { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const UCB0CTLW0 ) } } # [ doc = "0x00 - eUSCI_Bx Control Word Register 0" ] # [ inline ( always ) ] pub fn ucb0ctlw0_mut ( & self ) -> & mut UCB0CTLW0 { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut UCB0CTLW0 ) } } # [ doc = "0x06 - eUSCI_Bx Bit Rate Control Register 1" ] # [ inline ( always ) ] pub fn ucb0brw_spi ( & self ) -> & UCB0BRW_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 6usize ) as * const UCB0BRW_SPI ) } } # [ doc = "0x06 - eUSCI_Bx Bit Rate Control Register 1" ] # [ inline ( always ) ] pub fn ucb0brw_spi_mut ( & self ) -> & mut UCB0BRW_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 6usize ) as * mut UCB0BRW_SPI ) } } # [ doc = "0x06 - eUSCI_Bx Baud Rate Control Word Register" ] # [ inline ( always ) ] pub fn ucb0brw ( & self ) -> & UCB0BRW { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 6usize ) as * const UCB0BRW ) } } # [ doc = "0x06 - eUSCI_Bx Baud Rate Control Word Register" ] # [ inline ( always ) ] pub fn ucb0brw_mut ( & self ) -> & mut UCB0BRW { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 6usize ) as * mut UCB0BRW ) } } # [ doc = "0x08 - UCB0STATW_SPI" ] # [ inline ( always ) ] pub fn ucb0statw_spi ( & self ) -> & UCB0STATW_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 8usize ) as * const UCB0STATW_SPI ) } } # [ doc = "0x08 - UCB0STATW_SPI" ] # [ inline ( always ) ] pub fn ucb0statw_spi_mut ( & self ) -> & mut UCB0STATW_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 8usize ) as * mut UCB0STATW_SPI ) } } # [ doc = "0x08 - eUSCI_Bx Status Register" ] # [ inline ( always ) ] pub fn ucb0statw ( & self ) -> & UCB0STATW { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 8usize ) as * const UCB0STATW ) } } # [ doc = "0x08 - eUSCI_Bx Status Register" ] # [ inline ( always ) ] pub fn ucb0statw_mut ( & self ) -> & mut UCB0STATW { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 8usize ) as * mut UCB0STATW ) } } # [ doc = "0x0c - eUSCI_Bx Receive Buffer Register" ] # [ inline ( always ) ] pub fn ucb0rxbuf_spi ( & self ) -> & UCB0RXBUF_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const UCB0RXBUF_SPI ) } } # [ doc = "0x0c - eUSCI_Bx Receive Buffer Register" ] # [ inline ( always ) ] pub fn ucb0rxbuf_spi_mut ( & self ) -> & mut UCB0RXBUF_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut UCB0RXBUF_SPI ) } } # [ doc = "0x0c - eUSCI_Bx Receive Buffer Register" ] # [ inline ( always ) ] pub fn ucb0rxbuf ( & self ) -> & UCB0RXBUF { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const UCB0RXBUF ) } } # [ doc = "0x0c - eUSCI_Bx Receive Buffer Register" ] # [ inline ( always ) ] pub fn ucb0rxbuf_mut ( & self ) -> & mut UCB0RXBUF { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut UCB0RXBUF ) } } # [ doc = "0x0e - eUSCI_Bx Transmit Buffer Register" ] # [ inline ( always ) ] pub fn ucb0txbuf_spi ( & self ) -> & UCB0TXBUF_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 14usize ) as * const UCB0TXBUF_SPI ) } } # [ doc = "0x0e - eUSCI_Bx Transmit Buffer Register" ] # [ inline ( always ) ] pub fn ucb0txbuf_spi_mut ( & self ) -> & mut UCB0TXBUF_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 14usize ) as * mut UCB0TXBUF_SPI ) } } # [ doc = "0x0e - eUSCI_Bx Transmit Buffer Register" ] # [ inline ( always ) ] pub fn ucb0txbuf ( & self ) -> & UCB0TXBUF { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 14usize ) as * const UCB0TXBUF ) } } # [ doc = "0x0e - eUSCI_Bx Transmit Buffer Register" ] # [ inline ( always ) ] pub fn ucb0txbuf_mut ( & self ) -> & mut UCB0TXBUF { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 14usize ) as * mut UCB0TXBUF ) } } # [ doc = "0x2a - eUSCI_Bx Interrupt Enable Register" ] # [ inline ( always ) ] pub fn ucb0ie_spi ( & self ) -> & UCB0IE_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 42usize ) as * const UCB0IE_SPI ) } } # [ doc = "0x2a - eUSCI_Bx Interrupt Enable Register" ] # [ inline ( always ) ] pub fn ucb0ie_spi_mut ( & self ) -> & mut UCB0IE_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 42usize ) as * mut UCB0IE_SPI ) } } # [ doc = "0x2a - eUSCI_Bx Interrupt Enable Register" ] # [ inline ( always ) ] pub fn ucb0ie ( & self ) -> & UCB0IE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 42usize ) as * const UCB0IE ) } } # [ doc = "0x2a - eUSCI_Bx Interrupt Enable Register" ] # [ inline ( always ) ] pub fn ucb0ie_mut ( & self ) -> & mut UCB0IE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 42usize ) as * mut UCB0IE ) } } # [ doc = "0x2c - eUSCI_Bx Interrupt Flag Register" ] # [ inline ( always ) ] pub fn ucb0ifg_spi ( & self ) -> & UCB0IFG_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 44usize ) as * const UCB0IFG_SPI ) } } # [ doc = "0x2c - eUSCI_Bx Interrupt Flag Register" ] # [ inline ( always ) ] pub fn ucb0ifg_spi_mut ( & self ) -> & mut UCB0IFG_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 44usize ) as * mut UCB0IFG_SPI ) } } # [ doc = "0x2c - eUSCI_Bx Interrupt Flag Register" ] # [ inline ( always ) ] pub fn ucb0ifg ( & self ) -> & UCB0IFG { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 44usize ) as * const UCB0IFG ) } } # [ doc = "0x2c - eUSCI_Bx Interrupt Flag Register" ] # [ inline ( always ) ] pub fn ucb0ifg_mut ( & self ) -> & mut UCB0IFG { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 44usize ) as * mut UCB0IFG ) } } # [ doc = "0x2e - eUSCI_Bx Interrupt Vector Register" ] # [ inline ( always ) ] pub fn ucb0iv_spi ( & self ) -> & UCB0IV_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 46usize ) as * const UCB0IV_SPI ) } } # [ doc = "0x2e - eUSCI_Bx Interrupt Vector Register" ] # [ inline ( always ) ] pub fn ucb0iv_spi_mut ( & self ) -> & mut UCB0IV_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 46usize ) as * mut UCB0IV_SPI ) } } # [ doc = "0x2e - eUSCI_Bx Interrupt Vector Register" ] # [ inline ( always ) ] pub fn ucb0iv ( & self ) -> & UCB0IV { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 46usize ) as * const UCB0IV ) } } # [ doc = "0x2e - eUSCI_Bx Interrupt Vector Register" ] # [ inline ( always ) ] pub fn ucb0iv_mut ( & self ) -> & mut UCB0IV { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 46usize ) as * mut UCB0IV ) } } }
# [ doc = "eUSCI_Bx Control Word Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ctlw0](ucb0ctlw0) module" ] pub type UCB0CTLW0 = crate :: Reg < u16 , _UCB0CTLW0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0CTLW0 ;
# [ doc = "`read()` method returns [ucb0ctlw0::R](ucb0ctlw0::R) reader structure" ] impl crate :: Readable for UCB0CTLW0 { }
# [ doc = "`write(|w| ..)` method takes [ucb0ctlw0::W](ucb0ctlw0::W) writer structure" ] impl crate :: Writable for UCB0CTLW0 { }
# [ doc = "eUSCI_Bx Control Word Register 0" ] pub mod ucb0ctlw0 {
# [ doc = "Reader of register UCB0CTLW0" ] pub type R = crate :: R < u16 , super :: UCB0CTLW0 > ;
# [ doc = "Writer for register UCB0CTLW0" ] pub type W = crate :: W < u16 , super :: UCB0CTLW0 > ;
# [ doc = "Register UCB0CTLW0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0CTLW0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Software reset enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSWRST_A { # [ doc = "0: Disabled. eUSCI_B reset released for operation" ] DISABLE = 0 , # [ doc = "1: Enabled. eUSCI_B logic held in reset state" ] ENABLE = 1 } impl From < UCSWRST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSWRST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSWRST`" ] pub type UCSWRST_R = crate :: R < bool , UCSWRST_A > ; impl UCSWRST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSWRST_A { match self . bits { false => UCSWRST_A :: DISABLE , true => UCSWRST_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCSWRST_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCSWRST_A :: ENABLE } }
# [ doc = "Write proxy for field `UCSWRST`" ] pub struct UCSWRST_W < 'a > { w : & 'a mut W , } impl < 'a > UCSWRST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSWRST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled. eUSCI_B reset released for operation" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: DISABLE ) } # [ doc = "Enabled. eUSCI_B logic held in reset state" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit START condition in master mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXSTT_A { # [ doc = "0: Do not generate START condition" ] UCTXSTT_0 = 0 , # [ doc = "1: Generate START condition" ] UCTXSTT_1 = 1 } impl From < UCTXSTT_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXSTT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXSTT`" ] pub type UCTXSTT_R = crate :: R < bool , UCTXSTT_A > ; impl UCTXSTT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXSTT_A { match self . bits { false => UCTXSTT_A :: UCTXSTT_0 , true => UCTXSTT_A :: UCTXSTT_1 } } # [ doc = "Checks if the value of the field is `UCTXSTT_0`" ] # [ inline ( always ) ] pub fn is_uctxstt_0 ( & self ) -> bool { * self == UCTXSTT_A :: UCTXSTT_0 } # [ doc = "Checks if the value of the field is `UCTXSTT_1`" ] # [ inline ( always ) ] pub fn is_uctxstt_1 ( & self ) -> bool { * self == UCTXSTT_A :: UCTXSTT_1 } }
# [ doc = "Write proxy for field `UCTXSTT`" ] pub struct UCTXSTT_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXSTT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXSTT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Do not generate START condition" ] # [ inline ( always ) ] pub fn uctxstt_0 ( self ) -> & 'a mut W { self . variant ( UCTXSTT_A :: UCTXSTT_0 ) } # [ doc = "Generate START condition" ] # [ inline ( always ) ] pub fn uctxstt_1 ( self ) -> & 'a mut W { self . variant ( UCTXSTT_A :: UCTXSTT_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Transmit STOP condition in master mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXSTP_A { # [ doc = "0: No STOP generated" ] UCTXSTP_0 = 0 , # [ doc = "1: Generate STOP" ] UCTXSTP_1 = 1 } impl From < UCTXSTP_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXSTP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXSTP`" ] pub type UCTXSTP_R = crate :: R < bool , UCTXSTP_A > ; impl UCTXSTP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXSTP_A { match self . bits { false => UCTXSTP_A :: UCTXSTP_0 , true => UCTXSTP_A :: UCTXSTP_1 } } # [ doc = "Checks if the value of the field is `UCTXSTP_0`" ] # [ inline ( always ) ] pub fn is_uctxstp_0 ( & self ) -> bool { * self == UCTXSTP_A :: UCTXSTP_0 } # [ doc = "Checks if the value of the field is `UCTXSTP_1`" ] # [ inline ( always ) ] pub fn is_uctxstp_1 ( & self ) -> bool { * self == UCTXSTP_A :: UCTXSTP_1 } }
# [ doc = "Write proxy for field `UCTXSTP`" ] pub struct UCTXSTP_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXSTP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXSTP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No STOP generated" ] # [ inline ( always ) ] pub fn uctxstp_0 ( self ) -> & 'a mut W { self . variant ( UCTXSTP_A :: UCTXSTP_0 ) } # [ doc = "Generate STOP" ] # [ inline ( always ) ] pub fn uctxstp_1 ( self ) -> & 'a mut W { self . variant ( UCTXSTP_A :: UCTXSTP_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Transmit a NACK\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXNACK_A { # [ doc = "0: Acknowledge normally" ] UCTXNACK_0 = 0 , # [ doc = "1: Generate NACK" ] UCTXNACK_1 = 1 } impl From < UCTXNACK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXNACK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXNACK`" ] pub type UCTXNACK_R = crate :: R < bool , UCTXNACK_A > ; impl UCTXNACK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXNACK_A { match self . bits { false => UCTXNACK_A :: UCTXNACK_0 , true => UCTXNACK_A :: UCTXNACK_1 } } # [ doc = "Checks if the value of the field is `UCTXNACK_0`" ] # [ inline ( always ) ] pub fn is_uctxnack_0 ( & self ) -> bool { * self == UCTXNACK_A :: UCTXNACK_0 } # [ doc = "Checks if the value of the field is `UCTXNACK_1`" ] # [ inline ( always ) ] pub fn is_uctxnack_1 ( & self ) -> bool { * self == UCTXNACK_A :: UCTXNACK_1 } }
# [ doc = "Write proxy for field `UCTXNACK`" ] pub struct UCTXNACK_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXNACK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXNACK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Acknowledge normally" ] # [ inline ( always ) ] pub fn uctxnack_0 ( self ) -> & 'a mut W { self . variant ( UCTXNACK_A :: UCTXNACK_0 ) } # [ doc = "Generate NACK" ] # [ inline ( always ) ] pub fn uctxnack_1 ( self ) -> & 'a mut W { self . variant ( UCTXNACK_A :: UCTXNACK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Transmitter/receiver\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTR_A { # [ doc = "0: Receiver" ] RX = 0 , # [ doc = "1: Transmitter" ] TX = 1 } impl From < UCTR_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTR`" ] pub type UCTR_R = crate :: R < bool , UCTR_A > ; impl UCTR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTR_A { match self . bits { false => UCTR_A :: RX , true => UCTR_A :: TX } } # [ doc = "Checks if the value of the field is `RX`" ] # [ inline ( always ) ] pub fn is_rx ( & self ) -> bool { * self == UCTR_A :: RX } # [ doc = "Checks if the value of the field is `TX`" ] # [ inline ( always ) ] pub fn is_tx ( & self ) -> bool { * self == UCTR_A :: TX } }
# [ doc = "Write proxy for field `UCTR`" ] pub struct UCTR_W < 'a > { w : & 'a mut W , } impl < 'a > UCTR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Receiver" ] # [ inline ( always ) ] pub fn rx ( self ) -> & 'a mut W { self . variant ( UCTR_A :: RX ) } # [ doc = "Transmitter" ] # [ inline ( always ) ] pub fn tx ( self ) -> & 'a mut W { self . variant ( UCTR_A :: TX ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Transmit ACK condition in slave mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXACK_A { # [ doc = "0: Do not acknowledge the slave address" ] UCTXACK_0 = 0 , # [ doc = "1: Acknowledge the slave address" ] UCTXACK_1 = 1 } impl From < UCTXACK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXACK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXACK`" ] pub type UCTXACK_R = crate :: R < bool , UCTXACK_A > ; impl UCTXACK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXACK_A { match self . bits { false => UCTXACK_A :: UCTXACK_0 , true => UCTXACK_A :: UCTXACK_1 } } # [ doc = "Checks if the value of the field is `UCTXACK_0`" ] # [ inline ( always ) ] pub fn is_uctxack_0 ( & self ) -> bool { * self == UCTXACK_A :: UCTXACK_0 } # [ doc = "Checks if the value of the field is `UCTXACK_1`" ] # [ inline ( always ) ] pub fn is_uctxack_1 ( & self ) -> bool { * self == UCTXACK_A :: UCTXACK_1 } }
# [ doc = "Write proxy for field `UCTXACK`" ] pub struct UCTXACK_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXACK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXACK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Do not acknowledge the slave address" ] # [ inline ( always ) ] pub fn uctxack_0 ( self ) -> & 'a mut W { self . variant ( UCTXACK_A :: UCTXACK_0 ) } # [ doc = "Acknowledge the slave address" ] # [ inline ( always ) ] pub fn uctxack_1 ( self ) -> & 'a mut W { self . variant ( UCTXACK_A :: UCTXACK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "eUSCI_B clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCSSEL_A { # [ doc = "0: UCLKI" ] UCLKI = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: SMCLK" ] UCSSEL_3 = 3 } impl From < UCSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCSSEL`" ] pub type UCSSEL_R = crate :: R < u8 , UCSSEL_A > ; impl UCSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSSEL_A { match self . bits { 0 => UCSSEL_A :: UCLKI , 1 => UCSSEL_A :: ACLK , 2 => UCSSEL_A :: SMCLK , 3 => UCSSEL_A :: UCSSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCLKI`" ] # [ inline ( always ) ] pub fn is_uclki ( & self ) -> bool { * self == UCSSEL_A :: UCLKI } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == UCSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == UCSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `UCSSEL_3`" ] # [ inline ( always ) ] pub fn is_ucssel_3 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_3 } }
# [ doc = "Write proxy for field `UCSSEL`" ] pub struct UCSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > UCSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "UCLKI" ] # [ inline ( always ) ] pub fn uclki ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCLKI ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: SMCLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn ucssel_3 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Synchronous mode enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSYNC_A { # [ doc = "0: Asynchronous mode" ] ASYNC = 0 , # [ doc = "1: Synchronous mode" ] SYNC = 1 } impl From < UCSYNC_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSYNC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSYNC`" ] pub type UCSYNC_R = crate :: R < bool , UCSYNC_A > ; impl UCSYNC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSYNC_A { match self . bits { false => UCSYNC_A :: ASYNC , true => UCSYNC_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == UCSYNC_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == UCSYNC_A :: SYNC } }
# [ doc = "Write proxy for field `UCSYNC`" ] pub struct UCSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > UCSYNC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSYNC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous mode" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: ASYNC ) } # [ doc = "Synchronous mode" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "eUSCI_B mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCMODE_A { # [ doc = "0: 3-pin SPI" ] UCMODE_0 = 0 , # [ doc = "1: 4-pin SPI (master or slave enabled if STE = 1)" ] UCMODE_1 = 1 , # [ doc = "2: 4-pin SPI (master or slave enabled if STE = 0)" ] UCMODE_2 = 2 , # [ doc = "3: I2C mode" ] UCMODE_3 = 3 } impl From < UCMODE_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCMODE_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCMODE`" ] pub type UCMODE_R = crate :: R < u8 , UCMODE_A > ; impl UCMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMODE_A { match self . bits { 0 => UCMODE_A :: UCMODE_0 , 1 => UCMODE_A :: UCMODE_1 , 2 => UCMODE_A :: UCMODE_2 , 3 => UCMODE_A :: UCMODE_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCMODE_0`" ] # [ inline ( always ) ] pub fn is_ucmode_0 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_0 } # [ doc = "Checks if the value of the field is `UCMODE_1`" ] # [ inline ( always ) ] pub fn is_ucmode_1 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_1 } # [ doc = "Checks if the value of the field is `UCMODE_2`" ] # [ inline ( always ) ] pub fn is_ucmode_2 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_2 } # [ doc = "Checks if the value of the field is `UCMODE_3`" ] # [ inline ( always ) ] pub fn is_ucmode_3 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_3 } }
# [ doc = "Write proxy for field `UCMODE`" ] pub struct UCMODE_W < 'a > { w : & 'a mut W , } impl < 'a > UCMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMODE_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "3-pin SPI" ] # [ inline ( always ) ] pub fn ucmode_0 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_0 ) } # [ doc = "4-pin SPI (master or slave enabled if STE = 1)" ] # [ inline ( always ) ] pub fn ucmode_1 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_1 ) } # [ doc = "4-pin SPI (master or slave enabled if STE = 0)" ] # [ inline ( always ) ] pub fn ucmode_2 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_2 ) } # [ doc = "I2C mode" ] # [ inline ( always ) ] pub fn ucmode_3 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Master mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMST_A { # [ doc = "0: Slave mode" ] SLAVE = 0 , # [ doc = "1: Master mode" ] MASTER = 1 } impl From < UCMST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMST`" ] pub type UCMST_R = crate :: R < bool , UCMST_A > ; impl UCMST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMST_A { match self . bits { false => UCMST_A :: SLAVE , true => UCMST_A :: MASTER } } # [ doc = "Checks if the value of the field is `SLAVE`" ] # [ inline ( always ) ] pub fn is_slave ( & self ) -> bool { * self == UCMST_A :: SLAVE } # [ doc = "Checks if the value of the field is `MASTER`" ] # [ inline ( always ) ] pub fn is_master ( & self ) -> bool { * self == UCMST_A :: MASTER } }
# [ doc = "Write proxy for field `UCMST`" ] pub struct UCMST_W < 'a > { w : & 'a mut W , } impl < 'a > UCMST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Slave mode" ] # [ inline ( always ) ] pub fn slave ( self ) -> & 'a mut W { self . variant ( UCMST_A :: SLAVE ) } # [ doc = "Master mode" ] # [ inline ( always ) ] pub fn master ( self ) -> & 'a mut W { self . variant ( UCMST_A :: MASTER ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Multi-master environment select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMM_A { # [ doc = "0: Single master environment. There is no other master in the system. The address compare unit is disabled." ] SINGLE = 0 , # [ doc = "1: Multi-master environment" ] MULTI = 1 } impl From < UCMM_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMM`" ] pub type UCMM_R = crate :: R < bool , UCMM_A > ; impl UCMM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMM_A { match self . bits { false => UCMM_A :: SINGLE , true => UCMM_A :: MULTI } } # [ doc = "Checks if the value of the field is `SINGLE`" ] # [ inline ( always ) ] pub fn is_single ( & self ) -> bool { * self == UCMM_A :: SINGLE } # [ doc = "Checks if the value of the field is `MULTI`" ] # [ inline ( always ) ] pub fn is_multi ( & self ) -> bool { * self == UCMM_A :: MULTI } }
# [ doc = "Write proxy for field `UCMM`" ] pub struct UCMM_W < 'a > { w : & 'a mut W , } impl < 'a > UCMM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Single master environment. There is no other master in the system. The address compare unit is disabled." ] # [ inline ( always ) ] pub fn single ( self ) -> & 'a mut W { self . variant ( UCMM_A :: SINGLE ) } # [ doc = "Multi-master environment" ] # [ inline ( always ) ] pub fn multi ( self ) -> & 'a mut W { self . variant ( UCMM_A :: MULTI ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Slave addressing mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSLA10_A { # [ doc = "0: Address slave with 7-bit address" ] _7BIT = 0 , # [ doc = "1: Address slave with 10-bit address" ] _10BIT = 1 } impl From < UCSLA10_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSLA10_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSLA10`" ] pub type UCSLA10_R = crate :: R < bool , UCSLA10_A > ; impl UCSLA10_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSLA10_A { match self . bits { false => UCSLA10_A :: _7BIT , true => UCSLA10_A :: _10BIT } } # [ doc = "Checks if the value of the field is `_7BIT`" ] # [ inline ( always ) ] pub fn is_7bit ( & self ) -> bool { * self == UCSLA10_A :: _7BIT } # [ doc = "Checks if the value of the field is `_10BIT`" ] # [ inline ( always ) ] pub fn is_10bit ( & self ) -> bool { * self == UCSLA10_A :: _10BIT } }
# [ doc = "Write proxy for field `UCSLA10`" ] pub struct UCSLA10_W < 'a > { w : & 'a mut W , } impl < 'a > UCSLA10_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSLA10_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Address slave with 7-bit address" ] # [ inline ( always ) ] pub fn _7bit ( self ) -> & 'a mut W { self . variant ( UCSLA10_A :: _7BIT ) } # [ doc = "Address slave with 10-bit address" ] # [ inline ( always ) ] pub fn _10bit ( self ) -> & 'a mut W { self . variant ( UCSLA10_A :: _10BIT ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Own addressing mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCA10_A { # [ doc = "0: Own address is a 7-bit address" ] UCA10_0 = 0 , # [ doc = "1: Own address is a 10-bit address" ] UCA10_1 = 1 } impl From < UCA10_A > for bool { # [ inline ( always ) ] fn from ( variant : UCA10_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCA10`" ] pub type UCA10_R = crate :: R < bool , UCA10_A > ; impl UCA10_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCA10_A { match self . bits { false => UCA10_A :: UCA10_0 , true => UCA10_A :: UCA10_1 } } # [ doc = "Checks if the value of the field is `UCA10_0`" ] # [ inline ( always ) ] pub fn is_uca10_0 ( & self ) -> bool { * self == UCA10_A :: UCA10_0 } # [ doc = "Checks if the value of the field is `UCA10_1`" ] # [ inline ( always ) ] pub fn is_uca10_1 ( & self ) -> bool { * self == UCA10_A :: UCA10_1 } }
# [ doc = "Write proxy for field `UCA10`" ] pub struct UCA10_W < 'a > { w : & 'a mut W , } impl < 'a > UCA10_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCA10_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Own address is a 7-bit address" ] # [ inline ( always ) ] pub fn uca10_0 ( self ) -> & 'a mut W { self . variant ( UCA10_A :: UCA10_0 ) } # [ doc = "Own address is a 10-bit address" ] # [ inline ( always ) ] pub fn uca10_1 ( self ) -> & 'a mut W { self . variant ( UCA10_A :: UCA10_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & self ) -> UCSWRST_R { UCSWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit START condition in master mode" ] # [ inline ( always ) ] pub fn uctxstt ( & self ) -> UCTXSTT_R { UCTXSTT_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Transmit STOP condition in master mode" ] # [ inline ( always ) ] pub fn uctxstp ( & self ) -> UCTXSTP_R { UCTXSTP_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Transmit a NACK" ] # [ inline ( always ) ] pub fn uctxnack ( & self ) -> UCTXNACK_R { UCTXNACK_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Transmitter/receiver" ] # [ inline ( always ) ] pub fn uctr ( & self ) -> UCTR_R { UCTR_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Transmit ACK condition in slave mode" ] # [ inline ( always ) ] pub fn uctxack ( & self ) -> UCTXACK_R { UCTXACK_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - eUSCI_B clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & self ) -> UCSSEL_R { UCSSEL_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & self ) -> UCSYNC_R { UCSYNC_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - eUSCI_B mode" ] # [ inline ( always ) ] pub fn ucmode ( & self ) -> UCMODE_R { UCMODE_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & self ) -> UCMST_R { UCMST_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Multi-master environment select" ] # [ inline ( always ) ] pub fn ucmm ( & self ) -> UCMM_R { UCMM_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Slave addressing mode select" ] # [ inline ( always ) ] pub fn ucsla10 ( & self ) -> UCSLA10_R { UCSLA10_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Own addressing mode select" ] # [ inline ( always ) ] pub fn uca10 ( & self ) -> UCA10_R { UCA10_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & mut self ) -> UCSWRST_W { UCSWRST_W { w : self } }
# [ doc = "Bit 1 - Transmit START condition in master mode" ] # [ inline ( always ) ] pub fn uctxstt ( & mut self ) -> UCTXSTT_W { UCTXSTT_W { w : self } }
# [ doc = "Bit 2 - Transmit STOP condition in master mode" ] # [ inline ( always ) ] pub fn uctxstp ( & mut self ) -> UCTXSTP_W { UCTXSTP_W { w : self } }
# [ doc = "Bit 3 - Transmit a NACK" ] # [ inline ( always ) ] pub fn uctxnack ( & mut self ) -> UCTXNACK_W { UCTXNACK_W { w : self } }
# [ doc = "Bit 4 - Transmitter/receiver" ] # [ inline ( always ) ] pub fn uctr ( & mut self ) -> UCTR_W { UCTR_W { w : self } }
# [ doc = "Bit 5 - Transmit ACK condition in slave mode" ] # [ inline ( always ) ] pub fn uctxack ( & mut self ) -> UCTXACK_W { UCTXACK_W { w : self } }
# [ doc = "Bits 6:7 - eUSCI_B clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & mut self ) -> UCSSEL_W { UCSSEL_W { w : self } }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & mut self ) -> UCSYNC_W { UCSYNC_W { w : self } }
# [ doc = "Bits 9:10 - eUSCI_B mode" ] # [ inline ( always ) ] pub fn ucmode ( & mut self ) -> UCMODE_W { UCMODE_W { w : self } }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & mut self ) -> UCMST_W { UCMST_W { w : self } }
# [ doc = "Bit 13 - Multi-master environment select" ] # [ inline ( always ) ] pub fn ucmm ( & mut self ) -> UCMM_W { UCMM_W { w : self } }
# [ doc = "Bit 14 - Slave addressing mode select" ] # [ inline ( always ) ] pub fn ucsla10 ( & mut self ) -> UCSLA10_W { UCSLA10_W { w : self } }
# [ doc = "Bit 15 - Own addressing mode select" ] # [ inline ( always ) ] pub fn uca10 ( & mut self ) -> UCA10_W { UCA10_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Control Word Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ctlw0_spi](ucb0ctlw0_spi) module" ] pub type UCB0CTLW0_SPI = crate :: Reg < u16 , _UCB0CTLW0_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0CTLW0_SPI ;
# [ doc = "`read()` method returns [ucb0ctlw0_spi::R](ucb0ctlw0_spi::R) reader structure" ] impl crate :: Readable for UCB0CTLW0_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb0ctlw0_spi::W](ucb0ctlw0_spi::W) writer structure" ] impl crate :: Writable for UCB0CTLW0_SPI { }
# [ doc = "eUSCI_Bx Control Word Register 0" ] pub mod ucb0ctlw0_spi {
# [ doc = "Reader of register UCB0CTLW0_SPI" ] pub type R = crate :: R < u16 , super :: UCB0CTLW0_SPI > ;
# [ doc = "Writer for register UCB0CTLW0_SPI" ] pub type W = crate :: W < u16 , super :: UCB0CTLW0_SPI > ;
# [ doc = "Register UCB0CTLW0_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0CTLW0_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Software reset enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSWRST_A { # [ doc = "0: Disabled. eUSCI_B reset released for operation" ] DISABLE = 0 , # [ doc = "1: Enabled. eUSCI_B logic held in reset state" ] ENABLE = 1 } impl From < UCSWRST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSWRST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSWRST`" ] pub type UCSWRST_R = crate :: R < bool , UCSWRST_A > ; impl UCSWRST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSWRST_A { match self . bits { false => UCSWRST_A :: DISABLE , true => UCSWRST_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCSWRST_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCSWRST_A :: ENABLE } }
# [ doc = "Write proxy for field `UCSWRST`" ] pub struct UCSWRST_W < 'a > { w : & 'a mut W , } impl < 'a > UCSWRST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSWRST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled. eUSCI_B reset released for operation" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: DISABLE ) } # [ doc = "Enabled. eUSCI_B logic held in reset state" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "STE mode select in master mode.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTEM_A { # [ doc = "0: STE pin is used to prevent conflicts with other masters" ] UCSTEM_0 = 0 , # [ doc = "1: STE pin is used to generate the enable signal for a 4-wire slave" ] UCSTEM_1 = 1 } impl From < UCSTEM_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTEM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTEM`" ] pub type UCSTEM_R = crate :: R < bool , UCSTEM_A > ; impl UCSTEM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTEM_A { match self . bits { false => UCSTEM_A :: UCSTEM_0 , true => UCSTEM_A :: UCSTEM_1 } } # [ doc = "Checks if the value of the field is `UCSTEM_0`" ] # [ inline ( always ) ] pub fn is_ucstem_0 ( & self ) -> bool { * self == UCSTEM_A :: UCSTEM_0 } # [ doc = "Checks if the value of the field is `UCSTEM_1`" ] # [ inline ( always ) ] pub fn is_ucstem_1 ( & self ) -> bool { * self == UCSTEM_A :: UCSTEM_1 } }
# [ doc = "Write proxy for field `UCSTEM`" ] pub struct UCSTEM_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTEM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTEM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "STE pin is used to prevent conflicts with other masters" ] # [ inline ( always ) ] pub fn ucstem_0 ( self ) -> & 'a mut W { self . variant ( UCSTEM_A :: UCSTEM_0 ) } # [ doc = "STE pin is used to generate the enable signal for a 4-wire slave" ] # [ inline ( always ) ] pub fn ucstem_1 ( self ) -> & 'a mut W { self . variant ( UCSTEM_A :: UCSTEM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "eUSCI_B clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCSSEL_A { # [ doc = "0: Reserved" ] UCSSEL_0 = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: SMCLK" ] UCSSEL_3 = 3 } impl From < UCSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCSSEL`" ] pub type UCSSEL_R = crate :: R < u8 , UCSSEL_A > ; impl UCSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSSEL_A { match self . bits { 0 => UCSSEL_A :: UCSSEL_0 , 1 => UCSSEL_A :: ACLK , 2 => UCSSEL_A :: SMCLK , 3 => UCSSEL_A :: UCSSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCSSEL_0`" ] # [ inline ( always ) ] pub fn is_ucssel_0 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_0 } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == UCSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == UCSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `UCSSEL_3`" ] # [ inline ( always ) ] pub fn is_ucssel_3 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_3 } }
# [ doc = "Write proxy for field `UCSSEL`" ] pub struct UCSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > UCSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn ucssel_0 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_0 ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: SMCLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn ucssel_3 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Synchronous mode enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSYNC_A { # [ doc = "0: Asynchronous mode" ] ASYNC = 0 , # [ doc = "1: Synchronous mode" ] SYNC = 1 } impl From < UCSYNC_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSYNC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSYNC`" ] pub type UCSYNC_R = crate :: R < bool , UCSYNC_A > ; impl UCSYNC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSYNC_A { match self . bits { false => UCSYNC_A :: ASYNC , true => UCSYNC_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == UCSYNC_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == UCSYNC_A :: SYNC } }
# [ doc = "Write proxy for field `UCSYNC`" ] pub struct UCSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > UCSYNC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSYNC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous mode" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: ASYNC ) } # [ doc = "Synchronous mode" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "eUSCI mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCMODE_A { # [ doc = "0: 3-pin SPI" ] UCMODE_0 = 0 , # [ doc = "1: 4-pin SPI with UCxSTE active high: Slave enabled when UCxSTE = 1" ] UCMODE_1 = 1 , # [ doc = "2: 4-pin SPI with UCxSTE active low: Slave enabled when UCxSTE = 0" ] UCMODE_2 = 2 , # [ doc = "3: I2C mode" ] UCMODE_3 = 3 } impl From < UCMODE_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCMODE_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCMODE`" ] pub type UCMODE_R = crate :: R < u8 , UCMODE_A > ; impl UCMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMODE_A { match self . bits { 0 => UCMODE_A :: UCMODE_0 , 1 => UCMODE_A :: UCMODE_1 , 2 => UCMODE_A :: UCMODE_2 , 3 => UCMODE_A :: UCMODE_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCMODE_0`" ] # [ inline ( always ) ] pub fn is_ucmode_0 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_0 } # [ doc = "Checks if the value of the field is `UCMODE_1`" ] # [ inline ( always ) ] pub fn is_ucmode_1 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_1 } # [ doc = "Checks if the value of the field is `UCMODE_2`" ] # [ inline ( always ) ] pub fn is_ucmode_2 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_2 } # [ doc = "Checks if the value of the field is `UCMODE_3`" ] # [ inline ( always ) ] pub fn is_ucmode_3 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_3 } }
# [ doc = "Write proxy for field `UCMODE`" ] pub struct UCMODE_W < 'a > { w : & 'a mut W , } impl < 'a > UCMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMODE_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "3-pin SPI" ] # [ inline ( always ) ] pub fn ucmode_0 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_0 ) } # [ doc = "4-pin SPI with UCxSTE active high: Slave enabled when UCxSTE = 1" ] # [ inline ( always ) ] pub fn ucmode_1 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_1 ) } # [ doc = "4-pin SPI with UCxSTE active low: Slave enabled when UCxSTE = 0" ] # [ inline ( always ) ] pub fn ucmode_2 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_2 ) } # [ doc = "I2C mode" ] # [ inline ( always ) ] pub fn ucmode_3 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Master mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMST_A { # [ doc = "0: Slave mode" ] SLAVE = 0 , # [ doc = "1: Master mode" ] MASTER = 1 } impl From < UCMST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMST`" ] pub type UCMST_R = crate :: R < bool , UCMST_A > ; impl UCMST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMST_A { match self . bits { false => UCMST_A :: SLAVE , true => UCMST_A :: MASTER } } # [ doc = "Checks if the value of the field is `SLAVE`" ] # [ inline ( always ) ] pub fn is_slave ( & self ) -> bool { * self == UCMST_A :: SLAVE } # [ doc = "Checks if the value of the field is `MASTER`" ] # [ inline ( always ) ] pub fn is_master ( & self ) -> bool { * self == UCMST_A :: MASTER } }
# [ doc = "Write proxy for field `UCMST`" ] pub struct UCMST_W < 'a > { w : & 'a mut W , } impl < 'a > UCMST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Slave mode" ] # [ inline ( always ) ] pub fn slave ( self ) -> & 'a mut W { self . variant ( UCMST_A :: SLAVE ) } # [ doc = "Master mode" ] # [ inline ( always ) ] pub fn master ( self ) -> & 'a mut W { self . variant ( UCMST_A :: MASTER ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Character length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UC7BIT_A { # [ doc = "0: 8-bit data" ] _8BIT = 0 , # [ doc = "1: 7-bit data" ] _7BIT = 1 } impl From < UC7BIT_A > for bool { # [ inline ( always ) ] fn from ( variant : UC7BIT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UC7BIT`" ] pub type UC7BIT_R = crate :: R < bool , UC7BIT_A > ; impl UC7BIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UC7BIT_A { match self . bits { false => UC7BIT_A :: _8BIT , true => UC7BIT_A :: _7BIT } } # [ doc = "Checks if the value of the field is `_8BIT`" ] # [ inline ( always ) ] pub fn is_8bit ( & self ) -> bool { * self == UC7BIT_A :: _8BIT } # [ doc = "Checks if the value of the field is `_7BIT`" ] # [ inline ( always ) ] pub fn is_7bit ( & self ) -> bool { * self == UC7BIT_A :: _7BIT } }
# [ doc = "Write proxy for field `UC7BIT`" ] pub struct UC7BIT_W < 'a > { w : & 'a mut W , } impl < 'a > UC7BIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UC7BIT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "8-bit data" ] # [ inline ( always ) ] pub fn _8bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _8BIT ) } # [ doc = "7-bit data" ] # [ inline ( always ) ] pub fn _7bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _7BIT ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "MSB first select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMSB_A { # [ doc = "0: LSB first" ] UCMSB_0 = 0 , # [ doc = "1: MSB first" ] UCMSB_1 = 1 } impl From < UCMSB_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMSB_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMSB`" ] pub type UCMSB_R = crate :: R < bool , UCMSB_A > ; impl UCMSB_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMSB_A { match self . bits { false => UCMSB_A :: UCMSB_0 , true => UCMSB_A :: UCMSB_1 } } # [ doc = "Checks if the value of the field is `UCMSB_0`" ] # [ inline ( always ) ] pub fn is_ucmsb_0 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_0 } # [ doc = "Checks if the value of the field is `UCMSB_1`" ] # [ inline ( always ) ] pub fn is_ucmsb_1 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_1 } }
# [ doc = "Write proxy for field `UCMSB`" ] pub struct UCMSB_W < 'a > { w : & 'a mut W , } impl < 'a > UCMSB_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMSB_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "LSB first" ] # [ inline ( always ) ] pub fn ucmsb_0 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_0 ) } # [ doc = "MSB first" ] # [ inline ( always ) ] pub fn ucmsb_1 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Clock polarity select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCKPL_A { # [ doc = "0: The inactive state is low" ] LOW = 0 , # [ doc = "1: The inactive state is high" ] HIGH = 1 } impl From < UCCKPL_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCKPL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCKPL`" ] pub type UCCKPL_R = crate :: R < bool , UCCKPL_A > ; impl UCCKPL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCKPL_A { match self . bits { false => UCCKPL_A :: LOW , true => UCCKPL_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == UCCKPL_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == UCCKPL_A :: HIGH } }
# [ doc = "Write proxy for field `UCCKPL`" ] pub struct UCCKPL_W < 'a > { w : & 'a mut W , } impl < 'a > UCCKPL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCKPL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The inactive state is low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( UCCKPL_A :: LOW ) } # [ doc = "The inactive state is high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( UCCKPL_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Clock phase select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCKPH_A { # [ doc = "0: Data is changed on the first UCLK edge and captured on the following edge." ] UCCKPH_0 = 0 , # [ doc = "1: Data is captured on the first UCLK edge and changed on the following edge." ] UCCKPH_1 = 1 } impl From < UCCKPH_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCKPH_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCKPH`" ] pub type UCCKPH_R = crate :: R < bool , UCCKPH_A > ; impl UCCKPH_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCKPH_A { match self . bits { false => UCCKPH_A :: UCCKPH_0 , true => UCCKPH_A :: UCCKPH_1 } } # [ doc = "Checks if the value of the field is `UCCKPH_0`" ] # [ inline ( always ) ] pub fn is_ucckph_0 ( & self ) -> bool { * self == UCCKPH_A :: UCCKPH_0 } # [ doc = "Checks if the value of the field is `UCCKPH_1`" ] # [ inline ( always ) ] pub fn is_ucckph_1 ( & self ) -> bool { * self == UCCKPH_A :: UCCKPH_1 } }
# [ doc = "Write proxy for field `UCCKPH`" ] pub struct UCCKPH_W < 'a > { w : & 'a mut W , } impl < 'a > UCCKPH_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCKPH_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Data is changed on the first UCLK edge and captured on the following edge." ] # [ inline ( always ) ] pub fn ucckph_0 ( self ) -> & 'a mut W { self . variant ( UCCKPH_A :: UCCKPH_0 ) } # [ doc = "Data is captured on the first UCLK edge and changed on the following edge." ] # [ inline ( always ) ] pub fn ucckph_1 ( self ) -> & 'a mut W { self . variant ( UCCKPH_A :: UCCKPH_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & self ) -> UCSWRST_R { UCSWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - STE mode select in master mode." ] # [ inline ( always ) ] pub fn ucstem ( & self ) -> UCSTEM_R { UCSTEM_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - eUSCI_B clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & self ) -> UCSSEL_R { UCSSEL_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & self ) -> UCSYNC_R { UCSYNC_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - eUSCI mode" ] # [ inline ( always ) ] pub fn ucmode ( & self ) -> UCMODE_R { UCMODE_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & self ) -> UCMST_R { UCMST_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & self ) -> UC7BIT_R { UC7BIT_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & self ) -> UCMSB_R { UCMSB_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Clock polarity select" ] # [ inline ( always ) ] pub fn ucckpl ( & self ) -> UCCKPL_R { UCCKPL_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Clock phase select" ] # [ inline ( always ) ] pub fn ucckph ( & self ) -> UCCKPH_R { UCCKPH_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & mut self ) -> UCSWRST_W { UCSWRST_W { w : self } }
# [ doc = "Bit 1 - STE mode select in master mode." ] # [ inline ( always ) ] pub fn ucstem ( & mut self ) -> UCSTEM_W { UCSTEM_W { w : self } }
# [ doc = "Bits 6:7 - eUSCI_B clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & mut self ) -> UCSSEL_W { UCSSEL_W { w : self } }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & mut self ) -> UCSYNC_W { UCSYNC_W { w : self } }
# [ doc = "Bits 9:10 - eUSCI mode" ] # [ inline ( always ) ] pub fn ucmode ( & mut self ) -> UCMODE_W { UCMODE_W { w : self } }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & mut self ) -> UCMST_W { UCMST_W { w : self } }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & mut self ) -> UC7BIT_W { UC7BIT_W { w : self } }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & mut self ) -> UCMSB_W { UCMSB_W { w : self } }
# [ doc = "Bit 14 - Clock polarity select" ] # [ inline ( always ) ] pub fn ucckpl ( & mut self ) -> UCCKPL_W { UCCKPL_W { w : self } }
# [ doc = "Bit 15 - Clock phase select" ] # [ inline ( always ) ] pub fn ucckph ( & mut self ) -> UCCKPH_W { UCCKPH_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Control Word Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ctlw1](ucb0ctlw1) module" ] pub type UCB0CTLW1 = crate :: Reg < u16 , _UCB0CTLW1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0CTLW1 ;
# [ doc = "`read()` method returns [ucb0ctlw1::R](ucb0ctlw1::R) reader structure" ] impl crate :: Readable for UCB0CTLW1 { }
# [ doc = "`write(|w| ..)` method takes [ucb0ctlw1::W](ucb0ctlw1::W) writer structure" ] impl crate :: Writable for UCB0CTLW1 { }
# [ doc = "eUSCI_Bx Control Word Register 1" ] pub mod ucb0ctlw1 {
# [ doc = "Reader of register UCB0CTLW1" ] pub type R = crate :: R < u16 , super :: UCB0CTLW1 > ;
# [ doc = "Writer for register UCB0CTLW1" ] pub type W = crate :: W < u16 , super :: UCB0CTLW1 > ;
# [ doc = "Register UCB0CTLW1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0CTLW1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Deglitch time\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCGLIT_A { # [ doc = "0: 50 ns" ] UCGLIT_0 = 0 , # [ doc = "1: 25 ns" ] UCGLIT_1 = 1 , # [ doc = "2: 12.5 ns" ] UCGLIT_2 = 2 , # [ doc = "3: 6.25 ns" ] UCGLIT_3 = 3 } impl From < UCGLIT_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCGLIT_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCGLIT`" ] pub type UCGLIT_R = crate :: R < u8 , UCGLIT_A > ; impl UCGLIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCGLIT_A { match self . bits { 0 => UCGLIT_A :: UCGLIT_0 , 1 => UCGLIT_A :: UCGLIT_1 , 2 => UCGLIT_A :: UCGLIT_2 , 3 => UCGLIT_A :: UCGLIT_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCGLIT_0`" ] # [ inline ( always ) ] pub fn is_ucglit_0 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_0 } # [ doc = "Checks if the value of the field is `UCGLIT_1`" ] # [ inline ( always ) ] pub fn is_ucglit_1 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_1 } # [ doc = "Checks if the value of the field is `UCGLIT_2`" ] # [ inline ( always ) ] pub fn is_ucglit_2 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_2 } # [ doc = "Checks if the value of the field is `UCGLIT_3`" ] # [ inline ( always ) ] pub fn is_ucglit_3 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_3 } }
# [ doc = "Write proxy for field `UCGLIT`" ] pub struct UCGLIT_W < 'a > { w : & 'a mut W , } impl < 'a > UCGLIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCGLIT_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "50 ns" ] # [ inline ( always ) ] pub fn ucglit_0 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_0 ) } # [ doc = "25 ns" ] # [ inline ( always ) ] pub fn ucglit_1 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_1 ) } # [ doc = "12.5 ns" ] # [ inline ( always ) ] pub fn ucglit_2 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_2 ) } # [ doc = "6.25 ns" ] # [ inline ( always ) ] pub fn ucglit_3 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Automatic STOP condition generation\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCASTP_A { # [ doc = "0: No automatic STOP generation. The STOP condition is generated after the user sets the UCTXSTP bit. The value in UCBxTBCNT is a don't care." ] UCASTP_0 = 0 , # [ doc = "1: UCBCNTIFG is set with the byte counter reaches the threshold defined in UCBxTBCNT" ] UCASTP_1 = 1 , # [ doc = "2: A STOP condition is generated automatically after the byte counter value reached UCBxTBCNT. UCBCNTIFG is set with the byte counter reaching the threshold" ] UCASTP_2 = 2 , # [ doc = "3: Reserved" ] UCASTP_3 = 3 } impl From < UCASTP_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCASTP_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCASTP`" ] pub type UCASTP_R = crate :: R < u8 , UCASTP_A > ; impl UCASTP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCASTP_A { match self . bits { 0 => UCASTP_A :: UCASTP_0 , 1 => UCASTP_A :: UCASTP_1 , 2 => UCASTP_A :: UCASTP_2 , 3 => UCASTP_A :: UCASTP_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCASTP_0`" ] # [ inline ( always ) ] pub fn is_ucastp_0 ( & self ) -> bool { * self == UCASTP_A :: UCASTP_0 } # [ doc = "Checks if the value of the field is `UCASTP_1`" ] # [ inline ( always ) ] pub fn is_ucastp_1 ( & self ) -> bool { * self == UCASTP_A :: UCASTP_1 } # [ doc = "Checks if the value of the field is `UCASTP_2`" ] # [ inline ( always ) ] pub fn is_ucastp_2 ( & self ) -> bool { * self == UCASTP_A :: UCASTP_2 } # [ doc = "Checks if the value of the field is `UCASTP_3`" ] # [ inline ( always ) ] pub fn is_ucastp_3 ( & self ) -> bool { * self == UCASTP_A :: UCASTP_3 } }
# [ doc = "Write proxy for field `UCASTP`" ] pub struct UCASTP_W < 'a > { w : & 'a mut W , } impl < 'a > UCASTP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCASTP_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No automatic STOP generation. The STOP condition is generated after the user sets the UCTXSTP bit. The value in UCBxTBCNT is a don't care." ] # [ inline ( always ) ] pub fn ucastp_0 ( self ) -> & 'a mut W { self . variant ( UCASTP_A :: UCASTP_0 ) } # [ doc = "UCBCNTIFG is set with the byte counter reaches the threshold defined in UCBxTBCNT" ] # [ inline ( always ) ] pub fn ucastp_1 ( self ) -> & 'a mut W { self . variant ( UCASTP_A :: UCASTP_1 ) } # [ doc = "A STOP condition is generated automatically after the byte counter value reached UCBxTBCNT. UCBCNTIFG is set with the byte counter reaching the threshold" ] # [ inline ( always ) ] pub fn ucastp_2 ( self ) -> & 'a mut W { self . variant ( UCASTP_A :: UCASTP_2 ) } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn ucastp_3 ( self ) -> & 'a mut W { self . variant ( UCASTP_A :: UCASTP_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u16 ) & 0x03 ) << 2 ) ; self . w } }
# [ doc = "SW or HW ACK control\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSWACK_A { # [ doc = "0: The address acknowledge of the slave is controlled by the eUSCI_B module" ] UCSWACK_0 = 0 , # [ doc = "1: The user needs to trigger the sending of the address ACK by issuing UCTXACK" ] UCSWACK_1 = 1 } impl From < UCSWACK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSWACK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSWACK`" ] pub type UCSWACK_R = crate :: R < bool , UCSWACK_A > ; impl UCSWACK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSWACK_A { match self . bits { false => UCSWACK_A :: UCSWACK_0 , true => UCSWACK_A :: UCSWACK_1 } } # [ doc = "Checks if the value of the field is `UCSWACK_0`" ] # [ inline ( always ) ] pub fn is_ucswack_0 ( & self ) -> bool { * self == UCSWACK_A :: UCSWACK_0 } # [ doc = "Checks if the value of the field is `UCSWACK_1`" ] # [ inline ( always ) ] pub fn is_ucswack_1 ( & self ) -> bool { * self == UCSWACK_A :: UCSWACK_1 } }
# [ doc = "Write proxy for field `UCSWACK`" ] pub struct UCSWACK_W < 'a > { w : & 'a mut W , } impl < 'a > UCSWACK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSWACK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The address acknowledge of the slave is controlled by the eUSCI_B module" ] # [ inline ( always ) ] pub fn ucswack_0 ( self ) -> & 'a mut W { self . variant ( UCSWACK_A :: UCSWACK_0 ) } # [ doc = "The user needs to trigger the sending of the address ACK by issuing UCTXACK" ] # [ inline ( always ) ] pub fn ucswack_1 ( self ) -> & 'a mut W { self . variant ( UCSWACK_A :: UCSWACK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "ACK all master bytes\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTPNACK_A { # [ doc = "0: Send a non-acknowledge before the STOP condition as a master receiver (conform to I2C standard)" ] UCSTPNACK_0 = 0 , # [ doc = "1: All bytes are acknowledged by the eUSCI_B when configured as master receiver" ] UCSTPNACK_1 = 1 } impl From < UCSTPNACK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTPNACK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTPNACK`" ] pub type UCSTPNACK_R = crate :: R < bool , UCSTPNACK_A > ; impl UCSTPNACK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTPNACK_A { match self . bits { false => UCSTPNACK_A :: UCSTPNACK_0 , true => UCSTPNACK_A :: UCSTPNACK_1 } } # [ doc = "Checks if the value of the field is `UCSTPNACK_0`" ] # [ inline ( always ) ] pub fn is_ucstpnack_0 ( & self ) -> bool { * self == UCSTPNACK_A :: UCSTPNACK_0 } # [ doc = "Checks if the value of the field is `UCSTPNACK_1`" ] # [ inline ( always ) ] pub fn is_ucstpnack_1 ( & self ) -> bool { * self == UCSTPNACK_A :: UCSTPNACK_1 } }
# [ doc = "Write proxy for field `UCSTPNACK`" ] pub struct UCSTPNACK_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTPNACK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTPNACK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Send a non-acknowledge before the STOP condition as a master receiver (conform to I2C standard)" ] # [ inline ( always ) ] pub fn ucstpnack_0 ( self ) -> & 'a mut W { self . variant ( UCSTPNACK_A :: UCSTPNACK_0 ) } # [ doc = "All bytes are acknowledged by the eUSCI_B when configured as master receiver" ] # [ inline ( always ) ] pub fn ucstpnack_1 ( self ) -> & 'a mut W { self . variant ( UCSTPNACK_A :: UCSTPNACK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Clock low timeout select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCCLTO_A { # [ doc = "0: Disable clock low timeout counter" ] UCCLTO_0 = 0 , # [ doc = "1: 135 000 SYSCLK cycles (approximately 28 ms)" ] UCCLTO_1 = 1 , # [ doc = "2: 150 000 SYSCLK cycles (approximately 31 ms)" ] UCCLTO_2 = 2 , # [ doc = "3: 165 000 SYSCLK cycles (approximately 34 ms)" ] UCCLTO_3 = 3 } impl From < UCCLTO_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCCLTO_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCCLTO`" ] pub type UCCLTO_R = crate :: R < u8 , UCCLTO_A > ; impl UCCLTO_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCLTO_A { match self . bits { 0 => UCCLTO_A :: UCCLTO_0 , 1 => UCCLTO_A :: UCCLTO_1 , 2 => UCCLTO_A :: UCCLTO_2 , 3 => UCCLTO_A :: UCCLTO_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCCLTO_0`" ] # [ inline ( always ) ] pub fn is_ucclto_0 ( & self ) -> bool { * self == UCCLTO_A :: UCCLTO_0 } # [ doc = "Checks if the value of the field is `UCCLTO_1`" ] # [ inline ( always ) ] pub fn is_ucclto_1 ( & self ) -> bool { * self == UCCLTO_A :: UCCLTO_1 } # [ doc = "Checks if the value of the field is `UCCLTO_2`" ] # [ inline ( always ) ] pub fn is_ucclto_2 ( & self ) -> bool { * self == UCCLTO_A :: UCCLTO_2 } # [ doc = "Checks if the value of the field is `UCCLTO_3`" ] # [ inline ( always ) ] pub fn is_ucclto_3 ( & self ) -> bool { * self == UCCLTO_A :: UCCLTO_3 } }
# [ doc = "Write proxy for field `UCCLTO`" ] pub struct UCCLTO_W < 'a > { w : & 'a mut W , } impl < 'a > UCCLTO_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCLTO_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Disable clock low timeout counter" ] # [ inline ( always ) ] pub fn ucclto_0 ( self ) -> & 'a mut W { self . variant ( UCCLTO_A :: UCCLTO_0 ) } # [ doc = "135 000 SYSCLK cycles (approximately 28 ms)" ] # [ inline ( always ) ] pub fn ucclto_1 ( self ) -> & 'a mut W { self . variant ( UCCLTO_A :: UCCLTO_1 ) } # [ doc = "150 000 SYSCLK cycles (approximately 31 ms)" ] # [ inline ( always ) ] pub fn ucclto_2 ( self ) -> & 'a mut W { self . variant ( UCCLTO_A :: UCCLTO_2 ) } # [ doc = "165 000 SYSCLK cycles (approximately 34 ms)" ] # [ inline ( always ) ] pub fn ucclto_3 ( self ) -> & 'a mut W { self . variant ( UCCLTO_A :: UCCLTO_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Early UCTXIFG0\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCETXINT_A { # [ doc = "0: UCTXIFGx is set after an address match with UCxI2COAx and the direction bit indicating slave transmit" ] UCETXINT_0 = 0 , # [ doc = "1: UCTXIFG0 is set for each START condition" ] UCETXINT_1 = 1 } impl From < UCETXINT_A > for bool { # [ inline ( always ) ] fn from ( variant : UCETXINT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCETXINT`" ] pub type UCETXINT_R = crate :: R < bool , UCETXINT_A > ; impl UCETXINT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCETXINT_A { match self . bits { false => UCETXINT_A :: UCETXINT_0 , true => UCETXINT_A :: UCETXINT_1 } } # [ doc = "Checks if the value of the field is `UCETXINT_0`" ] # [ inline ( always ) ] pub fn is_ucetxint_0 ( & self ) -> bool { * self == UCETXINT_A :: UCETXINT_0 } # [ doc = "Checks if the value of the field is `UCETXINT_1`" ] # [ inline ( always ) ] pub fn is_ucetxint_1 ( & self ) -> bool { * self == UCETXINT_A :: UCETXINT_1 } }
# [ doc = "Write proxy for field `UCETXINT`" ] pub struct UCETXINT_W < 'a > { w : & 'a mut W , } impl < 'a > UCETXINT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCETXINT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "UCTXIFGx is set after an address match with UCxI2COAx and the direction bit indicating slave transmit" ] # [ inline ( always ) ] pub fn ucetxint_0 ( self ) -> & 'a mut W { self . variant ( UCETXINT_A :: UCETXINT_0 ) } # [ doc = "UCTXIFG0 is set for each START condition" ] # [ inline ( always ) ] pub fn ucetxint_1 ( self ) -> & 'a mut W { self . variant ( UCETXINT_A :: UCETXINT_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Deglitch time" ] # [ inline ( always ) ] pub fn ucglit ( & self ) -> UCGLIT_R { UCGLIT_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 2:3 - Automatic STOP condition generation" ] # [ inline ( always ) ] pub fn ucastp ( & self ) -> UCASTP_R { UCASTP_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 4 - SW or HW ACK control" ] # [ inline ( always ) ] pub fn ucswack ( & self ) -> UCSWACK_R { UCSWACK_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - ACK all master bytes" ] # [ inline ( always ) ] pub fn ucstpnack ( & self ) -> UCSTPNACK_R { UCSTPNACK_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - Clock low timeout select" ] # [ inline ( always ) ] pub fn ucclto ( & self ) -> UCCLTO_R { UCCLTO_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Early UCTXIFG0" ] # [ inline ( always ) ] pub fn ucetxint ( & self ) -> UCETXINT_R { UCETXINT_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:1 - Deglitch time" ] # [ inline ( always ) ] pub fn ucglit ( & mut self ) -> UCGLIT_W { UCGLIT_W { w : self } }
# [ doc = "Bits 2:3 - Automatic STOP condition generation" ] # [ inline ( always ) ] pub fn ucastp ( & mut self ) -> UCASTP_W { UCASTP_W { w : self } }
# [ doc = "Bit 4 - SW or HW ACK control" ] # [ inline ( always ) ] pub fn ucswack ( & mut self ) -> UCSWACK_W { UCSWACK_W { w : self } }
# [ doc = "Bit 5 - ACK all master bytes" ] # [ inline ( always ) ] pub fn ucstpnack ( & mut self ) -> UCSTPNACK_W { UCSTPNACK_W { w : self } }
# [ doc = "Bits 6:7 - Clock low timeout select" ] # [ inline ( always ) ] pub fn ucclto ( & mut self ) -> UCCLTO_W { UCCLTO_W { w : self } }
# [ doc = "Bit 8 - Early UCTXIFG0" ] # [ inline ( always ) ] pub fn ucetxint ( & mut self ) -> UCETXINT_W { UCETXINT_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Baud Rate Control Word Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0brw](ucb0brw) module" ] pub type UCB0BRW = crate :: Reg < u16 , _UCB0BRW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0BRW ;
# [ doc = "`read()` method returns [ucb0brw::R](ucb0brw::R) reader structure" ] impl crate :: Readable for UCB0BRW { }
# [ doc = "`write(|w| ..)` method takes [ucb0brw::W](ucb0brw::W) writer structure" ] impl crate :: Writable for UCB0BRW { }
# [ doc = "eUSCI_Bx Baud Rate Control Word Register" ] pub mod ucb0brw {
# [ doc = "Reader of register UCB0BRW" ] pub type R = crate :: R < u16 , super :: UCB0BRW > ;
# [ doc = "Writer for register UCB0BRW" ] pub type W = crate :: W < u16 , super :: UCB0BRW > ;
# [ doc = "Register UCB0BRW `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0BRW { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "eUSCI_Bx Bit Rate Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0brw_spi](ucb0brw_spi) module" ] pub type UCB0BRW_SPI = crate :: Reg < u16 , _UCB0BRW_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0BRW_SPI ;
# [ doc = "`read()` method returns [ucb0brw_spi::R](ucb0brw_spi::R) reader structure" ] impl crate :: Readable for UCB0BRW_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb0brw_spi::W](ucb0brw_spi::W) writer structure" ] impl crate :: Writable for UCB0BRW_SPI { }
# [ doc = "eUSCI_Bx Bit Rate Control Register 1" ] pub mod ucb0brw_spi {
# [ doc = "Reader of register UCB0BRW_SPI" ] pub type R = crate :: R < u16 , super :: UCB0BRW_SPI > ;
# [ doc = "Writer for register UCB0BRW_SPI" ] pub type W = crate :: W < u16 , super :: UCB0BRW_SPI > ;
# [ doc = "Register UCB0BRW_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0BRW_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "eUSCI_Bx Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0statw](ucb0statw) module" ] pub type UCB0STATW = crate :: Reg < u16 , _UCB0STATW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0STATW ;
# [ doc = "`read()` method returns [ucb0statw::R](ucb0statw::R) reader structure" ] impl crate :: Readable for UCB0STATW { }
# [ doc = "eUSCI_Bx Status Register" ] pub mod ucb0statw {
# [ doc = "Reader of register UCB0STATW" ] pub type R = crate :: R < u16 , super :: UCB0STATW > ;
# [ doc = "Bus busy\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBBUSY_A { # [ doc = "0: Bus inactive" ] IDLE = 0 , # [ doc = "1: Bus busy" ] BUSY = 1 } impl From < UCBBUSY_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBBUSY_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBBUSY`" ] pub type UCBBUSY_R = crate :: R < bool , UCBBUSY_A > ; impl UCBBUSY_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBBUSY_A { match self . bits { false => UCBBUSY_A :: IDLE , true => UCBBUSY_A :: BUSY } } # [ doc = "Checks if the value of the field is `IDLE`" ] # [ inline ( always ) ] pub fn is_idle ( & self ) -> bool { * self == UCBBUSY_A :: IDLE } # [ doc = "Checks if the value of the field is `BUSY`" ] # [ inline ( always ) ] pub fn is_busy ( & self ) -> bool { * self == UCBBUSY_A :: BUSY } }
# [ doc = "General call address received\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCGC_A { # [ doc = "0: No general call address received" ] UCGC_0 = 0 , # [ doc = "1: General call address received" ] UCGC_1 = 1 } impl From < UCGC_A > for bool { # [ inline ( always ) ] fn from ( variant : UCGC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCGC`" ] pub type UCGC_R = crate :: R < bool , UCGC_A > ; impl UCGC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCGC_A { match self . bits { false => UCGC_A :: UCGC_0 , true => UCGC_A :: UCGC_1 } } # [ doc = "Checks if the value of the field is `UCGC_0`" ] # [ inline ( always ) ] pub fn is_ucgc_0 ( & self ) -> bool { * self == UCGC_A :: UCGC_0 } # [ doc = "Checks if the value of the field is `UCGC_1`" ] # [ inline ( always ) ] pub fn is_ucgc_1 ( & self ) -> bool { * self == UCGC_A :: UCGC_1 } }
# [ doc = "SCL low\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSCLLOW_A { # [ doc = "0: SCL is not held low" ] UCSCLLOW_0 = 0 , # [ doc = "1: SCL is held low" ] UCSCLLOW_1 = 1 } impl From < UCSCLLOW_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSCLLOW_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSCLLOW`" ] pub type UCSCLLOW_R = crate :: R < bool , UCSCLLOW_A > ; impl UCSCLLOW_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSCLLOW_A { match self . bits { false => UCSCLLOW_A :: UCSCLLOW_0 , true => UCSCLLOW_A :: UCSCLLOW_1 } } # [ doc = "Checks if the value of the field is `UCSCLLOW_0`" ] # [ inline ( always ) ] pub fn is_ucscllow_0 ( & self ) -> bool { * self == UCSCLLOW_A :: UCSCLLOW_0 } # [ doc = "Checks if the value of the field is `UCSCLLOW_1`" ] # [ inline ( always ) ] pub fn is_ucscllow_1 ( & self ) -> bool { * self == UCSCLLOW_A :: UCSCLLOW_1 } }
# [ doc = "Reader of field `UCBCNT`" ] pub type UCBCNT_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bit 4 - Bus busy" ] # [ inline ( always ) ] pub fn ucbbusy ( & self ) -> UCBBUSY_R { UCBBUSY_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - General call address received" ] # [ inline ( always ) ] pub fn ucgc ( & self ) -> UCGC_R { UCGC_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - SCL low" ] # [ inline ( always ) ] pub fn ucscllow ( & self ) -> UCSCLLOW_R { UCSCLLOW_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:15 - Hardware byte counter value" ] # [ inline ( always ) ] pub fn ucbcnt ( & self ) -> UCBCNT_R { UCBCNT_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
}
}
# [ doc = "UCB0STATW_SPI\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0statw_spi](ucb0statw_spi) module" ] pub type UCB0STATW_SPI = crate :: Reg < u16 , _UCB0STATW_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0STATW_SPI ;
# [ doc = "`read()` method returns [ucb0statw_spi::R](ucb0statw_spi::R) reader structure" ] impl crate :: Readable for UCB0STATW_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb0statw_spi::W](ucb0statw_spi::W) writer structure" ] impl crate :: Writable for UCB0STATW_SPI { }
# [ doc = "UCB0STATW_SPI" ] pub mod ucb0statw_spi {
# [ doc = "Reader of register UCB0STATW_SPI" ] pub type R = crate :: R < u16 , super :: UCB0STATW_SPI > ;
# [ doc = "Writer for register UCB0STATW_SPI" ] pub type W = crate :: W < u16 , super :: UCB0STATW_SPI > ;
# [ doc = "Register UCB0STATW_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0STATW_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Overrun error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOE_A { # [ doc = "0: No error" ] UCOE_0 = 0 , # [ doc = "1: Overrun error occurred" ] UCOE_1 = 1 } impl From < UCOE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOE`" ] pub type UCOE_R = crate :: R < bool , UCOE_A > ; impl UCOE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOE_A { match self . bits { false => UCOE_A :: UCOE_0 , true => UCOE_A :: UCOE_1 } } # [ doc = "Checks if the value of the field is `UCOE_0`" ] # [ inline ( always ) ] pub fn is_ucoe_0 ( & self ) -> bool { * self == UCOE_A :: UCOE_0 } # [ doc = "Checks if the value of the field is `UCOE_1`" ] # [ inline ( always ) ] pub fn is_ucoe_1 ( & self ) -> bool { * self == UCOE_A :: UCOE_1 } }
# [ doc = "Write proxy for field `UCOE`" ] pub struct UCOE_W < 'a > { w : & 'a mut W , } impl < 'a > UCOE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucoe_0 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_0 ) } # [ doc = "Overrun error occurred" ] # [ inline ( always ) ] pub fn ucoe_1 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Framing error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCFE_A { # [ doc = "0: No error" ] UCFE_0 = 0 , # [ doc = "1: Bus conflict occurred" ] UCFE_1 = 1 } impl From < UCFE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCFE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCFE`" ] pub type UCFE_R = crate :: R < bool , UCFE_A > ; impl UCFE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCFE_A { match self . bits { false => UCFE_A :: UCFE_0 , true => UCFE_A :: UCFE_1 } } # [ doc = "Checks if the value of the field is `UCFE_0`" ] # [ inline ( always ) ] pub fn is_ucfe_0 ( & self ) -> bool { * self == UCFE_A :: UCFE_0 } # [ doc = "Checks if the value of the field is `UCFE_1`" ] # [ inline ( always ) ] pub fn is_ucfe_1 ( & self ) -> bool { * self == UCFE_A :: UCFE_1 } }
# [ doc = "Write proxy for field `UCFE`" ] pub struct UCFE_W < 'a > { w : & 'a mut W , } impl < 'a > UCFE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCFE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucfe_0 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_0 ) } # [ doc = "Bus conflict occurred" ] # [ inline ( always ) ] pub fn ucfe_1 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Listen enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCLISTEN_A { # [ doc = "0: Disabled" ] UCLISTEN_0 = 0 , # [ doc = "1: Enabled. UCBxTXD is internally fed back to the receiver" ] UCLISTEN_1 = 1 } impl From < UCLISTEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCLISTEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCLISTEN`" ] pub type UCLISTEN_R = crate :: R < bool , UCLISTEN_A > ; impl UCLISTEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCLISTEN_A { match self . bits { false => UCLISTEN_A :: UCLISTEN_0 , true => UCLISTEN_A :: UCLISTEN_1 } } # [ doc = "Checks if the value of the field is `UCLISTEN_0`" ] # [ inline ( always ) ] pub fn is_uclisten_0 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_0 } # [ doc = "Checks if the value of the field is `UCLISTEN_1`" ] # [ inline ( always ) ] pub fn is_uclisten_1 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_1 } }
# [ doc = "Write proxy for field `UCLISTEN`" ] pub struct UCLISTEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCLISTEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCLISTEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn uclisten_0 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_0 ) } # [ doc = "Enabled. UCBxTXD is internally fed back to the receiver" ] # [ inline ( always ) ] pub fn uclisten_1 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & self ) -> UCOE_R { UCOE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & self ) -> UCFE_R { UCFE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & self ) -> UCLISTEN_R { UCLISTEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & mut self ) -> UCOE_W { UCOE_W { w : self } }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & mut self ) -> UCFE_W { UCFE_W { w : self } }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & mut self ) -> UCLISTEN_W { UCLISTEN_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Byte Counter Threshold Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0tbcnt](ucb0tbcnt) module" ] pub type UCB0TBCNT = crate :: Reg < u16 , _UCB0TBCNT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0TBCNT ;
# [ doc = "`read()` method returns [ucb0tbcnt::R](ucb0tbcnt::R) reader structure" ] impl crate :: Readable for UCB0TBCNT { }
# [ doc = "`write(|w| ..)` method takes [ucb0tbcnt::W](ucb0tbcnt::W) writer structure" ] impl crate :: Writable for UCB0TBCNT { }
# [ doc = "eUSCI_Bx Byte Counter Threshold Register" ] pub mod ucb0tbcnt {
# [ doc = "Reader of register UCB0TBCNT" ] pub type R = crate :: R < u16 , super :: UCB0TBCNT > ;
# [ doc = "Writer for register UCB0TBCNT" ] pub type W = crate :: W < u16 , super :: UCB0TBCNT > ;
# [ doc = "Register UCB0TBCNT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0TBCNT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UCTBCNT`" ] pub type UCTBCNT_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCTBCNT`" ] pub struct UCTBCNT_W < 'a > { w : & 'a mut W , } impl < 'a > UCTBCNT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Byte counter threshold value" ] # [ inline ( always ) ] pub fn uctbcnt ( & self ) -> UCTBCNT_R { UCTBCNT_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Byte counter threshold value" ] # [ inline ( always ) ] pub fn uctbcnt ( & mut self ) -> UCTBCNT_W { UCTBCNT_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Receive Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0rxbuf](ucb0rxbuf) module" ] pub type UCB0RXBUF = crate :: Reg < u16 , _UCB0RXBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0RXBUF ;
# [ doc = "`read()` method returns [ucb0rxbuf::R](ucb0rxbuf::R) reader structure" ] impl crate :: Readable for UCB0RXBUF { }
# [ doc = "eUSCI_Bx Receive Buffer Register" ] pub mod ucb0rxbuf {
# [ doc = "Reader of register UCB0RXBUF" ] pub type R = crate :: R < u16 , super :: UCB0RXBUF > ;
# [ doc = "Reader of field `UCRXBUF`" ] pub type UCRXBUF_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Receive data buffer" ] # [ inline ( always ) ] pub fn ucrxbuf ( & self ) -> UCRXBUF_R { UCRXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
}
# [ doc = "eUSCI_Bx Receive Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0rxbuf_spi](ucb0rxbuf_spi) module" ] pub type UCB0RXBUF_SPI = crate :: Reg < u16 , _UCB0RXBUF_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0RXBUF_SPI ;
# [ doc = "`read()` method returns [ucb0rxbuf_spi::R](ucb0rxbuf_spi::R) reader structure" ] impl crate :: Readable for UCB0RXBUF_SPI { }
# [ doc = "eUSCI_Bx Receive Buffer Register" ] pub mod ucb0rxbuf_spi {
# [ doc = "Reader of register UCB0RXBUF_SPI" ] pub type R = crate :: R < u16 , super :: UCB0RXBUF_SPI > ;
# [ doc = "Reader of field `UCRXBUF`" ] pub type UCRXBUF_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Receive data buffer" ] # [ inline ( always ) ] pub fn ucrxbuf ( & self ) -> UCRXBUF_R { UCRXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
}
# [ doc = "eUSCI_Bx Transmit Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0txbuf](ucb0txbuf) module" ] pub type UCB0TXBUF = crate :: Reg < u16 , _UCB0TXBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0TXBUF ;
# [ doc = "`read()` method returns [ucb0txbuf::R](ucb0txbuf::R) reader structure" ] impl crate :: Readable for UCB0TXBUF { }
# [ doc = "`write(|w| ..)` method takes [ucb0txbuf::W](ucb0txbuf::W) writer structure" ] impl crate :: Writable for UCB0TXBUF { }
# [ doc = "eUSCI_Bx Transmit Buffer Register" ] pub mod ucb0txbuf {
# [ doc = "Reader of register UCB0TXBUF" ] pub type R = crate :: R < u16 , super :: UCB0TXBUF > ;
# [ doc = "Writer for register UCB0TXBUF" ] pub type W = crate :: W < u16 , super :: UCB0TXBUF > ;
# [ doc = "Register UCB0TXBUF `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0TXBUF { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UCTXBUF`" ] pub type UCTXBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCTXBUF`" ] pub struct UCTXBUF_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & self ) -> UCTXBUF_R { UCTXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & mut self ) -> UCTXBUF_W { UCTXBUF_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Transmit Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0txbuf_spi](ucb0txbuf_spi) module" ] pub type UCB0TXBUF_SPI = crate :: Reg < u16 , _UCB0TXBUF_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0TXBUF_SPI ;
# [ doc = "`read()` method returns [ucb0txbuf_spi::R](ucb0txbuf_spi::R) reader structure" ] impl crate :: Readable for UCB0TXBUF_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb0txbuf_spi::W](ucb0txbuf_spi::W) writer structure" ] impl crate :: Writable for UCB0TXBUF_SPI { }
# [ doc = "eUSCI_Bx Transmit Buffer Register" ] pub mod ucb0txbuf_spi {
# [ doc = "Reader of register UCB0TXBUF_SPI" ] pub type R = crate :: R < u16 , super :: UCB0TXBUF_SPI > ;
# [ doc = "Writer for register UCB0TXBUF_SPI" ] pub type W = crate :: W < u16 , super :: UCB0TXBUF_SPI > ;
# [ doc = "Register UCB0TXBUF_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0TXBUF_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UCTXBUF`" ] pub type UCTXBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCTXBUF`" ] pub struct UCTXBUF_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & self ) -> UCTXBUF_R { UCTXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & mut self ) -> UCTXBUF_W { UCTXBUF_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Own Address 0 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0i2coa0](ucb0i2coa0) module" ] pub type UCB0I2COA0 = crate :: Reg < u16 , _UCB0I2COA0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0I2COA0 ;
# [ doc = "`read()` method returns [ucb0i2coa0::R](ucb0i2coa0::R) reader structure" ] impl crate :: Readable for UCB0I2COA0 { }
# [ doc = "`write(|w| ..)` method takes [ucb0i2coa0::W](ucb0i2coa0::W) writer structure" ] impl crate :: Writable for UCB0I2COA0 { }
# [ doc = "eUSCI_Bx I2C Own Address 0 Register" ] pub mod ucb0i2coa0 {
# [ doc = "Reader of register UCB0I2COA0" ] pub type R = crate :: R < u16 , super :: UCB0I2COA0 > ;
# [ doc = "Writer for register UCB0I2COA0" ] pub type W = crate :: W < u16 , super :: UCB0I2COA0 > ;
# [ doc = "Register UCB0I2COA0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0I2COA0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `I2COA0`" ] pub type I2COA0_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `I2COA0`" ] pub struct I2COA0_W < 'a > { w : & 'a mut W , } impl < 'a > I2COA0_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
# [ doc = "Own Address enable register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOAEN_A { # [ doc = "0: The slave address defined in I2COA0 is disabled" ] DISABLE = 0 , # [ doc = "1: The slave address defined in I2COA0 is enabled" ] ENABLE = 1 } impl From < UCOAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOAEN`" ] pub type UCOAEN_R = crate :: R < bool , UCOAEN_A > ; impl UCOAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOAEN_A { match self . bits { false => UCOAEN_A :: DISABLE , true => UCOAEN_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCOAEN_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCOAEN_A :: ENABLE } }
# [ doc = "Write proxy for field `UCOAEN`" ] pub struct UCOAEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCOAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The slave address defined in I2COA0 is disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: DISABLE ) } # [ doc = "The slave address defined in I2COA0 is enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "General call response enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCGCEN_A { # [ doc = "0: Do not respond to a general call" ] UCGCEN_0 = 0 , # [ doc = "1: Respond to a general call" ] UCGCEN_1 = 1 } impl From < UCGCEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCGCEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCGCEN`" ] pub type UCGCEN_R = crate :: R < bool , UCGCEN_A > ; impl UCGCEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCGCEN_A { match self . bits { false => UCGCEN_A :: UCGCEN_0 , true => UCGCEN_A :: UCGCEN_1 } } # [ doc = "Checks if the value of the field is `UCGCEN_0`" ] # [ inline ( always ) ] pub fn is_ucgcen_0 ( & self ) -> bool { * self == UCGCEN_A :: UCGCEN_0 } # [ doc = "Checks if the value of the field is `UCGCEN_1`" ] # [ inline ( always ) ] pub fn is_ucgcen_1 ( & self ) -> bool { * self == UCGCEN_A :: UCGCEN_1 } }
# [ doc = "Write proxy for field `UCGCEN`" ] pub struct UCGCEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCGCEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCGCEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Do not respond to a general call" ] # [ inline ( always ) ] pub fn ucgcen_0 ( self ) -> & 'a mut W { self . variant ( UCGCEN_A :: UCGCEN_0 ) } # [ doc = "Respond to a general call" ] # [ inline ( always ) ] pub fn ucgcen_1 ( self ) -> & 'a mut W { self . variant ( UCGCEN_A :: UCGCEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa0 ( & self ) -> I2COA0_R { I2COA0_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & self ) -> UCOAEN_R { UCOAEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - General call response enable" ] # [ inline ( always ) ] pub fn ucgcen ( & self ) -> UCGCEN_R { UCGCEN_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa0 ( & mut self ) -> I2COA0_W { I2COA0_W { w : self } }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & mut self ) -> UCOAEN_W { UCOAEN_W { w : self } }
# [ doc = "Bit 15 - General call response enable" ] # [ inline ( always ) ] pub fn ucgcen ( & mut self ) -> UCGCEN_W { UCGCEN_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Own Address 1 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0i2coa1](ucb0i2coa1) module" ] pub type UCB0I2COA1 = crate :: Reg < u16 , _UCB0I2COA1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0I2COA1 ;
# [ doc = "`read()` method returns [ucb0i2coa1::R](ucb0i2coa1::R) reader structure" ] impl crate :: Readable for UCB0I2COA1 { }
# [ doc = "`write(|w| ..)` method takes [ucb0i2coa1::W](ucb0i2coa1::W) writer structure" ] impl crate :: Writable for UCB0I2COA1 { }
# [ doc = "eUSCI_Bx I2C Own Address 1 Register" ] pub mod ucb0i2coa1 {
# [ doc = "Reader of register UCB0I2COA1" ] pub type R = crate :: R < u16 , super :: UCB0I2COA1 > ;
# [ doc = "Writer for register UCB0I2COA1" ] pub type W = crate :: W < u16 , super :: UCB0I2COA1 > ;
# [ doc = "Register UCB0I2COA1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0I2COA1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `I2COA1`" ] pub type I2COA1_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `I2COA1`" ] pub struct I2COA1_W < 'a > { w : & 'a mut W , } impl < 'a > I2COA1_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
# [ doc = "Own Address enable register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOAEN_A { # [ doc = "0: The slave address defined in I2COA1 is disabled" ] DISABLE = 0 , # [ doc = "1: The slave address defined in I2COA1 is enabled" ] ENABLE = 1 } impl From < UCOAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOAEN`" ] pub type UCOAEN_R = crate :: R < bool , UCOAEN_A > ; impl UCOAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOAEN_A { match self . bits { false => UCOAEN_A :: DISABLE , true => UCOAEN_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCOAEN_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCOAEN_A :: ENABLE } }
# [ doc = "Write proxy for field `UCOAEN`" ] pub struct UCOAEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCOAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The slave address defined in I2COA1 is disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: DISABLE ) } # [ doc = "The slave address defined in I2COA1 is enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa1 ( & self ) -> I2COA1_R { I2COA1_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & self ) -> UCOAEN_R { UCOAEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa1 ( & mut self ) -> I2COA1_W { I2COA1_W { w : self } }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & mut self ) -> UCOAEN_W { UCOAEN_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Own Address 2 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0i2coa2](ucb0i2coa2) module" ] pub type UCB0I2COA2 = crate :: Reg < u16 , _UCB0I2COA2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0I2COA2 ;
# [ doc = "`read()` method returns [ucb0i2coa2::R](ucb0i2coa2::R) reader structure" ] impl crate :: Readable for UCB0I2COA2 { }
# [ doc = "`write(|w| ..)` method takes [ucb0i2coa2::W](ucb0i2coa2::W) writer structure" ] impl crate :: Writable for UCB0I2COA2 { }
# [ doc = "eUSCI_Bx I2C Own Address 2 Register" ] pub mod ucb0i2coa2 {
# [ doc = "Reader of register UCB0I2COA2" ] pub type R = crate :: R < u16 , super :: UCB0I2COA2 > ;
# [ doc = "Writer for register UCB0I2COA2" ] pub type W = crate :: W < u16 , super :: UCB0I2COA2 > ;
# [ doc = "Register UCB0I2COA2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0I2COA2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `I2COA2`" ] pub type I2COA2_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `I2COA2`" ] pub struct I2COA2_W < 'a > { w : & 'a mut W , } impl < 'a > I2COA2_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
# [ doc = "Own Address enable register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOAEN_A { # [ doc = "0: The slave address defined in I2COA2 is disabled" ] DISABLE = 0 , # [ doc = "1: The slave address defined in I2COA2 is enabled" ] ENABLE = 1 } impl From < UCOAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOAEN`" ] pub type UCOAEN_R = crate :: R < bool , UCOAEN_A > ; impl UCOAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOAEN_A { match self . bits { false => UCOAEN_A :: DISABLE , true => UCOAEN_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCOAEN_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCOAEN_A :: ENABLE } }
# [ doc = "Write proxy for field `UCOAEN`" ] pub struct UCOAEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCOAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The slave address defined in I2COA2 is disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: DISABLE ) } # [ doc = "The slave address defined in I2COA2 is enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa2 ( & self ) -> I2COA2_R { I2COA2_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & self ) -> UCOAEN_R { UCOAEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa2 ( & mut self ) -> I2COA2_W { I2COA2_W { w : self } }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & mut self ) -> UCOAEN_W { UCOAEN_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Own Address 3 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0i2coa3](ucb0i2coa3) module" ] pub type UCB0I2COA3 = crate :: Reg < u16 , _UCB0I2COA3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0I2COA3 ;
# [ doc = "`read()` method returns [ucb0i2coa3::R](ucb0i2coa3::R) reader structure" ] impl crate :: Readable for UCB0I2COA3 { }
# [ doc = "`write(|w| ..)` method takes [ucb0i2coa3::W](ucb0i2coa3::W) writer structure" ] impl crate :: Writable for UCB0I2COA3 { }
# [ doc = "eUSCI_Bx I2C Own Address 3 Register" ] pub mod ucb0i2coa3 {
# [ doc = "Reader of register UCB0I2COA3" ] pub type R = crate :: R < u16 , super :: UCB0I2COA3 > ;
# [ doc = "Writer for register UCB0I2COA3" ] pub type W = crate :: W < u16 , super :: UCB0I2COA3 > ;
# [ doc = "Register UCB0I2COA3 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0I2COA3 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `I2COA3`" ] pub type I2COA3_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `I2COA3`" ] pub struct I2COA3_W < 'a > { w : & 'a mut W , } impl < 'a > I2COA3_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
# [ doc = "Own Address enable register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOAEN_A { # [ doc = "0: The slave address defined in I2COA3 is disabled" ] DISABLE = 0 , # [ doc = "1: The slave address defined in I2COA3 is enabled" ] ENABLE = 1 } impl From < UCOAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOAEN`" ] pub type UCOAEN_R = crate :: R < bool , UCOAEN_A > ; impl UCOAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOAEN_A { match self . bits { false => UCOAEN_A :: DISABLE , true => UCOAEN_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCOAEN_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCOAEN_A :: ENABLE } }
# [ doc = "Write proxy for field `UCOAEN`" ] pub struct UCOAEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCOAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The slave address defined in I2COA3 is disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: DISABLE ) } # [ doc = "The slave address defined in I2COA3 is enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa3 ( & self ) -> I2COA3_R { I2COA3_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & self ) -> UCOAEN_R { UCOAEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa3 ( & mut self ) -> I2COA3_W { I2COA3_W { w : self } }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & mut self ) -> UCOAEN_W { UCOAEN_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Received Address Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0addrx](ucb0addrx) module" ] pub type UCB0ADDRX = crate :: Reg < u16 , _UCB0ADDRX > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0ADDRX ;
# [ doc = "`read()` method returns [ucb0addrx::R](ucb0addrx::R) reader structure" ] impl crate :: Readable for UCB0ADDRX { }
# [ doc = "eUSCI_Bx I2C Received Address Register" ] pub mod ucb0addrx {
# [ doc = "Reader of register UCB0ADDRX" ] pub type R = crate :: R < u16 , super :: UCB0ADDRX > ;
# [ doc = "Reader of field `ADDRX`" ] pub type ADDRX_R = crate :: R < u16 , u16 > ;
impl R {
# [ doc = "Bits 0:9 - Received Address Register" ] # [ inline ( always ) ] pub fn addrx ( & self ) -> ADDRX_R { ADDRX_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
}
}
# [ doc = "eUSCI_Bx I2C Address Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0addmask](ucb0addmask) module" ] pub type UCB0ADDMASK = crate :: Reg < u16 , _UCB0ADDMASK > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0ADDMASK ;
# [ doc = "`read()` method returns [ucb0addmask::R](ucb0addmask::R) reader structure" ] impl crate :: Readable for UCB0ADDMASK { }
# [ doc = "`write(|w| ..)` method takes [ucb0addmask::W](ucb0addmask::W) writer structure" ] impl crate :: Writable for UCB0ADDMASK { }
# [ doc = "eUSCI_Bx I2C Address Mask Register" ] pub mod ucb0addmask {
# [ doc = "Reader of register UCB0ADDMASK" ] pub type R = crate :: R < u16 , super :: UCB0ADDMASK > ;
# [ doc = "Writer for register UCB0ADDMASK" ] pub type W = crate :: W < u16 , super :: UCB0ADDMASK > ;
# [ doc = "Register UCB0ADDMASK `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0ADDMASK { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ADDMASK`" ] pub type ADDMASK_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `ADDMASK`" ] pub struct ADDMASK_W < 'a > { w : & 'a mut W , } impl < 'a > ADDMASK_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - Address Mask Register. By clearing the corresponding bit of the own address, this bit is a don't care when comparing the address on the bus to the own address. Using this method, it is possible to react on more than one slave address. When all bits of ADDMASKx are set, the address mask feature is deactivated. Modify only when UCSWRST = 1." ] # [ inline ( always ) ] pub fn addmask ( & self ) -> ADDMASK_R { ADDMASK_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:9 - Address Mask Register. By clearing the corresponding bit of the own address, this bit is a don't care when comparing the address on the bus to the own address. Using this method, it is possible to react on more than one slave address. When all bits of ADDMASKx are set, the address mask feature is deactivated. Modify only when UCSWRST = 1." ] # [ inline ( always ) ] pub fn addmask ( & mut self ) -> ADDMASK_W { ADDMASK_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Slave Address Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0i2csa](ucb0i2csa) module" ] pub type UCB0I2CSA = crate :: Reg < u16 , _UCB0I2CSA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0I2CSA ;
# [ doc = "`read()` method returns [ucb0i2csa::R](ucb0i2csa::R) reader structure" ] impl crate :: Readable for UCB0I2CSA { }
# [ doc = "`write(|w| ..)` method takes [ucb0i2csa::W](ucb0i2csa::W) writer structure" ] impl crate :: Writable for UCB0I2CSA { }
# [ doc = "eUSCI_Bx I2C Slave Address Register" ] pub mod ucb0i2csa {
# [ doc = "Reader of register UCB0I2CSA" ] pub type R = crate :: R < u16 , super :: UCB0I2CSA > ;
# [ doc = "Writer for register UCB0I2CSA" ] pub type W = crate :: W < u16 , super :: UCB0I2CSA > ;
# [ doc = "Register UCB0I2CSA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0I2CSA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `I2CSA`" ] pub type I2CSA_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `I2CSA`" ] pub struct I2CSA_W < 'a > { w : & 'a mut W , } impl < 'a > I2CSA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - I2C slave address" ] # [ inline ( always ) ] pub fn i2csa ( & self ) -> I2CSA_R { I2CSA_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:9 - I2C slave address" ] # [ inline ( always ) ] pub fn i2csa ( & mut self ) -> I2CSA_W { I2CSA_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ie](ucb0ie) module" ] pub type UCB0IE = crate :: Reg < u16 , _UCB0IE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0IE ;
# [ doc = "`read()` method returns [ucb0ie::R](ucb0ie::R) reader structure" ] impl crate :: Readable for UCB0IE { }
# [ doc = "`write(|w| ..)` method takes [ucb0ie::W](ucb0ie::W) writer structure" ] impl crate :: Writable for UCB0IE { }
# [ doc = "eUSCI_Bx Interrupt Enable Register" ] pub mod ucb0ie {
# [ doc = "Reader of register UCB0IE" ] pub type R = crate :: R < u16 , super :: UCB0IE > ;
# [ doc = "Writer for register UCB0IE" ] pub type W = crate :: W < u16 , super :: UCB0IE > ;
# [ doc = "Register UCB0IE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0IE { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt enable 0\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE0_A { # [ doc = "0: Interrupt disabled" ] UCRXIE0_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE0_1 = 1 } impl From < UCRXIE0_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE0`" ] pub type UCRXIE0_R = crate :: R < bool , UCRXIE0_A > ; impl UCRXIE0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE0_A { match self . bits { false => UCRXIE0_A :: UCRXIE0_0 , true => UCRXIE0_A :: UCRXIE0_1 } } # [ doc = "Checks if the value of the field is `UCRXIE0_0`" ] # [ inline ( always ) ] pub fn is_ucrxie0_0 ( & self ) -> bool { * self == UCRXIE0_A :: UCRXIE0_0 } # [ doc = "Checks if the value of the field is `UCRXIE0_1`" ] # [ inline ( always ) ] pub fn is_ucrxie0_1 ( & self ) -> bool { * self == UCRXIE0_A :: UCRXIE0_1 } }
# [ doc = "Write proxy for field `UCRXIE0`" ] pub struct UCRXIE0_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie0_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE0_A :: UCRXIE0_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie0_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE0_A :: UCRXIE0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt enable 0\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE0_A { # [ doc = "0: Interrupt disabled" ] UCTXIE0_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE0_1 = 1 } impl From < UCTXIE0_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE0`" ] pub type UCTXIE0_R = crate :: R < bool , UCTXIE0_A > ; impl UCTXIE0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE0_A { match self . bits { false => UCTXIE0_A :: UCTXIE0_0 , true => UCTXIE0_A :: UCTXIE0_1 } } # [ doc = "Checks if the value of the field is `UCTXIE0_0`" ] # [ inline ( always ) ] pub fn is_uctxie0_0 ( & self ) -> bool { * self == UCTXIE0_A :: UCTXIE0_0 } # [ doc = "Checks if the value of the field is `UCTXIE0_1`" ] # [ inline ( always ) ] pub fn is_uctxie0_1 ( & self ) -> bool { * self == UCTXIE0_A :: UCTXIE0_1 } }
# [ doc = "Write proxy for field `UCTXIE0`" ] pub struct UCTXIE0_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie0_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE0_A :: UCTXIE0_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie0_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE0_A :: UCTXIE0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "START condition interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTTIE_A { # [ doc = "0: Interrupt disabled" ] UCSTTIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCSTTIE_1 = 1 } impl From < UCSTTIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTTIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTTIE`" ] pub type UCSTTIE_R = crate :: R < bool , UCSTTIE_A > ; impl UCSTTIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTTIE_A { match self . bits { false => UCSTTIE_A :: UCSTTIE_0 , true => UCSTTIE_A :: UCSTTIE_1 } } # [ doc = "Checks if the value of the field is `UCSTTIE_0`" ] # [ inline ( always ) ] pub fn is_ucsttie_0 ( & self ) -> bool { * self == UCSTTIE_A :: UCSTTIE_0 } # [ doc = "Checks if the value of the field is `UCSTTIE_1`" ] # [ inline ( always ) ] pub fn is_ucsttie_1 ( & self ) -> bool { * self == UCSTTIE_A :: UCSTTIE_1 } }
# [ doc = "Write proxy for field `UCSTTIE`" ] pub struct UCSTTIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTTIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTTIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucsttie_0 ( self ) -> & 'a mut W { self . variant ( UCSTTIE_A :: UCSTTIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucsttie_1 ( self ) -> & 'a mut W { self . variant ( UCSTTIE_A :: UCSTTIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "STOP condition interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTPIE_A { # [ doc = "0: Interrupt disabled" ] UCSTPIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCSTPIE_1 = 1 } impl From < UCSTPIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTPIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTPIE`" ] pub type UCSTPIE_R = crate :: R < bool , UCSTPIE_A > ; impl UCSTPIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTPIE_A { match self . bits { false => UCSTPIE_A :: UCSTPIE_0 , true => UCSTPIE_A :: UCSTPIE_1 } } # [ doc = "Checks if the value of the field is `UCSTPIE_0`" ] # [ inline ( always ) ] pub fn is_ucstpie_0 ( & self ) -> bool { * self == UCSTPIE_A :: UCSTPIE_0 } # [ doc = "Checks if the value of the field is `UCSTPIE_1`" ] # [ inline ( always ) ] pub fn is_ucstpie_1 ( & self ) -> bool { * self == UCSTPIE_A :: UCSTPIE_1 } }
# [ doc = "Write proxy for field `UCSTPIE`" ] pub struct UCSTPIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTPIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTPIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucstpie_0 ( self ) -> & 'a mut W { self . variant ( UCSTPIE_A :: UCSTPIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucstpie_1 ( self ) -> & 'a mut W { self . variant ( UCSTPIE_A :: UCSTPIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Arbitration lost interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCALIE_A { # [ doc = "0: Interrupt disabled" ] UCALIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCALIE_1 = 1 } impl From < UCALIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCALIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCALIE`" ] pub type UCALIE_R = crate :: R < bool , UCALIE_A > ; impl UCALIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCALIE_A { match self . bits { false => UCALIE_A :: UCALIE_0 , true => UCALIE_A :: UCALIE_1 } } # [ doc = "Checks if the value of the field is `UCALIE_0`" ] # [ inline ( always ) ] pub fn is_ucalie_0 ( & self ) -> bool { * self == UCALIE_A :: UCALIE_0 } # [ doc = "Checks if the value of the field is `UCALIE_1`" ] # [ inline ( always ) ] pub fn is_ucalie_1 ( & self ) -> bool { * self == UCALIE_A :: UCALIE_1 } }
# [ doc = "Write proxy for field `UCALIE`" ] pub struct UCALIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCALIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCALIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucalie_0 ( self ) -> & 'a mut W { self . variant ( UCALIE_A :: UCALIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucalie_1 ( self ) -> & 'a mut W { self . variant ( UCALIE_A :: UCALIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Not-acknowledge interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCNACKIE_A { # [ doc = "0: Interrupt disabled" ] UCNACKIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCNACKIE_1 = 1 } impl From < UCNACKIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCNACKIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCNACKIE`" ] pub type UCNACKIE_R = crate :: R < bool , UCNACKIE_A > ; impl UCNACKIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCNACKIE_A { match self . bits { false => UCNACKIE_A :: UCNACKIE_0 , true => UCNACKIE_A :: UCNACKIE_1 } } # [ doc = "Checks if the value of the field is `UCNACKIE_0`" ] # [ inline ( always ) ] pub fn is_ucnackie_0 ( & self ) -> bool { * self == UCNACKIE_A :: UCNACKIE_0 } # [ doc = "Checks if the value of the field is `UCNACKIE_1`" ] # [ inline ( always ) ] pub fn is_ucnackie_1 ( & self ) -> bool { * self == UCNACKIE_A :: UCNACKIE_1 } }
# [ doc = "Write proxy for field `UCNACKIE`" ] pub struct UCNACKIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCNACKIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCNACKIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucnackie_0 ( self ) -> & 'a mut W { self . variant ( UCNACKIE_A :: UCNACKIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucnackie_1 ( self ) -> & 'a mut W { self . variant ( UCNACKIE_A :: UCNACKIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Byte counter interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBCNTIE_A { # [ doc = "0: Interrupt disabled" ] UCBCNTIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCBCNTIE_1 = 1 } impl From < UCBCNTIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBCNTIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBCNTIE`" ] pub type UCBCNTIE_R = crate :: R < bool , UCBCNTIE_A > ; impl UCBCNTIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBCNTIE_A { match self . bits { false => UCBCNTIE_A :: UCBCNTIE_0 , true => UCBCNTIE_A :: UCBCNTIE_1 } } # [ doc = "Checks if the value of the field is `UCBCNTIE_0`" ] # [ inline ( always ) ] pub fn is_ucbcntie_0 ( & self ) -> bool { * self == UCBCNTIE_A :: UCBCNTIE_0 } # [ doc = "Checks if the value of the field is `UCBCNTIE_1`" ] # [ inline ( always ) ] pub fn is_ucbcntie_1 ( & self ) -> bool { * self == UCBCNTIE_A :: UCBCNTIE_1 } }
# [ doc = "Write proxy for field `UCBCNTIE`" ] pub struct UCBCNTIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCBCNTIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBCNTIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucbcntie_0 ( self ) -> & 'a mut W { self . variant ( UCBCNTIE_A :: UCBCNTIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucbcntie_1 ( self ) -> & 'a mut W { self . variant ( UCBCNTIE_A :: UCBCNTIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Clock low timeout interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCLTOIE_A { # [ doc = "0: Interrupt disabled" ] UCCLTOIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCCLTOIE_1 = 1 } impl From < UCCLTOIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCLTOIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCLTOIE`" ] pub type UCCLTOIE_R = crate :: R < bool , UCCLTOIE_A > ; impl UCCLTOIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCLTOIE_A { match self . bits { false => UCCLTOIE_A :: UCCLTOIE_0 , true => UCCLTOIE_A :: UCCLTOIE_1 } } # [ doc = "Checks if the value of the field is `UCCLTOIE_0`" ] # [ inline ( always ) ] pub fn is_uccltoie_0 ( & self ) -> bool { * self == UCCLTOIE_A :: UCCLTOIE_0 } # [ doc = "Checks if the value of the field is `UCCLTOIE_1`" ] # [ inline ( always ) ] pub fn is_uccltoie_1 ( & self ) -> bool { * self == UCCLTOIE_A :: UCCLTOIE_1 } }
# [ doc = "Write proxy for field `UCCLTOIE`" ] pub struct UCCLTOIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCCLTOIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCLTOIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uccltoie_0 ( self ) -> & 'a mut W { self . variant ( UCCLTOIE_A :: UCCLTOIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uccltoie_1 ( self ) -> & 'a mut W { self . variant ( UCCLTOIE_A :: UCCLTOIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Receive interrupt enable 1\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE1_A { # [ doc = "0: Interrupt disabled" ] UCRXIE1_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE1_1 = 1 } impl From < UCRXIE1_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE1_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE1`" ] pub type UCRXIE1_R = crate :: R < bool , UCRXIE1_A > ; impl UCRXIE1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE1_A { match self . bits { false => UCRXIE1_A :: UCRXIE1_0 , true => UCRXIE1_A :: UCRXIE1_1 } } # [ doc = "Checks if the value of the field is `UCRXIE1_0`" ] # [ inline ( always ) ] pub fn is_ucrxie1_0 ( & self ) -> bool { * self == UCRXIE1_A :: UCRXIE1_0 } # [ doc = "Checks if the value of the field is `UCRXIE1_1`" ] # [ inline ( always ) ] pub fn is_ucrxie1_1 ( & self ) -> bool { * self == UCRXIE1_A :: UCRXIE1_1 } }
# [ doc = "Write proxy for field `UCRXIE1`" ] pub struct UCRXIE1_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE1_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie1_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE1_A :: UCRXIE1_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie1_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE1_A :: UCRXIE1_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Transmit interrupt enable 1\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE1_A { # [ doc = "0: Interrupt disabled" ] UCTXIE1_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE1_1 = 1 } impl From < UCTXIE1_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE1_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE1`" ] pub type UCTXIE1_R = crate :: R < bool , UCTXIE1_A > ; impl UCTXIE1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE1_A { match self . bits { false => UCTXIE1_A :: UCTXIE1_0 , true => UCTXIE1_A :: UCTXIE1_1 } } # [ doc = "Checks if the value of the field is `UCTXIE1_0`" ] # [ inline ( always ) ] pub fn is_uctxie1_0 ( & self ) -> bool { * self == UCTXIE1_A :: UCTXIE1_0 } # [ doc = "Checks if the value of the field is `UCTXIE1_1`" ] # [ inline ( always ) ] pub fn is_uctxie1_1 ( & self ) -> bool { * self == UCTXIE1_A :: UCTXIE1_1 } }
# [ doc = "Write proxy for field `UCTXIE1`" ] pub struct UCTXIE1_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE1_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie1_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE1_A :: UCTXIE1_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie1_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE1_A :: UCTXIE1_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Receive interrupt enable 2\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE2_A { # [ doc = "0: Interrupt disabled" ] UCRXIE2_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE2_1 = 1 } impl From < UCRXIE2_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE2_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE2`" ] pub type UCRXIE2_R = crate :: R < bool , UCRXIE2_A > ; impl UCRXIE2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE2_A { match self . bits { false => UCRXIE2_A :: UCRXIE2_0 , true => UCRXIE2_A :: UCRXIE2_1 } } # [ doc = "Checks if the value of the field is `UCRXIE2_0`" ] # [ inline ( always ) ] pub fn is_ucrxie2_0 ( & self ) -> bool { * self == UCRXIE2_A :: UCRXIE2_0 } # [ doc = "Checks if the value of the field is `UCRXIE2_1`" ] # [ inline ( always ) ] pub fn is_ucrxie2_1 ( & self ) -> bool { * self == UCRXIE2_A :: UCRXIE2_1 } }
# [ doc = "Write proxy for field `UCRXIE2`" ] pub struct UCRXIE2_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE2_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie2_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE2_A :: UCRXIE2_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie2_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE2_A :: UCRXIE2_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Transmit interrupt enable 2\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE2_A { # [ doc = "0: Interrupt disabled" ] UCTXIE2_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE2_1 = 1 } impl From < UCTXIE2_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE2_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE2`" ] pub type UCTXIE2_R = crate :: R < bool , UCTXIE2_A > ; impl UCTXIE2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE2_A { match self . bits { false => UCTXIE2_A :: UCTXIE2_0 , true => UCTXIE2_A :: UCTXIE2_1 } } # [ doc = "Checks if the value of the field is `UCTXIE2_0`" ] # [ inline ( always ) ] pub fn is_uctxie2_0 ( & self ) -> bool { * self == UCTXIE2_A :: UCTXIE2_0 } # [ doc = "Checks if the value of the field is `UCTXIE2_1`" ] # [ inline ( always ) ] pub fn is_uctxie2_1 ( & self ) -> bool { * self == UCTXIE2_A :: UCTXIE2_1 } }
# [ doc = "Write proxy for field `UCTXIE2`" ] pub struct UCTXIE2_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE2_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie2_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE2_A :: UCTXIE2_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie2_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE2_A :: UCTXIE2_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Receive interrupt enable 3\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE3_A { # [ doc = "0: Interrupt disabled" ] UCRXIE3_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE3_1 = 1 } impl From < UCRXIE3_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE3_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE3`" ] pub type UCRXIE3_R = crate :: R < bool , UCRXIE3_A > ; impl UCRXIE3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE3_A { match self . bits { false => UCRXIE3_A :: UCRXIE3_0 , true => UCRXIE3_A :: UCRXIE3_1 } } # [ doc = "Checks if the value of the field is `UCRXIE3_0`" ] # [ inline ( always ) ] pub fn is_ucrxie3_0 ( & self ) -> bool { * self == UCRXIE3_A :: UCRXIE3_0 } # [ doc = "Checks if the value of the field is `UCRXIE3_1`" ] # [ inline ( always ) ] pub fn is_ucrxie3_1 ( & self ) -> bool { * self == UCRXIE3_A :: UCRXIE3_1 } }
# [ doc = "Write proxy for field `UCRXIE3`" ] pub struct UCRXIE3_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE3_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE3_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie3_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE3_A :: UCRXIE3_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie3_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE3_A :: UCRXIE3_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Transmit interrupt enable 3\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE3_A { # [ doc = "0: Interrupt disabled" ] UCTXIE3_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE3_1 = 1 } impl From < UCTXIE3_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE3_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE3`" ] pub type UCTXIE3_R = crate :: R < bool , UCTXIE3_A > ; impl UCTXIE3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE3_A { match self . bits { false => UCTXIE3_A :: UCTXIE3_0 , true => UCTXIE3_A :: UCTXIE3_1 } } # [ doc = "Checks if the value of the field is `UCTXIE3_0`" ] # [ inline ( always ) ] pub fn is_uctxie3_0 ( & self ) -> bool { * self == UCTXIE3_A :: UCTXIE3_0 } # [ doc = "Checks if the value of the field is `UCTXIE3_1`" ] # [ inline ( always ) ] pub fn is_uctxie3_1 ( & self ) -> bool { * self == UCTXIE3_A :: UCTXIE3_1 } }
# [ doc = "Write proxy for field `UCTXIE3`" ] pub struct UCTXIE3_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE3_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE3_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie3_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE3_A :: UCTXIE3_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie3_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE3_A :: UCTXIE3_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Bit position 9 interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBIT9IE_A { # [ doc = "0: Interrupt disabled" ] UCBIT9IE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCBIT9IE_1 = 1 } impl From < UCBIT9IE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBIT9IE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBIT9IE`" ] pub type UCBIT9IE_R = crate :: R < bool , UCBIT9IE_A > ; impl UCBIT9IE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBIT9IE_A { match self . bits { false => UCBIT9IE_A :: UCBIT9IE_0 , true => UCBIT9IE_A :: UCBIT9IE_1 } } # [ doc = "Checks if the value of the field is `UCBIT9IE_0`" ] # [ inline ( always ) ] pub fn is_ucbit9ie_0 ( & self ) -> bool { * self == UCBIT9IE_A :: UCBIT9IE_0 } # [ doc = "Checks if the value of the field is `UCBIT9IE_1`" ] # [ inline ( always ) ] pub fn is_ucbit9ie_1 ( & self ) -> bool { * self == UCBIT9IE_A :: UCBIT9IE_1 } }
# [ doc = "Write proxy for field `UCBIT9IE`" ] pub struct UCBIT9IE_W < 'a > { w : & 'a mut W , } impl < 'a > UCBIT9IE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBIT9IE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucbit9ie_0 ( self ) -> & 'a mut W { self . variant ( UCBIT9IE_A :: UCBIT9IE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucbit9ie_1 ( self ) -> & 'a mut W { self . variant ( UCBIT9IE_A :: UCBIT9IE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt enable 0" ] # [ inline ( always ) ] pub fn ucrxie0 ( & self ) -> UCRXIE0_R { UCRXIE0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt enable 0" ] # [ inline ( always ) ] pub fn uctxie0 ( & self ) -> UCTXIE0_R { UCTXIE0_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - START condition interrupt enable" ] # [ inline ( always ) ] pub fn ucsttie ( & self ) -> UCSTTIE_R { UCSTTIE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - STOP condition interrupt enable" ] # [ inline ( always ) ] pub fn ucstpie ( & self ) -> UCSTPIE_R { UCSTPIE_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Arbitration lost interrupt enable" ] # [ inline ( always ) ] pub fn ucalie ( & self ) -> UCALIE_R { UCALIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Not-acknowledge interrupt enable" ] # [ inline ( always ) ] pub fn ucnackie ( & self ) -> UCNACKIE_R { UCNACKIE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Byte counter interrupt enable" ] # [ inline ( always ) ] pub fn ucbcntie ( & self ) -> UCBCNTIE_R { UCBCNTIE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Clock low timeout interrupt enable" ] # [ inline ( always ) ] pub fn uccltoie ( & self ) -> UCCLTOIE_R { UCCLTOIE_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Receive interrupt enable 1" ] # [ inline ( always ) ] pub fn ucrxie1 ( & self ) -> UCRXIE1_R { UCRXIE1_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Transmit interrupt enable 1" ] # [ inline ( always ) ] pub fn uctxie1 ( & self ) -> UCTXIE1_R { UCTXIE1_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Receive interrupt enable 2" ] # [ inline ( always ) ] pub fn ucrxie2 ( & self ) -> UCRXIE2_R { UCRXIE2_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Transmit interrupt enable 2" ] # [ inline ( always ) ] pub fn uctxie2 ( & self ) -> UCTXIE2_R { UCTXIE2_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Receive interrupt enable 3" ] # [ inline ( always ) ] pub fn ucrxie3 ( & self ) -> UCRXIE3_R { UCRXIE3_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Transmit interrupt enable 3" ] # [ inline ( always ) ] pub fn uctxie3 ( & self ) -> UCTXIE3_R { UCTXIE3_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Bit position 9 interrupt enable" ] # [ inline ( always ) ] pub fn ucbit9ie ( & self ) -> UCBIT9IE_R { UCBIT9IE_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt enable 0" ] # [ inline ( always ) ] pub fn ucrxie0 ( & mut self ) -> UCRXIE0_W { UCRXIE0_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt enable 0" ] # [ inline ( always ) ] pub fn uctxie0 ( & mut self ) -> UCTXIE0_W { UCTXIE0_W { w : self } }
# [ doc = "Bit 2 - START condition interrupt enable" ] # [ inline ( always ) ] pub fn ucsttie ( & mut self ) -> UCSTTIE_W { UCSTTIE_W { w : self } }
# [ doc = "Bit 3 - STOP condition interrupt enable" ] # [ inline ( always ) ] pub fn ucstpie ( & mut self ) -> UCSTPIE_W { UCSTPIE_W { w : self } }
# [ doc = "Bit 4 - Arbitration lost interrupt enable" ] # [ inline ( always ) ] pub fn ucalie ( & mut self ) -> UCALIE_W { UCALIE_W { w : self } }
# [ doc = "Bit 5 - Not-acknowledge interrupt enable" ] # [ inline ( always ) ] pub fn ucnackie ( & mut self ) -> UCNACKIE_W { UCNACKIE_W { w : self } }
# [ doc = "Bit 6 - Byte counter interrupt enable" ] # [ inline ( always ) ] pub fn ucbcntie ( & mut self ) -> UCBCNTIE_W { UCBCNTIE_W { w : self } }
# [ doc = "Bit 7 - Clock low timeout interrupt enable" ] # [ inline ( always ) ] pub fn uccltoie ( & mut self ) -> UCCLTOIE_W { UCCLTOIE_W { w : self } }
# [ doc = "Bit 8 - Receive interrupt enable 1" ] # [ inline ( always ) ] pub fn ucrxie1 ( & mut self ) -> UCRXIE1_W { UCRXIE1_W { w : self } }
# [ doc = "Bit 9 - Transmit interrupt enable 1" ] # [ inline ( always ) ] pub fn uctxie1 ( & mut self ) -> UCTXIE1_W { UCTXIE1_W { w : self } }
# [ doc = "Bit 10 - Receive interrupt enable 2" ] # [ inline ( always ) ] pub fn ucrxie2 ( & mut self ) -> UCRXIE2_W { UCRXIE2_W { w : self } }
# [ doc = "Bit 11 - Transmit interrupt enable 2" ] # [ inline ( always ) ] pub fn uctxie2 ( & mut self ) -> UCTXIE2_W { UCTXIE2_W { w : self } }
# [ doc = "Bit 12 - Receive interrupt enable 3" ] # [ inline ( always ) ] pub fn ucrxie3 ( & mut self ) -> UCRXIE3_W { UCRXIE3_W { w : self } }
# [ doc = "Bit 13 - Transmit interrupt enable 3" ] # [ inline ( always ) ] pub fn uctxie3 ( & mut self ) -> UCTXIE3_W { UCTXIE3_W { w : self } }
# [ doc = "Bit 14 - Bit position 9 interrupt enable" ] # [ inline ( always ) ] pub fn ucbit9ie ( & mut self ) -> UCBIT9IE_W { UCBIT9IE_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ie_spi](ucb0ie_spi) module" ] pub type UCB0IE_SPI = crate :: Reg < u16 , _UCB0IE_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0IE_SPI ;
# [ doc = "`read()` method returns [ucb0ie_spi::R](ucb0ie_spi::R) reader structure" ] impl crate :: Readable for UCB0IE_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb0ie_spi::W](ucb0ie_spi::W) writer structure" ] impl crate :: Writable for UCB0IE_SPI { }
# [ doc = "eUSCI_Bx Interrupt Enable Register" ] pub mod ucb0ie_spi {
# [ doc = "Reader of register UCB0IE_SPI" ] pub type R = crate :: R < u16 , super :: UCB0IE_SPI > ;
# [ doc = "Writer for register UCB0IE_SPI" ] pub type W = crate :: W < u16 , super :: UCB0IE_SPI > ;
# [ doc = "Register UCB0IE_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0IE_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE_A { # [ doc = "0: Interrupt disabled" ] UCRXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE_1 = 1 } impl From < UCRXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE`" ] pub type UCRXIE_R = crate :: R < bool , UCRXIE_A > ; impl UCRXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE_A { match self . bits { false => UCRXIE_A :: UCRXIE_0 , true => UCRXIE_A :: UCRXIE_1 } } # [ doc = "Checks if the value of the field is `UCRXIE_0`" ] # [ inline ( always ) ] pub fn is_ucrxie_0 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_0 } # [ doc = "Checks if the value of the field is `UCRXIE_1`" ] # [ inline ( always ) ] pub fn is_ucrxie_1 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_1 } }
# [ doc = "Write proxy for field `UCRXIE`" ] pub struct UCRXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE_A { # [ doc = "0: Interrupt disabled" ] UCTXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE_1 = 1 } impl From < UCTXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE`" ] pub type UCTXIE_R = crate :: R < bool , UCTXIE_A > ; impl UCTXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE_A { match self . bits { false => UCTXIE_A :: UCTXIE_0 , true => UCTXIE_A :: UCTXIE_1 } } # [ doc = "Checks if the value of the field is `UCTXIE_0`" ] # [ inline ( always ) ] pub fn is_uctxie_0 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_0 } # [ doc = "Checks if the value of the field is `UCTXIE_1`" ] # [ inline ( always ) ] pub fn is_uctxie_1 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_1 } }
# [ doc = "Write proxy for field `UCTXIE`" ] pub struct UCTXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & self ) -> UCRXIE_R { UCRXIE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & self ) -> UCTXIE_R { UCTXIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & mut self ) -> UCRXIE_W { UCRXIE_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & mut self ) -> UCTXIE_W { UCTXIE_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ifg](ucb0ifg) module" ] pub type UCB0IFG = crate :: Reg < u16 , _UCB0IFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0IFG ;
# [ doc = "`read()` method returns [ucb0ifg::R](ucb0ifg::R) reader structure" ] impl crate :: Readable for UCB0IFG { }
# [ doc = "`write(|w| ..)` method takes [ucb0ifg::W](ucb0ifg::W) writer structure" ] impl crate :: Writable for UCB0IFG { }
# [ doc = "eUSCI_Bx Interrupt Flag Register" ] pub mod ucb0ifg {
# [ doc = "Reader of register UCB0IFG" ] pub type R = crate :: R < u16 , super :: UCB0IFG > ;
# [ doc = "Writer for register UCB0IFG" ] pub type W = crate :: W < u16 , super :: UCB0IFG > ;
# [ doc = "Register UCB0IFG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0IFG { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "eUSCI_B receive interrupt flag 0\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG0_A { # [ doc = "0: No interrupt pending" ] UCRXIFG0_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG0_1 = 1 } impl From < UCRXIFG0_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG0`" ] pub type UCRXIFG0_R = crate :: R < bool , UCRXIFG0_A > ; impl UCRXIFG0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG0_A { match self . bits { false => UCRXIFG0_A :: UCRXIFG0_0 , true => UCRXIFG0_A :: UCRXIFG0_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG0_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg0_0 ( & self ) -> bool { * self == UCRXIFG0_A :: UCRXIFG0_0 } # [ doc = "Checks if the value of the field is `UCRXIFG0_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg0_1 ( & self ) -> bool { * self == UCRXIFG0_A :: UCRXIFG0_1 } }
# [ doc = "Write proxy for field `UCRXIFG0`" ] pub struct UCRXIFG0_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg0_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG0_A :: UCRXIFG0_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg0_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG0_A :: UCRXIFG0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "eUSCI_B transmit interrupt flag 0\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG0_A { # [ doc = "0: No interrupt pending" ] UCTXIFG0_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG0_1 = 1 } impl From < UCTXIFG0_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG0`" ] pub type UCTXIFG0_R = crate :: R < bool , UCTXIFG0_A > ; impl UCTXIFG0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG0_A { match self . bits { false => UCTXIFG0_A :: UCTXIFG0_0 , true => UCTXIFG0_A :: UCTXIFG0_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG0_0`" ] # [ inline ( always ) ] pub fn is_uctxifg0_0 ( & self ) -> bool { * self == UCTXIFG0_A :: UCTXIFG0_0 } # [ doc = "Checks if the value of the field is `UCTXIFG0_1`" ] # [ inline ( always ) ] pub fn is_uctxifg0_1 ( & self ) -> bool { * self == UCTXIFG0_A :: UCTXIFG0_1 } }
# [ doc = "Write proxy for field `UCTXIFG0`" ] pub struct UCTXIFG0_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg0_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG0_A :: UCTXIFG0_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg0_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG0_A :: UCTXIFG0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "START condition interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTTIFG_A { # [ doc = "0: No interrupt pending" ] UCSTTIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCSTTIFG_1 = 1 } impl From < UCSTTIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTTIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTTIFG`" ] pub type UCSTTIFG_R = crate :: R < bool , UCSTTIFG_A > ; impl UCSTTIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTTIFG_A { match self . bits { false => UCSTTIFG_A :: UCSTTIFG_0 , true => UCSTTIFG_A :: UCSTTIFG_1 } } # [ doc = "Checks if the value of the field is `UCSTTIFG_0`" ] # [ inline ( always ) ] pub fn is_ucsttifg_0 ( & self ) -> bool { * self == UCSTTIFG_A :: UCSTTIFG_0 } # [ doc = "Checks if the value of the field is `UCSTTIFG_1`" ] # [ inline ( always ) ] pub fn is_ucsttifg_1 ( & self ) -> bool { * self == UCSTTIFG_A :: UCSTTIFG_1 } }
# [ doc = "Write proxy for field `UCSTTIFG`" ] pub struct UCSTTIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTTIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTTIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucsttifg_0 ( self ) -> & 'a mut W { self . variant ( UCSTTIFG_A :: UCSTTIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucsttifg_1 ( self ) -> & 'a mut W { self . variant ( UCSTTIFG_A :: UCSTTIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "STOP condition interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTPIFG_A { # [ doc = "0: No interrupt pending" ] UCSTPIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCSTPIFG_1 = 1 } impl From < UCSTPIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTPIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTPIFG`" ] pub type UCSTPIFG_R = crate :: R < bool , UCSTPIFG_A > ; impl UCSTPIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTPIFG_A { match self . bits { false => UCSTPIFG_A :: UCSTPIFG_0 , true => UCSTPIFG_A :: UCSTPIFG_1 } } # [ doc = "Checks if the value of the field is `UCSTPIFG_0`" ] # [ inline ( always ) ] pub fn is_ucstpifg_0 ( & self ) -> bool { * self == UCSTPIFG_A :: UCSTPIFG_0 } # [ doc = "Checks if the value of the field is `UCSTPIFG_1`" ] # [ inline ( always ) ] pub fn is_ucstpifg_1 ( & self ) -> bool { * self == UCSTPIFG_A :: UCSTPIFG_1 } }
# [ doc = "Write proxy for field `UCSTPIFG`" ] pub struct UCSTPIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTPIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTPIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucstpifg_0 ( self ) -> & 'a mut W { self . variant ( UCSTPIFG_A :: UCSTPIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucstpifg_1 ( self ) -> & 'a mut W { self . variant ( UCSTPIFG_A :: UCSTPIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Arbitration lost interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCALIFG_A { # [ doc = "0: No interrupt pending" ] UCALIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCALIFG_1 = 1 } impl From < UCALIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCALIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCALIFG`" ] pub type UCALIFG_R = crate :: R < bool , UCALIFG_A > ; impl UCALIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCALIFG_A { match self . bits { false => UCALIFG_A :: UCALIFG_0 , true => UCALIFG_A :: UCALIFG_1 } } # [ doc = "Checks if the value of the field is `UCALIFG_0`" ] # [ inline ( always ) ] pub fn is_ucalifg_0 ( & self ) -> bool { * self == UCALIFG_A :: UCALIFG_0 } # [ doc = "Checks if the value of the field is `UCALIFG_1`" ] # [ inline ( always ) ] pub fn is_ucalifg_1 ( & self ) -> bool { * self == UCALIFG_A :: UCALIFG_1 } }
# [ doc = "Write proxy for field `UCALIFG`" ] pub struct UCALIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCALIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCALIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucalifg_0 ( self ) -> & 'a mut W { self . variant ( UCALIFG_A :: UCALIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucalifg_1 ( self ) -> & 'a mut W { self . variant ( UCALIFG_A :: UCALIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Not-acknowledge received interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCNACKIFG_A { # [ doc = "0: No interrupt pending" ] UCNACKIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCNACKIFG_1 = 1 } impl From < UCNACKIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCNACKIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCNACKIFG`" ] pub type UCNACKIFG_R = crate :: R < bool , UCNACKIFG_A > ; impl UCNACKIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCNACKIFG_A { match self . bits { false => UCNACKIFG_A :: UCNACKIFG_0 , true => UCNACKIFG_A :: UCNACKIFG_1 } } # [ doc = "Checks if the value of the field is `UCNACKIFG_0`" ] # [ inline ( always ) ] pub fn is_ucnackifg_0 ( & self ) -> bool { * self == UCNACKIFG_A :: UCNACKIFG_0 } # [ doc = "Checks if the value of the field is `UCNACKIFG_1`" ] # [ inline ( always ) ] pub fn is_ucnackifg_1 ( & self ) -> bool { * self == UCNACKIFG_A :: UCNACKIFG_1 } }
# [ doc = "Write proxy for field `UCNACKIFG`" ] pub struct UCNACKIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCNACKIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCNACKIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucnackifg_0 ( self ) -> & 'a mut W { self . variant ( UCNACKIFG_A :: UCNACKIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucnackifg_1 ( self ) -> & 'a mut W { self . variant ( UCNACKIFG_A :: UCNACKIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Byte counter interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBCNTIFG_A { # [ doc = "0: No interrupt pending" ] UCBCNTIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCBCNTIFG_1 = 1 } impl From < UCBCNTIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBCNTIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBCNTIFG`" ] pub type UCBCNTIFG_R = crate :: R < bool , UCBCNTIFG_A > ; impl UCBCNTIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBCNTIFG_A { match self . bits { false => UCBCNTIFG_A :: UCBCNTIFG_0 , true => UCBCNTIFG_A :: UCBCNTIFG_1 } } # [ doc = "Checks if the value of the field is `UCBCNTIFG_0`" ] # [ inline ( always ) ] pub fn is_ucbcntifg_0 ( & self ) -> bool { * self == UCBCNTIFG_A :: UCBCNTIFG_0 } # [ doc = "Checks if the value of the field is `UCBCNTIFG_1`" ] # [ inline ( always ) ] pub fn is_ucbcntifg_1 ( & self ) -> bool { * self == UCBCNTIFG_A :: UCBCNTIFG_1 } }
# [ doc = "Write proxy for field `UCBCNTIFG`" ] pub struct UCBCNTIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCBCNTIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBCNTIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucbcntifg_0 ( self ) -> & 'a mut W { self . variant ( UCBCNTIFG_A :: UCBCNTIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucbcntifg_1 ( self ) -> & 'a mut W { self . variant ( UCBCNTIFG_A :: UCBCNTIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Clock low timeout interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCLTOIFG_A { # [ doc = "0: No interrupt pending" ] UCCLTOIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCCLTOIFG_1 = 1 } impl From < UCCLTOIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCLTOIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCLTOIFG`" ] pub type UCCLTOIFG_R = crate :: R < bool , UCCLTOIFG_A > ; impl UCCLTOIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCLTOIFG_A { match self . bits { false => UCCLTOIFG_A :: UCCLTOIFG_0 , true => UCCLTOIFG_A :: UCCLTOIFG_1 } } # [ doc = "Checks if the value of the field is `UCCLTOIFG_0`" ] # [ inline ( always ) ] pub fn is_uccltoifg_0 ( & self ) -> bool { * self == UCCLTOIFG_A :: UCCLTOIFG_0 } # [ doc = "Checks if the value of the field is `UCCLTOIFG_1`" ] # [ inline ( always ) ] pub fn is_uccltoifg_1 ( & self ) -> bool { * self == UCCLTOIFG_A :: UCCLTOIFG_1 } }
# [ doc = "Write proxy for field `UCCLTOIFG`" ] pub struct UCCLTOIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCCLTOIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCLTOIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uccltoifg_0 ( self ) -> & 'a mut W { self . variant ( UCCLTOIFG_A :: UCCLTOIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uccltoifg_1 ( self ) -> & 'a mut W { self . variant ( UCCLTOIFG_A :: UCCLTOIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "eUSCI_B receive interrupt flag 1\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG1_A { # [ doc = "0: No interrupt pending" ] UCRXIFG1_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG1_1 = 1 } impl From < UCRXIFG1_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG1_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG1`" ] pub type UCRXIFG1_R = crate :: R < bool , UCRXIFG1_A > ; impl UCRXIFG1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG1_A { match self . bits { false => UCRXIFG1_A :: UCRXIFG1_0 , true => UCRXIFG1_A :: UCRXIFG1_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG1_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg1_0 ( & self ) -> bool { * self == UCRXIFG1_A :: UCRXIFG1_0 } # [ doc = "Checks if the value of the field is `UCRXIFG1_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg1_1 ( & self ) -> bool { * self == UCRXIFG1_A :: UCRXIFG1_1 } }
# [ doc = "Write proxy for field `UCRXIFG1`" ] pub struct UCRXIFG1_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG1_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg1_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG1_A :: UCRXIFG1_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg1_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG1_A :: UCRXIFG1_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "eUSCI_B transmit interrupt flag 1\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG1_A { # [ doc = "0: No interrupt pending" ] UCTXIFG1_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG1_1 = 1 } impl From < UCTXIFG1_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG1_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG1`" ] pub type UCTXIFG1_R = crate :: R < bool , UCTXIFG1_A > ; impl UCTXIFG1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG1_A { match self . bits { false => UCTXIFG1_A :: UCTXIFG1_0 , true => UCTXIFG1_A :: UCTXIFG1_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG1_0`" ] # [ inline ( always ) ] pub fn is_uctxifg1_0 ( & self ) -> bool { * self == UCTXIFG1_A :: UCTXIFG1_0 } # [ doc = "Checks if the value of the field is `UCTXIFG1_1`" ] # [ inline ( always ) ] pub fn is_uctxifg1_1 ( & self ) -> bool { * self == UCTXIFG1_A :: UCTXIFG1_1 } }
# [ doc = "Write proxy for field `UCTXIFG1`" ] pub struct UCTXIFG1_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG1_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg1_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG1_A :: UCTXIFG1_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg1_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG1_A :: UCTXIFG1_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "eUSCI_B receive interrupt flag 2\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG2_A { # [ doc = "0: No interrupt pending" ] UCRXIFG2_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG2_1 = 1 } impl From < UCRXIFG2_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG2_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG2`" ] pub type UCRXIFG2_R = crate :: R < bool , UCRXIFG2_A > ; impl UCRXIFG2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG2_A { match self . bits { false => UCRXIFG2_A :: UCRXIFG2_0 , true => UCRXIFG2_A :: UCRXIFG2_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG2_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg2_0 ( & self ) -> bool { * self == UCRXIFG2_A :: UCRXIFG2_0 } # [ doc = "Checks if the value of the field is `UCRXIFG2_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg2_1 ( & self ) -> bool { * self == UCRXIFG2_A :: UCRXIFG2_1 } }
# [ doc = "Write proxy for field `UCRXIFG2`" ] pub struct UCRXIFG2_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG2_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg2_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG2_A :: UCRXIFG2_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg2_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG2_A :: UCRXIFG2_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "eUSCI_B transmit interrupt flag 2\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG2_A { # [ doc = "0: No interrupt pending" ] UCTXIFG2_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG2_1 = 1 } impl From < UCTXIFG2_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG2_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG2`" ] pub type UCTXIFG2_R = crate :: R < bool , UCTXIFG2_A > ; impl UCTXIFG2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG2_A { match self . bits { false => UCTXIFG2_A :: UCTXIFG2_0 , true => UCTXIFG2_A :: UCTXIFG2_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG2_0`" ] # [ inline ( always ) ] pub fn is_uctxifg2_0 ( & self ) -> bool { * self == UCTXIFG2_A :: UCTXIFG2_0 } # [ doc = "Checks if the value of the field is `UCTXIFG2_1`" ] # [ inline ( always ) ] pub fn is_uctxifg2_1 ( & self ) -> bool { * self == UCTXIFG2_A :: UCTXIFG2_1 } }
# [ doc = "Write proxy for field `UCTXIFG2`" ] pub struct UCTXIFG2_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG2_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg2_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG2_A :: UCTXIFG2_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg2_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG2_A :: UCTXIFG2_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "eUSCI_B receive interrupt flag 3\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG3_A { # [ doc = "0: No interrupt pending" ] UCRXIFG3_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG3_1 = 1 } impl From < UCRXIFG3_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG3_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG3`" ] pub type UCRXIFG3_R = crate :: R < bool , UCRXIFG3_A > ; impl UCRXIFG3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG3_A { match self . bits { false => UCRXIFG3_A :: UCRXIFG3_0 , true => UCRXIFG3_A :: UCRXIFG3_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG3_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg3_0 ( & self ) -> bool { * self == UCRXIFG3_A :: UCRXIFG3_0 } # [ doc = "Checks if the value of the field is `UCRXIFG3_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg3_1 ( & self ) -> bool { * self == UCRXIFG3_A :: UCRXIFG3_1 } }
# [ doc = "Write proxy for field `UCRXIFG3`" ] pub struct UCRXIFG3_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG3_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG3_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg3_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG3_A :: UCRXIFG3_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg3_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG3_A :: UCRXIFG3_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "eUSCI_B transmit interrupt flag 3\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG3_A { # [ doc = "0: No interrupt pending" ] UCTXIFG3_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG3_1 = 1 } impl From < UCTXIFG3_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG3_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG3`" ] pub type UCTXIFG3_R = crate :: R < bool , UCTXIFG3_A > ; impl UCTXIFG3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG3_A { match self . bits { false => UCTXIFG3_A :: UCTXIFG3_0 , true => UCTXIFG3_A :: UCTXIFG3_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG3_0`" ] # [ inline ( always ) ] pub fn is_uctxifg3_0 ( & self ) -> bool { * self == UCTXIFG3_A :: UCTXIFG3_0 } # [ doc = "Checks if the value of the field is `UCTXIFG3_1`" ] # [ inline ( always ) ] pub fn is_uctxifg3_1 ( & self ) -> bool { * self == UCTXIFG3_A :: UCTXIFG3_1 } }
# [ doc = "Write proxy for field `UCTXIFG3`" ] pub struct UCTXIFG3_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG3_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG3_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg3_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG3_A :: UCTXIFG3_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg3_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG3_A :: UCTXIFG3_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Bit position 9 interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBIT9IFG_A { # [ doc = "0: No interrupt pending" ] UCBIT9IFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCBIT9IFG_1 = 1 } impl From < UCBIT9IFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBIT9IFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBIT9IFG`" ] pub type UCBIT9IFG_R = crate :: R < bool , UCBIT9IFG_A > ; impl UCBIT9IFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBIT9IFG_A { match self . bits { false => UCBIT9IFG_A :: UCBIT9IFG_0 , true => UCBIT9IFG_A :: UCBIT9IFG_1 } } # [ doc = "Checks if the value of the field is `UCBIT9IFG_0`" ] # [ inline ( always ) ] pub fn is_ucbit9ifg_0 ( & self ) -> bool { * self == UCBIT9IFG_A :: UCBIT9IFG_0 } # [ doc = "Checks if the value of the field is `UCBIT9IFG_1`" ] # [ inline ( always ) ] pub fn is_ucbit9ifg_1 ( & self ) -> bool { * self == UCBIT9IFG_A :: UCBIT9IFG_1 } }
# [ doc = "Write proxy for field `UCBIT9IFG`" ] pub struct UCBIT9IFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCBIT9IFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBIT9IFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucbit9ifg_0 ( self ) -> & 'a mut W { self . variant ( UCBIT9IFG_A :: UCBIT9IFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucbit9ifg_1 ( self ) -> & 'a mut W { self . variant ( UCBIT9IFG_A :: UCBIT9IFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - eUSCI_B receive interrupt flag 0" ] # [ inline ( always ) ] pub fn ucrxifg0 ( & self ) -> UCRXIFG0_R { UCRXIFG0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - eUSCI_B transmit interrupt flag 0" ] # [ inline ( always ) ] pub fn uctxifg0 ( & self ) -> UCTXIFG0_R { UCTXIFG0_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - START condition interrupt flag" ] # [ inline ( always ) ] pub fn ucsttifg ( & self ) -> UCSTTIFG_R { UCSTTIFG_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - STOP condition interrupt flag" ] # [ inline ( always ) ] pub fn ucstpifg ( & self ) -> UCSTPIFG_R { UCSTPIFG_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Arbitration lost interrupt flag" ] # [ inline ( always ) ] pub fn ucalifg ( & self ) -> UCALIFG_R { UCALIFG_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Not-acknowledge received interrupt flag" ] # [ inline ( always ) ] pub fn ucnackifg ( & self ) -> UCNACKIFG_R { UCNACKIFG_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Byte counter interrupt flag" ] # [ inline ( always ) ] pub fn ucbcntifg ( & self ) -> UCBCNTIFG_R { UCBCNTIFG_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Clock low timeout interrupt flag" ] # [ inline ( always ) ] pub fn uccltoifg ( & self ) -> UCCLTOIFG_R { UCCLTOIFG_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - eUSCI_B receive interrupt flag 1" ] # [ inline ( always ) ] pub fn ucrxifg1 ( & self ) -> UCRXIFG1_R { UCRXIFG1_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - eUSCI_B transmit interrupt flag 1" ] # [ inline ( always ) ] pub fn uctxifg1 ( & self ) -> UCTXIFG1_R { UCTXIFG1_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - eUSCI_B receive interrupt flag 2" ] # [ inline ( always ) ] pub fn ucrxifg2 ( & self ) -> UCRXIFG2_R { UCRXIFG2_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - eUSCI_B transmit interrupt flag 2" ] # [ inline ( always ) ] pub fn uctxifg2 ( & self ) -> UCTXIFG2_R { UCTXIFG2_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - eUSCI_B receive interrupt flag 3" ] # [ inline ( always ) ] pub fn ucrxifg3 ( & self ) -> UCRXIFG3_R { UCRXIFG3_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - eUSCI_B transmit interrupt flag 3" ] # [ inline ( always ) ] pub fn uctxifg3 ( & self ) -> UCTXIFG3_R { UCTXIFG3_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Bit position 9 interrupt flag" ] # [ inline ( always ) ] pub fn ucbit9ifg ( & self ) -> UCBIT9IFG_R { UCBIT9IFG_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - eUSCI_B receive interrupt flag 0" ] # [ inline ( always ) ] pub fn ucrxifg0 ( & mut self ) -> UCRXIFG0_W { UCRXIFG0_W { w : self } }
# [ doc = "Bit 1 - eUSCI_B transmit interrupt flag 0" ] # [ inline ( always ) ] pub fn uctxifg0 ( & mut self ) -> UCTXIFG0_W { UCTXIFG0_W { w : self } }
# [ doc = "Bit 2 - START condition interrupt flag" ] # [ inline ( always ) ] pub fn ucsttifg ( & mut self ) -> UCSTTIFG_W { UCSTTIFG_W { w : self } }
# [ doc = "Bit 3 - STOP condition interrupt flag" ] # [ inline ( always ) ] pub fn ucstpifg ( & mut self ) -> UCSTPIFG_W { UCSTPIFG_W { w : self } }
# [ doc = "Bit 4 - Arbitration lost interrupt flag" ] # [ inline ( always ) ] pub fn ucalifg ( & mut self ) -> UCALIFG_W { UCALIFG_W { w : self } }
# [ doc = "Bit 5 - Not-acknowledge received interrupt flag" ] # [ inline ( always ) ] pub fn ucnackifg ( & mut self ) -> UCNACKIFG_W { UCNACKIFG_W { w : self } }
# [ doc = "Bit 6 - Byte counter interrupt flag" ] # [ inline ( always ) ] pub fn ucbcntifg ( & mut self ) -> UCBCNTIFG_W { UCBCNTIFG_W { w : self } }
# [ doc = "Bit 7 - Clock low timeout interrupt flag" ] # [ inline ( always ) ] pub fn uccltoifg ( & mut self ) -> UCCLTOIFG_W { UCCLTOIFG_W { w : self } }
# [ doc = "Bit 8 - eUSCI_B receive interrupt flag 1" ] # [ inline ( always ) ] pub fn ucrxifg1 ( & mut self ) -> UCRXIFG1_W { UCRXIFG1_W { w : self } }
# [ doc = "Bit 9 - eUSCI_B transmit interrupt flag 1" ] # [ inline ( always ) ] pub fn uctxifg1 ( & mut self ) -> UCTXIFG1_W { UCTXIFG1_W { w : self } }
# [ doc = "Bit 10 - eUSCI_B receive interrupt flag 2" ] # [ inline ( always ) ] pub fn ucrxifg2 ( & mut self ) -> UCRXIFG2_W { UCRXIFG2_W { w : self } }
# [ doc = "Bit 11 - eUSCI_B transmit interrupt flag 2" ] # [ inline ( always ) ] pub fn uctxifg2 ( & mut self ) -> UCTXIFG2_W { UCTXIFG2_W { w : self } }
# [ doc = "Bit 12 - eUSCI_B receive interrupt flag 3" ] # [ inline ( always ) ] pub fn ucrxifg3 ( & mut self ) -> UCRXIFG3_W { UCRXIFG3_W { w : self } }
# [ doc = "Bit 13 - eUSCI_B transmit interrupt flag 3" ] # [ inline ( always ) ] pub fn uctxifg3 ( & mut self ) -> UCTXIFG3_W { UCTXIFG3_W { w : self } }
# [ doc = "Bit 14 - Bit position 9 interrupt flag" ] # [ inline ( always ) ] pub fn ucbit9ifg ( & mut self ) -> UCBIT9IFG_W { UCBIT9IFG_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ifg_spi](ucb0ifg_spi) module" ] pub type UCB0IFG_SPI = crate :: Reg < u16 , _UCB0IFG_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0IFG_SPI ;
# [ doc = "`read()` method returns [ucb0ifg_spi::R](ucb0ifg_spi::R) reader structure" ] impl crate :: Readable for UCB0IFG_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb0ifg_spi::W](ucb0ifg_spi::W) writer structure" ] impl crate :: Writable for UCB0IFG_SPI { }
# [ doc = "eUSCI_Bx Interrupt Flag Register" ] pub mod ucb0ifg_spi {
# [ doc = "Reader of register UCB0IFG_SPI" ] pub type R = crate :: R < u16 , super :: UCB0IFG_SPI > ;
# [ doc = "Writer for register UCB0IFG_SPI" ] pub type W = crate :: W < u16 , super :: UCB0IFG_SPI > ;
# [ doc = "Register UCB0IFG_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB0IFG_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG_A { # [ doc = "0: No interrupt pending" ] UCRXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG_1 = 1 } impl From < UCRXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG`" ] pub type UCRXIFG_R = crate :: R < bool , UCRXIFG_A > ; impl UCRXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG_A { match self . bits { false => UCRXIFG_A :: UCRXIFG_0 , true => UCRXIFG_A :: UCRXIFG_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg_0 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_0 } # [ doc = "Checks if the value of the field is `UCRXIFG_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg_1 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_1 } }
# [ doc = "Write proxy for field `UCRXIFG`" ] pub struct UCRXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG_A { # [ doc = "0: No interrupt pending" ] UCTXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG_1 = 1 } impl From < UCTXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG`" ] pub type UCTXIFG_R = crate :: R < bool , UCTXIFG_A > ; impl UCTXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG_A { match self . bits { false => UCTXIFG_A :: UCTXIFG_0 , true => UCTXIFG_A :: UCTXIFG_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG_0`" ] # [ inline ( always ) ] pub fn is_uctxifg_0 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_0 } # [ doc = "Checks if the value of the field is `UCTXIFG_1`" ] # [ inline ( always ) ] pub fn is_uctxifg_1 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_1 } }
# [ doc = "Write proxy for field `UCTXIFG`" ] pub struct UCTXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & self ) -> UCRXIFG_R { UCRXIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & self ) -> UCTXIFG_R { UCTXIFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & mut self ) -> UCRXIFG_W { UCRXIFG_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & mut self ) -> UCTXIFG_W { UCTXIFG_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0iv](ucb0iv) module" ] pub type UCB0IV = crate :: Reg < u16 , _UCB0IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0IV ;
# [ doc = "`read()` method returns [ucb0iv::R](ucb0iv::R) reader structure" ] impl crate :: Readable for UCB0IV { }
# [ doc = "eUSCI_Bx Interrupt Vector Register" ] pub mod ucb0iv {
# [ doc = "Reader of register UCB0IV" ] pub type R = crate :: R < u16 , super :: UCB0IV > ;
# [ doc = "eUSCI_B interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum UCIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Arbitration lost; Interrupt Flag: UCALIFG; Interrupt Priority: Highest" ] UCALIFG = 2 , # [ doc = "4: Interrupt Source: Not acknowledgment; Interrupt Flag: UCNACKIFG" ] UCNACKIFG = 4 , # [ doc = "6: Interrupt Source: Start condition received; Interrupt Flag: UCSTTIFG" ] UCSTTIFG = 6 , # [ doc = "8: Interrupt Source: Stop condition received; Interrupt Flag: UCSTPIFG" ] UCSTPIFG = 8 , # [ doc = "10: Interrupt Source: Slave 3 Data received; Interrupt Flag: UCRXIFG3" ] UCRXIFG3 = 10 , # [ doc = "12: Interrupt Source: Slave 3 Transmit buffer empty; Interrupt Flag: UCTXIFG3" ] UCTXIFG3 = 12 , # [ doc = "14: Interrupt Source: Slave 2 Data received; Interrupt Flag: UCRXIFG2" ] UCRXIFG2 = 14 , # [ doc = "16: Interrupt Source: Slave 2 Transmit buffer empty; Interrupt Flag: UCTXIFG2" ] UCTXIFG2 = 16 , # [ doc = "18: Interrupt Source: Slave 1 Data received; Interrupt Flag: UCRXIFG1" ] UCRXIFG1 = 18 , # [ doc = "20: Interrupt Source: Slave 1 Transmit buffer empty; Interrupt Flag: UCTXIFG1" ] UCTXIFG1 = 20 , # [ doc = "22: Interrupt Source: Data received; Interrupt Flag: UCRXIFG0" ] UCRXIFG0 = 22 , # [ doc = "24: Interrupt Source: Transmit buffer empty; Interrupt Flag: UCTXIFG0" ] UCTXIFG0 = 24 , # [ doc = "26: Interrupt Source: Byte counter zero; Interrupt Flag: UCBCNTIFG" ] UCBCNTIFG = 26 , # [ doc = "28: Interrupt Source: Clock low timeout; Interrupt Flag: UCCLTOIFG" ] UCCLTOIFG = 28 , # [ doc = "30: Interrupt Source: Nineth bit position; Interrupt Flag: UCBIT9IFG; Priority: Lowest" ] UCBIT9IFG = 30 } impl From < UCIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : UCIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCIV`" ] pub type UCIV_R = crate :: R < u16 , UCIV_A > ; impl UCIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , UCIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( UCIV_A :: NONE ) , 2 => Val ( UCIV_A :: UCALIFG ) , 4 => Val ( UCIV_A :: UCNACKIFG ) , 6 => Val ( UCIV_A :: UCSTTIFG ) , 8 => Val ( UCIV_A :: UCSTPIFG ) , 10 => Val ( UCIV_A :: UCRXIFG3 ) , 12 => Val ( UCIV_A :: UCTXIFG3 ) , 14 => Val ( UCIV_A :: UCRXIFG2 ) , 16 => Val ( UCIV_A :: UCTXIFG2 ) , 18 => Val ( UCIV_A :: UCRXIFG1 ) , 20 => Val ( UCIV_A :: UCTXIFG1 ) , 22 => Val ( UCIV_A :: UCRXIFG0 ) , 24 => Val ( UCIV_A :: UCTXIFG0 ) , 26 => Val ( UCIV_A :: UCBCNTIFG ) , 28 => Val ( UCIV_A :: UCCLTOIFG ) , 30 => Val ( UCIV_A :: UCBIT9IFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == UCIV_A :: NONE } # [ doc = "Checks if the value of the field is `UCALIFG`" ] # [ inline ( always ) ] pub fn is_ucalifg ( & self ) -> bool { * self == UCIV_A :: UCALIFG } # [ doc = "Checks if the value of the field is `UCNACKIFG`" ] # [ inline ( always ) ] pub fn is_ucnackifg ( & self ) -> bool { * self == UCIV_A :: UCNACKIFG } # [ doc = "Checks if the value of the field is `UCSTTIFG`" ] # [ inline ( always ) ] pub fn is_ucsttifg ( & self ) -> bool { * self == UCIV_A :: UCSTTIFG } # [ doc = "Checks if the value of the field is `UCSTPIFG`" ] # [ inline ( always ) ] pub fn is_ucstpifg ( & self ) -> bool { * self == UCIV_A :: UCSTPIFG } # [ doc = "Checks if the value of the field is `UCRXIFG3`" ] # [ inline ( always ) ] pub fn is_ucrxifg3 ( & self ) -> bool { * self == UCIV_A :: UCRXIFG3 } # [ doc = "Checks if the value of the field is `UCTXIFG3`" ] # [ inline ( always ) ] pub fn is_uctxifg3 ( & self ) -> bool { * self == UCIV_A :: UCTXIFG3 } # [ doc = "Checks if the value of the field is `UCRXIFG2`" ] # [ inline ( always ) ] pub fn is_ucrxifg2 ( & self ) -> bool { * self == UCIV_A :: UCRXIFG2 } # [ doc = "Checks if the value of the field is `UCTXIFG2`" ] # [ inline ( always ) ] pub fn is_uctxifg2 ( & self ) -> bool { * self == UCIV_A :: UCTXIFG2 } # [ doc = "Checks if the value of the field is `UCRXIFG1`" ] # [ inline ( always ) ] pub fn is_ucrxifg1 ( & self ) -> bool { * self == UCIV_A :: UCRXIFG1 } # [ doc = "Checks if the value of the field is `UCTXIFG1`" ] # [ inline ( always ) ] pub fn is_uctxifg1 ( & self ) -> bool { * self == UCIV_A :: UCTXIFG1 } # [ doc = "Checks if the value of the field is `UCRXIFG0`" ] # [ inline ( always ) ] pub fn is_ucrxifg0 ( & self ) -> bool { * self == UCIV_A :: UCRXIFG0 } # [ doc = "Checks if the value of the field is `UCTXIFG0`" ] # [ inline ( always ) ] pub fn is_uctxifg0 ( & self ) -> bool { * self == UCIV_A :: UCTXIFG0 } # [ doc = "Checks if the value of the field is `UCBCNTIFG`" ] # [ inline ( always ) ] pub fn is_ucbcntifg ( & self ) -> bool { * self == UCIV_A :: UCBCNTIFG } # [ doc = "Checks if the value of the field is `UCCLTOIFG`" ] # [ inline ( always ) ] pub fn is_uccltoifg ( & self ) -> bool { * self == UCIV_A :: UCCLTOIFG } # [ doc = "Checks if the value of the field is `UCBIT9IFG`" ] # [ inline ( always ) ] pub fn is_ucbit9ifg ( & self ) -> bool { * self == UCIV_A :: UCBIT9IFG } }
impl R {
# [ doc = "Bits 0:15 - eUSCI_B interrupt vector value" ] # [ inline ( always ) ] pub fn uciv ( & self ) -> UCIV_R { UCIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
# [ doc = "eUSCI_Bx Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0iv_spi](ucb0iv_spi) module" ] pub type UCB0IV_SPI = crate :: Reg < u16 , _UCB0IV_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB0IV_SPI ;
# [ doc = "`read()` method returns [ucb0iv_spi::R](ucb0iv_spi::R) reader structure" ] impl crate :: Readable for UCB0IV_SPI { }
# [ doc = "eUSCI_Bx Interrupt Vector Register" ] pub mod ucb0iv_spi {
# [ doc = "Reader of register UCB0IV_SPI" ] pub type R = crate :: R < u16 , super :: UCB0IV_SPI > ;
# [ doc = "eUSCI_B interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum UCIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Data received; Interrupt Flag: UCRXIFG; Interrupt Priority: Highest" ] UCRXIFG = 2 , # [ doc = "4: Interrupt Source: Transmit buffer empty; Interrupt Flag: UCTXIFG; Interrupt Priority: Lowest" ] UCTXIFG = 4 } impl From < UCIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : UCIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCIV`" ] pub type UCIV_R = crate :: R < u16 , UCIV_A > ; impl UCIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , UCIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( UCIV_A :: NONE ) , 2 => Val ( UCIV_A :: UCRXIFG ) , 4 => Val ( UCIV_A :: UCTXIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == UCIV_A :: NONE } # [ doc = "Checks if the value of the field is `UCRXIFG`" ] # [ inline ( always ) ] pub fn is_ucrxifg ( & self ) -> bool { * self == UCIV_A :: UCRXIFG } # [ doc = "Checks if the value of the field is `UCTXIFG`" ] # [ inline ( always ) ] pub fn is_uctxifg ( & self ) -> bool { * self == UCIV_A :: UCTXIFG } }
impl R {
# [ doc = "Bits 0:15 - eUSCI_B interrupt vector value" ] # [ inline ( always ) ] pub fn uciv ( & self ) -> UCIV_R { UCIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "eUSCI_A1" ] pub struct E_USCI_A1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for E_USCI_A1 { } impl E_USCI_A1 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const e_usci_a1 :: RegisterBlock { 0x0580 as * const _ } } impl Deref for E_USCI_A1 { type Target = e_usci_a1 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * E_USCI_A1 :: ptr ( ) } } }
# [ doc = "eUSCI_A1" ] pub mod e_usci_a1 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved_0_uca1ctlw : [ u8 ; 2usize ] , # [ doc = "0x02 - eUSCI_Ax Control Word Register 1" ] pub uca1ctlw1 : UCA1CTLW1 , _reserved2 : [ u8 ; 2usize ] , _reserved_2_uca1 : [ u8 ; 2usize ] , # [ doc = "0x08 - eUSCI_Ax Modulation Control Word Register" ] pub uca1mctlw : UCA1MCTLW , _reserved_4_uca1 : [ u8 ; 2usize ] , _reserved_5_uca1 : [ u8 ; 2usize ] , _reserved_6_uca1 : [ u8 ; 2usize ] , # [ doc = "0x10 - eUSCI_Ax Auto Baud Rate Control Register" ] pub uca1abctl : UCA1ABCTL , # [ doc = "0x12 - eUSCI_Ax IrDA Control Word Register" ] pub uca1irctl : UCA1IRCTL , _reserved9 : [ u8 ; 6usize ] , _reserved_9_uca1 : [ u8 ; 2usize ] , _reserved_10_uca1 : [ u8 ; 2usize ] , _reserved_11_uca1 : [ u8 ; 2usize ] , } impl RegisterBlock { # [ doc = "0x00 - eUSCI_Ax Control Word Register 0" ] # [ inline ( always ) ] pub fn uca1ctlw0_spi ( & self ) -> & UCA1CTLW0_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const UCA1CTLW0_SPI ) } } # [ doc = "0x00 - eUSCI_Ax Control Word Register 0" ] # [ inline ( always ) ] pub fn uca1ctlw0_spi_mut ( & self ) -> & mut UCA1CTLW0_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut UCA1CTLW0_SPI ) } } # [ doc = "0x00 - eUSCI_Ax Control Word Register 0" ] # [ inline ( always ) ] pub fn uca1ctlw0 ( & self ) -> & UCA1CTLW0 { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const UCA1CTLW0 ) } } # [ doc = "0x00 - eUSCI_Ax Control Word Register 0" ] # [ inline ( always ) ] pub fn uca1ctlw0_mut ( & self ) -> & mut UCA1CTLW0 { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut UCA1CTLW0 ) } } # [ doc = "0x06 - eUSCI_Ax Bit Rate Control Register 1" ] # [ inline ( always ) ] pub fn uca1brw_spi ( & self ) -> & UCA1BRW_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 6usize ) as * const UCA1BRW_SPI ) } } # [ doc = "0x06 - eUSCI_Ax Bit Rate Control Register 1" ] # [ inline ( always ) ] pub fn uca1brw_spi_mut ( & self ) -> & mut UCA1BRW_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 6usize ) as * mut UCA1BRW_SPI ) } } # [ doc = "0x06 - eUSCI_Ax Baud Rate Control Word Register" ] # [ inline ( always ) ] pub fn uca1brw ( & self ) -> & UCA1BRW { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 6usize ) as * const UCA1BRW ) } } # [ doc = "0x06 - eUSCI_Ax Baud Rate Control Word Register" ] # [ inline ( always ) ] pub fn uca1brw_mut ( & self ) -> & mut UCA1BRW { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 6usize ) as * mut UCA1BRW ) } } # [ doc = "0x0a - UCA1STATW_SPI" ] # [ inline ( always ) ] pub fn uca1statw_spi ( & self ) -> & UCA1STATW_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 10usize ) as * const UCA1STATW_SPI ) } } # [ doc = "0x0a - UCA1STATW_SPI" ] # [ inline ( always ) ] pub fn uca1statw_spi_mut ( & self ) -> & mut UCA1STATW_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 10usize ) as * mut UCA1STATW_SPI ) } } # [ doc = "0x0a - eUSCI_Ax Status Register" ] # [ inline ( always ) ] pub fn uca1statw ( & self ) -> & UCA1STATW { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 10usize ) as * const UCA1STATW ) } } # [ doc = "0x0a - eUSCI_Ax Status Register" ] # [ inline ( always ) ] pub fn uca1statw_mut ( & self ) -> & mut UCA1STATW { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 10usize ) as * mut UCA1STATW ) } } # [ doc = "0x0c - eUSCI_Ax Receive Buffer Register" ] # [ inline ( always ) ] pub fn uca1rxbuf_spi ( & self ) -> & UCA1RXBUF_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const UCA1RXBUF_SPI ) } } # [ doc = "0x0c - eUSCI_Ax Receive Buffer Register" ] # [ inline ( always ) ] pub fn uca1rxbuf_spi_mut ( & self ) -> & mut UCA1RXBUF_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut UCA1RXBUF_SPI ) } } # [ doc = "0x0c - eUSCI_Ax Receive Buffer Register" ] # [ inline ( always ) ] pub fn uca1rxbuf ( & self ) -> & UCA1RXBUF { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const UCA1RXBUF ) } } # [ doc = "0x0c - eUSCI_Ax Receive Buffer Register" ] # [ inline ( always ) ] pub fn uca1rxbuf_mut ( & self ) -> & mut UCA1RXBUF { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut UCA1RXBUF ) } } # [ doc = "0x0e - eUSCI_Ax Transmit Buffer Register" ] # [ inline ( always ) ] pub fn uca1txbuf_spi ( & self ) -> & UCA1TXBUF_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 14usize ) as * const UCA1TXBUF_SPI ) } } # [ doc = "0x0e - eUSCI_Ax Transmit Buffer Register" ] # [ inline ( always ) ] pub fn uca1txbuf_spi_mut ( & self ) -> & mut UCA1TXBUF_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 14usize ) as * mut UCA1TXBUF_SPI ) } } # [ doc = "0x0e - eUSCI_Ax Transmit Buffer Register" ] # [ inline ( always ) ] pub fn uca1txbuf ( & self ) -> & UCA1TXBUF { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 14usize ) as * const UCA1TXBUF ) } } # [ doc = "0x0e - eUSCI_Ax Transmit Buffer Register" ] # [ inline ( always ) ] pub fn uca1txbuf_mut ( & self ) -> & mut UCA1TXBUF { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 14usize ) as * mut UCA1TXBUF ) } } # [ doc = "0x1a - eUSCI_Ax Interrupt Enable Register" ] # [ inline ( always ) ] pub fn uca1ie_spi ( & self ) -> & UCA1IE_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 26usize ) as * const UCA1IE_SPI ) } } # [ doc = "0x1a - eUSCI_Ax Interrupt Enable Register" ] # [ inline ( always ) ] pub fn uca1ie_spi_mut ( & self ) -> & mut UCA1IE_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 26usize ) as * mut UCA1IE_SPI ) } } # [ doc = "0x1a - eUSCI_Ax Interrupt Enable Register" ] # [ inline ( always ) ] pub fn uca1ie ( & self ) -> & UCA1IE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 26usize ) as * const UCA1IE ) } } # [ doc = "0x1a - eUSCI_Ax Interrupt Enable Register" ] # [ inline ( always ) ] pub fn uca1ie_mut ( & self ) -> & mut UCA1IE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 26usize ) as * mut UCA1IE ) } } # [ doc = "0x1c - eUSCI_Ax Interrupt Flag Register" ] # [ inline ( always ) ] pub fn uca1ifg_spi ( & self ) -> & UCA1IFG_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 28usize ) as * const UCA1IFG_SPI ) } } # [ doc = "0x1c - eUSCI_Ax Interrupt Flag Register" ] # [ inline ( always ) ] pub fn uca1ifg_spi_mut ( & self ) -> & mut UCA1IFG_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 28usize ) as * mut UCA1IFG_SPI ) } } # [ doc = "0x1c - eUSCI_Ax Interrupt Flag Register" ] # [ inline ( always ) ] pub fn uca1ifg ( & self ) -> & UCA1IFG { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 28usize ) as * const UCA1IFG ) } } # [ doc = "0x1c - eUSCI_Ax Interrupt Flag Register" ] # [ inline ( always ) ] pub fn uca1ifg_mut ( & self ) -> & mut UCA1IFG { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 28usize ) as * mut UCA1IFG ) } } # [ doc = "0x1e - eUSCI_Ax Interrupt Vector Register" ] # [ inline ( always ) ] pub fn uca1iv_spi ( & self ) -> & UCA1IV_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 30usize ) as * const UCA1IV_SPI ) } } # [ doc = "0x1e - eUSCI_Ax Interrupt Vector Register" ] # [ inline ( always ) ] pub fn uca1iv_spi_mut ( & self ) -> & mut UCA1IV_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 30usize ) as * mut UCA1IV_SPI ) } } # [ doc = "0x1e - eUSCI_Ax Interrupt Vector Register" ] # [ inline ( always ) ] pub fn uca1iv ( & self ) -> & UCA1IV { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 30usize ) as * const UCA1IV ) } } # [ doc = "0x1e - eUSCI_Ax Interrupt Vector Register" ] # [ inline ( always ) ] pub fn uca1iv_mut ( & self ) -> & mut UCA1IV { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 30usize ) as * mut UCA1IV ) } } }
# [ doc = "eUSCI_Ax Control Word Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ctlw0](uca1ctlw0) module" ] pub type UCA1CTLW0 = crate :: Reg < u16 , _UCA1CTLW0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1CTLW0 ;
# [ doc = "`read()` method returns [uca1ctlw0::R](uca1ctlw0::R) reader structure" ] impl crate :: Readable for UCA1CTLW0 { }
# [ doc = "`write(|w| ..)` method takes [uca1ctlw0::W](uca1ctlw0::W) writer structure" ] impl crate :: Writable for UCA1CTLW0 { }
# [ doc = "eUSCI_Ax Control Word Register 0" ] pub mod uca1ctlw0 {
# [ doc = "Reader of register UCA1CTLW0" ] pub type R = crate :: R < u16 , super :: UCA1CTLW0 > ;
# [ doc = "Writer for register UCA1CTLW0" ] pub type W = crate :: W < u16 , super :: UCA1CTLW0 > ;
# [ doc = "Register UCA1CTLW0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1CTLW0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Software reset enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSWRST_A { # [ doc = "0: Disabled. eUSCI_A reset released for operation" ] DISABLE = 0 , # [ doc = "1: Enabled. eUSCI_A logic held in reset state" ] ENABLE = 1 } impl From < UCSWRST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSWRST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSWRST`" ] pub type UCSWRST_R = crate :: R < bool , UCSWRST_A > ; impl UCSWRST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSWRST_A { match self . bits { false => UCSWRST_A :: DISABLE , true => UCSWRST_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCSWRST_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCSWRST_A :: ENABLE } }
# [ doc = "Write proxy for field `UCSWRST`" ] pub struct UCSWRST_W < 'a > { w : & 'a mut W , } impl < 'a > UCSWRST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSWRST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled. eUSCI_A reset released for operation" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: DISABLE ) } # [ doc = "Enabled. eUSCI_A logic held in reset state" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit break\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXBRK_A { # [ doc = "0: Next frame transmitted is not a break" ] UCTXBRK_0 = 0 , # [ doc = "1: Next frame transmitted is a break or a break/synch" ] UCTXBRK_1 = 1 } impl From < UCTXBRK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXBRK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXBRK`" ] pub type UCTXBRK_R = crate :: R < bool , UCTXBRK_A > ; impl UCTXBRK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXBRK_A { match self . bits { false => UCTXBRK_A :: UCTXBRK_0 , true => UCTXBRK_A :: UCTXBRK_1 } } # [ doc = "Checks if the value of the field is `UCTXBRK_0`" ] # [ inline ( always ) ] pub fn is_uctxbrk_0 ( & self ) -> bool { * self == UCTXBRK_A :: UCTXBRK_0 } # [ doc = "Checks if the value of the field is `UCTXBRK_1`" ] # [ inline ( always ) ] pub fn is_uctxbrk_1 ( & self ) -> bool { * self == UCTXBRK_A :: UCTXBRK_1 } }
# [ doc = "Write proxy for field `UCTXBRK`" ] pub struct UCTXBRK_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXBRK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXBRK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Next frame transmitted is not a break" ] # [ inline ( always ) ] pub fn uctxbrk_0 ( self ) -> & 'a mut W { self . variant ( UCTXBRK_A :: UCTXBRK_0 ) } # [ doc = "Next frame transmitted is a break or a break/synch" ] # [ inline ( always ) ] pub fn uctxbrk_1 ( self ) -> & 'a mut W { self . variant ( UCTXBRK_A :: UCTXBRK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Transmit address\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXADDR_A { # [ doc = "0: Next frame transmitted is data" ] UCTXADDR_0 = 0 , # [ doc = "1: Next frame transmitted is an address" ] UCTXADDR_1 = 1 } impl From < UCTXADDR_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXADDR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXADDR`" ] pub type UCTXADDR_R = crate :: R < bool , UCTXADDR_A > ; impl UCTXADDR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXADDR_A { match self . bits { false => UCTXADDR_A :: UCTXADDR_0 , true => UCTXADDR_A :: UCTXADDR_1 } } # [ doc = "Checks if the value of the field is `UCTXADDR_0`" ] # [ inline ( always ) ] pub fn is_uctxaddr_0 ( & self ) -> bool { * self == UCTXADDR_A :: UCTXADDR_0 } # [ doc = "Checks if the value of the field is `UCTXADDR_1`" ] # [ inline ( always ) ] pub fn is_uctxaddr_1 ( & self ) -> bool { * self == UCTXADDR_A :: UCTXADDR_1 } }
# [ doc = "Write proxy for field `UCTXADDR`" ] pub struct UCTXADDR_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXADDR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXADDR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Next frame transmitted is data" ] # [ inline ( always ) ] pub fn uctxaddr_0 ( self ) -> & 'a mut W { self . variant ( UCTXADDR_A :: UCTXADDR_0 ) } # [ doc = "Next frame transmitted is an address" ] # [ inline ( always ) ] pub fn uctxaddr_1 ( self ) -> & 'a mut W { self . variant ( UCTXADDR_A :: UCTXADDR_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Dormant\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCDORM_A { # [ doc = "0: Not dormant. All received characters set UCRXIFG." ] UCDORM_0 = 0 , # [ doc = "1: Dormant. Only characters that are preceded by an idle-line or with address bit set UCRXIFG. In UART mode with automatic baud-rate detection, only the combination of a break and synch field sets UCRXIFG." ] UCDORM_1 = 1 } impl From < UCDORM_A > for bool { # [ inline ( always ) ] fn from ( variant : UCDORM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCDORM`" ] pub type UCDORM_R = crate :: R < bool , UCDORM_A > ; impl UCDORM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCDORM_A { match self . bits { false => UCDORM_A :: UCDORM_0 , true => UCDORM_A :: UCDORM_1 } } # [ doc = "Checks if the value of the field is `UCDORM_0`" ] # [ inline ( always ) ] pub fn is_ucdorm_0 ( & self ) -> bool { * self == UCDORM_A :: UCDORM_0 } # [ doc = "Checks if the value of the field is `UCDORM_1`" ] # [ inline ( always ) ] pub fn is_ucdorm_1 ( & self ) -> bool { * self == UCDORM_A :: UCDORM_1 } }
# [ doc = "Write proxy for field `UCDORM`" ] pub struct UCDORM_W < 'a > { w : & 'a mut W , } impl < 'a > UCDORM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCDORM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Not dormant. All received characters set UCRXIFG." ] # [ inline ( always ) ] pub fn ucdorm_0 ( self ) -> & 'a mut W { self . variant ( UCDORM_A :: UCDORM_0 ) } # [ doc = "Dormant. Only characters that are preceded by an idle-line or with address bit set UCRXIFG. In UART mode with automatic baud-rate detection, only the combination of a break and synch field sets UCRXIFG." ] # [ inline ( always ) ] pub fn ucdorm_1 ( self ) -> & 'a mut W { self . variant ( UCDORM_A :: UCDORM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Receive break character interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBRKIE_A { # [ doc = "0: Received break characters do not set UCRXIFG" ] UCBRKIE_0 = 0 , # [ doc = "1: Received break characters set UCRXIFG" ] UCBRKIE_1 = 1 } impl From < UCBRKIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBRKIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBRKIE`" ] pub type UCBRKIE_R = crate :: R < bool , UCBRKIE_A > ; impl UCBRKIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBRKIE_A { match self . bits { false => UCBRKIE_A :: UCBRKIE_0 , true => UCBRKIE_A :: UCBRKIE_1 } } # [ doc = "Checks if the value of the field is `UCBRKIE_0`" ] # [ inline ( always ) ] pub fn is_ucbrkie_0 ( & self ) -> bool { * self == UCBRKIE_A :: UCBRKIE_0 } # [ doc = "Checks if the value of the field is `UCBRKIE_1`" ] # [ inline ( always ) ] pub fn is_ucbrkie_1 ( & self ) -> bool { * self == UCBRKIE_A :: UCBRKIE_1 } }
# [ doc = "Write proxy for field `UCBRKIE`" ] pub struct UCBRKIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCBRKIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBRKIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Received break characters do not set UCRXIFG" ] # [ inline ( always ) ] pub fn ucbrkie_0 ( self ) -> & 'a mut W { self . variant ( UCBRKIE_A :: UCBRKIE_0 ) } # [ doc = "Received break characters set UCRXIFG" ] # [ inline ( always ) ] pub fn ucbrkie_1 ( self ) -> & 'a mut W { self . variant ( UCBRKIE_A :: UCBRKIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Receive erroneous-character interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXEIE_A { # [ doc = "0: Erroneous characters rejected and UCRXIFG is not set" ] UCRXEIE_0 = 0 , # [ doc = "1: Erroneous characters received set UCRXIFG" ] UCRXEIE_1 = 1 } impl From < UCRXEIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXEIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXEIE`" ] pub type UCRXEIE_R = crate :: R < bool , UCRXEIE_A > ; impl UCRXEIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXEIE_A { match self . bits { false => UCRXEIE_A :: UCRXEIE_0 , true => UCRXEIE_A :: UCRXEIE_1 } } # [ doc = "Checks if the value of the field is `UCRXEIE_0`" ] # [ inline ( always ) ] pub fn is_ucrxeie_0 ( & self ) -> bool { * self == UCRXEIE_A :: UCRXEIE_0 } # [ doc = "Checks if the value of the field is `UCRXEIE_1`" ] # [ inline ( always ) ] pub fn is_ucrxeie_1 ( & self ) -> bool { * self == UCRXEIE_A :: UCRXEIE_1 } }
# [ doc = "Write proxy for field `UCRXEIE`" ] pub struct UCRXEIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXEIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXEIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Erroneous characters rejected and UCRXIFG is not set" ] # [ inline ( always ) ] pub fn ucrxeie_0 ( self ) -> & 'a mut W { self . variant ( UCRXEIE_A :: UCRXEIE_0 ) } # [ doc = "Erroneous characters received set UCRXIFG" ] # [ inline ( always ) ] pub fn ucrxeie_1 ( self ) -> & 'a mut W { self . variant ( UCRXEIE_A :: UCRXEIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "eUSCI_A clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCSSEL_A { # [ doc = "0: UCLK" ] UCLK = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: SMCLK" ] UCSSEL_3 = 3 } impl From < UCSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCSSEL`" ] pub type UCSSEL_R = crate :: R < u8 , UCSSEL_A > ; impl UCSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSSEL_A { match self . bits { 0 => UCSSEL_A :: UCLK , 1 => UCSSEL_A :: ACLK , 2 => UCSSEL_A :: SMCLK , 3 => UCSSEL_A :: UCSSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCLK`" ] # [ inline ( always ) ] pub fn is_uclk ( & self ) -> bool { * self == UCSSEL_A :: UCLK } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == UCSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == UCSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `UCSSEL_3`" ] # [ inline ( always ) ] pub fn is_ucssel_3 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_3 } }
# [ doc = "Write proxy for field `UCSSEL`" ] pub struct UCSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > UCSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "UCLK" ] # [ inline ( always ) ] pub fn uclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCLK ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: SMCLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn ucssel_3 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Synchronous mode enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSYNC_A { # [ doc = "0: Asynchronous mode" ] ASYNC = 0 , # [ doc = "1: Synchronous mode" ] SYNC = 1 } impl From < UCSYNC_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSYNC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSYNC`" ] pub type UCSYNC_R = crate :: R < bool , UCSYNC_A > ; impl UCSYNC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSYNC_A { match self . bits { false => UCSYNC_A :: ASYNC , true => UCSYNC_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == UCSYNC_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == UCSYNC_A :: SYNC } }
# [ doc = "Write proxy for field `UCSYNC`" ] pub struct UCSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > UCSYNC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSYNC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous mode" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: ASYNC ) } # [ doc = "Synchronous mode" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "eUSCI_A mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCMODE_A { # [ doc = "0: UART mode" ] UCMODE_0 = 0 , # [ doc = "1: Idle-line multiprocessor mode" ] UCMODE_1 = 1 , # [ doc = "2: Address-bit multiprocessor mode" ] UCMODE_2 = 2 , # [ doc = "3: UART mode with automatic baud-rate detection" ] UCMODE_3 = 3 } impl From < UCMODE_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCMODE_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCMODE`" ] pub type UCMODE_R = crate :: R < u8 , UCMODE_A > ; impl UCMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMODE_A { match self . bits { 0 => UCMODE_A :: UCMODE_0 , 1 => UCMODE_A :: UCMODE_1 , 2 => UCMODE_A :: UCMODE_2 , 3 => UCMODE_A :: UCMODE_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCMODE_0`" ] # [ inline ( always ) ] pub fn is_ucmode_0 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_0 } # [ doc = "Checks if the value of the field is `UCMODE_1`" ] # [ inline ( always ) ] pub fn is_ucmode_1 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_1 } # [ doc = "Checks if the value of the field is `UCMODE_2`" ] # [ inline ( always ) ] pub fn is_ucmode_2 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_2 } # [ doc = "Checks if the value of the field is `UCMODE_3`" ] # [ inline ( always ) ] pub fn is_ucmode_3 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_3 } }
# [ doc = "Write proxy for field `UCMODE`" ] pub struct UCMODE_W < 'a > { w : & 'a mut W , } impl < 'a > UCMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMODE_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "UART mode" ] # [ inline ( always ) ] pub fn ucmode_0 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_0 ) } # [ doc = "Idle-line multiprocessor mode" ] # [ inline ( always ) ] pub fn ucmode_1 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_1 ) } # [ doc = "Address-bit multiprocessor mode" ] # [ inline ( always ) ] pub fn ucmode_2 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_2 ) } # [ doc = "UART mode with automatic baud-rate detection" ] # [ inline ( always ) ] pub fn ucmode_3 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Stop bit select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSPB_A { # [ doc = "0: One stop bit" ] UCSPB_0 = 0 , # [ doc = "1: Two stop bits" ] UCSPB_1 = 1 } impl From < UCSPB_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSPB_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSPB`" ] pub type UCSPB_R = crate :: R < bool , UCSPB_A > ; impl UCSPB_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSPB_A { match self . bits { false => UCSPB_A :: UCSPB_0 , true => UCSPB_A :: UCSPB_1 } } # [ doc = "Checks if the value of the field is `UCSPB_0`" ] # [ inline ( always ) ] pub fn is_ucspb_0 ( & self ) -> bool { * self == UCSPB_A :: UCSPB_0 } # [ doc = "Checks if the value of the field is `UCSPB_1`" ] # [ inline ( always ) ] pub fn is_ucspb_1 ( & self ) -> bool { * self == UCSPB_A :: UCSPB_1 } }
# [ doc = "Write proxy for field `UCSPB`" ] pub struct UCSPB_W < 'a > { w : & 'a mut W , } impl < 'a > UCSPB_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSPB_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "One stop bit" ] # [ inline ( always ) ] pub fn ucspb_0 ( self ) -> & 'a mut W { self . variant ( UCSPB_A :: UCSPB_0 ) } # [ doc = "Two stop bits" ] # [ inline ( always ) ] pub fn ucspb_1 ( self ) -> & 'a mut W { self . variant ( UCSPB_A :: UCSPB_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Character length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UC7BIT_A { # [ doc = "0: 8-bit data" ] _8BIT = 0 , # [ doc = "1: 7-bit data" ] _7BIT = 1 } impl From < UC7BIT_A > for bool { # [ inline ( always ) ] fn from ( variant : UC7BIT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UC7BIT`" ] pub type UC7BIT_R = crate :: R < bool , UC7BIT_A > ; impl UC7BIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UC7BIT_A { match self . bits { false => UC7BIT_A :: _8BIT , true => UC7BIT_A :: _7BIT } } # [ doc = "Checks if the value of the field is `_8BIT`" ] # [ inline ( always ) ] pub fn is_8bit ( & self ) -> bool { * self == UC7BIT_A :: _8BIT } # [ doc = "Checks if the value of the field is `_7BIT`" ] # [ inline ( always ) ] pub fn is_7bit ( & self ) -> bool { * self == UC7BIT_A :: _7BIT } }
# [ doc = "Write proxy for field `UC7BIT`" ] pub struct UC7BIT_W < 'a > { w : & 'a mut W , } impl < 'a > UC7BIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UC7BIT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "8-bit data" ] # [ inline ( always ) ] pub fn _8bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _8BIT ) } # [ doc = "7-bit data" ] # [ inline ( always ) ] pub fn _7bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _7BIT ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "MSB first select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMSB_A { # [ doc = "0: LSB first" ] UCMSB_0 = 0 , # [ doc = "1: MSB first" ] UCMSB_1 = 1 } impl From < UCMSB_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMSB_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMSB`" ] pub type UCMSB_R = crate :: R < bool , UCMSB_A > ; impl UCMSB_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMSB_A { match self . bits { false => UCMSB_A :: UCMSB_0 , true => UCMSB_A :: UCMSB_1 } } # [ doc = "Checks if the value of the field is `UCMSB_0`" ] # [ inline ( always ) ] pub fn is_ucmsb_0 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_0 } # [ doc = "Checks if the value of the field is `UCMSB_1`" ] # [ inline ( always ) ] pub fn is_ucmsb_1 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_1 } }
# [ doc = "Write proxy for field `UCMSB`" ] pub struct UCMSB_W < 'a > { w : & 'a mut W , } impl < 'a > UCMSB_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMSB_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "LSB first" ] # [ inline ( always ) ] pub fn ucmsb_0 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_0 ) } # [ doc = "MSB first" ] # [ inline ( always ) ] pub fn ucmsb_1 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Parity select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCPAR_A { # [ doc = "0: Odd parity" ] ODD = 0 , # [ doc = "1: Even parity" ] EVEN = 1 } impl From < UCPAR_A > for bool { # [ inline ( always ) ] fn from ( variant : UCPAR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCPAR`" ] pub type UCPAR_R = crate :: R < bool , UCPAR_A > ; impl UCPAR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCPAR_A { match self . bits { false => UCPAR_A :: ODD , true => UCPAR_A :: EVEN } } # [ doc = "Checks if the value of the field is `ODD`" ] # [ inline ( always ) ] pub fn is_odd ( & self ) -> bool { * self == UCPAR_A :: ODD } # [ doc = "Checks if the value of the field is `EVEN`" ] # [ inline ( always ) ] pub fn is_even ( & self ) -> bool { * self == UCPAR_A :: EVEN } }
# [ doc = "Write proxy for field `UCPAR`" ] pub struct UCPAR_W < 'a > { w : & 'a mut W , } impl < 'a > UCPAR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCPAR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Odd parity" ] # [ inline ( always ) ] pub fn odd ( self ) -> & 'a mut W { self . variant ( UCPAR_A :: ODD ) } # [ doc = "Even parity" ] # [ inline ( always ) ] pub fn even ( self ) -> & 'a mut W { self . variant ( UCPAR_A :: EVEN ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Parity enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCPEN_A { # [ doc = "0: Parity disabled" ] UCPEN_0 = 0 , # [ doc = "1: Parity enabled. Parity bit is generated (UCAxTXD) and expected (UCAxRXD). In address-bit multiprocessor mode, the address bit is included in the parity calculation." ] UCPEN_1 = 1 } impl From < UCPEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCPEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCPEN`" ] pub type UCPEN_R = crate :: R < bool , UCPEN_A > ; impl UCPEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCPEN_A { match self . bits { false => UCPEN_A :: UCPEN_0 , true => UCPEN_A :: UCPEN_1 } } # [ doc = "Checks if the value of the field is `UCPEN_0`" ] # [ inline ( always ) ] pub fn is_ucpen_0 ( & self ) -> bool { * self == UCPEN_A :: UCPEN_0 } # [ doc = "Checks if the value of the field is `UCPEN_1`" ] # [ inline ( always ) ] pub fn is_ucpen_1 ( & self ) -> bool { * self == UCPEN_A :: UCPEN_1 } }
# [ doc = "Write proxy for field `UCPEN`" ] pub struct UCPEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCPEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCPEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Parity disabled" ] # [ inline ( always ) ] pub fn ucpen_0 ( self ) -> & 'a mut W { self . variant ( UCPEN_A :: UCPEN_0 ) } # [ doc = "Parity enabled. Parity bit is generated (UCAxTXD) and expected (UCAxRXD). In address-bit multiprocessor mode, the address bit is included in the parity calculation." ] # [ inline ( always ) ] pub fn ucpen_1 ( self ) -> & 'a mut W { self . variant ( UCPEN_A :: UCPEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & self ) -> UCSWRST_R { UCSWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit break" ] # [ inline ( always ) ] pub fn uctxbrk ( & self ) -> UCTXBRK_R { UCTXBRK_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Transmit address" ] # [ inline ( always ) ] pub fn uctxaddr ( & self ) -> UCTXADDR_R { UCTXADDR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Dormant" ] # [ inline ( always ) ] pub fn ucdorm ( & self ) -> UCDORM_R { UCDORM_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Receive break character interrupt enable" ] # [ inline ( always ) ] pub fn ucbrkie ( & self ) -> UCBRKIE_R { UCBRKIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Receive erroneous-character interrupt enable" ] # [ inline ( always ) ] pub fn ucrxeie ( & self ) -> UCRXEIE_R { UCRXEIE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - eUSCI_A clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & self ) -> UCSSEL_R { UCSSEL_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & self ) -> UCSYNC_R { UCSYNC_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - eUSCI_A mode" ] # [ inline ( always ) ] pub fn ucmode ( & self ) -> UCMODE_R { UCMODE_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Stop bit select" ] # [ inline ( always ) ] pub fn ucspb ( & self ) -> UCSPB_R { UCSPB_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & self ) -> UC7BIT_R { UC7BIT_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & self ) -> UCMSB_R { UCMSB_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Parity select" ] # [ inline ( always ) ] pub fn ucpar ( & self ) -> UCPAR_R { UCPAR_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Parity enable" ] # [ inline ( always ) ] pub fn ucpen ( & self ) -> UCPEN_R { UCPEN_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & mut self ) -> UCSWRST_W { UCSWRST_W { w : self } }
# [ doc = "Bit 1 - Transmit break" ] # [ inline ( always ) ] pub fn uctxbrk ( & mut self ) -> UCTXBRK_W { UCTXBRK_W { w : self } }
# [ doc = "Bit 2 - Transmit address" ] # [ inline ( always ) ] pub fn uctxaddr ( & mut self ) -> UCTXADDR_W { UCTXADDR_W { w : self } }
# [ doc = "Bit 3 - Dormant" ] # [ inline ( always ) ] pub fn ucdorm ( & mut self ) -> UCDORM_W { UCDORM_W { w : self } }
# [ doc = "Bit 4 - Receive break character interrupt enable" ] # [ inline ( always ) ] pub fn ucbrkie ( & mut self ) -> UCBRKIE_W { UCBRKIE_W { w : self } }
# [ doc = "Bit 5 - Receive erroneous-character interrupt enable" ] # [ inline ( always ) ] pub fn ucrxeie ( & mut self ) -> UCRXEIE_W { UCRXEIE_W { w : self } }
# [ doc = "Bits 6:7 - eUSCI_A clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & mut self ) -> UCSSEL_W { UCSSEL_W { w : self } }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & mut self ) -> UCSYNC_W { UCSYNC_W { w : self } }
# [ doc = "Bits 9:10 - eUSCI_A mode" ] # [ inline ( always ) ] pub fn ucmode ( & mut self ) -> UCMODE_W { UCMODE_W { w : self } }
# [ doc = "Bit 11 - Stop bit select" ] # [ inline ( always ) ] pub fn ucspb ( & mut self ) -> UCSPB_W { UCSPB_W { w : self } }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & mut self ) -> UC7BIT_W { UC7BIT_W { w : self } }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & mut self ) -> UCMSB_W { UCMSB_W { w : self } }
# [ doc = "Bit 14 - Parity select" ] # [ inline ( always ) ] pub fn ucpar ( & mut self ) -> UCPAR_W { UCPAR_W { w : self } }
# [ doc = "Bit 15 - Parity enable" ] # [ inline ( always ) ] pub fn ucpen ( & mut self ) -> UCPEN_W { UCPEN_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Control Word Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ctlw0_spi](uca1ctlw0_spi) module" ] pub type UCA1CTLW0_SPI = crate :: Reg < u16 , _UCA1CTLW0_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1CTLW0_SPI ;
# [ doc = "`read()` method returns [uca1ctlw0_spi::R](uca1ctlw0_spi::R) reader structure" ] impl crate :: Readable for UCA1CTLW0_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca1ctlw0_spi::W](uca1ctlw0_spi::W) writer structure" ] impl crate :: Writable for UCA1CTLW0_SPI { }
# [ doc = "eUSCI_Ax Control Word Register 0" ] pub mod uca1ctlw0_spi {
# [ doc = "Reader of register UCA1CTLW0_SPI" ] pub type R = crate :: R < u16 , super :: UCA1CTLW0_SPI > ;
# [ doc = "Writer for register UCA1CTLW0_SPI" ] pub type W = crate :: W < u16 , super :: UCA1CTLW0_SPI > ;
# [ doc = "Register UCA1CTLW0_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1CTLW0_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Software reset enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSWRST_A { # [ doc = "0: Disabled. eUSCI_A reset released for operation" ] DISABLE = 0 , # [ doc = "1: Enabled. eUSCI_A logic held in reset state" ] ENABLE = 1 } impl From < UCSWRST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSWRST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSWRST`" ] pub type UCSWRST_R = crate :: R < bool , UCSWRST_A > ; impl UCSWRST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSWRST_A { match self . bits { false => UCSWRST_A :: DISABLE , true => UCSWRST_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCSWRST_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCSWRST_A :: ENABLE } }
# [ doc = "Write proxy for field `UCSWRST`" ] pub struct UCSWRST_W < 'a > { w : & 'a mut W , } impl < 'a > UCSWRST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSWRST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled. eUSCI_A reset released for operation" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: DISABLE ) } # [ doc = "Enabled. eUSCI_A logic held in reset state" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "STE mode select in master mode.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTEM_A { # [ doc = "0: STE pin is used to prevent conflicts with other masters" ] UCSTEM_0 = 0 , # [ doc = "1: STE pin is used to generate the enable signal for a 4-wire slave" ] UCSTEM_1 = 1 } impl From < UCSTEM_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTEM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTEM`" ] pub type UCSTEM_R = crate :: R < bool , UCSTEM_A > ; impl UCSTEM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTEM_A { match self . bits { false => UCSTEM_A :: UCSTEM_0 , true => UCSTEM_A :: UCSTEM_1 } } # [ doc = "Checks if the value of the field is `UCSTEM_0`" ] # [ inline ( always ) ] pub fn is_ucstem_0 ( & self ) -> bool { * self == UCSTEM_A :: UCSTEM_0 } # [ doc = "Checks if the value of the field is `UCSTEM_1`" ] # [ inline ( always ) ] pub fn is_ucstem_1 ( & self ) -> bool { * self == UCSTEM_A :: UCSTEM_1 } }
# [ doc = "Write proxy for field `UCSTEM`" ] pub struct UCSTEM_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTEM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTEM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "STE pin is used to prevent conflicts with other masters" ] # [ inline ( always ) ] pub fn ucstem_0 ( self ) -> & 'a mut W { self . variant ( UCSTEM_A :: UCSTEM_0 ) } # [ doc = "STE pin is used to generate the enable signal for a 4-wire slave" ] # [ inline ( always ) ] pub fn ucstem_1 ( self ) -> & 'a mut W { self . variant ( UCSTEM_A :: UCSTEM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "eUSCI_A clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCSSEL_A { # [ doc = "0: Reserved" ] UCSSEL_0 = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: SMCLK" ] UCSSEL_3 = 3 } impl From < UCSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCSSEL`" ] pub type UCSSEL_R = crate :: R < u8 , UCSSEL_A > ; impl UCSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSSEL_A { match self . bits { 0 => UCSSEL_A :: UCSSEL_0 , 1 => UCSSEL_A :: ACLK , 2 => UCSSEL_A :: SMCLK , 3 => UCSSEL_A :: UCSSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCSSEL_0`" ] # [ inline ( always ) ] pub fn is_ucssel_0 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_0 } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == UCSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == UCSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `UCSSEL_3`" ] # [ inline ( always ) ] pub fn is_ucssel_3 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_3 } }
# [ doc = "Write proxy for field `UCSSEL`" ] pub struct UCSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > UCSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn ucssel_0 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_0 ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: SMCLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn ucssel_3 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Synchronous mode enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSYNC_A { # [ doc = "0: Asynchronous mode" ] ASYNC = 0 , # [ doc = "1: Synchronous mode" ] SYNC = 1 } impl From < UCSYNC_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSYNC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSYNC`" ] pub type UCSYNC_R = crate :: R < bool , UCSYNC_A > ; impl UCSYNC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSYNC_A { match self . bits { false => UCSYNC_A :: ASYNC , true => UCSYNC_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == UCSYNC_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == UCSYNC_A :: SYNC } }
# [ doc = "Write proxy for field `UCSYNC`" ] pub struct UCSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > UCSYNC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSYNC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous mode" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: ASYNC ) } # [ doc = "Synchronous mode" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "eUSCI mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCMODE_A { # [ doc = "0: 3-pin SPI" ] UCMODE_0 = 0 , # [ doc = "1: 4-pin SPI with UCxSTE active high: Slave enabled when UCxSTE = 1" ] UCMODE_1 = 1 , # [ doc = "2: 4-pin SPI with UCxSTE active low: Slave enabled when UCxSTE = 0" ] UCMODE_2 = 2 , # [ doc = "3: I2C mode" ] UCMODE_3 = 3 } impl From < UCMODE_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCMODE_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCMODE`" ] pub type UCMODE_R = crate :: R < u8 , UCMODE_A > ; impl UCMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMODE_A { match self . bits { 0 => UCMODE_A :: UCMODE_0 , 1 => UCMODE_A :: UCMODE_1 , 2 => UCMODE_A :: UCMODE_2 , 3 => UCMODE_A :: UCMODE_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCMODE_0`" ] # [ inline ( always ) ] pub fn is_ucmode_0 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_0 } # [ doc = "Checks if the value of the field is `UCMODE_1`" ] # [ inline ( always ) ] pub fn is_ucmode_1 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_1 } # [ doc = "Checks if the value of the field is `UCMODE_2`" ] # [ inline ( always ) ] pub fn is_ucmode_2 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_2 } # [ doc = "Checks if the value of the field is `UCMODE_3`" ] # [ inline ( always ) ] pub fn is_ucmode_3 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_3 } }
# [ doc = "Write proxy for field `UCMODE`" ] pub struct UCMODE_W < 'a > { w : & 'a mut W , } impl < 'a > UCMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMODE_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "3-pin SPI" ] # [ inline ( always ) ] pub fn ucmode_0 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_0 ) } # [ doc = "4-pin SPI with UCxSTE active high: Slave enabled when UCxSTE = 1" ] # [ inline ( always ) ] pub fn ucmode_1 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_1 ) } # [ doc = "4-pin SPI with UCxSTE active low: Slave enabled when UCxSTE = 0" ] # [ inline ( always ) ] pub fn ucmode_2 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_2 ) } # [ doc = "I2C mode" ] # [ inline ( always ) ] pub fn ucmode_3 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Master mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMST_A { # [ doc = "0: Slave mode" ] SLAVE = 0 , # [ doc = "1: Master mode" ] MASTER = 1 } impl From < UCMST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMST`" ] pub type UCMST_R = crate :: R < bool , UCMST_A > ; impl UCMST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMST_A { match self . bits { false => UCMST_A :: SLAVE , true => UCMST_A :: MASTER } } # [ doc = "Checks if the value of the field is `SLAVE`" ] # [ inline ( always ) ] pub fn is_slave ( & self ) -> bool { * self == UCMST_A :: SLAVE } # [ doc = "Checks if the value of the field is `MASTER`" ] # [ inline ( always ) ] pub fn is_master ( & self ) -> bool { * self == UCMST_A :: MASTER } }
# [ doc = "Write proxy for field `UCMST`" ] pub struct UCMST_W < 'a > { w : & 'a mut W , } impl < 'a > UCMST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Slave mode" ] # [ inline ( always ) ] pub fn slave ( self ) -> & 'a mut W { self . variant ( UCMST_A :: SLAVE ) } # [ doc = "Master mode" ] # [ inline ( always ) ] pub fn master ( self ) -> & 'a mut W { self . variant ( UCMST_A :: MASTER ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Character length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UC7BIT_A { # [ doc = "0: 8-bit data" ] _8BIT = 0 , # [ doc = "1: 7-bit data" ] _7BIT = 1 } impl From < UC7BIT_A > for bool { # [ inline ( always ) ] fn from ( variant : UC7BIT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UC7BIT`" ] pub type UC7BIT_R = crate :: R < bool , UC7BIT_A > ; impl UC7BIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UC7BIT_A { match self . bits { false => UC7BIT_A :: _8BIT , true => UC7BIT_A :: _7BIT } } # [ doc = "Checks if the value of the field is `_8BIT`" ] # [ inline ( always ) ] pub fn is_8bit ( & self ) -> bool { * self == UC7BIT_A :: _8BIT } # [ doc = "Checks if the value of the field is `_7BIT`" ] # [ inline ( always ) ] pub fn is_7bit ( & self ) -> bool { * self == UC7BIT_A :: _7BIT } }
# [ doc = "Write proxy for field `UC7BIT`" ] pub struct UC7BIT_W < 'a > { w : & 'a mut W , } impl < 'a > UC7BIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UC7BIT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "8-bit data" ] # [ inline ( always ) ] pub fn _8bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _8BIT ) } # [ doc = "7-bit data" ] # [ inline ( always ) ] pub fn _7bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _7BIT ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "MSB first select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMSB_A { # [ doc = "0: LSB first" ] UCMSB_0 = 0 , # [ doc = "1: MSB first" ] UCMSB_1 = 1 } impl From < UCMSB_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMSB_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMSB`" ] pub type UCMSB_R = crate :: R < bool , UCMSB_A > ; impl UCMSB_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMSB_A { match self . bits { false => UCMSB_A :: UCMSB_0 , true => UCMSB_A :: UCMSB_1 } } # [ doc = "Checks if the value of the field is `UCMSB_0`" ] # [ inline ( always ) ] pub fn is_ucmsb_0 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_0 } # [ doc = "Checks if the value of the field is `UCMSB_1`" ] # [ inline ( always ) ] pub fn is_ucmsb_1 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_1 } }
# [ doc = "Write proxy for field `UCMSB`" ] pub struct UCMSB_W < 'a > { w : & 'a mut W , } impl < 'a > UCMSB_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMSB_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "LSB first" ] # [ inline ( always ) ] pub fn ucmsb_0 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_0 ) } # [ doc = "MSB first" ] # [ inline ( always ) ] pub fn ucmsb_1 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Clock polarity select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCKPL_A { # [ doc = "0: The inactive state is low" ] LOW = 0 , # [ doc = "1: The inactive state is high" ] HIGH = 1 } impl From < UCCKPL_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCKPL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCKPL`" ] pub type UCCKPL_R = crate :: R < bool , UCCKPL_A > ; impl UCCKPL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCKPL_A { match self . bits { false => UCCKPL_A :: LOW , true => UCCKPL_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == UCCKPL_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == UCCKPL_A :: HIGH } }
# [ doc = "Write proxy for field `UCCKPL`" ] pub struct UCCKPL_W < 'a > { w : & 'a mut W , } impl < 'a > UCCKPL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCKPL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The inactive state is low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( UCCKPL_A :: LOW ) } # [ doc = "The inactive state is high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( UCCKPL_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Clock phase select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCKPH_A { # [ doc = "0: Data is changed on the first UCLK edge and captured on the following edge." ] UCCKPH_0 = 0 , # [ doc = "1: Data is captured on the first UCLK edge and changed on the following edge." ] UCCKPH_1 = 1 } impl From < UCCKPH_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCKPH_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCKPH`" ] pub type UCCKPH_R = crate :: R < bool , UCCKPH_A > ; impl UCCKPH_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCKPH_A { match self . bits { false => UCCKPH_A :: UCCKPH_0 , true => UCCKPH_A :: UCCKPH_1 } } # [ doc = "Checks if the value of the field is `UCCKPH_0`" ] # [ inline ( always ) ] pub fn is_ucckph_0 ( & self ) -> bool { * self == UCCKPH_A :: UCCKPH_0 } # [ doc = "Checks if the value of the field is `UCCKPH_1`" ] # [ inline ( always ) ] pub fn is_ucckph_1 ( & self ) -> bool { * self == UCCKPH_A :: UCCKPH_1 } }
# [ doc = "Write proxy for field `UCCKPH`" ] pub struct UCCKPH_W < 'a > { w : & 'a mut W , } impl < 'a > UCCKPH_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCKPH_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Data is changed on the first UCLK edge and captured on the following edge." ] # [ inline ( always ) ] pub fn ucckph_0 ( self ) -> & 'a mut W { self . variant ( UCCKPH_A :: UCCKPH_0 ) } # [ doc = "Data is captured on the first UCLK edge and changed on the following edge." ] # [ inline ( always ) ] pub fn ucckph_1 ( self ) -> & 'a mut W { self . variant ( UCCKPH_A :: UCCKPH_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & self ) -> UCSWRST_R { UCSWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - STE mode select in master mode." ] # [ inline ( always ) ] pub fn ucstem ( & self ) -> UCSTEM_R { UCSTEM_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - eUSCI_A clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & self ) -> UCSSEL_R { UCSSEL_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & self ) -> UCSYNC_R { UCSYNC_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - eUSCI mode" ] # [ inline ( always ) ] pub fn ucmode ( & self ) -> UCMODE_R { UCMODE_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & self ) -> UCMST_R { UCMST_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & self ) -> UC7BIT_R { UC7BIT_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & self ) -> UCMSB_R { UCMSB_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Clock polarity select" ] # [ inline ( always ) ] pub fn ucckpl ( & self ) -> UCCKPL_R { UCCKPL_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Clock phase select" ] # [ inline ( always ) ] pub fn ucckph ( & self ) -> UCCKPH_R { UCCKPH_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & mut self ) -> UCSWRST_W { UCSWRST_W { w : self } }
# [ doc = "Bit 1 - STE mode select in master mode." ] # [ inline ( always ) ] pub fn ucstem ( & mut self ) -> UCSTEM_W { UCSTEM_W { w : self } }
# [ doc = "Bits 6:7 - eUSCI_A clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & mut self ) -> UCSSEL_W { UCSSEL_W { w : self } }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & mut self ) -> UCSYNC_W { UCSYNC_W { w : self } }
# [ doc = "Bits 9:10 - eUSCI mode" ] # [ inline ( always ) ] pub fn ucmode ( & mut self ) -> UCMODE_W { UCMODE_W { w : self } }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & mut self ) -> UCMST_W { UCMST_W { w : self } }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & mut self ) -> UC7BIT_W { UC7BIT_W { w : self } }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & mut self ) -> UCMSB_W { UCMSB_W { w : self } }
# [ doc = "Bit 14 - Clock polarity select" ] # [ inline ( always ) ] pub fn ucckpl ( & mut self ) -> UCCKPL_W { UCCKPL_W { w : self } }
# [ doc = "Bit 15 - Clock phase select" ] # [ inline ( always ) ] pub fn ucckph ( & mut self ) -> UCCKPH_W { UCCKPH_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Control Word Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ctlw1](uca1ctlw1) module" ] pub type UCA1CTLW1 = crate :: Reg < u16 , _UCA1CTLW1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1CTLW1 ;
# [ doc = "`read()` method returns [uca1ctlw1::R](uca1ctlw1::R) reader structure" ] impl crate :: Readable for UCA1CTLW1 { }
# [ doc = "`write(|w| ..)` method takes [uca1ctlw1::W](uca1ctlw1::W) writer structure" ] impl crate :: Writable for UCA1CTLW1 { }
# [ doc = "eUSCI_Ax Control Word Register 1" ] pub mod uca1ctlw1 {
# [ doc = "Reader of register UCA1CTLW1" ] pub type R = crate :: R < u16 , super :: UCA1CTLW1 > ;
# [ doc = "Writer for register UCA1CTLW1" ] pub type W = crate :: W < u16 , super :: UCA1CTLW1 > ;
# [ doc = "Register UCA1CTLW1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1CTLW1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Deglitch time\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCGLIT_A { # [ doc = "0: Approximately 2 ns (equivalent of 1 delay element)" ] UCGLIT_0 = 0 , # [ doc = "1: Approximately 50 ns" ] UCGLIT_1 = 1 , # [ doc = "2: Approximately 100 ns" ] UCGLIT_2 = 2 , # [ doc = "3: Approximately 200 ns" ] UCGLIT_3 = 3 } impl From < UCGLIT_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCGLIT_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCGLIT`" ] pub type UCGLIT_R = crate :: R < u8 , UCGLIT_A > ; impl UCGLIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCGLIT_A { match self . bits { 0 => UCGLIT_A :: UCGLIT_0 , 1 => UCGLIT_A :: UCGLIT_1 , 2 => UCGLIT_A :: UCGLIT_2 , 3 => UCGLIT_A :: UCGLIT_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCGLIT_0`" ] # [ inline ( always ) ] pub fn is_ucglit_0 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_0 } # [ doc = "Checks if the value of the field is `UCGLIT_1`" ] # [ inline ( always ) ] pub fn is_ucglit_1 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_1 } # [ doc = "Checks if the value of the field is `UCGLIT_2`" ] # [ inline ( always ) ] pub fn is_ucglit_2 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_2 } # [ doc = "Checks if the value of the field is `UCGLIT_3`" ] # [ inline ( always ) ] pub fn is_ucglit_3 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_3 } }
# [ doc = "Write proxy for field `UCGLIT`" ] pub struct UCGLIT_W < 'a > { w : & 'a mut W , } impl < 'a > UCGLIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCGLIT_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Approximately 2 ns (equivalent of 1 delay element)" ] # [ inline ( always ) ] pub fn ucglit_0 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_0 ) } # [ doc = "Approximately 50 ns" ] # [ inline ( always ) ] pub fn ucglit_1 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_1 ) } # [ doc = "Approximately 100 ns" ] # [ inline ( always ) ] pub fn ucglit_2 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_2 ) } # [ doc = "Approximately 200 ns" ] # [ inline ( always ) ] pub fn ucglit_3 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Deglitch time" ] # [ inline ( always ) ] pub fn ucglit ( & self ) -> UCGLIT_R { UCGLIT_R :: new ( ( self . bits & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - Deglitch time" ] # [ inline ( always ) ] pub fn ucglit ( & mut self ) -> UCGLIT_W { UCGLIT_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Baud Rate Control Word Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1brw](uca1brw) module" ] pub type UCA1BRW = crate :: Reg < u16 , _UCA1BRW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1BRW ;
# [ doc = "`read()` method returns [uca1brw::R](uca1brw::R) reader structure" ] impl crate :: Readable for UCA1BRW { }
# [ doc = "`write(|w| ..)` method takes [uca1brw::W](uca1brw::W) writer structure" ] impl crate :: Writable for UCA1BRW { }
# [ doc = "eUSCI_Ax Baud Rate Control Word Register" ] pub mod uca1brw {
# [ doc = "Reader of register UCA1BRW" ] pub type R = crate :: R < u16 , super :: UCA1BRW > ;
# [ doc = "Writer for register UCA1BRW" ] pub type W = crate :: W < u16 , super :: UCA1BRW > ;
# [ doc = "Register UCA1BRW `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1BRW { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "eUSCI_Ax Bit Rate Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1brw_spi](uca1brw_spi) module" ] pub type UCA1BRW_SPI = crate :: Reg < u16 , _UCA1BRW_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1BRW_SPI ;
# [ doc = "`read()` method returns [uca1brw_spi::R](uca1brw_spi::R) reader structure" ] impl crate :: Readable for UCA1BRW_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca1brw_spi::W](uca1brw_spi::W) writer structure" ] impl crate :: Writable for UCA1BRW_SPI { }
# [ doc = "eUSCI_Ax Bit Rate Control Register 1" ] pub mod uca1brw_spi {
# [ doc = "Reader of register UCA1BRW_SPI" ] pub type R = crate :: R < u16 , super :: UCA1BRW_SPI > ;
# [ doc = "Writer for register UCA1BRW_SPI" ] pub type W = crate :: W < u16 , super :: UCA1BRW_SPI > ;
# [ doc = "Register UCA1BRW_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1BRW_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "eUSCI_Ax Modulation Control Word Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1mctlw](uca1mctlw) module" ] pub type UCA1MCTLW = crate :: Reg < u16 , _UCA1MCTLW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1MCTLW ;
# [ doc = "`read()` method returns [uca1mctlw::R](uca1mctlw::R) reader structure" ] impl crate :: Readable for UCA1MCTLW { }
# [ doc = "`write(|w| ..)` method takes [uca1mctlw::W](uca1mctlw::W) writer structure" ] impl crate :: Writable for UCA1MCTLW { }
# [ doc = "eUSCI_Ax Modulation Control Word Register" ] pub mod uca1mctlw {
# [ doc = "Reader of register UCA1MCTLW" ] pub type R = crate :: R < u16 , super :: UCA1MCTLW > ;
# [ doc = "Writer for register UCA1MCTLW" ] pub type W = crate :: W < u16 , super :: UCA1MCTLW > ;
# [ doc = "Register UCA1MCTLW `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1MCTLW { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Oversampling mode enabled\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOS16_A { # [ doc = "0: Disabled" ] UCOS16_0 = 0 , # [ doc = "1: Enabled" ] UCOS16_1 = 1 } impl From < UCOS16_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOS16_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOS16`" ] pub type UCOS16_R = crate :: R < bool , UCOS16_A > ; impl UCOS16_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOS16_A { match self . bits { false => UCOS16_A :: UCOS16_0 , true => UCOS16_A :: UCOS16_1 } } # [ doc = "Checks if the value of the field is `UCOS16_0`" ] # [ inline ( always ) ] pub fn is_ucos16_0 ( & self ) -> bool { * self == UCOS16_A :: UCOS16_0 } # [ doc = "Checks if the value of the field is `UCOS16_1`" ] # [ inline ( always ) ] pub fn is_ucos16_1 ( & self ) -> bool { * self == UCOS16_A :: UCOS16_1 } }
# [ doc = "Write proxy for field `UCOS16`" ] pub struct UCOS16_W < 'a > { w : & 'a mut W , } impl < 'a > UCOS16_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOS16_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn ucos16_0 ( self ) -> & 'a mut W { self . variant ( UCOS16_A :: UCOS16_0 ) } # [ doc = "Enabled" ] # [ inline ( always ) ] pub fn ucos16_1 ( self ) -> & 'a mut W { self . variant ( UCOS16_A :: UCOS16_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `UCBRF`" ] pub type UCBRF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCBRF`" ] pub struct UCBRF_W < 'a > { w : & 'a mut W , } impl < 'a > UCBRF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 4 ) ) | ( ( ( value as u16 ) & 0x0f ) << 4 ) ; self . w } }
# [ doc = "Reader of field `UCBRS`" ] pub type UCBRS_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCBRS`" ] pub struct UCBRS_W < 'a > { w : & 'a mut W , } impl < 'a > UCBRS_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 8 ) ) | ( ( ( value as u16 ) & 0xff ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Oversampling mode enabled" ] # [ inline ( always ) ] pub fn ucos16 ( & self ) -> UCOS16_R { UCOS16_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bits 4:7 - First modulation stage select" ] # [ inline ( always ) ] pub fn ucbrf ( & self ) -> UCBRF_R { UCBRF_R :: new ( ( ( self . bits >> 4 ) & 0x0f ) as u8 ) }
# [ doc = "Bits 8:15 - Second modulation stage select" ] # [ inline ( always ) ] pub fn ucbrs ( & self ) -> UCBRS_R { UCBRS_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Oversampling mode enabled" ] # [ inline ( always ) ] pub fn ucos16 ( & mut self ) -> UCOS16_W { UCOS16_W { w : self } }
# [ doc = "Bits 4:7 - First modulation stage select" ] # [ inline ( always ) ] pub fn ucbrf ( & mut self ) -> UCBRF_W { UCBRF_W { w : self } }
# [ doc = "Bits 8:15 - Second modulation stage select" ] # [ inline ( always ) ] pub fn ucbrs ( & mut self ) -> UCBRS_W { UCBRS_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1statw](uca1statw) module" ] pub type UCA1STATW = crate :: Reg < u16 , _UCA1STATW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1STATW ;
# [ doc = "`read()` method returns [uca1statw::R](uca1statw::R) reader structure" ] impl crate :: Readable for UCA1STATW { }
# [ doc = "`write(|w| ..)` method takes [uca1statw::W](uca1statw::W) writer structure" ] impl crate :: Writable for UCA1STATW { }
# [ doc = "eUSCI_Ax Status Register" ] pub mod uca1statw {
# [ doc = "Reader of register UCA1STATW" ] pub type R = crate :: R < u16 , super :: UCA1STATW > ;
# [ doc = "Writer for register UCA1STATW" ] pub type W = crate :: W < u16 , super :: UCA1STATW > ;
# [ doc = "Register UCA1STATW `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1STATW { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "eUSCI_A busy\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBUSY_A { # [ doc = "0: eUSCI_A inactive" ] IDLE = 0 , # [ doc = "1: eUSCI_A transmitting or receiving" ] BUSY = 1 } impl From < UCBUSY_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBUSY_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBUSY`" ] pub type UCBUSY_R = crate :: R < bool , UCBUSY_A > ; impl UCBUSY_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBUSY_A { match self . bits { false => UCBUSY_A :: IDLE , true => UCBUSY_A :: BUSY } } # [ doc = "Checks if the value of the field is `IDLE`" ] # [ inline ( always ) ] pub fn is_idle ( & self ) -> bool { * self == UCBUSY_A :: IDLE } # [ doc = "Checks if the value of the field is `BUSY`" ] # [ inline ( always ) ] pub fn is_busy ( & self ) -> bool { * self == UCBUSY_A :: BUSY } }
# [ doc = "Address received / Idle line detected\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCADDR_UCIDLE_A { # [ doc = "0: UCADDR: Received character is data. UCIDLE: No idle line detected" ] UCADDR_UCIDLE_0 = 0 , # [ doc = "1: UCADDR: Received character is an address. UCIDLE: Idle line detected" ] UCADDR_UCIDLE_1 = 1 } impl From < UCADDR_UCIDLE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCADDR_UCIDLE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCADDR_UCIDLE`" ] pub type UCADDR_UCIDLE_R = crate :: R < bool , UCADDR_UCIDLE_A > ; impl UCADDR_UCIDLE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCADDR_UCIDLE_A { match self . bits { false => UCADDR_UCIDLE_A :: UCADDR_UCIDLE_0 , true => UCADDR_UCIDLE_A :: UCADDR_UCIDLE_1 } } # [ doc = "Checks if the value of the field is `UCADDR_UCIDLE_0`" ] # [ inline ( always ) ] pub fn is_ucaddr_ucidle_0 ( & self ) -> bool { * self == UCADDR_UCIDLE_A :: UCADDR_UCIDLE_0 } # [ doc = "Checks if the value of the field is `UCADDR_UCIDLE_1`" ] # [ inline ( always ) ] pub fn is_ucaddr_ucidle_1 ( & self ) -> bool { * self == UCADDR_UCIDLE_A :: UCADDR_UCIDLE_1 } }
# [ doc = "Write proxy for field `UCADDR_UCIDLE`" ] pub struct UCADDR_UCIDLE_W < 'a > { w : & 'a mut W , } impl < 'a > UCADDR_UCIDLE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCADDR_UCIDLE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "UCADDR: Received character is data. UCIDLE: No idle line detected" ] # [ inline ( always ) ] pub fn ucaddr_ucidle_0 ( self ) -> & 'a mut W { self . variant ( UCADDR_UCIDLE_A :: UCADDR_UCIDLE_0 ) } # [ doc = "UCADDR: Received character is an address. UCIDLE: Idle line detected" ] # [ inline ( always ) ] pub fn ucaddr_ucidle_1 ( self ) -> & 'a mut W { self . variant ( UCADDR_UCIDLE_A :: UCADDR_UCIDLE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Receive error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXERR_A { # [ doc = "0: No receive errors detected" ] UCRXERR_0 = 0 , # [ doc = "1: Receive error detected" ] UCRXERR_1 = 1 } impl From < UCRXERR_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXERR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXERR`" ] pub type UCRXERR_R = crate :: R < bool , UCRXERR_A > ; impl UCRXERR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXERR_A { match self . bits { false => UCRXERR_A :: UCRXERR_0 , true => UCRXERR_A :: UCRXERR_1 } } # [ doc = "Checks if the value of the field is `UCRXERR_0`" ] # [ inline ( always ) ] pub fn is_ucrxerr_0 ( & self ) -> bool { * self == UCRXERR_A :: UCRXERR_0 } # [ doc = "Checks if the value of the field is `UCRXERR_1`" ] # [ inline ( always ) ] pub fn is_ucrxerr_1 ( & self ) -> bool { * self == UCRXERR_A :: UCRXERR_1 } }
# [ doc = "Write proxy for field `UCRXERR`" ] pub struct UCRXERR_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXERR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXERR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No receive errors detected" ] # [ inline ( always ) ] pub fn ucrxerr_0 ( self ) -> & 'a mut W { self . variant ( UCRXERR_A :: UCRXERR_0 ) } # [ doc = "Receive error detected" ] # [ inline ( always ) ] pub fn ucrxerr_1 ( self ) -> & 'a mut W { self . variant ( UCRXERR_A :: UCRXERR_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Break detect flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBRK_A { # [ doc = "0: No break condition" ] UCBRK_0 = 0 , # [ doc = "1: Break condition occurred" ] UCBRK_1 = 1 } impl From < UCBRK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBRK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBRK`" ] pub type UCBRK_R = crate :: R < bool , UCBRK_A > ; impl UCBRK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBRK_A { match self . bits { false => UCBRK_A :: UCBRK_0 , true => UCBRK_A :: UCBRK_1 } } # [ doc = "Checks if the value of the field is `UCBRK_0`" ] # [ inline ( always ) ] pub fn is_ucbrk_0 ( & self ) -> bool { * self == UCBRK_A :: UCBRK_0 } # [ doc = "Checks if the value of the field is `UCBRK_1`" ] # [ inline ( always ) ] pub fn is_ucbrk_1 ( & self ) -> bool { * self == UCBRK_A :: UCBRK_1 } }
# [ doc = "Write proxy for field `UCBRK`" ] pub struct UCBRK_W < 'a > { w : & 'a mut W , } impl < 'a > UCBRK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBRK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No break condition" ] # [ inline ( always ) ] pub fn ucbrk_0 ( self ) -> & 'a mut W { self . variant ( UCBRK_A :: UCBRK_0 ) } # [ doc = "Break condition occurred" ] # [ inline ( always ) ] pub fn ucbrk_1 ( self ) -> & 'a mut W { self . variant ( UCBRK_A :: UCBRK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Parity error flag. When UCPEN = 0, UCPE is read as 0. UCPE is cleared when UCAxRXBUF is read.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCPE_A { # [ doc = "0: No error" ] UCPE_0 = 0 , # [ doc = "1: Character received with parity error" ] UCPE_1 = 1 } impl From < UCPE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCPE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCPE`" ] pub type UCPE_R = crate :: R < bool , UCPE_A > ; impl UCPE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCPE_A { match self . bits { false => UCPE_A :: UCPE_0 , true => UCPE_A :: UCPE_1 } } # [ doc = "Checks if the value of the field is `UCPE_0`" ] # [ inline ( always ) ] pub fn is_ucpe_0 ( & self ) -> bool { * self == UCPE_A :: UCPE_0 } # [ doc = "Checks if the value of the field is `UCPE_1`" ] # [ inline ( always ) ] pub fn is_ucpe_1 ( & self ) -> bool { * self == UCPE_A :: UCPE_1 } }
# [ doc = "Write proxy for field `UCPE`" ] pub struct UCPE_W < 'a > { w : & 'a mut W , } impl < 'a > UCPE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCPE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucpe_0 ( self ) -> & 'a mut W { self . variant ( UCPE_A :: UCPE_0 ) } # [ doc = "Character received with parity error" ] # [ inline ( always ) ] pub fn ucpe_1 ( self ) -> & 'a mut W { self . variant ( UCPE_A :: UCPE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Overrun error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOE_A { # [ doc = "0: No error" ] UCOE_0 = 0 , # [ doc = "1: Overrun error occurred" ] UCOE_1 = 1 } impl From < UCOE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOE`" ] pub type UCOE_R = crate :: R < bool , UCOE_A > ; impl UCOE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOE_A { match self . bits { false => UCOE_A :: UCOE_0 , true => UCOE_A :: UCOE_1 } } # [ doc = "Checks if the value of the field is `UCOE_0`" ] # [ inline ( always ) ] pub fn is_ucoe_0 ( & self ) -> bool { * self == UCOE_A :: UCOE_0 } # [ doc = "Checks if the value of the field is `UCOE_1`" ] # [ inline ( always ) ] pub fn is_ucoe_1 ( & self ) -> bool { * self == UCOE_A :: UCOE_1 } }
# [ doc = "Write proxy for field `UCOE`" ] pub struct UCOE_W < 'a > { w : & 'a mut W , } impl < 'a > UCOE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucoe_0 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_0 ) } # [ doc = "Overrun error occurred" ] # [ inline ( always ) ] pub fn ucoe_1 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Framing error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCFE_A { # [ doc = "0: No error" ] UCFE_0 = 0 , # [ doc = "1: Character received with low stop bit" ] UCFE_1 = 1 } impl From < UCFE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCFE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCFE`" ] pub type UCFE_R = crate :: R < bool , UCFE_A > ; impl UCFE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCFE_A { match self . bits { false => UCFE_A :: UCFE_0 , true => UCFE_A :: UCFE_1 } } # [ doc = "Checks if the value of the field is `UCFE_0`" ] # [ inline ( always ) ] pub fn is_ucfe_0 ( & self ) -> bool { * self == UCFE_A :: UCFE_0 } # [ doc = "Checks if the value of the field is `UCFE_1`" ] # [ inline ( always ) ] pub fn is_ucfe_1 ( & self ) -> bool { * self == UCFE_A :: UCFE_1 } }
# [ doc = "Write proxy for field `UCFE`" ] pub struct UCFE_W < 'a > { w : & 'a mut W , } impl < 'a > UCFE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCFE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucfe_0 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_0 ) } # [ doc = "Character received with low stop bit" ] # [ inline ( always ) ] pub fn ucfe_1 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Listen enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCLISTEN_A { # [ doc = "0: Disabled" ] UCLISTEN_0 = 0 , # [ doc = "1: Enabled. UCAxTXD is internally fed back to the receiver" ] UCLISTEN_1 = 1 } impl From < UCLISTEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCLISTEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCLISTEN`" ] pub type UCLISTEN_R = crate :: R < bool , UCLISTEN_A > ; impl UCLISTEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCLISTEN_A { match self . bits { false => UCLISTEN_A :: UCLISTEN_0 , true => UCLISTEN_A :: UCLISTEN_1 } } # [ doc = "Checks if the value of the field is `UCLISTEN_0`" ] # [ inline ( always ) ] pub fn is_uclisten_0 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_0 } # [ doc = "Checks if the value of the field is `UCLISTEN_1`" ] # [ inline ( always ) ] pub fn is_uclisten_1 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_1 } }
# [ doc = "Write proxy for field `UCLISTEN`" ] pub struct UCLISTEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCLISTEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCLISTEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn uclisten_0 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_0 ) } # [ doc = "Enabled. UCAxTXD is internally fed back to the receiver" ] # [ inline ( always ) ] pub fn uclisten_1 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - eUSCI_A busy" ] # [ inline ( always ) ] pub fn ucbusy ( & self ) -> UCBUSY_R { UCBUSY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Address received / Idle line detected" ] # [ inline ( always ) ] pub fn ucaddr_ucidle ( & self ) -> UCADDR_UCIDLE_R { UCADDR_UCIDLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Receive error flag" ] # [ inline ( always ) ] pub fn ucrxerr ( & self ) -> UCRXERR_R { UCRXERR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Break detect flag" ] # [ inline ( always ) ] pub fn ucbrk ( & self ) -> UCBRK_R { UCBRK_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Parity error flag. When UCPEN = 0, UCPE is read as 0. UCPE is cleared when UCAxRXBUF is read." ] # [ inline ( always ) ] pub fn ucpe ( & self ) -> UCPE_R { UCPE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & self ) -> UCOE_R { UCOE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & self ) -> UCFE_R { UCFE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & self ) -> UCLISTEN_R { UCLISTEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 1 - Address received / Idle line detected" ] # [ inline ( always ) ] pub fn ucaddr_ucidle ( & mut self ) -> UCADDR_UCIDLE_W { UCADDR_UCIDLE_W { w : self } }
# [ doc = "Bit 2 - Receive error flag" ] # [ inline ( always ) ] pub fn ucrxerr ( & mut self ) -> UCRXERR_W { UCRXERR_W { w : self } }
# [ doc = "Bit 3 - Break detect flag" ] # [ inline ( always ) ] pub fn ucbrk ( & mut self ) -> UCBRK_W { UCBRK_W { w : self } }
# [ doc = "Bit 4 - Parity error flag. When UCPEN = 0, UCPE is read as 0. UCPE is cleared when UCAxRXBUF is read." ] # [ inline ( always ) ] pub fn ucpe ( & mut self ) -> UCPE_W { UCPE_W { w : self } }
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & mut self ) -> UCOE_W { UCOE_W { w : self } }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & mut self ) -> UCFE_W { UCFE_W { w : self } }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & mut self ) -> UCLISTEN_W { UCLISTEN_W { w : self } }
}
}
# [ doc = "UCA1STATW_SPI\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1statw_spi](uca1statw_spi) module" ] pub type UCA1STATW_SPI = crate :: Reg < u16 , _UCA1STATW_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1STATW_SPI ;
# [ doc = "`read()` method returns [uca1statw_spi::R](uca1statw_spi::R) reader structure" ] impl crate :: Readable for UCA1STATW_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca1statw_spi::W](uca1statw_spi::W) writer structure" ] impl crate :: Writable for UCA1STATW_SPI { }
# [ doc = "UCA1STATW_SPI" ] pub mod uca1statw_spi {
# [ doc = "Reader of register UCA1STATW_SPI" ] pub type R = crate :: R < u16 , super :: UCA1STATW_SPI > ;
# [ doc = "Writer for register UCA1STATW_SPI" ] pub type W = crate :: W < u16 , super :: UCA1STATW_SPI > ;
# [ doc = "Register UCA1STATW_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1STATW_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Overrun error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOE_A { # [ doc = "0: No error" ] UCOE_0 = 0 , # [ doc = "1: Overrun error occurred" ] UCOE_1 = 1 } impl From < UCOE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOE`" ] pub type UCOE_R = crate :: R < bool , UCOE_A > ; impl UCOE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOE_A { match self . bits { false => UCOE_A :: UCOE_0 , true => UCOE_A :: UCOE_1 } } # [ doc = "Checks if the value of the field is `UCOE_0`" ] # [ inline ( always ) ] pub fn is_ucoe_0 ( & self ) -> bool { * self == UCOE_A :: UCOE_0 } # [ doc = "Checks if the value of the field is `UCOE_1`" ] # [ inline ( always ) ] pub fn is_ucoe_1 ( & self ) -> bool { * self == UCOE_A :: UCOE_1 } }
# [ doc = "Write proxy for field `UCOE`" ] pub struct UCOE_W < 'a > { w : & 'a mut W , } impl < 'a > UCOE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucoe_0 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_0 ) } # [ doc = "Overrun error occurred" ] # [ inline ( always ) ] pub fn ucoe_1 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Framing error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCFE_A { # [ doc = "0: No error" ] UCFE_0 = 0 , # [ doc = "1: Bus conflict occurred" ] UCFE_1 = 1 } impl From < UCFE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCFE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCFE`" ] pub type UCFE_R = crate :: R < bool , UCFE_A > ; impl UCFE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCFE_A { match self . bits { false => UCFE_A :: UCFE_0 , true => UCFE_A :: UCFE_1 } } # [ doc = "Checks if the value of the field is `UCFE_0`" ] # [ inline ( always ) ] pub fn is_ucfe_0 ( & self ) -> bool { * self == UCFE_A :: UCFE_0 } # [ doc = "Checks if the value of the field is `UCFE_1`" ] # [ inline ( always ) ] pub fn is_ucfe_1 ( & self ) -> bool { * self == UCFE_A :: UCFE_1 } }
# [ doc = "Write proxy for field `UCFE`" ] pub struct UCFE_W < 'a > { w : & 'a mut W , } impl < 'a > UCFE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCFE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucfe_0 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_0 ) } # [ doc = "Bus conflict occurred" ] # [ inline ( always ) ] pub fn ucfe_1 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Listen enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCLISTEN_A { # [ doc = "0: Disabled" ] UCLISTEN_0 = 0 , # [ doc = "1: Enabled. UCAxTXD is internally fed back to the receiver" ] UCLISTEN_1 = 1 } impl From < UCLISTEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCLISTEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCLISTEN`" ] pub type UCLISTEN_R = crate :: R < bool , UCLISTEN_A > ; impl UCLISTEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCLISTEN_A { match self . bits { false => UCLISTEN_A :: UCLISTEN_0 , true => UCLISTEN_A :: UCLISTEN_1 } } # [ doc = "Checks if the value of the field is `UCLISTEN_0`" ] # [ inline ( always ) ] pub fn is_uclisten_0 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_0 } # [ doc = "Checks if the value of the field is `UCLISTEN_1`" ] # [ inline ( always ) ] pub fn is_uclisten_1 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_1 } }
# [ doc = "Write proxy for field `UCLISTEN`" ] pub struct UCLISTEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCLISTEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCLISTEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn uclisten_0 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_0 ) } # [ doc = "Enabled. UCAxTXD is internally fed back to the receiver" ] # [ inline ( always ) ] pub fn uclisten_1 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & self ) -> UCOE_R { UCOE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & self ) -> UCFE_R { UCFE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & self ) -> UCLISTEN_R { UCLISTEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & mut self ) -> UCOE_W { UCOE_W { w : self } }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & mut self ) -> UCFE_W { UCFE_W { w : self } }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & mut self ) -> UCLISTEN_W { UCLISTEN_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Receive Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1rxbuf](uca1rxbuf) module" ] pub type UCA1RXBUF = crate :: Reg < u16 , _UCA1RXBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1RXBUF ;
# [ doc = "`read()` method returns [uca1rxbuf::R](uca1rxbuf::R) reader structure" ] impl crate :: Readable for UCA1RXBUF { }
# [ doc = "eUSCI_Ax Receive Buffer Register" ] pub mod uca1rxbuf {
# [ doc = "Reader of register UCA1RXBUF" ] pub type R = crate :: R < u16 , super :: UCA1RXBUF > ;
# [ doc = "Reader of field `UCRXBUF`" ] pub type UCRXBUF_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Receive data buffer" ] # [ inline ( always ) ] pub fn ucrxbuf ( & self ) -> UCRXBUF_R { UCRXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
}
# [ doc = "eUSCI_Ax Receive Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1rxbuf_spi](uca1rxbuf_spi) module" ] pub type UCA1RXBUF_SPI = crate :: Reg < u16 , _UCA1RXBUF_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1RXBUF_SPI ;
# [ doc = "`read()` method returns [uca1rxbuf_spi::R](uca1rxbuf_spi::R) reader structure" ] impl crate :: Readable for UCA1RXBUF_SPI { }
# [ doc = "eUSCI_Ax Receive Buffer Register" ] pub mod uca1rxbuf_spi {
# [ doc = "Reader of register UCA1RXBUF_SPI" ] pub type R = crate :: R < u16 , super :: UCA1RXBUF_SPI > ;
# [ doc = "Reader of field `UCRXBUF`" ] pub type UCRXBUF_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Receive data buffer" ] # [ inline ( always ) ] pub fn ucrxbuf ( & self ) -> UCRXBUF_R { UCRXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
}
# [ doc = "eUSCI_Ax Transmit Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1txbuf](uca1txbuf) module" ] pub type UCA1TXBUF = crate :: Reg < u16 , _UCA1TXBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1TXBUF ;
# [ doc = "`read()` method returns [uca1txbuf::R](uca1txbuf::R) reader structure" ] impl crate :: Readable for UCA1TXBUF { }
# [ doc = "`write(|w| ..)` method takes [uca1txbuf::W](uca1txbuf::W) writer structure" ] impl crate :: Writable for UCA1TXBUF { }
# [ doc = "eUSCI_Ax Transmit Buffer Register" ] pub mod uca1txbuf {
# [ doc = "Reader of register UCA1TXBUF" ] pub type R = crate :: R < u16 , super :: UCA1TXBUF > ;
# [ doc = "Writer for register UCA1TXBUF" ] pub type W = crate :: W < u16 , super :: UCA1TXBUF > ;
# [ doc = "Register UCA1TXBUF `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1TXBUF { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UCTXBUF`" ] pub type UCTXBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCTXBUF`" ] pub struct UCTXBUF_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & self ) -> UCTXBUF_R { UCTXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & mut self ) -> UCTXBUF_W { UCTXBUF_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Transmit Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1txbuf_spi](uca1txbuf_spi) module" ] pub type UCA1TXBUF_SPI = crate :: Reg < u16 , _UCA1TXBUF_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1TXBUF_SPI ;
# [ doc = "`read()` method returns [uca1txbuf_spi::R](uca1txbuf_spi::R) reader structure" ] impl crate :: Readable for UCA1TXBUF_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca1txbuf_spi::W](uca1txbuf_spi::W) writer structure" ] impl crate :: Writable for UCA1TXBUF_SPI { }
# [ doc = "eUSCI_Ax Transmit Buffer Register" ] pub mod uca1txbuf_spi {
# [ doc = "Reader of register UCA1TXBUF_SPI" ] pub type R = crate :: R < u16 , super :: UCA1TXBUF_SPI > ;
# [ doc = "Writer for register UCA1TXBUF_SPI" ] pub type W = crate :: W < u16 , super :: UCA1TXBUF_SPI > ;
# [ doc = "Register UCA1TXBUF_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1TXBUF_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UCTXBUF`" ] pub type UCTXBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCTXBUF`" ] pub struct UCTXBUF_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & self ) -> UCTXBUF_R { UCTXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & mut self ) -> UCTXBUF_W { UCTXBUF_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Auto Baud Rate Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1abctl](uca1abctl) module" ] pub type UCA1ABCTL = crate :: Reg < u16 , _UCA1ABCTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1ABCTL ;
# [ doc = "`read()` method returns [uca1abctl::R](uca1abctl::R) reader structure" ] impl crate :: Readable for UCA1ABCTL { }
# [ doc = "`write(|w| ..)` method takes [uca1abctl::W](uca1abctl::W) writer structure" ] impl crate :: Writable for UCA1ABCTL { }
# [ doc = "eUSCI_Ax Auto Baud Rate Control Register" ] pub mod uca1abctl {
# [ doc = "Reader of register UCA1ABCTL" ] pub type R = crate :: R < u16 , super :: UCA1ABCTL > ;
# [ doc = "Writer for register UCA1ABCTL" ] pub type W = crate :: W < u16 , super :: UCA1ABCTL > ;
# [ doc = "Register UCA1ABCTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1ABCTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Automatic baud-rate detect enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCABDEN_A { # [ doc = "0: Baud-rate detection disabled. Length of break and synch field is not measured." ] UCABDEN_0 = 0 , # [ doc = "1: Baud-rate detection enabled. Length of break and synch field is measured and baud-rate settings are changed accordingly." ] UCABDEN_1 = 1 } impl From < UCABDEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCABDEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCABDEN`" ] pub type UCABDEN_R = crate :: R < bool , UCABDEN_A > ; impl UCABDEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCABDEN_A { match self . bits { false => UCABDEN_A :: UCABDEN_0 , true => UCABDEN_A :: UCABDEN_1 } } # [ doc = "Checks if the value of the field is `UCABDEN_0`" ] # [ inline ( always ) ] pub fn is_ucabden_0 ( & self ) -> bool { * self == UCABDEN_A :: UCABDEN_0 } # [ doc = "Checks if the value of the field is `UCABDEN_1`" ] # [ inline ( always ) ] pub fn is_ucabden_1 ( & self ) -> bool { * self == UCABDEN_A :: UCABDEN_1 } }
# [ doc = "Write proxy for field `UCABDEN`" ] pub struct UCABDEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCABDEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCABDEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Baud-rate detection disabled. Length of break and synch field is not measured." ] # [ inline ( always ) ] pub fn ucabden_0 ( self ) -> & 'a mut W { self . variant ( UCABDEN_A :: UCABDEN_0 ) } # [ doc = "Baud-rate detection enabled. Length of break and synch field is measured and baud-rate settings are changed accordingly." ] # [ inline ( always ) ] pub fn ucabden_1 ( self ) -> & 'a mut W { self . variant ( UCABDEN_A :: UCABDEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Break time out error\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBTOE_A { # [ doc = "0: No error" ] UCBTOE_0 = 0 , # [ doc = "1: Length of break field exceeded 22 bit times" ] UCBTOE_1 = 1 } impl From < UCBTOE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBTOE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBTOE`" ] pub type UCBTOE_R = crate :: R < bool , UCBTOE_A > ; impl UCBTOE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBTOE_A { match self . bits { false => UCBTOE_A :: UCBTOE_0 , true => UCBTOE_A :: UCBTOE_1 } } # [ doc = "Checks if the value of the field is `UCBTOE_0`" ] # [ inline ( always ) ] pub fn is_ucbtoe_0 ( & self ) -> bool { * self == UCBTOE_A :: UCBTOE_0 } # [ doc = "Checks if the value of the field is `UCBTOE_1`" ] # [ inline ( always ) ] pub fn is_ucbtoe_1 ( & self ) -> bool { * self == UCBTOE_A :: UCBTOE_1 } }
# [ doc = "Write proxy for field `UCBTOE`" ] pub struct UCBTOE_W < 'a > { w : & 'a mut W , } impl < 'a > UCBTOE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBTOE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucbtoe_0 ( self ) -> & 'a mut W { self . variant ( UCBTOE_A :: UCBTOE_0 ) } # [ doc = "Length of break field exceeded 22 bit times" ] # [ inline ( always ) ] pub fn ucbtoe_1 ( self ) -> & 'a mut W { self . variant ( UCBTOE_A :: UCBTOE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Synch field time out error\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTOE_A { # [ doc = "0: No error" ] UCSTOE_0 = 0 , # [ doc = "1: Length of synch field exceeded measurable time" ] UCSTOE_1 = 1 } impl From < UCSTOE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTOE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTOE`" ] pub type UCSTOE_R = crate :: R < bool , UCSTOE_A > ; impl UCSTOE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTOE_A { match self . bits { false => UCSTOE_A :: UCSTOE_0 , true => UCSTOE_A :: UCSTOE_1 } } # [ doc = "Checks if the value of the field is `UCSTOE_0`" ] # [ inline ( always ) ] pub fn is_ucstoe_0 ( & self ) -> bool { * self == UCSTOE_A :: UCSTOE_0 } # [ doc = "Checks if the value of the field is `UCSTOE_1`" ] # [ inline ( always ) ] pub fn is_ucstoe_1 ( & self ) -> bool { * self == UCSTOE_A :: UCSTOE_1 } }
# [ doc = "Write proxy for field `UCSTOE`" ] pub struct UCSTOE_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTOE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTOE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucstoe_0 ( self ) -> & 'a mut W { self . variant ( UCSTOE_A :: UCSTOE_0 ) } # [ doc = "Length of synch field exceeded measurable time" ] # [ inline ( always ) ] pub fn ucstoe_1 ( self ) -> & 'a mut W { self . variant ( UCSTOE_A :: UCSTOE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Break/synch delimiter length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCDELIM_A { # [ doc = "0: 1 bit time" ] UCDELIM_0 = 0 , # [ doc = "1: 2 bit times" ] UCDELIM_1 = 1 , # [ doc = "2: 3 bit times" ] UCDELIM_2 = 2 , # [ doc = "3: 4 bit times" ] UCDELIM_3 = 3 } impl From < UCDELIM_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCDELIM_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCDELIM`" ] pub type UCDELIM_R = crate :: R < u8 , UCDELIM_A > ; impl UCDELIM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCDELIM_A { match self . bits { 0 => UCDELIM_A :: UCDELIM_0 , 1 => UCDELIM_A :: UCDELIM_1 , 2 => UCDELIM_A :: UCDELIM_2 , 3 => UCDELIM_A :: UCDELIM_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCDELIM_0`" ] # [ inline ( always ) ] pub fn is_ucdelim_0 ( & self ) -> bool { * self == UCDELIM_A :: UCDELIM_0 } # [ doc = "Checks if the value of the field is `UCDELIM_1`" ] # [ inline ( always ) ] pub fn is_ucdelim_1 ( & self ) -> bool { * self == UCDELIM_A :: UCDELIM_1 } # [ doc = "Checks if the value of the field is `UCDELIM_2`" ] # [ inline ( always ) ] pub fn is_ucdelim_2 ( & self ) -> bool { * self == UCDELIM_A :: UCDELIM_2 } # [ doc = "Checks if the value of the field is `UCDELIM_3`" ] # [ inline ( always ) ] pub fn is_ucdelim_3 ( & self ) -> bool { * self == UCDELIM_A :: UCDELIM_3 } }
# [ doc = "Write proxy for field `UCDELIM`" ] pub struct UCDELIM_W < 'a > { w : & 'a mut W , } impl < 'a > UCDELIM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCDELIM_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "1 bit time" ] # [ inline ( always ) ] pub fn ucdelim_0 ( self ) -> & 'a mut W { self . variant ( UCDELIM_A :: UCDELIM_0 ) } # [ doc = "2 bit times" ] # [ inline ( always ) ] pub fn ucdelim_1 ( self ) -> & 'a mut W { self . variant ( UCDELIM_A :: UCDELIM_1 ) } # [ doc = "3 bit times" ] # [ inline ( always ) ] pub fn ucdelim_2 ( self ) -> & 'a mut W { self . variant ( UCDELIM_A :: UCDELIM_2 ) } # [ doc = "4 bit times" ] # [ inline ( always ) ] pub fn ucdelim_3 ( self ) -> & 'a mut W { self . variant ( UCDELIM_A :: UCDELIM_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Automatic baud-rate detect enable" ] # [ inline ( always ) ] pub fn ucabden ( & self ) -> UCABDEN_R { UCABDEN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Break time out error" ] # [ inline ( always ) ] pub fn ucbtoe ( & self ) -> UCBTOE_R { UCBTOE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Synch field time out error" ] # [ inline ( always ) ] pub fn ucstoe ( & self ) -> UCSTOE_R { UCSTOE_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - Break/synch delimiter length" ] # [ inline ( always ) ] pub fn ucdelim ( & self ) -> UCDELIM_R { UCDELIM_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Automatic baud-rate detect enable" ] # [ inline ( always ) ] pub fn ucabden ( & mut self ) -> UCABDEN_W { UCABDEN_W { w : self } }
# [ doc = "Bit 2 - Break time out error" ] # [ inline ( always ) ] pub fn ucbtoe ( & mut self ) -> UCBTOE_W { UCBTOE_W { w : self } }
# [ doc = "Bit 3 - Synch field time out error" ] # [ inline ( always ) ] pub fn ucstoe ( & mut self ) -> UCSTOE_W { UCSTOE_W { w : self } }
# [ doc = "Bits 4:5 - Break/synch delimiter length" ] # [ inline ( always ) ] pub fn ucdelim ( & mut self ) -> UCDELIM_W { UCDELIM_W { w : self } }
}
}
# [ doc = "eUSCI_Ax IrDA Control Word Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1irctl](uca1irctl) module" ] pub type UCA1IRCTL = crate :: Reg < u16 , _UCA1IRCTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1IRCTL ;
# [ doc = "`read()` method returns [uca1irctl::R](uca1irctl::R) reader structure" ] impl crate :: Readable for UCA1IRCTL { }
# [ doc = "`write(|w| ..)` method takes [uca1irctl::W](uca1irctl::W) writer structure" ] impl crate :: Writable for UCA1IRCTL { }
# [ doc = "eUSCI_Ax IrDA Control Word Register" ] pub mod uca1irctl {
# [ doc = "Reader of register UCA1IRCTL" ] pub type R = crate :: R < u16 , super :: UCA1IRCTL > ;
# [ doc = "Writer for register UCA1IRCTL" ] pub type W = crate :: W < u16 , super :: UCA1IRCTL > ;
# [ doc = "Register UCA1IRCTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1IRCTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "IrDA encoder/decoder enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCIREN_A { # [ doc = "0: IrDA encoder/decoder disabled" ] UCIREN_0 = 0 , # [ doc = "1: IrDA encoder/decoder enabled" ] UCIREN_1 = 1 } impl From < UCIREN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCIREN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCIREN`" ] pub type UCIREN_R = crate :: R < bool , UCIREN_A > ; impl UCIREN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCIREN_A { match self . bits { false => UCIREN_A :: UCIREN_0 , true => UCIREN_A :: UCIREN_1 } } # [ doc = "Checks if the value of the field is `UCIREN_0`" ] # [ inline ( always ) ] pub fn is_uciren_0 ( & self ) -> bool { * self == UCIREN_A :: UCIREN_0 } # [ doc = "Checks if the value of the field is `UCIREN_1`" ] # [ inline ( always ) ] pub fn is_uciren_1 ( & self ) -> bool { * self == UCIREN_A :: UCIREN_1 } }
# [ doc = "Write proxy for field `UCIREN`" ] pub struct UCIREN_W < 'a > { w : & 'a mut W , } impl < 'a > UCIREN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCIREN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "IrDA encoder/decoder disabled" ] # [ inline ( always ) ] pub fn uciren_0 ( self ) -> & 'a mut W { self . variant ( UCIREN_A :: UCIREN_0 ) } # [ doc = "IrDA encoder/decoder enabled" ] # [ inline ( always ) ] pub fn uciren_1 ( self ) -> & 'a mut W { self . variant ( UCIREN_A :: UCIREN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "IrDA transmit pulse clock select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCIRTXCLK_A { # [ doc = "0: BRCLK" ] UCIRTXCLK_0 = 0 , # [ doc = "1: BITCLK16 when UCOS16 = 1. Otherwise, BRCLK." ] UCIRTXCLK_1 = 1 } impl From < UCIRTXCLK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCIRTXCLK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCIRTXCLK`" ] pub type UCIRTXCLK_R = crate :: R < bool , UCIRTXCLK_A > ; impl UCIRTXCLK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCIRTXCLK_A { match self . bits { false => UCIRTXCLK_A :: UCIRTXCLK_0 , true => UCIRTXCLK_A :: UCIRTXCLK_1 } } # [ doc = "Checks if the value of the field is `UCIRTXCLK_0`" ] # [ inline ( always ) ] pub fn is_ucirtxclk_0 ( & self ) -> bool { * self == UCIRTXCLK_A :: UCIRTXCLK_0 } # [ doc = "Checks if the value of the field is `UCIRTXCLK_1`" ] # [ inline ( always ) ] pub fn is_ucirtxclk_1 ( & self ) -> bool { * self == UCIRTXCLK_A :: UCIRTXCLK_1 } }
# [ doc = "Write proxy for field `UCIRTXCLK`" ] pub struct UCIRTXCLK_W < 'a > { w : & 'a mut W , } impl < 'a > UCIRTXCLK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCIRTXCLK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "BRCLK" ] # [ inline ( always ) ] pub fn ucirtxclk_0 ( self ) -> & 'a mut W { self . variant ( UCIRTXCLK_A :: UCIRTXCLK_0 ) } # [ doc = "BITCLK16 when UCOS16 = 1. Otherwise, BRCLK." ] # [ inline ( always ) ] pub fn ucirtxclk_1 ( self ) -> & 'a mut W { self . variant ( UCIRTXCLK_A :: UCIRTXCLK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `UCIRTXPL`" ] pub type UCIRTXPL_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCIRTXPL`" ] pub struct UCIRTXPL_W < 'a > { w : & 'a mut W , } impl < 'a > UCIRTXPL_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 2 ) ) | ( ( ( value as u16 ) & 0x3f ) << 2 ) ; self . w } }
# [ doc = "IrDA receive filter enabled\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCIRRXFE_A { # [ doc = "0: Receive filter disabled" ] UCIRRXFE_0 = 0 , # [ doc = "1: Receive filter enabled" ] UCIRRXFE_1 = 1 } impl From < UCIRRXFE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCIRRXFE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCIRRXFE`" ] pub type UCIRRXFE_R = crate :: R < bool , UCIRRXFE_A > ; impl UCIRRXFE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCIRRXFE_A { match self . bits { false => UCIRRXFE_A :: UCIRRXFE_0 , true => UCIRRXFE_A :: UCIRRXFE_1 } } # [ doc = "Checks if the value of the field is `UCIRRXFE_0`" ] # [ inline ( always ) ] pub fn is_ucirrxfe_0 ( & self ) -> bool { * self == UCIRRXFE_A :: UCIRRXFE_0 } # [ doc = "Checks if the value of the field is `UCIRRXFE_1`" ] # [ inline ( always ) ] pub fn is_ucirrxfe_1 ( & self ) -> bool { * self == UCIRRXFE_A :: UCIRRXFE_1 } }
# [ doc = "Write proxy for field `UCIRRXFE`" ] pub struct UCIRRXFE_W < 'a > { w : & 'a mut W , } impl < 'a > UCIRRXFE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCIRRXFE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Receive filter disabled" ] # [ inline ( always ) ] pub fn ucirrxfe_0 ( self ) -> & 'a mut W { self . variant ( UCIRRXFE_A :: UCIRRXFE_0 ) } # [ doc = "Receive filter enabled" ] # [ inline ( always ) ] pub fn ucirrxfe_1 ( self ) -> & 'a mut W { self . variant ( UCIRRXFE_A :: UCIRRXFE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "IrDA receive input UCAxRXD polarity\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCIRRXPL_A { # [ doc = "0: IrDA transceiver delivers a high pulse when a light pulse is seen" ] HIGH = 0 , # [ doc = "1: IrDA transceiver delivers a low pulse when a light pulse is seen" ] LOW = 1 } impl From < UCIRRXPL_A > for bool { # [ inline ( always ) ] fn from ( variant : UCIRRXPL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCIRRXPL`" ] pub type UCIRRXPL_R = crate :: R < bool , UCIRRXPL_A > ; impl UCIRRXPL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCIRRXPL_A { match self . bits { false => UCIRRXPL_A :: HIGH , true => UCIRRXPL_A :: LOW } } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == UCIRRXPL_A :: HIGH } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == UCIRRXPL_A :: LOW } }
# [ doc = "Write proxy for field `UCIRRXPL`" ] pub struct UCIRRXPL_W < 'a > { w : & 'a mut W , } impl < 'a > UCIRRXPL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCIRRXPL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "IrDA transceiver delivers a high pulse when a light pulse is seen" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( UCIRRXPL_A :: HIGH ) } # [ doc = "IrDA transceiver delivers a low pulse when a light pulse is seen" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( UCIRRXPL_A :: LOW ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `UCIRRXFL`" ] pub type UCIRRXFL_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCIRRXFL`" ] pub struct UCIRRXFL_W < 'a > { w : & 'a mut W , } impl < 'a > UCIRRXFL_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 10 ) ) | ( ( ( value as u16 ) & 0x3f ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - IrDA encoder/decoder enable" ] # [ inline ( always ) ] pub fn uciren ( & self ) -> UCIREN_R { UCIREN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - IrDA transmit pulse clock select" ] # [ inline ( always ) ] pub fn ucirtxclk ( & self ) -> UCIRTXCLK_R { UCIRTXCLK_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 2:7 - Transmit pulse length" ] # [ inline ( always ) ] pub fn ucirtxpl ( & self ) -> UCIRTXPL_R { UCIRTXPL_R :: new ( ( ( self . bits >> 2 ) & 0x3f ) as u8 ) }
# [ doc = "Bit 8 - IrDA receive filter enabled" ] # [ inline ( always ) ] pub fn ucirrxfe ( & self ) -> UCIRRXFE_R { UCIRRXFE_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - IrDA receive input UCAxRXD polarity" ] # [ inline ( always ) ] pub fn ucirrxpl ( & self ) -> UCIRRXPL_R { UCIRRXPL_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 10:15 - Receive filter length" ] # [ inline ( always ) ] pub fn ucirrxfl ( & self ) -> UCIRRXFL_R { UCIRRXFL_R :: new ( ( ( self . bits >> 10 ) & 0x3f ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - IrDA encoder/decoder enable" ] # [ inline ( always ) ] pub fn uciren ( & mut self ) -> UCIREN_W { UCIREN_W { w : self } }
# [ doc = "Bit 1 - IrDA transmit pulse clock select" ] # [ inline ( always ) ] pub fn ucirtxclk ( & mut self ) -> UCIRTXCLK_W { UCIRTXCLK_W { w : self } }
# [ doc = "Bits 2:7 - Transmit pulse length" ] # [ inline ( always ) ] pub fn ucirtxpl ( & mut self ) -> UCIRTXPL_W { UCIRTXPL_W { w : self } }
# [ doc = "Bit 8 - IrDA receive filter enabled" ] # [ inline ( always ) ] pub fn ucirrxfe ( & mut self ) -> UCIRRXFE_W { UCIRRXFE_W { w : self } }
# [ doc = "Bit 9 - IrDA receive input UCAxRXD polarity" ] # [ inline ( always ) ] pub fn ucirrxpl ( & mut self ) -> UCIRRXPL_W { UCIRRXPL_W { w : self } }
# [ doc = "Bits 10:15 - Receive filter length" ] # [ inline ( always ) ] pub fn ucirrxfl ( & mut self ) -> UCIRRXFL_W { UCIRRXFL_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ie](uca1ie) module" ] pub type UCA1IE = crate :: Reg < u16 , _UCA1IE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1IE ;
# [ doc = "`read()` method returns [uca1ie::R](uca1ie::R) reader structure" ] impl crate :: Readable for UCA1IE { }
# [ doc = "`write(|w| ..)` method takes [uca1ie::W](uca1ie::W) writer structure" ] impl crate :: Writable for UCA1IE { }
# [ doc = "eUSCI_Ax Interrupt Enable Register" ] pub mod uca1ie {
# [ doc = "Reader of register UCA1IE" ] pub type R = crate :: R < u16 , super :: UCA1IE > ;
# [ doc = "Writer for register UCA1IE" ] pub type W = crate :: W < u16 , super :: UCA1IE > ;
# [ doc = "Register UCA1IE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1IE { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE_A { # [ doc = "0: Interrupt disabled" ] UCRXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE_1 = 1 } impl From < UCRXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE`" ] pub type UCRXIE_R = crate :: R < bool , UCRXIE_A > ; impl UCRXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE_A { match self . bits { false => UCRXIE_A :: UCRXIE_0 , true => UCRXIE_A :: UCRXIE_1 } } # [ doc = "Checks if the value of the field is `UCRXIE_0`" ] # [ inline ( always ) ] pub fn is_ucrxie_0 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_0 } # [ doc = "Checks if the value of the field is `UCRXIE_1`" ] # [ inline ( always ) ] pub fn is_ucrxie_1 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_1 } }
# [ doc = "Write proxy for field `UCRXIE`" ] pub struct UCRXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE_A { # [ doc = "0: Interrupt disabled" ] UCTXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE_1 = 1 } impl From < UCTXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE`" ] pub type UCTXIE_R = crate :: R < bool , UCTXIE_A > ; impl UCTXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE_A { match self . bits { false => UCTXIE_A :: UCTXIE_0 , true => UCTXIE_A :: UCTXIE_1 } } # [ doc = "Checks if the value of the field is `UCTXIE_0`" ] # [ inline ( always ) ] pub fn is_uctxie_0 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_0 } # [ doc = "Checks if the value of the field is `UCTXIE_1`" ] # [ inline ( always ) ] pub fn is_uctxie_1 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_1 } }
# [ doc = "Write proxy for field `UCTXIE`" ] pub struct UCTXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Start bit interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTTIE_A { # [ doc = "0: Interrupt disabled" ] UCSTTIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCSTTIE_1 = 1 } impl From < UCSTTIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTTIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTTIE`" ] pub type UCSTTIE_R = crate :: R < bool , UCSTTIE_A > ; impl UCSTTIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTTIE_A { match self . bits { false => UCSTTIE_A :: UCSTTIE_0 , true => UCSTTIE_A :: UCSTTIE_1 } } # [ doc = "Checks if the value of the field is `UCSTTIE_0`" ] # [ inline ( always ) ] pub fn is_ucsttie_0 ( & self ) -> bool { * self == UCSTTIE_A :: UCSTTIE_0 } # [ doc = "Checks if the value of the field is `UCSTTIE_1`" ] # [ inline ( always ) ] pub fn is_ucsttie_1 ( & self ) -> bool { * self == UCSTTIE_A :: UCSTTIE_1 } }
# [ doc = "Write proxy for field `UCSTTIE`" ] pub struct UCSTTIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTTIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTTIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucsttie_0 ( self ) -> & 'a mut W { self . variant ( UCSTTIE_A :: UCSTTIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucsttie_1 ( self ) -> & 'a mut W { self . variant ( UCSTTIE_A :: UCSTTIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Transmit complete interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXCPTIE_A { # [ doc = "0: Interrupt disabled" ] UCTXCPTIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXCPTIE_1 = 1 } impl From < UCTXCPTIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXCPTIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXCPTIE`" ] pub type UCTXCPTIE_R = crate :: R < bool , UCTXCPTIE_A > ; impl UCTXCPTIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXCPTIE_A { match self . bits { false => UCTXCPTIE_A :: UCTXCPTIE_0 , true => UCTXCPTIE_A :: UCTXCPTIE_1 } } # [ doc = "Checks if the value of the field is `UCTXCPTIE_0`" ] # [ inline ( always ) ] pub fn is_uctxcptie_0 ( & self ) -> bool { * self == UCTXCPTIE_A :: UCTXCPTIE_0 } # [ doc = "Checks if the value of the field is `UCTXCPTIE_1`" ] # [ inline ( always ) ] pub fn is_uctxcptie_1 ( & self ) -> bool { * self == UCTXCPTIE_A :: UCTXCPTIE_1 } }
# [ doc = "Write proxy for field `UCTXCPTIE`" ] pub struct UCTXCPTIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXCPTIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXCPTIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxcptie_0 ( self ) -> & 'a mut W { self . variant ( UCTXCPTIE_A :: UCTXCPTIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxcptie_1 ( self ) -> & 'a mut W { self . variant ( UCTXCPTIE_A :: UCTXCPTIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & self ) -> UCRXIE_R { UCRXIE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & self ) -> UCTXIE_R { UCTXIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Start bit interrupt enable" ] # [ inline ( always ) ] pub fn ucsttie ( & self ) -> UCSTTIE_R { UCSTTIE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Transmit complete interrupt enable" ] # [ inline ( always ) ] pub fn uctxcptie ( & self ) -> UCTXCPTIE_R { UCTXCPTIE_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & mut self ) -> UCRXIE_W { UCRXIE_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & mut self ) -> UCTXIE_W { UCTXIE_W { w : self } }
# [ doc = "Bit 2 - Start bit interrupt enable" ] # [ inline ( always ) ] pub fn ucsttie ( & mut self ) -> UCSTTIE_W { UCSTTIE_W { w : self } }
# [ doc = "Bit 3 - Transmit complete interrupt enable" ] # [ inline ( always ) ] pub fn uctxcptie ( & mut self ) -> UCTXCPTIE_W { UCTXCPTIE_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ie_spi](uca1ie_spi) module" ] pub type UCA1IE_SPI = crate :: Reg < u16 , _UCA1IE_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1IE_SPI ;
# [ doc = "`read()` method returns [uca1ie_spi::R](uca1ie_spi::R) reader structure" ] impl crate :: Readable for UCA1IE_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca1ie_spi::W](uca1ie_spi::W) writer structure" ] impl crate :: Writable for UCA1IE_SPI { }
# [ doc = "eUSCI_Ax Interrupt Enable Register" ] pub mod uca1ie_spi {
# [ doc = "Reader of register UCA1IE_SPI" ] pub type R = crate :: R < u16 , super :: UCA1IE_SPI > ;
# [ doc = "Writer for register UCA1IE_SPI" ] pub type W = crate :: W < u16 , super :: UCA1IE_SPI > ;
# [ doc = "Register UCA1IE_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1IE_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE_A { # [ doc = "0: Interrupt disabled" ] UCRXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE_1 = 1 } impl From < UCRXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE`" ] pub type UCRXIE_R = crate :: R < bool , UCRXIE_A > ; impl UCRXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE_A { match self . bits { false => UCRXIE_A :: UCRXIE_0 , true => UCRXIE_A :: UCRXIE_1 } } # [ doc = "Checks if the value of the field is `UCRXIE_0`" ] # [ inline ( always ) ] pub fn is_ucrxie_0 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_0 } # [ doc = "Checks if the value of the field is `UCRXIE_1`" ] # [ inline ( always ) ] pub fn is_ucrxie_1 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_1 } }
# [ doc = "Write proxy for field `UCRXIE`" ] pub struct UCRXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE_A { # [ doc = "0: Interrupt disabled" ] UCTXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE_1 = 1 } impl From < UCTXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE`" ] pub type UCTXIE_R = crate :: R < bool , UCTXIE_A > ; impl UCTXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE_A { match self . bits { false => UCTXIE_A :: UCTXIE_0 , true => UCTXIE_A :: UCTXIE_1 } } # [ doc = "Checks if the value of the field is `UCTXIE_0`" ] # [ inline ( always ) ] pub fn is_uctxie_0 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_0 } # [ doc = "Checks if the value of the field is `UCTXIE_1`" ] # [ inline ( always ) ] pub fn is_uctxie_1 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_1 } }
# [ doc = "Write proxy for field `UCTXIE`" ] pub struct UCTXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & self ) -> UCRXIE_R { UCRXIE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & self ) -> UCTXIE_R { UCTXIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & mut self ) -> UCRXIE_W { UCRXIE_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & mut self ) -> UCTXIE_W { UCTXIE_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ifg](uca1ifg) module" ] pub type UCA1IFG = crate :: Reg < u16 , _UCA1IFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1IFG ;
# [ doc = "`read()` method returns [uca1ifg::R](uca1ifg::R) reader structure" ] impl crate :: Readable for UCA1IFG { }
# [ doc = "`write(|w| ..)` method takes [uca1ifg::W](uca1ifg::W) writer structure" ] impl crate :: Writable for UCA1IFG { }
# [ doc = "eUSCI_Ax Interrupt Flag Register" ] pub mod uca1ifg {
# [ doc = "Reader of register UCA1IFG" ] pub type R = crate :: R < u16 , super :: UCA1IFG > ;
# [ doc = "Writer for register UCA1IFG" ] pub type W = crate :: W < u16 , super :: UCA1IFG > ;
# [ doc = "Register UCA1IFG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1IFG { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG_A { # [ doc = "0: No interrupt pending" ] UCRXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG_1 = 1 } impl From < UCRXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG`" ] pub type UCRXIFG_R = crate :: R < bool , UCRXIFG_A > ; impl UCRXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG_A { match self . bits { false => UCRXIFG_A :: UCRXIFG_0 , true => UCRXIFG_A :: UCRXIFG_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg_0 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_0 } # [ doc = "Checks if the value of the field is `UCRXIFG_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg_1 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_1 } }
# [ doc = "Write proxy for field `UCRXIFG`" ] pub struct UCRXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG_A { # [ doc = "0: No interrupt pending" ] UCTXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG_1 = 1 } impl From < UCTXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG`" ] pub type UCTXIFG_R = crate :: R < bool , UCTXIFG_A > ; impl UCTXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG_A { match self . bits { false => UCTXIFG_A :: UCTXIFG_0 , true => UCTXIFG_A :: UCTXIFG_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG_0`" ] # [ inline ( always ) ] pub fn is_uctxifg_0 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_0 } # [ doc = "Checks if the value of the field is `UCTXIFG_1`" ] # [ inline ( always ) ] pub fn is_uctxifg_1 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_1 } }
# [ doc = "Write proxy for field `UCTXIFG`" ] pub struct UCTXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Start bit interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTTIFG_A { # [ doc = "0: No interrupt pending" ] UCSTTIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCSTTIFG_1 = 1 } impl From < UCSTTIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTTIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTTIFG`" ] pub type UCSTTIFG_R = crate :: R < bool , UCSTTIFG_A > ; impl UCSTTIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTTIFG_A { match self . bits { false => UCSTTIFG_A :: UCSTTIFG_0 , true => UCSTTIFG_A :: UCSTTIFG_1 } } # [ doc = "Checks if the value of the field is `UCSTTIFG_0`" ] # [ inline ( always ) ] pub fn is_ucsttifg_0 ( & self ) -> bool { * self == UCSTTIFG_A :: UCSTTIFG_0 } # [ doc = "Checks if the value of the field is `UCSTTIFG_1`" ] # [ inline ( always ) ] pub fn is_ucsttifg_1 ( & self ) -> bool { * self == UCSTTIFG_A :: UCSTTIFG_1 } }
# [ doc = "Write proxy for field `UCSTTIFG`" ] pub struct UCSTTIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTTIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTTIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucsttifg_0 ( self ) -> & 'a mut W { self . variant ( UCSTTIFG_A :: UCSTTIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucsttifg_1 ( self ) -> & 'a mut W { self . variant ( UCSTTIFG_A :: UCSTTIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Transmit ready interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXCPTIFG_A { # [ doc = "0: No interrupt pending" ] UCTXCPTIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXCPTIFG_1 = 1 } impl From < UCTXCPTIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXCPTIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXCPTIFG`" ] pub type UCTXCPTIFG_R = crate :: R < bool , UCTXCPTIFG_A > ; impl UCTXCPTIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXCPTIFG_A { match self . bits { false => UCTXCPTIFG_A :: UCTXCPTIFG_0 , true => UCTXCPTIFG_A :: UCTXCPTIFG_1 } } # [ doc = "Checks if the value of the field is `UCTXCPTIFG_0`" ] # [ inline ( always ) ] pub fn is_uctxcptifg_0 ( & self ) -> bool { * self == UCTXCPTIFG_A :: UCTXCPTIFG_0 } # [ doc = "Checks if the value of the field is `UCTXCPTIFG_1`" ] # [ inline ( always ) ] pub fn is_uctxcptifg_1 ( & self ) -> bool { * self == UCTXCPTIFG_A :: UCTXCPTIFG_1 } }
# [ doc = "Write proxy for field `UCTXCPTIFG`" ] pub struct UCTXCPTIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXCPTIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXCPTIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxcptifg_0 ( self ) -> & 'a mut W { self . variant ( UCTXCPTIFG_A :: UCTXCPTIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxcptifg_1 ( self ) -> & 'a mut W { self . variant ( UCTXCPTIFG_A :: UCTXCPTIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & self ) -> UCRXIFG_R { UCRXIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & self ) -> UCTXIFG_R { UCTXIFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Start bit interrupt flag" ] # [ inline ( always ) ] pub fn ucsttifg ( & self ) -> UCSTTIFG_R { UCSTTIFG_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Transmit ready interrupt enable" ] # [ inline ( always ) ] pub fn uctxcptifg ( & self ) -> UCTXCPTIFG_R { UCTXCPTIFG_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & mut self ) -> UCRXIFG_W { UCRXIFG_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & mut self ) -> UCTXIFG_W { UCTXIFG_W { w : self } }
# [ doc = "Bit 2 - Start bit interrupt flag" ] # [ inline ( always ) ] pub fn ucsttifg ( & mut self ) -> UCSTTIFG_W { UCSTTIFG_W { w : self } }
# [ doc = "Bit 3 - Transmit ready interrupt enable" ] # [ inline ( always ) ] pub fn uctxcptifg ( & mut self ) -> UCTXCPTIFG_W { UCTXCPTIFG_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ifg_spi](uca1ifg_spi) module" ] pub type UCA1IFG_SPI = crate :: Reg < u16 , _UCA1IFG_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1IFG_SPI ;
# [ doc = "`read()` method returns [uca1ifg_spi::R](uca1ifg_spi::R) reader structure" ] impl crate :: Readable for UCA1IFG_SPI { }
# [ doc = "`write(|w| ..)` method takes [uca1ifg_spi::W](uca1ifg_spi::W) writer structure" ] impl crate :: Writable for UCA1IFG_SPI { }
# [ doc = "eUSCI_Ax Interrupt Flag Register" ] pub mod uca1ifg_spi {
# [ doc = "Reader of register UCA1IFG_SPI" ] pub type R = crate :: R < u16 , super :: UCA1IFG_SPI > ;
# [ doc = "Writer for register UCA1IFG_SPI" ] pub type W = crate :: W < u16 , super :: UCA1IFG_SPI > ;
# [ doc = "Register UCA1IFG_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCA1IFG_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG_A { # [ doc = "0: No interrupt pending" ] UCRXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG_1 = 1 } impl From < UCRXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG`" ] pub type UCRXIFG_R = crate :: R < bool , UCRXIFG_A > ; impl UCRXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG_A { match self . bits { false => UCRXIFG_A :: UCRXIFG_0 , true => UCRXIFG_A :: UCRXIFG_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg_0 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_0 } # [ doc = "Checks if the value of the field is `UCRXIFG_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg_1 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_1 } }
# [ doc = "Write proxy for field `UCRXIFG`" ] pub struct UCRXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG_A { # [ doc = "0: No interrupt pending" ] UCTXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG_1 = 1 } impl From < UCTXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG`" ] pub type UCTXIFG_R = crate :: R < bool , UCTXIFG_A > ; impl UCTXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG_A { match self . bits { false => UCTXIFG_A :: UCTXIFG_0 , true => UCTXIFG_A :: UCTXIFG_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG_0`" ] # [ inline ( always ) ] pub fn is_uctxifg_0 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_0 } # [ doc = "Checks if the value of the field is `UCTXIFG_1`" ] # [ inline ( always ) ] pub fn is_uctxifg_1 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_1 } }
# [ doc = "Write proxy for field `UCTXIFG`" ] pub struct UCTXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & self ) -> UCRXIFG_R { UCRXIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & self ) -> UCTXIFG_R { UCTXIFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & mut self ) -> UCRXIFG_W { UCRXIFG_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & mut self ) -> UCTXIFG_W { UCTXIFG_W { w : self } }
}
}
# [ doc = "eUSCI_Ax Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1iv](uca1iv) module" ] pub type UCA1IV = crate :: Reg < u16 , _UCA1IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1IV ;
# [ doc = "`read()` method returns [uca1iv::R](uca1iv::R) reader structure" ] impl crate :: Readable for UCA1IV { }
# [ doc = "eUSCI_Ax Interrupt Vector Register" ] pub mod uca1iv {
# [ doc = "Reader of register UCA1IV" ] pub type R = crate :: R < u16 , super :: UCA1IV > ;
# [ doc = "eUSCI_A interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum UCIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Receive buffer full; Interrupt Flag: UCRXIFG; Interrupt Priority: Highest" ] UCRXIFG = 2 , # [ doc = "4: Interrupt Source: Transmit buffer empty; Interrupt Flag: UCTXIFG" ] UCTXIFG = 4 , # [ doc = "6: Interrupt Source: Start bit received; Interrupt Flag: UCSTTIFG" ] UCSTTIFG = 6 , # [ doc = "8: Interrupt Source: Transmit complete; Interrupt Flag: UCTXCPTIFG; Interrupt Priority: Lowest" ] UCTXCPTIFG = 8 } impl From < UCIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : UCIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCIV`" ] pub type UCIV_R = crate :: R < u16 , UCIV_A > ; impl UCIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , UCIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( UCIV_A :: NONE ) , 2 => Val ( UCIV_A :: UCRXIFG ) , 4 => Val ( UCIV_A :: UCTXIFG ) , 6 => Val ( UCIV_A :: UCSTTIFG ) , 8 => Val ( UCIV_A :: UCTXCPTIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == UCIV_A :: NONE } # [ doc = "Checks if the value of the field is `UCRXIFG`" ] # [ inline ( always ) ] pub fn is_ucrxifg ( & self ) -> bool { * self == UCIV_A :: UCRXIFG } # [ doc = "Checks if the value of the field is `UCTXIFG`" ] # [ inline ( always ) ] pub fn is_uctxifg ( & self ) -> bool { * self == UCIV_A :: UCTXIFG } # [ doc = "Checks if the value of the field is `UCSTTIFG`" ] # [ inline ( always ) ] pub fn is_ucsttifg ( & self ) -> bool { * self == UCIV_A :: UCSTTIFG } # [ doc = "Checks if the value of the field is `UCTXCPTIFG`" ] # [ inline ( always ) ] pub fn is_uctxcptifg ( & self ) -> bool { * self == UCIV_A :: UCTXCPTIFG } }
impl R {
# [ doc = "Bits 0:15 - eUSCI_A interrupt vector value" ] # [ inline ( always ) ] pub fn uciv ( & self ) -> UCIV_R { UCIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
# [ doc = "eUSCI_Ax Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1iv_spi](uca1iv_spi) module" ] pub type UCA1IV_SPI = crate :: Reg < u16 , _UCA1IV_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCA1IV_SPI ;
# [ doc = "`read()` method returns [uca1iv_spi::R](uca1iv_spi::R) reader structure" ] impl crate :: Readable for UCA1IV_SPI { }
# [ doc = "eUSCI_Ax Interrupt Vector Register" ] pub mod uca1iv_spi {
# [ doc = "Reader of register UCA1IV_SPI" ] pub type R = crate :: R < u16 , super :: UCA1IV_SPI > ;
# [ doc = "eUSCI_A interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum UCIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Data received; Interrupt Flag: UCRXIFG; Interrupt Priority: Highest" ] UCRXIFG = 2 , # [ doc = "4: Interrupt Source: Transmit buffer empty; Interrupt Flag: UCTXIFG; Interrupt Priority: Lowest" ] UCTXIFG = 4 } impl From < UCIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : UCIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCIV`" ] pub type UCIV_R = crate :: R < u16 , UCIV_A > ; impl UCIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , UCIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( UCIV_A :: NONE ) , 2 => Val ( UCIV_A :: UCRXIFG ) , 4 => Val ( UCIV_A :: UCTXIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == UCIV_A :: NONE } # [ doc = "Checks if the value of the field is `UCRXIFG`" ] # [ inline ( always ) ] pub fn is_ucrxifg ( & self ) -> bool { * self == UCIV_A :: UCRXIFG } # [ doc = "Checks if the value of the field is `UCTXIFG`" ] # [ inline ( always ) ] pub fn is_uctxifg ( & self ) -> bool { * self == UCIV_A :: UCTXIFG } }
impl R {
# [ doc = "Bits 0:15 - eUSCI_A interrupt vector value" ] # [ inline ( always ) ] pub fn uciv ( & self ) -> UCIV_R { UCIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "eUSCI_B1" ] pub struct E_USCI_B1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for E_USCI_B1 { } impl E_USCI_B1 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const e_usci_b1 :: RegisterBlock { 0x05c0 as * const _ } } impl Deref for E_USCI_B1 { type Target = e_usci_b1 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * E_USCI_B1 :: ptr ( ) } } }
# [ doc = "eUSCI_B1" ] pub mod e_usci_b1 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved_0_ucb1ctlw : [ u8 ; 2usize ] , # [ doc = "0x02 - eUSCI_Bx Control Word Register 1" ] pub ucb1ctlw1 : UCB1CTLW1 , _reserved2 : [ u8 ; 2usize ] , _reserved_2_ucb1 : [ u8 ; 2usize ] , _reserved_3_ucb1 : [ u8 ; 2usize ] , # [ doc = "0x0a - eUSCI_Bx Byte Counter Threshold Register" ] pub ucb1tbcnt : UCB1TBCNT , _reserved_5_ucb1 : [ u8 ; 2usize ] , _reserved_6_ucb1 : [ u8 ; 2usize ] , _reserved7 : [ u8 ; 4usize ] , # [ doc = "0x14 - eUSCI_Bx I2C Own Address 0 Register" ] pub ucb1i2coa0 : UCB1I2COA0 , # [ doc = "0x16 - eUSCI_Bx I2C Own Address 1 Register" ] pub ucb1i2coa1 : UCB1I2COA1 , # [ doc = "0x18 - eUSCI_Bx I2C Own Address 2 Register" ] pub ucb1i2coa2 : UCB1I2COA2 , # [ doc = "0x1a - eUSCI_Bx I2C Own Address 3 Register" ] pub ucb1i2coa3 : UCB1I2COA3 , # [ doc = "0x1c - eUSCI_Bx I2C Received Address Register" ] pub ucb1addrx : UCB1ADDRX , # [ doc = "0x1e - eUSCI_Bx I2C Address Mask Register" ] pub ucb1addmask : UCB1ADDMASK , # [ doc = "0x20 - eUSCI_Bx I2C Slave Address Register" ] pub ucb1i2csa : UCB1I2CSA , _reserved14 : [ u8 ; 8usize ] , _reserved_14_ucb1 : [ u8 ; 2usize ] , _reserved_15_ucb1 : [ u8 ; 2usize ] , _reserved_16_ucb1 : [ u8 ; 2usize ] , } impl RegisterBlock { # [ doc = "0x00 - eUSCI_Bx Control Word Register 0" ] # [ inline ( always ) ] pub fn ucb1ctlw0_spi ( & self ) -> & UCB1CTLW0_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const UCB1CTLW0_SPI ) } } # [ doc = "0x00 - eUSCI_Bx Control Word Register 0" ] # [ inline ( always ) ] pub fn ucb1ctlw0_spi_mut ( & self ) -> & mut UCB1CTLW0_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut UCB1CTLW0_SPI ) } } # [ doc = "0x00 - eUSCI_Bx Control Word Register 0" ] # [ inline ( always ) ] pub fn ucb1ctlw0 ( & self ) -> & UCB1CTLW0 { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const UCB1CTLW0 ) } } # [ doc = "0x00 - eUSCI_Bx Control Word Register 0" ] # [ inline ( always ) ] pub fn ucb1ctlw0_mut ( & self ) -> & mut UCB1CTLW0 { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut UCB1CTLW0 ) } } # [ doc = "0x06 - eUSCI_Bx Bit Rate Control Register 1" ] # [ inline ( always ) ] pub fn ucb1brw_spi ( & self ) -> & UCB1BRW_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 6usize ) as * const UCB1BRW_SPI ) } } # [ doc = "0x06 - eUSCI_Bx Bit Rate Control Register 1" ] # [ inline ( always ) ] pub fn ucb1brw_spi_mut ( & self ) -> & mut UCB1BRW_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 6usize ) as * mut UCB1BRW_SPI ) } } # [ doc = "0x06 - eUSCI_Bx Baud Rate Control Word Register" ] # [ inline ( always ) ] pub fn ucb1brw ( & self ) -> & UCB1BRW { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 6usize ) as * const UCB1BRW ) } } # [ doc = "0x06 - eUSCI_Bx Baud Rate Control Word Register" ] # [ inline ( always ) ] pub fn ucb1brw_mut ( & self ) -> & mut UCB1BRW { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 6usize ) as * mut UCB1BRW ) } } # [ doc = "0x08 - UCB1STATW_SPI" ] # [ inline ( always ) ] pub fn ucb1statw_spi ( & self ) -> & UCB1STATW_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 8usize ) as * const UCB1STATW_SPI ) } } # [ doc = "0x08 - UCB1STATW_SPI" ] # [ inline ( always ) ] pub fn ucb1statw_spi_mut ( & self ) -> & mut UCB1STATW_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 8usize ) as * mut UCB1STATW_SPI ) } } # [ doc = "0x08 - eUSCI_Bx Status Register" ] # [ inline ( always ) ] pub fn ucb1statw ( & self ) -> & UCB1STATW { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 8usize ) as * const UCB1STATW ) } } # [ doc = "0x08 - eUSCI_Bx Status Register" ] # [ inline ( always ) ] pub fn ucb1statw_mut ( & self ) -> & mut UCB1STATW { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 8usize ) as * mut UCB1STATW ) } } # [ doc = "0x0c - eUSCI_Bx Receive Buffer Register" ] # [ inline ( always ) ] pub fn ucb1rxbuf_spi ( & self ) -> & UCB1RXBUF_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const UCB1RXBUF_SPI ) } } # [ doc = "0x0c - eUSCI_Bx Receive Buffer Register" ] # [ inline ( always ) ] pub fn ucb1rxbuf_spi_mut ( & self ) -> & mut UCB1RXBUF_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut UCB1RXBUF_SPI ) } } # [ doc = "0x0c - eUSCI_Bx Receive Buffer Register" ] # [ inline ( always ) ] pub fn ucb1rxbuf ( & self ) -> & UCB1RXBUF { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const UCB1RXBUF ) } } # [ doc = "0x0c - eUSCI_Bx Receive Buffer Register" ] # [ inline ( always ) ] pub fn ucb1rxbuf_mut ( & self ) -> & mut UCB1RXBUF { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut UCB1RXBUF ) } } # [ doc = "0x0e - eUSCI_Bx Transmit Buffer Register" ] # [ inline ( always ) ] pub fn ucb1txbuf_spi ( & self ) -> & UCB1TXBUF_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 14usize ) as * const UCB1TXBUF_SPI ) } } # [ doc = "0x0e - eUSCI_Bx Transmit Buffer Register" ] # [ inline ( always ) ] pub fn ucb1txbuf_spi_mut ( & self ) -> & mut UCB1TXBUF_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 14usize ) as * mut UCB1TXBUF_SPI ) } } # [ doc = "0x0e - eUSCI_Bx Transmit Buffer Register" ] # [ inline ( always ) ] pub fn ucb1txbuf ( & self ) -> & UCB1TXBUF { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 14usize ) as * const UCB1TXBUF ) } } # [ doc = "0x0e - eUSCI_Bx Transmit Buffer Register" ] # [ inline ( always ) ] pub fn ucb1txbuf_mut ( & self ) -> & mut UCB1TXBUF { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 14usize ) as * mut UCB1TXBUF ) } } # [ doc = "0x2a - eUSCI_Bx Interrupt Enable Register" ] # [ inline ( always ) ] pub fn ucb1ie_spi ( & self ) -> & UCB1IE_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 42usize ) as * const UCB1IE_SPI ) } } # [ doc = "0x2a - eUSCI_Bx Interrupt Enable Register" ] # [ inline ( always ) ] pub fn ucb1ie_spi_mut ( & self ) -> & mut UCB1IE_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 42usize ) as * mut UCB1IE_SPI ) } } # [ doc = "0x2a - eUSCI_Bx Interrupt Enable Register" ] # [ inline ( always ) ] pub fn ucb1ie ( & self ) -> & UCB1IE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 42usize ) as * const UCB1IE ) } } # [ doc = "0x2a - eUSCI_Bx Interrupt Enable Register" ] # [ inline ( always ) ] pub fn ucb1ie_mut ( & self ) -> & mut UCB1IE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 42usize ) as * mut UCB1IE ) } } # [ doc = "0x2c - eUSCI_Bx Interrupt Flag Register" ] # [ inline ( always ) ] pub fn ucb1ifg_spi ( & self ) -> & UCB1IFG_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 44usize ) as * const UCB1IFG_SPI ) } } # [ doc = "0x2c - eUSCI_Bx Interrupt Flag Register" ] # [ inline ( always ) ] pub fn ucb1ifg_spi_mut ( & self ) -> & mut UCB1IFG_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 44usize ) as * mut UCB1IFG_SPI ) } } # [ doc = "0x2c - eUSCI_Bx Interrupt Flag Register" ] # [ inline ( always ) ] pub fn ucb1ifg ( & self ) -> & UCB1IFG { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 44usize ) as * const UCB1IFG ) } } # [ doc = "0x2c - eUSCI_Bx Interrupt Flag Register" ] # [ inline ( always ) ] pub fn ucb1ifg_mut ( & self ) -> & mut UCB1IFG { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 44usize ) as * mut UCB1IFG ) } } # [ doc = "0x2e - eUSCI_Bx Interrupt Vector Register" ] # [ inline ( always ) ] pub fn ucb1iv_spi ( & self ) -> & UCB1IV_SPI { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 46usize ) as * const UCB1IV_SPI ) } } # [ doc = "0x2e - eUSCI_Bx Interrupt Vector Register" ] # [ inline ( always ) ] pub fn ucb1iv_spi_mut ( & self ) -> & mut UCB1IV_SPI { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 46usize ) as * mut UCB1IV_SPI ) } } # [ doc = "0x2e - eUSCI_Bx Interrupt Vector Register" ] # [ inline ( always ) ] pub fn ucb1iv ( & self ) -> & UCB1IV { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 46usize ) as * const UCB1IV ) } } # [ doc = "0x2e - eUSCI_Bx Interrupt Vector Register" ] # [ inline ( always ) ] pub fn ucb1iv_mut ( & self ) -> & mut UCB1IV { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 46usize ) as * mut UCB1IV ) } } }
# [ doc = "eUSCI_Bx Control Word Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1ctlw0](ucb1ctlw0) module" ] pub type UCB1CTLW0 = crate :: Reg < u16 , _UCB1CTLW0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1CTLW0 ;
# [ doc = "`read()` method returns [ucb1ctlw0::R](ucb1ctlw0::R) reader structure" ] impl crate :: Readable for UCB1CTLW0 { }
# [ doc = "`write(|w| ..)` method takes [ucb1ctlw0::W](ucb1ctlw0::W) writer structure" ] impl crate :: Writable for UCB1CTLW0 { }
# [ doc = "eUSCI_Bx Control Word Register 0" ] pub mod ucb1ctlw0 {
# [ doc = "Reader of register UCB1CTLW0" ] pub type R = crate :: R < u16 , super :: UCB1CTLW0 > ;
# [ doc = "Writer for register UCB1CTLW0" ] pub type W = crate :: W < u16 , super :: UCB1CTLW0 > ;
# [ doc = "Register UCB1CTLW0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1CTLW0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Software reset enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSWRST_A { # [ doc = "0: Disabled. eUSCI_B reset released for operation" ] DISABLE = 0 , # [ doc = "1: Enabled. eUSCI_B logic held in reset state" ] ENABLE = 1 } impl From < UCSWRST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSWRST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSWRST`" ] pub type UCSWRST_R = crate :: R < bool , UCSWRST_A > ; impl UCSWRST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSWRST_A { match self . bits { false => UCSWRST_A :: DISABLE , true => UCSWRST_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCSWRST_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCSWRST_A :: ENABLE } }
# [ doc = "Write proxy for field `UCSWRST`" ] pub struct UCSWRST_W < 'a > { w : & 'a mut W , } impl < 'a > UCSWRST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSWRST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled. eUSCI_B reset released for operation" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: DISABLE ) } # [ doc = "Enabled. eUSCI_B logic held in reset state" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit START condition in master mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXSTT_A { # [ doc = "0: Do not generate START condition" ] UCTXSTT_0 = 0 , # [ doc = "1: Generate START condition" ] UCTXSTT_1 = 1 } impl From < UCTXSTT_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXSTT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXSTT`" ] pub type UCTXSTT_R = crate :: R < bool , UCTXSTT_A > ; impl UCTXSTT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXSTT_A { match self . bits { false => UCTXSTT_A :: UCTXSTT_0 , true => UCTXSTT_A :: UCTXSTT_1 } } # [ doc = "Checks if the value of the field is `UCTXSTT_0`" ] # [ inline ( always ) ] pub fn is_uctxstt_0 ( & self ) -> bool { * self == UCTXSTT_A :: UCTXSTT_0 } # [ doc = "Checks if the value of the field is `UCTXSTT_1`" ] # [ inline ( always ) ] pub fn is_uctxstt_1 ( & self ) -> bool { * self == UCTXSTT_A :: UCTXSTT_1 } }
# [ doc = "Write proxy for field `UCTXSTT`" ] pub struct UCTXSTT_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXSTT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXSTT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Do not generate START condition" ] # [ inline ( always ) ] pub fn uctxstt_0 ( self ) -> & 'a mut W { self . variant ( UCTXSTT_A :: UCTXSTT_0 ) } # [ doc = "Generate START condition" ] # [ inline ( always ) ] pub fn uctxstt_1 ( self ) -> & 'a mut W { self . variant ( UCTXSTT_A :: UCTXSTT_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Transmit STOP condition in master mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXSTP_A { # [ doc = "0: No STOP generated" ] UCTXSTP_0 = 0 , # [ doc = "1: Generate STOP" ] UCTXSTP_1 = 1 } impl From < UCTXSTP_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXSTP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXSTP`" ] pub type UCTXSTP_R = crate :: R < bool , UCTXSTP_A > ; impl UCTXSTP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXSTP_A { match self . bits { false => UCTXSTP_A :: UCTXSTP_0 , true => UCTXSTP_A :: UCTXSTP_1 } } # [ doc = "Checks if the value of the field is `UCTXSTP_0`" ] # [ inline ( always ) ] pub fn is_uctxstp_0 ( & self ) -> bool { * self == UCTXSTP_A :: UCTXSTP_0 } # [ doc = "Checks if the value of the field is `UCTXSTP_1`" ] # [ inline ( always ) ] pub fn is_uctxstp_1 ( & self ) -> bool { * self == UCTXSTP_A :: UCTXSTP_1 } }
# [ doc = "Write proxy for field `UCTXSTP`" ] pub struct UCTXSTP_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXSTP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXSTP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No STOP generated" ] # [ inline ( always ) ] pub fn uctxstp_0 ( self ) -> & 'a mut W { self . variant ( UCTXSTP_A :: UCTXSTP_0 ) } # [ doc = "Generate STOP" ] # [ inline ( always ) ] pub fn uctxstp_1 ( self ) -> & 'a mut W { self . variant ( UCTXSTP_A :: UCTXSTP_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Transmit a NACK\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXNACK_A { # [ doc = "0: Acknowledge normally" ] UCTXNACK_0 = 0 , # [ doc = "1: Generate NACK" ] UCTXNACK_1 = 1 } impl From < UCTXNACK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXNACK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXNACK`" ] pub type UCTXNACK_R = crate :: R < bool , UCTXNACK_A > ; impl UCTXNACK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXNACK_A { match self . bits { false => UCTXNACK_A :: UCTXNACK_0 , true => UCTXNACK_A :: UCTXNACK_1 } } # [ doc = "Checks if the value of the field is `UCTXNACK_0`" ] # [ inline ( always ) ] pub fn is_uctxnack_0 ( & self ) -> bool { * self == UCTXNACK_A :: UCTXNACK_0 } # [ doc = "Checks if the value of the field is `UCTXNACK_1`" ] # [ inline ( always ) ] pub fn is_uctxnack_1 ( & self ) -> bool { * self == UCTXNACK_A :: UCTXNACK_1 } }
# [ doc = "Write proxy for field `UCTXNACK`" ] pub struct UCTXNACK_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXNACK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXNACK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Acknowledge normally" ] # [ inline ( always ) ] pub fn uctxnack_0 ( self ) -> & 'a mut W { self . variant ( UCTXNACK_A :: UCTXNACK_0 ) } # [ doc = "Generate NACK" ] # [ inline ( always ) ] pub fn uctxnack_1 ( self ) -> & 'a mut W { self . variant ( UCTXNACK_A :: UCTXNACK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Transmitter/receiver\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTR_A { # [ doc = "0: Receiver" ] RX = 0 , # [ doc = "1: Transmitter" ] TX = 1 } impl From < UCTR_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTR_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTR`" ] pub type UCTR_R = crate :: R < bool , UCTR_A > ; impl UCTR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTR_A { match self . bits { false => UCTR_A :: RX , true => UCTR_A :: TX } } # [ doc = "Checks if the value of the field is `RX`" ] # [ inline ( always ) ] pub fn is_rx ( & self ) -> bool { * self == UCTR_A :: RX } # [ doc = "Checks if the value of the field is `TX`" ] # [ inline ( always ) ] pub fn is_tx ( & self ) -> bool { * self == UCTR_A :: TX } }
# [ doc = "Write proxy for field `UCTR`" ] pub struct UCTR_W < 'a > { w : & 'a mut W , } impl < 'a > UCTR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTR_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Receiver" ] # [ inline ( always ) ] pub fn rx ( self ) -> & 'a mut W { self . variant ( UCTR_A :: RX ) } # [ doc = "Transmitter" ] # [ inline ( always ) ] pub fn tx ( self ) -> & 'a mut W { self . variant ( UCTR_A :: TX ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Transmit ACK condition in slave mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXACK_A { # [ doc = "0: Do not acknowledge the slave address" ] UCTXACK_0 = 0 , # [ doc = "1: Acknowledge the slave address" ] UCTXACK_1 = 1 } impl From < UCTXACK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXACK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXACK`" ] pub type UCTXACK_R = crate :: R < bool , UCTXACK_A > ; impl UCTXACK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXACK_A { match self . bits { false => UCTXACK_A :: UCTXACK_0 , true => UCTXACK_A :: UCTXACK_1 } } # [ doc = "Checks if the value of the field is `UCTXACK_0`" ] # [ inline ( always ) ] pub fn is_uctxack_0 ( & self ) -> bool { * self == UCTXACK_A :: UCTXACK_0 } # [ doc = "Checks if the value of the field is `UCTXACK_1`" ] # [ inline ( always ) ] pub fn is_uctxack_1 ( & self ) -> bool { * self == UCTXACK_A :: UCTXACK_1 } }
# [ doc = "Write proxy for field `UCTXACK`" ] pub struct UCTXACK_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXACK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXACK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Do not acknowledge the slave address" ] # [ inline ( always ) ] pub fn uctxack_0 ( self ) -> & 'a mut W { self . variant ( UCTXACK_A :: UCTXACK_0 ) } # [ doc = "Acknowledge the slave address" ] # [ inline ( always ) ] pub fn uctxack_1 ( self ) -> & 'a mut W { self . variant ( UCTXACK_A :: UCTXACK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "eUSCI_B clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCSSEL_A { # [ doc = "0: UCLKI" ] UCLKI = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: SMCLK" ] UCSSEL_3 = 3 } impl From < UCSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCSSEL`" ] pub type UCSSEL_R = crate :: R < u8 , UCSSEL_A > ; impl UCSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSSEL_A { match self . bits { 0 => UCSSEL_A :: UCLKI , 1 => UCSSEL_A :: ACLK , 2 => UCSSEL_A :: SMCLK , 3 => UCSSEL_A :: UCSSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCLKI`" ] # [ inline ( always ) ] pub fn is_uclki ( & self ) -> bool { * self == UCSSEL_A :: UCLKI } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == UCSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == UCSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `UCSSEL_3`" ] # [ inline ( always ) ] pub fn is_ucssel_3 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_3 } }
# [ doc = "Write proxy for field `UCSSEL`" ] pub struct UCSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > UCSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "UCLKI" ] # [ inline ( always ) ] pub fn uclki ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCLKI ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: SMCLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn ucssel_3 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Synchronous mode enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSYNC_A { # [ doc = "0: Asynchronous mode" ] ASYNC = 0 , # [ doc = "1: Synchronous mode" ] SYNC = 1 } impl From < UCSYNC_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSYNC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSYNC`" ] pub type UCSYNC_R = crate :: R < bool , UCSYNC_A > ; impl UCSYNC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSYNC_A { match self . bits { false => UCSYNC_A :: ASYNC , true => UCSYNC_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == UCSYNC_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == UCSYNC_A :: SYNC } }
# [ doc = "Write proxy for field `UCSYNC`" ] pub struct UCSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > UCSYNC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSYNC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous mode" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: ASYNC ) } # [ doc = "Synchronous mode" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "eUSCI_B mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCMODE_A { # [ doc = "0: 3-pin SPI" ] UCMODE_0 = 0 , # [ doc = "1: 4-pin SPI (master or slave enabled if STE = 1)" ] UCMODE_1 = 1 , # [ doc = "2: 4-pin SPI (master or slave enabled if STE = 0)" ] UCMODE_2 = 2 , # [ doc = "3: I2C mode" ] UCMODE_3 = 3 } impl From < UCMODE_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCMODE_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCMODE`" ] pub type UCMODE_R = crate :: R < u8 , UCMODE_A > ; impl UCMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMODE_A { match self . bits { 0 => UCMODE_A :: UCMODE_0 , 1 => UCMODE_A :: UCMODE_1 , 2 => UCMODE_A :: UCMODE_2 , 3 => UCMODE_A :: UCMODE_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCMODE_0`" ] # [ inline ( always ) ] pub fn is_ucmode_0 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_0 } # [ doc = "Checks if the value of the field is `UCMODE_1`" ] # [ inline ( always ) ] pub fn is_ucmode_1 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_1 } # [ doc = "Checks if the value of the field is `UCMODE_2`" ] # [ inline ( always ) ] pub fn is_ucmode_2 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_2 } # [ doc = "Checks if the value of the field is `UCMODE_3`" ] # [ inline ( always ) ] pub fn is_ucmode_3 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_3 } }
# [ doc = "Write proxy for field `UCMODE`" ] pub struct UCMODE_W < 'a > { w : & 'a mut W , } impl < 'a > UCMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMODE_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "3-pin SPI" ] # [ inline ( always ) ] pub fn ucmode_0 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_0 ) } # [ doc = "4-pin SPI (master or slave enabled if STE = 1)" ] # [ inline ( always ) ] pub fn ucmode_1 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_1 ) } # [ doc = "4-pin SPI (master or slave enabled if STE = 0)" ] # [ inline ( always ) ] pub fn ucmode_2 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_2 ) } # [ doc = "I2C mode" ] # [ inline ( always ) ] pub fn ucmode_3 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Master mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMST_A { # [ doc = "0: Slave mode" ] SLAVE = 0 , # [ doc = "1: Master mode" ] MASTER = 1 } impl From < UCMST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMST`" ] pub type UCMST_R = crate :: R < bool , UCMST_A > ; impl UCMST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMST_A { match self . bits { false => UCMST_A :: SLAVE , true => UCMST_A :: MASTER } } # [ doc = "Checks if the value of the field is `SLAVE`" ] # [ inline ( always ) ] pub fn is_slave ( & self ) -> bool { * self == UCMST_A :: SLAVE } # [ doc = "Checks if the value of the field is `MASTER`" ] # [ inline ( always ) ] pub fn is_master ( & self ) -> bool { * self == UCMST_A :: MASTER } }
# [ doc = "Write proxy for field `UCMST`" ] pub struct UCMST_W < 'a > { w : & 'a mut W , } impl < 'a > UCMST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Slave mode" ] # [ inline ( always ) ] pub fn slave ( self ) -> & 'a mut W { self . variant ( UCMST_A :: SLAVE ) } # [ doc = "Master mode" ] # [ inline ( always ) ] pub fn master ( self ) -> & 'a mut W { self . variant ( UCMST_A :: MASTER ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Multi-master environment select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMM_A { # [ doc = "0: Single master environment. There is no other master in the system. The address compare unit is disabled." ] SINGLE = 0 , # [ doc = "1: Multi-master environment" ] MULTI = 1 } impl From < UCMM_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMM`" ] pub type UCMM_R = crate :: R < bool , UCMM_A > ; impl UCMM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMM_A { match self . bits { false => UCMM_A :: SINGLE , true => UCMM_A :: MULTI } } # [ doc = "Checks if the value of the field is `SINGLE`" ] # [ inline ( always ) ] pub fn is_single ( & self ) -> bool { * self == UCMM_A :: SINGLE } # [ doc = "Checks if the value of the field is `MULTI`" ] # [ inline ( always ) ] pub fn is_multi ( & self ) -> bool { * self == UCMM_A :: MULTI } }
# [ doc = "Write proxy for field `UCMM`" ] pub struct UCMM_W < 'a > { w : & 'a mut W , } impl < 'a > UCMM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Single master environment. There is no other master in the system. The address compare unit is disabled." ] # [ inline ( always ) ] pub fn single ( self ) -> & 'a mut W { self . variant ( UCMM_A :: SINGLE ) } # [ doc = "Multi-master environment" ] # [ inline ( always ) ] pub fn multi ( self ) -> & 'a mut W { self . variant ( UCMM_A :: MULTI ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Slave addressing mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSLA10_A { # [ doc = "0: Address slave with 7-bit address" ] _7BIT = 0 , # [ doc = "1: Address slave with 10-bit address" ] _10BIT = 1 } impl From < UCSLA10_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSLA10_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSLA10`" ] pub type UCSLA10_R = crate :: R < bool , UCSLA10_A > ; impl UCSLA10_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSLA10_A { match self . bits { false => UCSLA10_A :: _7BIT , true => UCSLA10_A :: _10BIT } } # [ doc = "Checks if the value of the field is `_7BIT`" ] # [ inline ( always ) ] pub fn is_7bit ( & self ) -> bool { * self == UCSLA10_A :: _7BIT } # [ doc = "Checks if the value of the field is `_10BIT`" ] # [ inline ( always ) ] pub fn is_10bit ( & self ) -> bool { * self == UCSLA10_A :: _10BIT } }
# [ doc = "Write proxy for field `UCSLA10`" ] pub struct UCSLA10_W < 'a > { w : & 'a mut W , } impl < 'a > UCSLA10_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSLA10_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Address slave with 7-bit address" ] # [ inline ( always ) ] pub fn _7bit ( self ) -> & 'a mut W { self . variant ( UCSLA10_A :: _7BIT ) } # [ doc = "Address slave with 10-bit address" ] # [ inline ( always ) ] pub fn _10bit ( self ) -> & 'a mut W { self . variant ( UCSLA10_A :: _10BIT ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Own addressing mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCA10_A { # [ doc = "0: Own address is a 7-bit address" ] UCA10_0 = 0 , # [ doc = "1: Own address is a 10-bit address" ] UCA10_1 = 1 } impl From < UCA10_A > for bool { # [ inline ( always ) ] fn from ( variant : UCA10_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCA10`" ] pub type UCA10_R = crate :: R < bool , UCA10_A > ; impl UCA10_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCA10_A { match self . bits { false => UCA10_A :: UCA10_0 , true => UCA10_A :: UCA10_1 } } # [ doc = "Checks if the value of the field is `UCA10_0`" ] # [ inline ( always ) ] pub fn is_uca10_0 ( & self ) -> bool { * self == UCA10_A :: UCA10_0 } # [ doc = "Checks if the value of the field is `UCA10_1`" ] # [ inline ( always ) ] pub fn is_uca10_1 ( & self ) -> bool { * self == UCA10_A :: UCA10_1 } }
# [ doc = "Write proxy for field `UCA10`" ] pub struct UCA10_W < 'a > { w : & 'a mut W , } impl < 'a > UCA10_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCA10_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Own address is a 7-bit address" ] # [ inline ( always ) ] pub fn uca10_0 ( self ) -> & 'a mut W { self . variant ( UCA10_A :: UCA10_0 ) } # [ doc = "Own address is a 10-bit address" ] # [ inline ( always ) ] pub fn uca10_1 ( self ) -> & 'a mut W { self . variant ( UCA10_A :: UCA10_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & self ) -> UCSWRST_R { UCSWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit START condition in master mode" ] # [ inline ( always ) ] pub fn uctxstt ( & self ) -> UCTXSTT_R { UCTXSTT_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Transmit STOP condition in master mode" ] # [ inline ( always ) ] pub fn uctxstp ( & self ) -> UCTXSTP_R { UCTXSTP_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Transmit a NACK" ] # [ inline ( always ) ] pub fn uctxnack ( & self ) -> UCTXNACK_R { UCTXNACK_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Transmitter/receiver" ] # [ inline ( always ) ] pub fn uctr ( & self ) -> UCTR_R { UCTR_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Transmit ACK condition in slave mode" ] # [ inline ( always ) ] pub fn uctxack ( & self ) -> UCTXACK_R { UCTXACK_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - eUSCI_B clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & self ) -> UCSSEL_R { UCSSEL_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & self ) -> UCSYNC_R { UCSYNC_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - eUSCI_B mode" ] # [ inline ( always ) ] pub fn ucmode ( & self ) -> UCMODE_R { UCMODE_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & self ) -> UCMST_R { UCMST_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Multi-master environment select" ] # [ inline ( always ) ] pub fn ucmm ( & self ) -> UCMM_R { UCMM_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Slave addressing mode select" ] # [ inline ( always ) ] pub fn ucsla10 ( & self ) -> UCSLA10_R { UCSLA10_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Own addressing mode select" ] # [ inline ( always ) ] pub fn uca10 ( & self ) -> UCA10_R { UCA10_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & mut self ) -> UCSWRST_W { UCSWRST_W { w : self } }
# [ doc = "Bit 1 - Transmit START condition in master mode" ] # [ inline ( always ) ] pub fn uctxstt ( & mut self ) -> UCTXSTT_W { UCTXSTT_W { w : self } }
# [ doc = "Bit 2 - Transmit STOP condition in master mode" ] # [ inline ( always ) ] pub fn uctxstp ( & mut self ) -> UCTXSTP_W { UCTXSTP_W { w : self } }
# [ doc = "Bit 3 - Transmit a NACK" ] # [ inline ( always ) ] pub fn uctxnack ( & mut self ) -> UCTXNACK_W { UCTXNACK_W { w : self } }
# [ doc = "Bit 4 - Transmitter/receiver" ] # [ inline ( always ) ] pub fn uctr ( & mut self ) -> UCTR_W { UCTR_W { w : self } }
# [ doc = "Bit 5 - Transmit ACK condition in slave mode" ] # [ inline ( always ) ] pub fn uctxack ( & mut self ) -> UCTXACK_W { UCTXACK_W { w : self } }
# [ doc = "Bits 6:7 - eUSCI_B clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & mut self ) -> UCSSEL_W { UCSSEL_W { w : self } }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & mut self ) -> UCSYNC_W { UCSYNC_W { w : self } }
# [ doc = "Bits 9:10 - eUSCI_B mode" ] # [ inline ( always ) ] pub fn ucmode ( & mut self ) -> UCMODE_W { UCMODE_W { w : self } }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & mut self ) -> UCMST_W { UCMST_W { w : self } }
# [ doc = "Bit 13 - Multi-master environment select" ] # [ inline ( always ) ] pub fn ucmm ( & mut self ) -> UCMM_W { UCMM_W { w : self } }
# [ doc = "Bit 14 - Slave addressing mode select" ] # [ inline ( always ) ] pub fn ucsla10 ( & mut self ) -> UCSLA10_W { UCSLA10_W { w : self } }
# [ doc = "Bit 15 - Own addressing mode select" ] # [ inline ( always ) ] pub fn uca10 ( & mut self ) -> UCA10_W { UCA10_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Control Word Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1ctlw0_spi](ucb1ctlw0_spi) module" ] pub type UCB1CTLW0_SPI = crate :: Reg < u16 , _UCB1CTLW0_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1CTLW0_SPI ;
# [ doc = "`read()` method returns [ucb1ctlw0_spi::R](ucb1ctlw0_spi::R) reader structure" ] impl crate :: Readable for UCB1CTLW0_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb1ctlw0_spi::W](ucb1ctlw0_spi::W) writer structure" ] impl crate :: Writable for UCB1CTLW0_SPI { }
# [ doc = "eUSCI_Bx Control Word Register 0" ] pub mod ucb1ctlw0_spi {
# [ doc = "Reader of register UCB1CTLW0_SPI" ] pub type R = crate :: R < u16 , super :: UCB1CTLW0_SPI > ;
# [ doc = "Writer for register UCB1CTLW0_SPI" ] pub type W = crate :: W < u16 , super :: UCB1CTLW0_SPI > ;
# [ doc = "Register UCB1CTLW0_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1CTLW0_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Software reset enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSWRST_A { # [ doc = "0: Disabled. eUSCI_B reset released for operation" ] DISABLE = 0 , # [ doc = "1: Enabled. eUSCI_B logic held in reset state" ] ENABLE = 1 } impl From < UCSWRST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSWRST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSWRST`" ] pub type UCSWRST_R = crate :: R < bool , UCSWRST_A > ; impl UCSWRST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSWRST_A { match self . bits { false => UCSWRST_A :: DISABLE , true => UCSWRST_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCSWRST_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCSWRST_A :: ENABLE } }
# [ doc = "Write proxy for field `UCSWRST`" ] pub struct UCSWRST_W < 'a > { w : & 'a mut W , } impl < 'a > UCSWRST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSWRST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled. eUSCI_B reset released for operation" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: DISABLE ) } # [ doc = "Enabled. eUSCI_B logic held in reset state" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCSWRST_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "STE mode select in master mode.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTEM_A { # [ doc = "0: STE pin is used to prevent conflicts with other masters" ] UCSTEM_0 = 0 , # [ doc = "1: STE pin is used to generate the enable signal for a 4-wire slave" ] UCSTEM_1 = 1 } impl From < UCSTEM_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTEM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTEM`" ] pub type UCSTEM_R = crate :: R < bool , UCSTEM_A > ; impl UCSTEM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTEM_A { match self . bits { false => UCSTEM_A :: UCSTEM_0 , true => UCSTEM_A :: UCSTEM_1 } } # [ doc = "Checks if the value of the field is `UCSTEM_0`" ] # [ inline ( always ) ] pub fn is_ucstem_0 ( & self ) -> bool { * self == UCSTEM_A :: UCSTEM_0 } # [ doc = "Checks if the value of the field is `UCSTEM_1`" ] # [ inline ( always ) ] pub fn is_ucstem_1 ( & self ) -> bool { * self == UCSTEM_A :: UCSTEM_1 } }
# [ doc = "Write proxy for field `UCSTEM`" ] pub struct UCSTEM_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTEM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTEM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "STE pin is used to prevent conflicts with other masters" ] # [ inline ( always ) ] pub fn ucstem_0 ( self ) -> & 'a mut W { self . variant ( UCSTEM_A :: UCSTEM_0 ) } # [ doc = "STE pin is used to generate the enable signal for a 4-wire slave" ] # [ inline ( always ) ] pub fn ucstem_1 ( self ) -> & 'a mut W { self . variant ( UCSTEM_A :: UCSTEM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "eUSCI_B clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCSSEL_A { # [ doc = "0: Reserved" ] UCSSEL_0 = 0 , # [ doc = "1: ACLK" ] ACLK = 1 , # [ doc = "2: SMCLK" ] SMCLK = 2 , # [ doc = "3: SMCLK" ] UCSSEL_3 = 3 } impl From < UCSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCSSEL`" ] pub type UCSSEL_R = crate :: R < u8 , UCSSEL_A > ; impl UCSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSSEL_A { match self . bits { 0 => UCSSEL_A :: UCSSEL_0 , 1 => UCSSEL_A :: ACLK , 2 => UCSSEL_A :: SMCLK , 3 => UCSSEL_A :: UCSSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCSSEL_0`" ] # [ inline ( always ) ] pub fn is_ucssel_0 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_0 } # [ doc = "Checks if the value of the field is `ACLK`" ] # [ inline ( always ) ] pub fn is_aclk ( & self ) -> bool { * self == UCSSEL_A :: ACLK } # [ doc = "Checks if the value of the field is `SMCLK`" ] # [ inline ( always ) ] pub fn is_smclk ( & self ) -> bool { * self == UCSSEL_A :: SMCLK } # [ doc = "Checks if the value of the field is `UCSSEL_3`" ] # [ inline ( always ) ] pub fn is_ucssel_3 ( & self ) -> bool { * self == UCSSEL_A :: UCSSEL_3 } }
# [ doc = "Write proxy for field `UCSSEL`" ] pub struct UCSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > UCSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn ucssel_0 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_0 ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn aclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: ACLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn smclk ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: SMCLK ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn ucssel_3 ( self ) -> & 'a mut W { self . variant ( UCSSEL_A :: UCSSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Synchronous mode enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSYNC_A { # [ doc = "0: Asynchronous mode" ] ASYNC = 0 , # [ doc = "1: Synchronous mode" ] SYNC = 1 } impl From < UCSYNC_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSYNC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSYNC`" ] pub type UCSYNC_R = crate :: R < bool , UCSYNC_A > ; impl UCSYNC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSYNC_A { match self . bits { false => UCSYNC_A :: ASYNC , true => UCSYNC_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == UCSYNC_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == UCSYNC_A :: SYNC } }
# [ doc = "Write proxy for field `UCSYNC`" ] pub struct UCSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > UCSYNC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSYNC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Asynchronous mode" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: ASYNC ) } # [ doc = "Synchronous mode" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( UCSYNC_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "eUSCI mode\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCMODE_A { # [ doc = "0: 3-pin SPI" ] UCMODE_0 = 0 , # [ doc = "1: 4-pin SPI with UCxSTE active high: Slave enabled when UCxSTE = 1" ] UCMODE_1 = 1 , # [ doc = "2: 4-pin SPI with UCxSTE active low: Slave enabled when UCxSTE = 0" ] UCMODE_2 = 2 , # [ doc = "3: I2C mode" ] UCMODE_3 = 3 } impl From < UCMODE_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCMODE_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCMODE`" ] pub type UCMODE_R = crate :: R < u8 , UCMODE_A > ; impl UCMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMODE_A { match self . bits { 0 => UCMODE_A :: UCMODE_0 , 1 => UCMODE_A :: UCMODE_1 , 2 => UCMODE_A :: UCMODE_2 , 3 => UCMODE_A :: UCMODE_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCMODE_0`" ] # [ inline ( always ) ] pub fn is_ucmode_0 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_0 } # [ doc = "Checks if the value of the field is `UCMODE_1`" ] # [ inline ( always ) ] pub fn is_ucmode_1 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_1 } # [ doc = "Checks if the value of the field is `UCMODE_2`" ] # [ inline ( always ) ] pub fn is_ucmode_2 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_2 } # [ doc = "Checks if the value of the field is `UCMODE_3`" ] # [ inline ( always ) ] pub fn is_ucmode_3 ( & self ) -> bool { * self == UCMODE_A :: UCMODE_3 } }
# [ doc = "Write proxy for field `UCMODE`" ] pub struct UCMODE_W < 'a > { w : & 'a mut W , } impl < 'a > UCMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMODE_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "3-pin SPI" ] # [ inline ( always ) ] pub fn ucmode_0 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_0 ) } # [ doc = "4-pin SPI with UCxSTE active high: Slave enabled when UCxSTE = 1" ] # [ inline ( always ) ] pub fn ucmode_1 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_1 ) } # [ doc = "4-pin SPI with UCxSTE active low: Slave enabled when UCxSTE = 0" ] # [ inline ( always ) ] pub fn ucmode_2 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_2 ) } # [ doc = "I2C mode" ] # [ inline ( always ) ] pub fn ucmode_3 ( self ) -> & 'a mut W { self . variant ( UCMODE_A :: UCMODE_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 9 ) ) | ( ( ( value as u16 ) & 0x03 ) << 9 ) ; self . w } }
# [ doc = "Master mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMST_A { # [ doc = "0: Slave mode" ] SLAVE = 0 , # [ doc = "1: Master mode" ] MASTER = 1 } impl From < UCMST_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMST_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMST`" ] pub type UCMST_R = crate :: R < bool , UCMST_A > ; impl UCMST_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMST_A { match self . bits { false => UCMST_A :: SLAVE , true => UCMST_A :: MASTER } } # [ doc = "Checks if the value of the field is `SLAVE`" ] # [ inline ( always ) ] pub fn is_slave ( & self ) -> bool { * self == UCMST_A :: SLAVE } # [ doc = "Checks if the value of the field is `MASTER`" ] # [ inline ( always ) ] pub fn is_master ( & self ) -> bool { * self == UCMST_A :: MASTER } }
# [ doc = "Write proxy for field `UCMST`" ] pub struct UCMST_W < 'a > { w : & 'a mut W , } impl < 'a > UCMST_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMST_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Slave mode" ] # [ inline ( always ) ] pub fn slave ( self ) -> & 'a mut W { self . variant ( UCMST_A :: SLAVE ) } # [ doc = "Master mode" ] # [ inline ( always ) ] pub fn master ( self ) -> & 'a mut W { self . variant ( UCMST_A :: MASTER ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Character length\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UC7BIT_A { # [ doc = "0: 8-bit data" ] _8BIT = 0 , # [ doc = "1: 7-bit data" ] _7BIT = 1 } impl From < UC7BIT_A > for bool { # [ inline ( always ) ] fn from ( variant : UC7BIT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UC7BIT`" ] pub type UC7BIT_R = crate :: R < bool , UC7BIT_A > ; impl UC7BIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UC7BIT_A { match self . bits { false => UC7BIT_A :: _8BIT , true => UC7BIT_A :: _7BIT } } # [ doc = "Checks if the value of the field is `_8BIT`" ] # [ inline ( always ) ] pub fn is_8bit ( & self ) -> bool { * self == UC7BIT_A :: _8BIT } # [ doc = "Checks if the value of the field is `_7BIT`" ] # [ inline ( always ) ] pub fn is_7bit ( & self ) -> bool { * self == UC7BIT_A :: _7BIT } }
# [ doc = "Write proxy for field `UC7BIT`" ] pub struct UC7BIT_W < 'a > { w : & 'a mut W , } impl < 'a > UC7BIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UC7BIT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "8-bit data" ] # [ inline ( always ) ] pub fn _8bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _8BIT ) } # [ doc = "7-bit data" ] # [ inline ( always ) ] pub fn _7bit ( self ) -> & 'a mut W { self . variant ( UC7BIT_A :: _7BIT ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "MSB first select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCMSB_A { # [ doc = "0: LSB first" ] UCMSB_0 = 0 , # [ doc = "1: MSB first" ] UCMSB_1 = 1 } impl From < UCMSB_A > for bool { # [ inline ( always ) ] fn from ( variant : UCMSB_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCMSB`" ] pub type UCMSB_R = crate :: R < bool , UCMSB_A > ; impl UCMSB_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCMSB_A { match self . bits { false => UCMSB_A :: UCMSB_0 , true => UCMSB_A :: UCMSB_1 } } # [ doc = "Checks if the value of the field is `UCMSB_0`" ] # [ inline ( always ) ] pub fn is_ucmsb_0 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_0 } # [ doc = "Checks if the value of the field is `UCMSB_1`" ] # [ inline ( always ) ] pub fn is_ucmsb_1 ( & self ) -> bool { * self == UCMSB_A :: UCMSB_1 } }
# [ doc = "Write proxy for field `UCMSB`" ] pub struct UCMSB_W < 'a > { w : & 'a mut W , } impl < 'a > UCMSB_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCMSB_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "LSB first" ] # [ inline ( always ) ] pub fn ucmsb_0 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_0 ) } # [ doc = "MSB first" ] # [ inline ( always ) ] pub fn ucmsb_1 ( self ) -> & 'a mut W { self . variant ( UCMSB_A :: UCMSB_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Clock polarity select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCKPL_A { # [ doc = "0: The inactive state is low" ] LOW = 0 , # [ doc = "1: The inactive state is high" ] HIGH = 1 } impl From < UCCKPL_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCKPL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCKPL`" ] pub type UCCKPL_R = crate :: R < bool , UCCKPL_A > ; impl UCCKPL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCKPL_A { match self . bits { false => UCCKPL_A :: LOW , true => UCCKPL_A :: HIGH } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == UCCKPL_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == UCCKPL_A :: HIGH } }
# [ doc = "Write proxy for field `UCCKPL`" ] pub struct UCCKPL_W < 'a > { w : & 'a mut W , } impl < 'a > UCCKPL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCKPL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The inactive state is low" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( UCCKPL_A :: LOW ) } # [ doc = "The inactive state is high" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( UCCKPL_A :: HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Clock phase select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCKPH_A { # [ doc = "0: Data is changed on the first UCLK edge and captured on the following edge." ] UCCKPH_0 = 0 , # [ doc = "1: Data is captured on the first UCLK edge and changed on the following edge." ] UCCKPH_1 = 1 } impl From < UCCKPH_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCKPH_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCKPH`" ] pub type UCCKPH_R = crate :: R < bool , UCCKPH_A > ; impl UCCKPH_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCKPH_A { match self . bits { false => UCCKPH_A :: UCCKPH_0 , true => UCCKPH_A :: UCCKPH_1 } } # [ doc = "Checks if the value of the field is `UCCKPH_0`" ] # [ inline ( always ) ] pub fn is_ucckph_0 ( & self ) -> bool { * self == UCCKPH_A :: UCCKPH_0 } # [ doc = "Checks if the value of the field is `UCCKPH_1`" ] # [ inline ( always ) ] pub fn is_ucckph_1 ( & self ) -> bool { * self == UCCKPH_A :: UCCKPH_1 } }
# [ doc = "Write proxy for field `UCCKPH`" ] pub struct UCCKPH_W < 'a > { w : & 'a mut W , } impl < 'a > UCCKPH_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCKPH_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Data is changed on the first UCLK edge and captured on the following edge." ] # [ inline ( always ) ] pub fn ucckph_0 ( self ) -> & 'a mut W { self . variant ( UCCKPH_A :: UCCKPH_0 ) } # [ doc = "Data is captured on the first UCLK edge and changed on the following edge." ] # [ inline ( always ) ] pub fn ucckph_1 ( self ) -> & 'a mut W { self . variant ( UCCKPH_A :: UCCKPH_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & self ) -> UCSWRST_R { UCSWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - STE mode select in master mode." ] # [ inline ( always ) ] pub fn ucstem ( & self ) -> UCSTEM_R { UCSTEM_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - eUSCI_B clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & self ) -> UCSSEL_R { UCSSEL_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & self ) -> UCSYNC_R { UCSYNC_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 9:10 - eUSCI mode" ] # [ inline ( always ) ] pub fn ucmode ( & self ) -> UCMODE_R { UCMODE_R :: new ( ( ( self . bits >> 9 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & self ) -> UCMST_R { UCMST_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & self ) -> UC7BIT_R { UC7BIT_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & self ) -> UCMSB_R { UCMSB_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Clock polarity select" ] # [ inline ( always ) ] pub fn ucckpl ( & self ) -> UCCKPL_R { UCCKPL_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Clock phase select" ] # [ inline ( always ) ] pub fn ucckph ( & self ) -> UCCKPH_R { UCCKPH_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software reset enable" ] # [ inline ( always ) ] pub fn ucswrst ( & mut self ) -> UCSWRST_W { UCSWRST_W { w : self } }
# [ doc = "Bit 1 - STE mode select in master mode." ] # [ inline ( always ) ] pub fn ucstem ( & mut self ) -> UCSTEM_W { UCSTEM_W { w : self } }
# [ doc = "Bits 6:7 - eUSCI_B clock source select" ] # [ inline ( always ) ] pub fn ucssel ( & mut self ) -> UCSSEL_W { UCSSEL_W { w : self } }
# [ doc = "Bit 8 - Synchronous mode enable" ] # [ inline ( always ) ] pub fn ucsync ( & mut self ) -> UCSYNC_W { UCSYNC_W { w : self } }
# [ doc = "Bits 9:10 - eUSCI mode" ] # [ inline ( always ) ] pub fn ucmode ( & mut self ) -> UCMODE_W { UCMODE_W { w : self } }
# [ doc = "Bit 11 - Master mode select" ] # [ inline ( always ) ] pub fn ucmst ( & mut self ) -> UCMST_W { UCMST_W { w : self } }
# [ doc = "Bit 12 - Character length" ] # [ inline ( always ) ] pub fn uc7bit ( & mut self ) -> UC7BIT_W { UC7BIT_W { w : self } }
# [ doc = "Bit 13 - MSB first select" ] # [ inline ( always ) ] pub fn ucmsb ( & mut self ) -> UCMSB_W { UCMSB_W { w : self } }
# [ doc = "Bit 14 - Clock polarity select" ] # [ inline ( always ) ] pub fn ucckpl ( & mut self ) -> UCCKPL_W { UCCKPL_W { w : self } }
# [ doc = "Bit 15 - Clock phase select" ] # [ inline ( always ) ] pub fn ucckph ( & mut self ) -> UCCKPH_W { UCCKPH_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Control Word Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1ctlw1](ucb1ctlw1) module" ] pub type UCB1CTLW1 = crate :: Reg < u16 , _UCB1CTLW1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1CTLW1 ;
# [ doc = "`read()` method returns [ucb1ctlw1::R](ucb1ctlw1::R) reader structure" ] impl crate :: Readable for UCB1CTLW1 { }
# [ doc = "`write(|w| ..)` method takes [ucb1ctlw1::W](ucb1ctlw1::W) writer structure" ] impl crate :: Writable for UCB1CTLW1 { }
# [ doc = "eUSCI_Bx Control Word Register 1" ] pub mod ucb1ctlw1 {
# [ doc = "Reader of register UCB1CTLW1" ] pub type R = crate :: R < u16 , super :: UCB1CTLW1 > ;
# [ doc = "Writer for register UCB1CTLW1" ] pub type W = crate :: W < u16 , super :: UCB1CTLW1 > ;
# [ doc = "Register UCB1CTLW1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1CTLW1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Deglitch time\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCGLIT_A { # [ doc = "0: 50 ns" ] UCGLIT_0 = 0 , # [ doc = "1: 25 ns" ] UCGLIT_1 = 1 , # [ doc = "2: 12.5 ns" ] UCGLIT_2 = 2 , # [ doc = "3: 6.25 ns" ] UCGLIT_3 = 3 } impl From < UCGLIT_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCGLIT_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCGLIT`" ] pub type UCGLIT_R = crate :: R < u8 , UCGLIT_A > ; impl UCGLIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCGLIT_A { match self . bits { 0 => UCGLIT_A :: UCGLIT_0 , 1 => UCGLIT_A :: UCGLIT_1 , 2 => UCGLIT_A :: UCGLIT_2 , 3 => UCGLIT_A :: UCGLIT_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCGLIT_0`" ] # [ inline ( always ) ] pub fn is_ucglit_0 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_0 } # [ doc = "Checks if the value of the field is `UCGLIT_1`" ] # [ inline ( always ) ] pub fn is_ucglit_1 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_1 } # [ doc = "Checks if the value of the field is `UCGLIT_2`" ] # [ inline ( always ) ] pub fn is_ucglit_2 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_2 } # [ doc = "Checks if the value of the field is `UCGLIT_3`" ] # [ inline ( always ) ] pub fn is_ucglit_3 ( & self ) -> bool { * self == UCGLIT_A :: UCGLIT_3 } }
# [ doc = "Write proxy for field `UCGLIT`" ] pub struct UCGLIT_W < 'a > { w : & 'a mut W , } impl < 'a > UCGLIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCGLIT_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "50 ns" ] # [ inline ( always ) ] pub fn ucglit_0 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_0 ) } # [ doc = "25 ns" ] # [ inline ( always ) ] pub fn ucglit_1 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_1 ) } # [ doc = "12.5 ns" ] # [ inline ( always ) ] pub fn ucglit_2 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_2 ) } # [ doc = "6.25 ns" ] # [ inline ( always ) ] pub fn ucglit_3 ( self ) -> & 'a mut W { self . variant ( UCGLIT_A :: UCGLIT_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Automatic STOP condition generation\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCASTP_A { # [ doc = "0: No automatic STOP generation. The STOP condition is generated after the user sets the UCTXSTP bit. The value in UCBxTBCNT is a don't care." ] UCASTP_0 = 0 , # [ doc = "1: UCBCNTIFG is set with the byte counter reaches the threshold defined in UCBxTBCNT" ] UCASTP_1 = 1 , # [ doc = "2: A STOP condition is generated automatically after the byte counter value reached UCBxTBCNT. UCBCNTIFG is set with the byte counter reaching the threshold" ] UCASTP_2 = 2 , # [ doc = "3: Reserved" ] UCASTP_3 = 3 } impl From < UCASTP_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCASTP_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCASTP`" ] pub type UCASTP_R = crate :: R < u8 , UCASTP_A > ; impl UCASTP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCASTP_A { match self . bits { 0 => UCASTP_A :: UCASTP_0 , 1 => UCASTP_A :: UCASTP_1 , 2 => UCASTP_A :: UCASTP_2 , 3 => UCASTP_A :: UCASTP_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCASTP_0`" ] # [ inline ( always ) ] pub fn is_ucastp_0 ( & self ) -> bool { * self == UCASTP_A :: UCASTP_0 } # [ doc = "Checks if the value of the field is `UCASTP_1`" ] # [ inline ( always ) ] pub fn is_ucastp_1 ( & self ) -> bool { * self == UCASTP_A :: UCASTP_1 } # [ doc = "Checks if the value of the field is `UCASTP_2`" ] # [ inline ( always ) ] pub fn is_ucastp_2 ( & self ) -> bool { * self == UCASTP_A :: UCASTP_2 } # [ doc = "Checks if the value of the field is `UCASTP_3`" ] # [ inline ( always ) ] pub fn is_ucastp_3 ( & self ) -> bool { * self == UCASTP_A :: UCASTP_3 } }
# [ doc = "Write proxy for field `UCASTP`" ] pub struct UCASTP_W < 'a > { w : & 'a mut W , } impl < 'a > UCASTP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCASTP_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "No automatic STOP generation. The STOP condition is generated after the user sets the UCTXSTP bit. The value in UCBxTBCNT is a don't care." ] # [ inline ( always ) ] pub fn ucastp_0 ( self ) -> & 'a mut W { self . variant ( UCASTP_A :: UCASTP_0 ) } # [ doc = "UCBCNTIFG is set with the byte counter reaches the threshold defined in UCBxTBCNT" ] # [ inline ( always ) ] pub fn ucastp_1 ( self ) -> & 'a mut W { self . variant ( UCASTP_A :: UCASTP_1 ) } # [ doc = "A STOP condition is generated automatically after the byte counter value reached UCBxTBCNT. UCBCNTIFG is set with the byte counter reaching the threshold" ] # [ inline ( always ) ] pub fn ucastp_2 ( self ) -> & 'a mut W { self . variant ( UCASTP_A :: UCASTP_2 ) } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn ucastp_3 ( self ) -> & 'a mut W { self . variant ( UCASTP_A :: UCASTP_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u16 ) & 0x03 ) << 2 ) ; self . w } }
# [ doc = "SW or HW ACK control\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSWACK_A { # [ doc = "0: The address acknowledge of the slave is controlled by the eUSCI_B module" ] UCSWACK_0 = 0 , # [ doc = "1: The user needs to trigger the sending of the address ACK by issuing UCTXACK" ] UCSWACK_1 = 1 } impl From < UCSWACK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSWACK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSWACK`" ] pub type UCSWACK_R = crate :: R < bool , UCSWACK_A > ; impl UCSWACK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSWACK_A { match self . bits { false => UCSWACK_A :: UCSWACK_0 , true => UCSWACK_A :: UCSWACK_1 } } # [ doc = "Checks if the value of the field is `UCSWACK_0`" ] # [ inline ( always ) ] pub fn is_ucswack_0 ( & self ) -> bool { * self == UCSWACK_A :: UCSWACK_0 } # [ doc = "Checks if the value of the field is `UCSWACK_1`" ] # [ inline ( always ) ] pub fn is_ucswack_1 ( & self ) -> bool { * self == UCSWACK_A :: UCSWACK_1 } }
# [ doc = "Write proxy for field `UCSWACK`" ] pub struct UCSWACK_W < 'a > { w : & 'a mut W , } impl < 'a > UCSWACK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSWACK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The address acknowledge of the slave is controlled by the eUSCI_B module" ] # [ inline ( always ) ] pub fn ucswack_0 ( self ) -> & 'a mut W { self . variant ( UCSWACK_A :: UCSWACK_0 ) } # [ doc = "The user needs to trigger the sending of the address ACK by issuing UCTXACK" ] # [ inline ( always ) ] pub fn ucswack_1 ( self ) -> & 'a mut W { self . variant ( UCSWACK_A :: UCSWACK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "ACK all master bytes\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTPNACK_A { # [ doc = "0: Send a non-acknowledge before the STOP condition as a master receiver (conform to I2C standard)" ] UCSTPNACK_0 = 0 , # [ doc = "1: All bytes are acknowledged by the eUSCI_B when configured as master receiver" ] UCSTPNACK_1 = 1 } impl From < UCSTPNACK_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTPNACK_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTPNACK`" ] pub type UCSTPNACK_R = crate :: R < bool , UCSTPNACK_A > ; impl UCSTPNACK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTPNACK_A { match self . bits { false => UCSTPNACK_A :: UCSTPNACK_0 , true => UCSTPNACK_A :: UCSTPNACK_1 } } # [ doc = "Checks if the value of the field is `UCSTPNACK_0`" ] # [ inline ( always ) ] pub fn is_ucstpnack_0 ( & self ) -> bool { * self == UCSTPNACK_A :: UCSTPNACK_0 } # [ doc = "Checks if the value of the field is `UCSTPNACK_1`" ] # [ inline ( always ) ] pub fn is_ucstpnack_1 ( & self ) -> bool { * self == UCSTPNACK_A :: UCSTPNACK_1 } }
# [ doc = "Write proxy for field `UCSTPNACK`" ] pub struct UCSTPNACK_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTPNACK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTPNACK_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Send a non-acknowledge before the STOP condition as a master receiver (conform to I2C standard)" ] # [ inline ( always ) ] pub fn ucstpnack_0 ( self ) -> & 'a mut W { self . variant ( UCSTPNACK_A :: UCSTPNACK_0 ) } # [ doc = "All bytes are acknowledged by the eUSCI_B when configured as master receiver" ] # [ inline ( always ) ] pub fn ucstpnack_1 ( self ) -> & 'a mut W { self . variant ( UCSTPNACK_A :: UCSTPNACK_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Clock low timeout select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum UCCLTO_A { # [ doc = "0: Disable clock low timeout counter" ] UCCLTO_0 = 0 , # [ doc = "1: 135 000 SYSCLK cycles (approximately 28 ms)" ] UCCLTO_1 = 1 , # [ doc = "2: 150 000 SYSCLK cycles (approximately 31 ms)" ] UCCLTO_2 = 2 , # [ doc = "3: 165 000 SYSCLK cycles (approximately 34 ms)" ] UCCLTO_3 = 3 } impl From < UCCLTO_A > for u8 { # [ inline ( always ) ] fn from ( variant : UCCLTO_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCCLTO`" ] pub type UCCLTO_R = crate :: R < u8 , UCCLTO_A > ; impl UCCLTO_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCLTO_A { match self . bits { 0 => UCCLTO_A :: UCCLTO_0 , 1 => UCCLTO_A :: UCCLTO_1 , 2 => UCCLTO_A :: UCCLTO_2 , 3 => UCCLTO_A :: UCCLTO_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `UCCLTO_0`" ] # [ inline ( always ) ] pub fn is_ucclto_0 ( & self ) -> bool { * self == UCCLTO_A :: UCCLTO_0 } # [ doc = "Checks if the value of the field is `UCCLTO_1`" ] # [ inline ( always ) ] pub fn is_ucclto_1 ( & self ) -> bool { * self == UCCLTO_A :: UCCLTO_1 } # [ doc = "Checks if the value of the field is `UCCLTO_2`" ] # [ inline ( always ) ] pub fn is_ucclto_2 ( & self ) -> bool { * self == UCCLTO_A :: UCCLTO_2 } # [ doc = "Checks if the value of the field is `UCCLTO_3`" ] # [ inline ( always ) ] pub fn is_ucclto_3 ( & self ) -> bool { * self == UCCLTO_A :: UCCLTO_3 } }
# [ doc = "Write proxy for field `UCCLTO`" ] pub struct UCCLTO_W < 'a > { w : & 'a mut W , } impl < 'a > UCCLTO_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCLTO_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Disable clock low timeout counter" ] # [ inline ( always ) ] pub fn ucclto_0 ( self ) -> & 'a mut W { self . variant ( UCCLTO_A :: UCCLTO_0 ) } # [ doc = "135 000 SYSCLK cycles (approximately 28 ms)" ] # [ inline ( always ) ] pub fn ucclto_1 ( self ) -> & 'a mut W { self . variant ( UCCLTO_A :: UCCLTO_1 ) } # [ doc = "150 000 SYSCLK cycles (approximately 31 ms)" ] # [ inline ( always ) ] pub fn ucclto_2 ( self ) -> & 'a mut W { self . variant ( UCCLTO_A :: UCCLTO_2 ) } # [ doc = "165 000 SYSCLK cycles (approximately 34 ms)" ] # [ inline ( always ) ] pub fn ucclto_3 ( self ) -> & 'a mut W { self . variant ( UCCLTO_A :: UCCLTO_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Early UCTXIFG0\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCETXINT_A { # [ doc = "0: UCTXIFGx is set after an address match with UCxI2COAx and the direction bit indicating slave transmit" ] UCETXINT_0 = 0 , # [ doc = "1: UCTXIFG0 is set for each START condition" ] UCETXINT_1 = 1 } impl From < UCETXINT_A > for bool { # [ inline ( always ) ] fn from ( variant : UCETXINT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCETXINT`" ] pub type UCETXINT_R = crate :: R < bool , UCETXINT_A > ; impl UCETXINT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCETXINT_A { match self . bits { false => UCETXINT_A :: UCETXINT_0 , true => UCETXINT_A :: UCETXINT_1 } } # [ doc = "Checks if the value of the field is `UCETXINT_0`" ] # [ inline ( always ) ] pub fn is_ucetxint_0 ( & self ) -> bool { * self == UCETXINT_A :: UCETXINT_0 } # [ doc = "Checks if the value of the field is `UCETXINT_1`" ] # [ inline ( always ) ] pub fn is_ucetxint_1 ( & self ) -> bool { * self == UCETXINT_A :: UCETXINT_1 } }
# [ doc = "Write proxy for field `UCETXINT`" ] pub struct UCETXINT_W < 'a > { w : & 'a mut W , } impl < 'a > UCETXINT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCETXINT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "UCTXIFGx is set after an address match with UCxI2COAx and the direction bit indicating slave transmit" ] # [ inline ( always ) ] pub fn ucetxint_0 ( self ) -> & 'a mut W { self . variant ( UCETXINT_A :: UCETXINT_0 ) } # [ doc = "UCTXIFG0 is set for each START condition" ] # [ inline ( always ) ] pub fn ucetxint_1 ( self ) -> & 'a mut W { self . variant ( UCETXINT_A :: UCETXINT_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Deglitch time" ] # [ inline ( always ) ] pub fn ucglit ( & self ) -> UCGLIT_R { UCGLIT_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 2:3 - Automatic STOP condition generation" ] # [ inline ( always ) ] pub fn ucastp ( & self ) -> UCASTP_R { UCASTP_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 4 - SW or HW ACK control" ] # [ inline ( always ) ] pub fn ucswack ( & self ) -> UCSWACK_R { UCSWACK_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - ACK all master bytes" ] # [ inline ( always ) ] pub fn ucstpnack ( & self ) -> UCSTPNACK_R { UCSTPNACK_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - Clock low timeout select" ] # [ inline ( always ) ] pub fn ucclto ( & self ) -> UCCLTO_R { UCCLTO_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Early UCTXIFG0" ] # [ inline ( always ) ] pub fn ucetxint ( & self ) -> UCETXINT_R { UCETXINT_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:1 - Deglitch time" ] # [ inline ( always ) ] pub fn ucglit ( & mut self ) -> UCGLIT_W { UCGLIT_W { w : self } }
# [ doc = "Bits 2:3 - Automatic STOP condition generation" ] # [ inline ( always ) ] pub fn ucastp ( & mut self ) -> UCASTP_W { UCASTP_W { w : self } }
# [ doc = "Bit 4 - SW or HW ACK control" ] # [ inline ( always ) ] pub fn ucswack ( & mut self ) -> UCSWACK_W { UCSWACK_W { w : self } }
# [ doc = "Bit 5 - ACK all master bytes" ] # [ inline ( always ) ] pub fn ucstpnack ( & mut self ) -> UCSTPNACK_W { UCSTPNACK_W { w : self } }
# [ doc = "Bits 6:7 - Clock low timeout select" ] # [ inline ( always ) ] pub fn ucclto ( & mut self ) -> UCCLTO_W { UCCLTO_W { w : self } }
# [ doc = "Bit 8 - Early UCTXIFG0" ] # [ inline ( always ) ] pub fn ucetxint ( & mut self ) -> UCETXINT_W { UCETXINT_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Baud Rate Control Word Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1brw](ucb1brw) module" ] pub type UCB1BRW = crate :: Reg < u16 , _UCB1BRW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1BRW ;
# [ doc = "`read()` method returns [ucb1brw::R](ucb1brw::R) reader structure" ] impl crate :: Readable for UCB1BRW { }
# [ doc = "`write(|w| ..)` method takes [ucb1brw::W](ucb1brw::W) writer structure" ] impl crate :: Writable for UCB1BRW { }
# [ doc = "eUSCI_Bx Baud Rate Control Word Register" ] pub mod ucb1brw {
# [ doc = "Reader of register UCB1BRW" ] pub type R = crate :: R < u16 , super :: UCB1BRW > ;
# [ doc = "Writer for register UCB1BRW" ] pub type W = crate :: W < u16 , super :: UCB1BRW > ;
# [ doc = "Register UCB1BRW `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1BRW { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "eUSCI_Bx Bit Rate Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1brw_spi](ucb1brw_spi) module" ] pub type UCB1BRW_SPI = crate :: Reg < u16 , _UCB1BRW_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1BRW_SPI ;
# [ doc = "`read()` method returns [ucb1brw_spi::R](ucb1brw_spi::R) reader structure" ] impl crate :: Readable for UCB1BRW_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb1brw_spi::W](ucb1brw_spi::W) writer structure" ] impl crate :: Writable for UCB1BRW_SPI { }
# [ doc = "eUSCI_Bx Bit Rate Control Register 1" ] pub mod ucb1brw_spi {
# [ doc = "Reader of register UCB1BRW_SPI" ] pub type R = crate :: R < u16 , super :: UCB1BRW_SPI > ;
# [ doc = "Writer for register UCB1BRW_SPI" ] pub type W = crate :: W < u16 , super :: UCB1BRW_SPI > ;
# [ doc = "Register UCB1BRW_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1BRW_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "eUSCI_Bx Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1statw](ucb1statw) module" ] pub type UCB1STATW = crate :: Reg < u16 , _UCB1STATW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1STATW ;
# [ doc = "`read()` method returns [ucb1statw::R](ucb1statw::R) reader structure" ] impl crate :: Readable for UCB1STATW { }
# [ doc = "eUSCI_Bx Status Register" ] pub mod ucb1statw {
# [ doc = "Reader of register UCB1STATW" ] pub type R = crate :: R < u16 , super :: UCB1STATW > ;
# [ doc = "Bus busy\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBBUSY_A { # [ doc = "0: Bus inactive" ] IDLE = 0 , # [ doc = "1: Bus busy" ] BUSY = 1 } impl From < UCBBUSY_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBBUSY_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBBUSY`" ] pub type UCBBUSY_R = crate :: R < bool , UCBBUSY_A > ; impl UCBBUSY_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBBUSY_A { match self . bits { false => UCBBUSY_A :: IDLE , true => UCBBUSY_A :: BUSY } } # [ doc = "Checks if the value of the field is `IDLE`" ] # [ inline ( always ) ] pub fn is_idle ( & self ) -> bool { * self == UCBBUSY_A :: IDLE } # [ doc = "Checks if the value of the field is `BUSY`" ] # [ inline ( always ) ] pub fn is_busy ( & self ) -> bool { * self == UCBBUSY_A :: BUSY } }
# [ doc = "General call address received\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCGC_A { # [ doc = "0: No general call address received" ] UCGC_0 = 0 , # [ doc = "1: General call address received" ] UCGC_1 = 1 } impl From < UCGC_A > for bool { # [ inline ( always ) ] fn from ( variant : UCGC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCGC`" ] pub type UCGC_R = crate :: R < bool , UCGC_A > ; impl UCGC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCGC_A { match self . bits { false => UCGC_A :: UCGC_0 , true => UCGC_A :: UCGC_1 } } # [ doc = "Checks if the value of the field is `UCGC_0`" ] # [ inline ( always ) ] pub fn is_ucgc_0 ( & self ) -> bool { * self == UCGC_A :: UCGC_0 } # [ doc = "Checks if the value of the field is `UCGC_1`" ] # [ inline ( always ) ] pub fn is_ucgc_1 ( & self ) -> bool { * self == UCGC_A :: UCGC_1 } }
# [ doc = "SCL low\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSCLLOW_A { # [ doc = "0: SCL is not held low" ] UCSCLLOW_0 = 0 , # [ doc = "1: SCL is held low" ] UCSCLLOW_1 = 1 } impl From < UCSCLLOW_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSCLLOW_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSCLLOW`" ] pub type UCSCLLOW_R = crate :: R < bool , UCSCLLOW_A > ; impl UCSCLLOW_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSCLLOW_A { match self . bits { false => UCSCLLOW_A :: UCSCLLOW_0 , true => UCSCLLOW_A :: UCSCLLOW_1 } } # [ doc = "Checks if the value of the field is `UCSCLLOW_0`" ] # [ inline ( always ) ] pub fn is_ucscllow_0 ( & self ) -> bool { * self == UCSCLLOW_A :: UCSCLLOW_0 } # [ doc = "Checks if the value of the field is `UCSCLLOW_1`" ] # [ inline ( always ) ] pub fn is_ucscllow_1 ( & self ) -> bool { * self == UCSCLLOW_A :: UCSCLLOW_1 } }
# [ doc = "Reader of field `UCBCNT`" ] pub type UCBCNT_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bit 4 - Bus busy" ] # [ inline ( always ) ] pub fn ucbbusy ( & self ) -> UCBBUSY_R { UCBBUSY_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - General call address received" ] # [ inline ( always ) ] pub fn ucgc ( & self ) -> UCGC_R { UCGC_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - SCL low" ] # [ inline ( always ) ] pub fn ucscllow ( & self ) -> UCSCLLOW_R { UCSCLLOW_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:15 - Hardware byte counter value" ] # [ inline ( always ) ] pub fn ucbcnt ( & self ) -> UCBCNT_R { UCBCNT_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
}
}
# [ doc = "UCB1STATW_SPI\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1statw_spi](ucb1statw_spi) module" ] pub type UCB1STATW_SPI = crate :: Reg < u16 , _UCB1STATW_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1STATW_SPI ;
# [ doc = "`read()` method returns [ucb1statw_spi::R](ucb1statw_spi::R) reader structure" ] impl crate :: Readable for UCB1STATW_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb1statw_spi::W](ucb1statw_spi::W) writer structure" ] impl crate :: Writable for UCB1STATW_SPI { }
# [ doc = "UCB1STATW_SPI" ] pub mod ucb1statw_spi {
# [ doc = "Reader of register UCB1STATW_SPI" ] pub type R = crate :: R < u16 , super :: UCB1STATW_SPI > ;
# [ doc = "Writer for register UCB1STATW_SPI" ] pub type W = crate :: W < u16 , super :: UCB1STATW_SPI > ;
# [ doc = "Register UCB1STATW_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1STATW_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Overrun error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOE_A { # [ doc = "0: No error" ] UCOE_0 = 0 , # [ doc = "1: Overrun error occurred" ] UCOE_1 = 1 } impl From < UCOE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOE`" ] pub type UCOE_R = crate :: R < bool , UCOE_A > ; impl UCOE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOE_A { match self . bits { false => UCOE_A :: UCOE_0 , true => UCOE_A :: UCOE_1 } } # [ doc = "Checks if the value of the field is `UCOE_0`" ] # [ inline ( always ) ] pub fn is_ucoe_0 ( & self ) -> bool { * self == UCOE_A :: UCOE_0 } # [ doc = "Checks if the value of the field is `UCOE_1`" ] # [ inline ( always ) ] pub fn is_ucoe_1 ( & self ) -> bool { * self == UCOE_A :: UCOE_1 } }
# [ doc = "Write proxy for field `UCOE`" ] pub struct UCOE_W < 'a > { w : & 'a mut W , } impl < 'a > UCOE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucoe_0 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_0 ) } # [ doc = "Overrun error occurred" ] # [ inline ( always ) ] pub fn ucoe_1 ( self ) -> & 'a mut W { self . variant ( UCOE_A :: UCOE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Framing error flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCFE_A { # [ doc = "0: No error" ] UCFE_0 = 0 , # [ doc = "1: Bus conflict occurred" ] UCFE_1 = 1 } impl From < UCFE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCFE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCFE`" ] pub type UCFE_R = crate :: R < bool , UCFE_A > ; impl UCFE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCFE_A { match self . bits { false => UCFE_A :: UCFE_0 , true => UCFE_A :: UCFE_1 } } # [ doc = "Checks if the value of the field is `UCFE_0`" ] # [ inline ( always ) ] pub fn is_ucfe_0 ( & self ) -> bool { * self == UCFE_A :: UCFE_0 } # [ doc = "Checks if the value of the field is `UCFE_1`" ] # [ inline ( always ) ] pub fn is_ucfe_1 ( & self ) -> bool { * self == UCFE_A :: UCFE_1 } }
# [ doc = "Write proxy for field `UCFE`" ] pub struct UCFE_W < 'a > { w : & 'a mut W , } impl < 'a > UCFE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCFE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No error" ] # [ inline ( always ) ] pub fn ucfe_0 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_0 ) } # [ doc = "Bus conflict occurred" ] # [ inline ( always ) ] pub fn ucfe_1 ( self ) -> & 'a mut W { self . variant ( UCFE_A :: UCFE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Listen enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCLISTEN_A { # [ doc = "0: Disabled" ] UCLISTEN_0 = 0 , # [ doc = "1: Enabled. UCBxTXD is internally fed back to the receiver" ] UCLISTEN_1 = 1 } impl From < UCLISTEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCLISTEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCLISTEN`" ] pub type UCLISTEN_R = crate :: R < bool , UCLISTEN_A > ; impl UCLISTEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCLISTEN_A { match self . bits { false => UCLISTEN_A :: UCLISTEN_0 , true => UCLISTEN_A :: UCLISTEN_1 } } # [ doc = "Checks if the value of the field is `UCLISTEN_0`" ] # [ inline ( always ) ] pub fn is_uclisten_0 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_0 } # [ doc = "Checks if the value of the field is `UCLISTEN_1`" ] # [ inline ( always ) ] pub fn is_uclisten_1 ( & self ) -> bool { * self == UCLISTEN_A :: UCLISTEN_1 } }
# [ doc = "Write proxy for field `UCLISTEN`" ] pub struct UCLISTEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCLISTEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCLISTEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn uclisten_0 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_0 ) } # [ doc = "Enabled. UCBxTXD is internally fed back to the receiver" ] # [ inline ( always ) ] pub fn uclisten_1 ( self ) -> & 'a mut W { self . variant ( UCLISTEN_A :: UCLISTEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & self ) -> UCOE_R { UCOE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & self ) -> UCFE_R { UCFE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & self ) -> UCLISTEN_R { UCLISTEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 5 - Overrun error flag" ] # [ inline ( always ) ] pub fn ucoe ( & mut self ) -> UCOE_W { UCOE_W { w : self } }
# [ doc = "Bit 6 - Framing error flag" ] # [ inline ( always ) ] pub fn ucfe ( & mut self ) -> UCFE_W { UCFE_W { w : self } }
# [ doc = "Bit 7 - Listen enable" ] # [ inline ( always ) ] pub fn uclisten ( & mut self ) -> UCLISTEN_W { UCLISTEN_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Byte Counter Threshold Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1tbcnt](ucb1tbcnt) module" ] pub type UCB1TBCNT = crate :: Reg < u16 , _UCB1TBCNT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1TBCNT ;
# [ doc = "`read()` method returns [ucb1tbcnt::R](ucb1tbcnt::R) reader structure" ] impl crate :: Readable for UCB1TBCNT { }
# [ doc = "`write(|w| ..)` method takes [ucb1tbcnt::W](ucb1tbcnt::W) writer structure" ] impl crate :: Writable for UCB1TBCNT { }
# [ doc = "eUSCI_Bx Byte Counter Threshold Register" ] pub mod ucb1tbcnt {
# [ doc = "Reader of register UCB1TBCNT" ] pub type R = crate :: R < u16 , super :: UCB1TBCNT > ;
# [ doc = "Writer for register UCB1TBCNT" ] pub type W = crate :: W < u16 , super :: UCB1TBCNT > ;
# [ doc = "Register UCB1TBCNT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1TBCNT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UCTBCNT`" ] pub type UCTBCNT_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCTBCNT`" ] pub struct UCTBCNT_W < 'a > { w : & 'a mut W , } impl < 'a > UCTBCNT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Byte counter threshold value" ] # [ inline ( always ) ] pub fn uctbcnt ( & self ) -> UCTBCNT_R { UCTBCNT_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Byte counter threshold value" ] # [ inline ( always ) ] pub fn uctbcnt ( & mut self ) -> UCTBCNT_W { UCTBCNT_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Receive Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1rxbuf](ucb1rxbuf) module" ] pub type UCB1RXBUF = crate :: Reg < u16 , _UCB1RXBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1RXBUF ;
# [ doc = "`read()` method returns [ucb1rxbuf::R](ucb1rxbuf::R) reader structure" ] impl crate :: Readable for UCB1RXBUF { }
# [ doc = "eUSCI_Bx Receive Buffer Register" ] pub mod ucb1rxbuf {
# [ doc = "Reader of register UCB1RXBUF" ] pub type R = crate :: R < u16 , super :: UCB1RXBUF > ;
# [ doc = "Reader of field `UCRXBUF`" ] pub type UCRXBUF_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Receive data buffer" ] # [ inline ( always ) ] pub fn ucrxbuf ( & self ) -> UCRXBUF_R { UCRXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
}
# [ doc = "eUSCI_Bx Receive Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1rxbuf_spi](ucb1rxbuf_spi) module" ] pub type UCB1RXBUF_SPI = crate :: Reg < u16 , _UCB1RXBUF_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1RXBUF_SPI ;
# [ doc = "`read()` method returns [ucb1rxbuf_spi::R](ucb1rxbuf_spi::R) reader structure" ] impl crate :: Readable for UCB1RXBUF_SPI { }
# [ doc = "eUSCI_Bx Receive Buffer Register" ] pub mod ucb1rxbuf_spi {
# [ doc = "Reader of register UCB1RXBUF_SPI" ] pub type R = crate :: R < u16 , super :: UCB1RXBUF_SPI > ;
# [ doc = "Reader of field `UCRXBUF`" ] pub type UCRXBUF_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Receive data buffer" ] # [ inline ( always ) ] pub fn ucrxbuf ( & self ) -> UCRXBUF_R { UCRXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
}
# [ doc = "eUSCI_Bx Transmit Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1txbuf](ucb1txbuf) module" ] pub type UCB1TXBUF = crate :: Reg < u16 , _UCB1TXBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1TXBUF ;
# [ doc = "`read()` method returns [ucb1txbuf::R](ucb1txbuf::R) reader structure" ] impl crate :: Readable for UCB1TXBUF { }
# [ doc = "`write(|w| ..)` method takes [ucb1txbuf::W](ucb1txbuf::W) writer structure" ] impl crate :: Writable for UCB1TXBUF { }
# [ doc = "eUSCI_Bx Transmit Buffer Register" ] pub mod ucb1txbuf {
# [ doc = "Reader of register UCB1TXBUF" ] pub type R = crate :: R < u16 , super :: UCB1TXBUF > ;
# [ doc = "Writer for register UCB1TXBUF" ] pub type W = crate :: W < u16 , super :: UCB1TXBUF > ;
# [ doc = "Register UCB1TXBUF `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1TXBUF { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UCTXBUF`" ] pub type UCTXBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCTXBUF`" ] pub struct UCTXBUF_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & self ) -> UCTXBUF_R { UCTXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & mut self ) -> UCTXBUF_W { UCTXBUF_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Transmit Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1txbuf_spi](ucb1txbuf_spi) module" ] pub type UCB1TXBUF_SPI = crate :: Reg < u16 , _UCB1TXBUF_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1TXBUF_SPI ;
# [ doc = "`read()` method returns [ucb1txbuf_spi::R](ucb1txbuf_spi::R) reader structure" ] impl crate :: Readable for UCB1TXBUF_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb1txbuf_spi::W](ucb1txbuf_spi::W) writer structure" ] impl crate :: Writable for UCB1TXBUF_SPI { }
# [ doc = "eUSCI_Bx Transmit Buffer Register" ] pub mod ucb1txbuf_spi {
# [ doc = "Reader of register UCB1TXBUF_SPI" ] pub type R = crate :: R < u16 , super :: UCB1TXBUF_SPI > ;
# [ doc = "Writer for register UCB1TXBUF_SPI" ] pub type W = crate :: W < u16 , super :: UCB1TXBUF_SPI > ;
# [ doc = "Register UCB1TXBUF_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1TXBUF_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UCTXBUF`" ] pub type UCTXBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `UCTXBUF`" ] pub struct UCTXBUF_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & self ) -> UCTXBUF_R { UCTXBUF_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Transmit data buffer" ] # [ inline ( always ) ] pub fn uctxbuf ( & mut self ) -> UCTXBUF_W { UCTXBUF_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Own Address 0 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1i2coa0](ucb1i2coa0) module" ] pub type UCB1I2COA0 = crate :: Reg < u16 , _UCB1I2COA0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1I2COA0 ;
# [ doc = "`read()` method returns [ucb1i2coa0::R](ucb1i2coa0::R) reader structure" ] impl crate :: Readable for UCB1I2COA0 { }
# [ doc = "`write(|w| ..)` method takes [ucb1i2coa0::W](ucb1i2coa0::W) writer structure" ] impl crate :: Writable for UCB1I2COA0 { }
# [ doc = "eUSCI_Bx I2C Own Address 0 Register" ] pub mod ucb1i2coa0 {
# [ doc = "Reader of register UCB1I2COA0" ] pub type R = crate :: R < u16 , super :: UCB1I2COA0 > ;
# [ doc = "Writer for register UCB1I2COA0" ] pub type W = crate :: W < u16 , super :: UCB1I2COA0 > ;
# [ doc = "Register UCB1I2COA0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1I2COA0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `I2COA0`" ] pub type I2COA0_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `I2COA0`" ] pub struct I2COA0_W < 'a > { w : & 'a mut W , } impl < 'a > I2COA0_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
# [ doc = "Own Address enable register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOAEN_A { # [ doc = "0: The slave address defined in I2COA0 is disabled" ] DISABLE = 0 , # [ doc = "1: The slave address defined in I2COA0 is enabled" ] ENABLE = 1 } impl From < UCOAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOAEN`" ] pub type UCOAEN_R = crate :: R < bool , UCOAEN_A > ; impl UCOAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOAEN_A { match self . bits { false => UCOAEN_A :: DISABLE , true => UCOAEN_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCOAEN_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCOAEN_A :: ENABLE } }
# [ doc = "Write proxy for field `UCOAEN`" ] pub struct UCOAEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCOAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The slave address defined in I2COA0 is disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: DISABLE ) } # [ doc = "The slave address defined in I2COA0 is enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "General call response enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCGCEN_A { # [ doc = "0: Do not respond to a general call" ] UCGCEN_0 = 0 , # [ doc = "1: Respond to a general call" ] UCGCEN_1 = 1 } impl From < UCGCEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCGCEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCGCEN`" ] pub type UCGCEN_R = crate :: R < bool , UCGCEN_A > ; impl UCGCEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCGCEN_A { match self . bits { false => UCGCEN_A :: UCGCEN_0 , true => UCGCEN_A :: UCGCEN_1 } } # [ doc = "Checks if the value of the field is `UCGCEN_0`" ] # [ inline ( always ) ] pub fn is_ucgcen_0 ( & self ) -> bool { * self == UCGCEN_A :: UCGCEN_0 } # [ doc = "Checks if the value of the field is `UCGCEN_1`" ] # [ inline ( always ) ] pub fn is_ucgcen_1 ( & self ) -> bool { * self == UCGCEN_A :: UCGCEN_1 } }
# [ doc = "Write proxy for field `UCGCEN`" ] pub struct UCGCEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCGCEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCGCEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Do not respond to a general call" ] # [ inline ( always ) ] pub fn ucgcen_0 ( self ) -> & 'a mut W { self . variant ( UCGCEN_A :: UCGCEN_0 ) } # [ doc = "Respond to a general call" ] # [ inline ( always ) ] pub fn ucgcen_1 ( self ) -> & 'a mut W { self . variant ( UCGCEN_A :: UCGCEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa0 ( & self ) -> I2COA0_R { I2COA0_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & self ) -> UCOAEN_R { UCOAEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - General call response enable" ] # [ inline ( always ) ] pub fn ucgcen ( & self ) -> UCGCEN_R { UCGCEN_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa0 ( & mut self ) -> I2COA0_W { I2COA0_W { w : self } }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & mut self ) -> UCOAEN_W { UCOAEN_W { w : self } }
# [ doc = "Bit 15 - General call response enable" ] # [ inline ( always ) ] pub fn ucgcen ( & mut self ) -> UCGCEN_W { UCGCEN_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Own Address 1 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1i2coa1](ucb1i2coa1) module" ] pub type UCB1I2COA1 = crate :: Reg < u16 , _UCB1I2COA1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1I2COA1 ;
# [ doc = "`read()` method returns [ucb1i2coa1::R](ucb1i2coa1::R) reader structure" ] impl crate :: Readable for UCB1I2COA1 { }
# [ doc = "`write(|w| ..)` method takes [ucb1i2coa1::W](ucb1i2coa1::W) writer structure" ] impl crate :: Writable for UCB1I2COA1 { }
# [ doc = "eUSCI_Bx I2C Own Address 1 Register" ] pub mod ucb1i2coa1 {
# [ doc = "Reader of register UCB1I2COA1" ] pub type R = crate :: R < u16 , super :: UCB1I2COA1 > ;
# [ doc = "Writer for register UCB1I2COA1" ] pub type W = crate :: W < u16 , super :: UCB1I2COA1 > ;
# [ doc = "Register UCB1I2COA1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1I2COA1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `I2COA1`" ] pub type I2COA1_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `I2COA1`" ] pub struct I2COA1_W < 'a > { w : & 'a mut W , } impl < 'a > I2COA1_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
# [ doc = "Own Address enable register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOAEN_A { # [ doc = "0: The slave address defined in I2COA1 is disabled" ] DISABLE = 0 , # [ doc = "1: The slave address defined in I2COA1 is enabled" ] ENABLE = 1 } impl From < UCOAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOAEN`" ] pub type UCOAEN_R = crate :: R < bool , UCOAEN_A > ; impl UCOAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOAEN_A { match self . bits { false => UCOAEN_A :: DISABLE , true => UCOAEN_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCOAEN_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCOAEN_A :: ENABLE } }
# [ doc = "Write proxy for field `UCOAEN`" ] pub struct UCOAEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCOAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The slave address defined in I2COA1 is disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: DISABLE ) } # [ doc = "The slave address defined in I2COA1 is enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa1 ( & self ) -> I2COA1_R { I2COA1_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & self ) -> UCOAEN_R { UCOAEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa1 ( & mut self ) -> I2COA1_W { I2COA1_W { w : self } }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & mut self ) -> UCOAEN_W { UCOAEN_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Own Address 2 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1i2coa2](ucb1i2coa2) module" ] pub type UCB1I2COA2 = crate :: Reg < u16 , _UCB1I2COA2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1I2COA2 ;
# [ doc = "`read()` method returns [ucb1i2coa2::R](ucb1i2coa2::R) reader structure" ] impl crate :: Readable for UCB1I2COA2 { }
# [ doc = "`write(|w| ..)` method takes [ucb1i2coa2::W](ucb1i2coa2::W) writer structure" ] impl crate :: Writable for UCB1I2COA2 { }
# [ doc = "eUSCI_Bx I2C Own Address 2 Register" ] pub mod ucb1i2coa2 {
# [ doc = "Reader of register UCB1I2COA2" ] pub type R = crate :: R < u16 , super :: UCB1I2COA2 > ;
# [ doc = "Writer for register UCB1I2COA2" ] pub type W = crate :: W < u16 , super :: UCB1I2COA2 > ;
# [ doc = "Register UCB1I2COA2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1I2COA2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `I2COA2`" ] pub type I2COA2_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `I2COA2`" ] pub struct I2COA2_W < 'a > { w : & 'a mut W , } impl < 'a > I2COA2_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
# [ doc = "Own Address enable register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOAEN_A { # [ doc = "0: The slave address defined in I2COA2 is disabled" ] DISABLE = 0 , # [ doc = "1: The slave address defined in I2COA2 is enabled" ] ENABLE = 1 } impl From < UCOAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOAEN`" ] pub type UCOAEN_R = crate :: R < bool , UCOAEN_A > ; impl UCOAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOAEN_A { match self . bits { false => UCOAEN_A :: DISABLE , true => UCOAEN_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCOAEN_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCOAEN_A :: ENABLE } }
# [ doc = "Write proxy for field `UCOAEN`" ] pub struct UCOAEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCOAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The slave address defined in I2COA2 is disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: DISABLE ) } # [ doc = "The slave address defined in I2COA2 is enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa2 ( & self ) -> I2COA2_R { I2COA2_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & self ) -> UCOAEN_R { UCOAEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa2 ( & mut self ) -> I2COA2_W { I2COA2_W { w : self } }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & mut self ) -> UCOAEN_W { UCOAEN_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Own Address 3 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1i2coa3](ucb1i2coa3) module" ] pub type UCB1I2COA3 = crate :: Reg < u16 , _UCB1I2COA3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1I2COA3 ;
# [ doc = "`read()` method returns [ucb1i2coa3::R](ucb1i2coa3::R) reader structure" ] impl crate :: Readable for UCB1I2COA3 { }
# [ doc = "`write(|w| ..)` method takes [ucb1i2coa3::W](ucb1i2coa3::W) writer structure" ] impl crate :: Writable for UCB1I2COA3 { }
# [ doc = "eUSCI_Bx I2C Own Address 3 Register" ] pub mod ucb1i2coa3 {
# [ doc = "Reader of register UCB1I2COA3" ] pub type R = crate :: R < u16 , super :: UCB1I2COA3 > ;
# [ doc = "Writer for register UCB1I2COA3" ] pub type W = crate :: W < u16 , super :: UCB1I2COA3 > ;
# [ doc = "Register UCB1I2COA3 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1I2COA3 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `I2COA3`" ] pub type I2COA3_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `I2COA3`" ] pub struct I2COA3_W < 'a > { w : & 'a mut W , } impl < 'a > I2COA3_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
# [ doc = "Own Address enable register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCOAEN_A { # [ doc = "0: The slave address defined in I2COA3 is disabled" ] DISABLE = 0 , # [ doc = "1: The slave address defined in I2COA3 is enabled" ] ENABLE = 1 } impl From < UCOAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : UCOAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCOAEN`" ] pub type UCOAEN_R = crate :: R < bool , UCOAEN_A > ; impl UCOAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCOAEN_A { match self . bits { false => UCOAEN_A :: DISABLE , true => UCOAEN_A :: ENABLE } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == UCOAEN_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == UCOAEN_A :: ENABLE } }
# [ doc = "Write proxy for field `UCOAEN`" ] pub struct UCOAEN_W < 'a > { w : & 'a mut W , } impl < 'a > UCOAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCOAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The slave address defined in I2COA3 is disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: DISABLE ) } # [ doc = "The slave address defined in I2COA3 is enabled" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( UCOAEN_A :: ENABLE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa3 ( & self ) -> I2COA3_R { I2COA3_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & self ) -> UCOAEN_R { UCOAEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:9 - I2C own address" ] # [ inline ( always ) ] pub fn i2coa3 ( & mut self ) -> I2COA3_W { I2COA3_W { w : self } }
# [ doc = "Bit 10 - Own Address enable register" ] # [ inline ( always ) ] pub fn ucoaen ( & mut self ) -> UCOAEN_W { UCOAEN_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Received Address Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1addrx](ucb1addrx) module" ] pub type UCB1ADDRX = crate :: Reg < u16 , _UCB1ADDRX > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1ADDRX ;
# [ doc = "`read()` method returns [ucb1addrx::R](ucb1addrx::R) reader structure" ] impl crate :: Readable for UCB1ADDRX { }
# [ doc = "eUSCI_Bx I2C Received Address Register" ] pub mod ucb1addrx {
# [ doc = "Reader of register UCB1ADDRX" ] pub type R = crate :: R < u16 , super :: UCB1ADDRX > ;
# [ doc = "Reader of field `ADDRX`" ] pub type ADDRX_R = crate :: R < u16 , u16 > ;
impl R {
# [ doc = "Bits 0:9 - Received Address Register" ] # [ inline ( always ) ] pub fn addrx ( & self ) -> ADDRX_R { ADDRX_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
}
}
# [ doc = "eUSCI_Bx I2C Address Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1addmask](ucb1addmask) module" ] pub type UCB1ADDMASK = crate :: Reg < u16 , _UCB1ADDMASK > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1ADDMASK ;
# [ doc = "`read()` method returns [ucb1addmask::R](ucb1addmask::R) reader structure" ] impl crate :: Readable for UCB1ADDMASK { }
# [ doc = "`write(|w| ..)` method takes [ucb1addmask::W](ucb1addmask::W) writer structure" ] impl crate :: Writable for UCB1ADDMASK { }
# [ doc = "eUSCI_Bx I2C Address Mask Register" ] pub mod ucb1addmask {
# [ doc = "Reader of register UCB1ADDMASK" ] pub type R = crate :: R < u16 , super :: UCB1ADDMASK > ;
# [ doc = "Writer for register UCB1ADDMASK" ] pub type W = crate :: W < u16 , super :: UCB1ADDMASK > ;
# [ doc = "Register UCB1ADDMASK `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1ADDMASK { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ADDMASK`" ] pub type ADDMASK_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `ADDMASK`" ] pub struct ADDMASK_W < 'a > { w : & 'a mut W , } impl < 'a > ADDMASK_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - Address Mask Register. By clearing the corresponding bit of the own address, this bit is a don't care when comparing the address on the bus to the own address. Using this method, it is possible to react on more than one slave address. When all bits of ADDMASKx are set, the address mask feature is deactivated. Modify only when UCSWRST = 1." ] # [ inline ( always ) ] pub fn addmask ( & self ) -> ADDMASK_R { ADDMASK_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:9 - Address Mask Register. By clearing the corresponding bit of the own address, this bit is a don't care when comparing the address on the bus to the own address. Using this method, it is possible to react on more than one slave address. When all bits of ADDMASKx are set, the address mask feature is deactivated. Modify only when UCSWRST = 1." ] # [ inline ( always ) ] pub fn addmask ( & mut self ) -> ADDMASK_W { ADDMASK_W { w : self } }
}
}
# [ doc = "eUSCI_Bx I2C Slave Address Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1i2csa](ucb1i2csa) module" ] pub type UCB1I2CSA = crate :: Reg < u16 , _UCB1I2CSA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1I2CSA ;
# [ doc = "`read()` method returns [ucb1i2csa::R](ucb1i2csa::R) reader structure" ] impl crate :: Readable for UCB1I2CSA { }
# [ doc = "`write(|w| ..)` method takes [ucb1i2csa::W](ucb1i2csa::W) writer structure" ] impl crate :: Writable for UCB1I2CSA { }
# [ doc = "eUSCI_Bx I2C Slave Address Register" ] pub mod ucb1i2csa {
# [ doc = "Reader of register UCB1I2CSA" ] pub type R = crate :: R < u16 , super :: UCB1I2CSA > ;
# [ doc = "Writer for register UCB1I2CSA" ] pub type W = crate :: W < u16 , super :: UCB1I2CSA > ;
# [ doc = "Register UCB1I2CSA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1I2CSA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `I2CSA`" ] pub type I2CSA_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `I2CSA`" ] pub struct I2CSA_W < 'a > { w : & 'a mut W , } impl < 'a > I2CSA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03ff ) | ( ( value as u16 ) & 0x03ff ) ; self . w } }
impl R {
# [ doc = "Bits 0:9 - I2C slave address" ] # [ inline ( always ) ] pub fn i2csa ( & self ) -> I2CSA_R { I2CSA_R :: new ( ( self . bits & 0x03ff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:9 - I2C slave address" ] # [ inline ( always ) ] pub fn i2csa ( & mut self ) -> I2CSA_W { I2CSA_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1ie](ucb1ie) module" ] pub type UCB1IE = crate :: Reg < u16 , _UCB1IE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1IE ;
# [ doc = "`read()` method returns [ucb1ie::R](ucb1ie::R) reader structure" ] impl crate :: Readable for UCB1IE { }
# [ doc = "`write(|w| ..)` method takes [ucb1ie::W](ucb1ie::W) writer structure" ] impl crate :: Writable for UCB1IE { }
# [ doc = "eUSCI_Bx Interrupt Enable Register" ] pub mod ucb1ie {
# [ doc = "Reader of register UCB1IE" ] pub type R = crate :: R < u16 , super :: UCB1IE > ;
# [ doc = "Writer for register UCB1IE" ] pub type W = crate :: W < u16 , super :: UCB1IE > ;
# [ doc = "Register UCB1IE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1IE { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt enable 0\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE0_A { # [ doc = "0: Interrupt disabled" ] UCRXIE0_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE0_1 = 1 } impl From < UCRXIE0_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE0`" ] pub type UCRXIE0_R = crate :: R < bool , UCRXIE0_A > ; impl UCRXIE0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE0_A { match self . bits { false => UCRXIE0_A :: UCRXIE0_0 , true => UCRXIE0_A :: UCRXIE0_1 } } # [ doc = "Checks if the value of the field is `UCRXIE0_0`" ] # [ inline ( always ) ] pub fn is_ucrxie0_0 ( & self ) -> bool { * self == UCRXIE0_A :: UCRXIE0_0 } # [ doc = "Checks if the value of the field is `UCRXIE0_1`" ] # [ inline ( always ) ] pub fn is_ucrxie0_1 ( & self ) -> bool { * self == UCRXIE0_A :: UCRXIE0_1 } }
# [ doc = "Write proxy for field `UCRXIE0`" ] pub struct UCRXIE0_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie0_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE0_A :: UCRXIE0_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie0_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE0_A :: UCRXIE0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt enable 0\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE0_A { # [ doc = "0: Interrupt disabled" ] UCTXIE0_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE0_1 = 1 } impl From < UCTXIE0_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE0`" ] pub type UCTXIE0_R = crate :: R < bool , UCTXIE0_A > ; impl UCTXIE0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE0_A { match self . bits { false => UCTXIE0_A :: UCTXIE0_0 , true => UCTXIE0_A :: UCTXIE0_1 } } # [ doc = "Checks if the value of the field is `UCTXIE0_0`" ] # [ inline ( always ) ] pub fn is_uctxie0_0 ( & self ) -> bool { * self == UCTXIE0_A :: UCTXIE0_0 } # [ doc = "Checks if the value of the field is `UCTXIE0_1`" ] # [ inline ( always ) ] pub fn is_uctxie0_1 ( & self ) -> bool { * self == UCTXIE0_A :: UCTXIE0_1 } }
# [ doc = "Write proxy for field `UCTXIE0`" ] pub struct UCTXIE0_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie0_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE0_A :: UCTXIE0_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie0_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE0_A :: UCTXIE0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "START condition interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTTIE_A { # [ doc = "0: Interrupt disabled" ] UCSTTIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCSTTIE_1 = 1 } impl From < UCSTTIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTTIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTTIE`" ] pub type UCSTTIE_R = crate :: R < bool , UCSTTIE_A > ; impl UCSTTIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTTIE_A { match self . bits { false => UCSTTIE_A :: UCSTTIE_0 , true => UCSTTIE_A :: UCSTTIE_1 } } # [ doc = "Checks if the value of the field is `UCSTTIE_0`" ] # [ inline ( always ) ] pub fn is_ucsttie_0 ( & self ) -> bool { * self == UCSTTIE_A :: UCSTTIE_0 } # [ doc = "Checks if the value of the field is `UCSTTIE_1`" ] # [ inline ( always ) ] pub fn is_ucsttie_1 ( & self ) -> bool { * self == UCSTTIE_A :: UCSTTIE_1 } }
# [ doc = "Write proxy for field `UCSTTIE`" ] pub struct UCSTTIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTTIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTTIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucsttie_0 ( self ) -> & 'a mut W { self . variant ( UCSTTIE_A :: UCSTTIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucsttie_1 ( self ) -> & 'a mut W { self . variant ( UCSTTIE_A :: UCSTTIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "STOP condition interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTPIE_A { # [ doc = "0: Interrupt disabled" ] UCSTPIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCSTPIE_1 = 1 } impl From < UCSTPIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTPIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTPIE`" ] pub type UCSTPIE_R = crate :: R < bool , UCSTPIE_A > ; impl UCSTPIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTPIE_A { match self . bits { false => UCSTPIE_A :: UCSTPIE_0 , true => UCSTPIE_A :: UCSTPIE_1 } } # [ doc = "Checks if the value of the field is `UCSTPIE_0`" ] # [ inline ( always ) ] pub fn is_ucstpie_0 ( & self ) -> bool { * self == UCSTPIE_A :: UCSTPIE_0 } # [ doc = "Checks if the value of the field is `UCSTPIE_1`" ] # [ inline ( always ) ] pub fn is_ucstpie_1 ( & self ) -> bool { * self == UCSTPIE_A :: UCSTPIE_1 } }
# [ doc = "Write proxy for field `UCSTPIE`" ] pub struct UCSTPIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTPIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTPIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucstpie_0 ( self ) -> & 'a mut W { self . variant ( UCSTPIE_A :: UCSTPIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucstpie_1 ( self ) -> & 'a mut W { self . variant ( UCSTPIE_A :: UCSTPIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Arbitration lost interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCALIE_A { # [ doc = "0: Interrupt disabled" ] UCALIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCALIE_1 = 1 } impl From < UCALIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCALIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCALIE`" ] pub type UCALIE_R = crate :: R < bool , UCALIE_A > ; impl UCALIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCALIE_A { match self . bits { false => UCALIE_A :: UCALIE_0 , true => UCALIE_A :: UCALIE_1 } } # [ doc = "Checks if the value of the field is `UCALIE_0`" ] # [ inline ( always ) ] pub fn is_ucalie_0 ( & self ) -> bool { * self == UCALIE_A :: UCALIE_0 } # [ doc = "Checks if the value of the field is `UCALIE_1`" ] # [ inline ( always ) ] pub fn is_ucalie_1 ( & self ) -> bool { * self == UCALIE_A :: UCALIE_1 } }
# [ doc = "Write proxy for field `UCALIE`" ] pub struct UCALIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCALIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCALIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucalie_0 ( self ) -> & 'a mut W { self . variant ( UCALIE_A :: UCALIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucalie_1 ( self ) -> & 'a mut W { self . variant ( UCALIE_A :: UCALIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Not-acknowledge interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCNACKIE_A { # [ doc = "0: Interrupt disabled" ] UCNACKIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCNACKIE_1 = 1 } impl From < UCNACKIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCNACKIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCNACKIE`" ] pub type UCNACKIE_R = crate :: R < bool , UCNACKIE_A > ; impl UCNACKIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCNACKIE_A { match self . bits { false => UCNACKIE_A :: UCNACKIE_0 , true => UCNACKIE_A :: UCNACKIE_1 } } # [ doc = "Checks if the value of the field is `UCNACKIE_0`" ] # [ inline ( always ) ] pub fn is_ucnackie_0 ( & self ) -> bool { * self == UCNACKIE_A :: UCNACKIE_0 } # [ doc = "Checks if the value of the field is `UCNACKIE_1`" ] # [ inline ( always ) ] pub fn is_ucnackie_1 ( & self ) -> bool { * self == UCNACKIE_A :: UCNACKIE_1 } }
# [ doc = "Write proxy for field `UCNACKIE`" ] pub struct UCNACKIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCNACKIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCNACKIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucnackie_0 ( self ) -> & 'a mut W { self . variant ( UCNACKIE_A :: UCNACKIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucnackie_1 ( self ) -> & 'a mut W { self . variant ( UCNACKIE_A :: UCNACKIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Byte counter interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBCNTIE_A { # [ doc = "0: Interrupt disabled" ] UCBCNTIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCBCNTIE_1 = 1 } impl From < UCBCNTIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBCNTIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBCNTIE`" ] pub type UCBCNTIE_R = crate :: R < bool , UCBCNTIE_A > ; impl UCBCNTIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBCNTIE_A { match self . bits { false => UCBCNTIE_A :: UCBCNTIE_0 , true => UCBCNTIE_A :: UCBCNTIE_1 } } # [ doc = "Checks if the value of the field is `UCBCNTIE_0`" ] # [ inline ( always ) ] pub fn is_ucbcntie_0 ( & self ) -> bool { * self == UCBCNTIE_A :: UCBCNTIE_0 } # [ doc = "Checks if the value of the field is `UCBCNTIE_1`" ] # [ inline ( always ) ] pub fn is_ucbcntie_1 ( & self ) -> bool { * self == UCBCNTIE_A :: UCBCNTIE_1 } }
# [ doc = "Write proxy for field `UCBCNTIE`" ] pub struct UCBCNTIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCBCNTIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBCNTIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucbcntie_0 ( self ) -> & 'a mut W { self . variant ( UCBCNTIE_A :: UCBCNTIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucbcntie_1 ( self ) -> & 'a mut W { self . variant ( UCBCNTIE_A :: UCBCNTIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Clock low timeout interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCLTOIE_A { # [ doc = "0: Interrupt disabled" ] UCCLTOIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCCLTOIE_1 = 1 } impl From < UCCLTOIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCLTOIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCLTOIE`" ] pub type UCCLTOIE_R = crate :: R < bool , UCCLTOIE_A > ; impl UCCLTOIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCLTOIE_A { match self . bits { false => UCCLTOIE_A :: UCCLTOIE_0 , true => UCCLTOIE_A :: UCCLTOIE_1 } } # [ doc = "Checks if the value of the field is `UCCLTOIE_0`" ] # [ inline ( always ) ] pub fn is_uccltoie_0 ( & self ) -> bool { * self == UCCLTOIE_A :: UCCLTOIE_0 } # [ doc = "Checks if the value of the field is `UCCLTOIE_1`" ] # [ inline ( always ) ] pub fn is_uccltoie_1 ( & self ) -> bool { * self == UCCLTOIE_A :: UCCLTOIE_1 } }
# [ doc = "Write proxy for field `UCCLTOIE`" ] pub struct UCCLTOIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCCLTOIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCLTOIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uccltoie_0 ( self ) -> & 'a mut W { self . variant ( UCCLTOIE_A :: UCCLTOIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uccltoie_1 ( self ) -> & 'a mut W { self . variant ( UCCLTOIE_A :: UCCLTOIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Receive interrupt enable 1\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE1_A { # [ doc = "0: Interrupt disabled" ] UCRXIE1_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE1_1 = 1 } impl From < UCRXIE1_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE1_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE1`" ] pub type UCRXIE1_R = crate :: R < bool , UCRXIE1_A > ; impl UCRXIE1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE1_A { match self . bits { false => UCRXIE1_A :: UCRXIE1_0 , true => UCRXIE1_A :: UCRXIE1_1 } } # [ doc = "Checks if the value of the field is `UCRXIE1_0`" ] # [ inline ( always ) ] pub fn is_ucrxie1_0 ( & self ) -> bool { * self == UCRXIE1_A :: UCRXIE1_0 } # [ doc = "Checks if the value of the field is `UCRXIE1_1`" ] # [ inline ( always ) ] pub fn is_ucrxie1_1 ( & self ) -> bool { * self == UCRXIE1_A :: UCRXIE1_1 } }
# [ doc = "Write proxy for field `UCRXIE1`" ] pub struct UCRXIE1_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE1_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie1_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE1_A :: UCRXIE1_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie1_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE1_A :: UCRXIE1_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Transmit interrupt enable 1\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE1_A { # [ doc = "0: Interrupt disabled" ] UCTXIE1_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE1_1 = 1 } impl From < UCTXIE1_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE1_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE1`" ] pub type UCTXIE1_R = crate :: R < bool , UCTXIE1_A > ; impl UCTXIE1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE1_A { match self . bits { false => UCTXIE1_A :: UCTXIE1_0 , true => UCTXIE1_A :: UCTXIE1_1 } } # [ doc = "Checks if the value of the field is `UCTXIE1_0`" ] # [ inline ( always ) ] pub fn is_uctxie1_0 ( & self ) -> bool { * self == UCTXIE1_A :: UCTXIE1_0 } # [ doc = "Checks if the value of the field is `UCTXIE1_1`" ] # [ inline ( always ) ] pub fn is_uctxie1_1 ( & self ) -> bool { * self == UCTXIE1_A :: UCTXIE1_1 } }
# [ doc = "Write proxy for field `UCTXIE1`" ] pub struct UCTXIE1_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE1_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie1_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE1_A :: UCTXIE1_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie1_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE1_A :: UCTXIE1_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Receive interrupt enable 2\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE2_A { # [ doc = "0: Interrupt disabled" ] UCRXIE2_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE2_1 = 1 } impl From < UCRXIE2_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE2_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE2`" ] pub type UCRXIE2_R = crate :: R < bool , UCRXIE2_A > ; impl UCRXIE2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE2_A { match self . bits { false => UCRXIE2_A :: UCRXIE2_0 , true => UCRXIE2_A :: UCRXIE2_1 } } # [ doc = "Checks if the value of the field is `UCRXIE2_0`" ] # [ inline ( always ) ] pub fn is_ucrxie2_0 ( & self ) -> bool { * self == UCRXIE2_A :: UCRXIE2_0 } # [ doc = "Checks if the value of the field is `UCRXIE2_1`" ] # [ inline ( always ) ] pub fn is_ucrxie2_1 ( & self ) -> bool { * self == UCRXIE2_A :: UCRXIE2_1 } }
# [ doc = "Write proxy for field `UCRXIE2`" ] pub struct UCRXIE2_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE2_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie2_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE2_A :: UCRXIE2_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie2_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE2_A :: UCRXIE2_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Transmit interrupt enable 2\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE2_A { # [ doc = "0: Interrupt disabled" ] UCTXIE2_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE2_1 = 1 } impl From < UCTXIE2_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE2_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE2`" ] pub type UCTXIE2_R = crate :: R < bool , UCTXIE2_A > ; impl UCTXIE2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE2_A { match self . bits { false => UCTXIE2_A :: UCTXIE2_0 , true => UCTXIE2_A :: UCTXIE2_1 } } # [ doc = "Checks if the value of the field is `UCTXIE2_0`" ] # [ inline ( always ) ] pub fn is_uctxie2_0 ( & self ) -> bool { * self == UCTXIE2_A :: UCTXIE2_0 } # [ doc = "Checks if the value of the field is `UCTXIE2_1`" ] # [ inline ( always ) ] pub fn is_uctxie2_1 ( & self ) -> bool { * self == UCTXIE2_A :: UCTXIE2_1 } }
# [ doc = "Write proxy for field `UCTXIE2`" ] pub struct UCTXIE2_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE2_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie2_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE2_A :: UCTXIE2_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie2_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE2_A :: UCTXIE2_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Receive interrupt enable 3\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE3_A { # [ doc = "0: Interrupt disabled" ] UCRXIE3_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE3_1 = 1 } impl From < UCRXIE3_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE3_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE3`" ] pub type UCRXIE3_R = crate :: R < bool , UCRXIE3_A > ; impl UCRXIE3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE3_A { match self . bits { false => UCRXIE3_A :: UCRXIE3_0 , true => UCRXIE3_A :: UCRXIE3_1 } } # [ doc = "Checks if the value of the field is `UCRXIE3_0`" ] # [ inline ( always ) ] pub fn is_ucrxie3_0 ( & self ) -> bool { * self == UCRXIE3_A :: UCRXIE3_0 } # [ doc = "Checks if the value of the field is `UCRXIE3_1`" ] # [ inline ( always ) ] pub fn is_ucrxie3_1 ( & self ) -> bool { * self == UCRXIE3_A :: UCRXIE3_1 } }
# [ doc = "Write proxy for field `UCRXIE3`" ] pub struct UCRXIE3_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE3_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE3_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie3_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE3_A :: UCRXIE3_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie3_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE3_A :: UCRXIE3_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Transmit interrupt enable 3\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE3_A { # [ doc = "0: Interrupt disabled" ] UCTXIE3_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE3_1 = 1 } impl From < UCTXIE3_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE3_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE3`" ] pub type UCTXIE3_R = crate :: R < bool , UCTXIE3_A > ; impl UCTXIE3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE3_A { match self . bits { false => UCTXIE3_A :: UCTXIE3_0 , true => UCTXIE3_A :: UCTXIE3_1 } } # [ doc = "Checks if the value of the field is `UCTXIE3_0`" ] # [ inline ( always ) ] pub fn is_uctxie3_0 ( & self ) -> bool { * self == UCTXIE3_A :: UCTXIE3_0 } # [ doc = "Checks if the value of the field is `UCTXIE3_1`" ] # [ inline ( always ) ] pub fn is_uctxie3_1 ( & self ) -> bool { * self == UCTXIE3_A :: UCTXIE3_1 } }
# [ doc = "Write proxy for field `UCTXIE3`" ] pub struct UCTXIE3_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE3_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE3_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie3_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE3_A :: UCTXIE3_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie3_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE3_A :: UCTXIE3_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Bit position 9 interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBIT9IE_A { # [ doc = "0: Interrupt disabled" ] UCBIT9IE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCBIT9IE_1 = 1 } impl From < UCBIT9IE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBIT9IE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBIT9IE`" ] pub type UCBIT9IE_R = crate :: R < bool , UCBIT9IE_A > ; impl UCBIT9IE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBIT9IE_A { match self . bits { false => UCBIT9IE_A :: UCBIT9IE_0 , true => UCBIT9IE_A :: UCBIT9IE_1 } } # [ doc = "Checks if the value of the field is `UCBIT9IE_0`" ] # [ inline ( always ) ] pub fn is_ucbit9ie_0 ( & self ) -> bool { * self == UCBIT9IE_A :: UCBIT9IE_0 } # [ doc = "Checks if the value of the field is `UCBIT9IE_1`" ] # [ inline ( always ) ] pub fn is_ucbit9ie_1 ( & self ) -> bool { * self == UCBIT9IE_A :: UCBIT9IE_1 } }
# [ doc = "Write proxy for field `UCBIT9IE`" ] pub struct UCBIT9IE_W < 'a > { w : & 'a mut W , } impl < 'a > UCBIT9IE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBIT9IE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucbit9ie_0 ( self ) -> & 'a mut W { self . variant ( UCBIT9IE_A :: UCBIT9IE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucbit9ie_1 ( self ) -> & 'a mut W { self . variant ( UCBIT9IE_A :: UCBIT9IE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt enable 0" ] # [ inline ( always ) ] pub fn ucrxie0 ( & self ) -> UCRXIE0_R { UCRXIE0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt enable 0" ] # [ inline ( always ) ] pub fn uctxie0 ( & self ) -> UCTXIE0_R { UCTXIE0_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - START condition interrupt enable" ] # [ inline ( always ) ] pub fn ucsttie ( & self ) -> UCSTTIE_R { UCSTTIE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - STOP condition interrupt enable" ] # [ inline ( always ) ] pub fn ucstpie ( & self ) -> UCSTPIE_R { UCSTPIE_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Arbitration lost interrupt enable" ] # [ inline ( always ) ] pub fn ucalie ( & self ) -> UCALIE_R { UCALIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Not-acknowledge interrupt enable" ] # [ inline ( always ) ] pub fn ucnackie ( & self ) -> UCNACKIE_R { UCNACKIE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Byte counter interrupt enable" ] # [ inline ( always ) ] pub fn ucbcntie ( & self ) -> UCBCNTIE_R { UCBCNTIE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Clock low timeout interrupt enable" ] # [ inline ( always ) ] pub fn uccltoie ( & self ) -> UCCLTOIE_R { UCCLTOIE_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Receive interrupt enable 1" ] # [ inline ( always ) ] pub fn ucrxie1 ( & self ) -> UCRXIE1_R { UCRXIE1_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Transmit interrupt enable 1" ] # [ inline ( always ) ] pub fn uctxie1 ( & self ) -> UCTXIE1_R { UCTXIE1_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Receive interrupt enable 2" ] # [ inline ( always ) ] pub fn ucrxie2 ( & self ) -> UCRXIE2_R { UCRXIE2_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Transmit interrupt enable 2" ] # [ inline ( always ) ] pub fn uctxie2 ( & self ) -> UCTXIE2_R { UCTXIE2_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Receive interrupt enable 3" ] # [ inline ( always ) ] pub fn ucrxie3 ( & self ) -> UCRXIE3_R { UCRXIE3_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Transmit interrupt enable 3" ] # [ inline ( always ) ] pub fn uctxie3 ( & self ) -> UCTXIE3_R { UCTXIE3_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Bit position 9 interrupt enable" ] # [ inline ( always ) ] pub fn ucbit9ie ( & self ) -> UCBIT9IE_R { UCBIT9IE_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt enable 0" ] # [ inline ( always ) ] pub fn ucrxie0 ( & mut self ) -> UCRXIE0_W { UCRXIE0_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt enable 0" ] # [ inline ( always ) ] pub fn uctxie0 ( & mut self ) -> UCTXIE0_W { UCTXIE0_W { w : self } }
# [ doc = "Bit 2 - START condition interrupt enable" ] # [ inline ( always ) ] pub fn ucsttie ( & mut self ) -> UCSTTIE_W { UCSTTIE_W { w : self } }
# [ doc = "Bit 3 - STOP condition interrupt enable" ] # [ inline ( always ) ] pub fn ucstpie ( & mut self ) -> UCSTPIE_W { UCSTPIE_W { w : self } }
# [ doc = "Bit 4 - Arbitration lost interrupt enable" ] # [ inline ( always ) ] pub fn ucalie ( & mut self ) -> UCALIE_W { UCALIE_W { w : self } }
# [ doc = "Bit 5 - Not-acknowledge interrupt enable" ] # [ inline ( always ) ] pub fn ucnackie ( & mut self ) -> UCNACKIE_W { UCNACKIE_W { w : self } }
# [ doc = "Bit 6 - Byte counter interrupt enable" ] # [ inline ( always ) ] pub fn ucbcntie ( & mut self ) -> UCBCNTIE_W { UCBCNTIE_W { w : self } }
# [ doc = "Bit 7 - Clock low timeout interrupt enable" ] # [ inline ( always ) ] pub fn uccltoie ( & mut self ) -> UCCLTOIE_W { UCCLTOIE_W { w : self } }
# [ doc = "Bit 8 - Receive interrupt enable 1" ] # [ inline ( always ) ] pub fn ucrxie1 ( & mut self ) -> UCRXIE1_W { UCRXIE1_W { w : self } }
# [ doc = "Bit 9 - Transmit interrupt enable 1" ] # [ inline ( always ) ] pub fn uctxie1 ( & mut self ) -> UCTXIE1_W { UCTXIE1_W { w : self } }
# [ doc = "Bit 10 - Receive interrupt enable 2" ] # [ inline ( always ) ] pub fn ucrxie2 ( & mut self ) -> UCRXIE2_W { UCRXIE2_W { w : self } }
# [ doc = "Bit 11 - Transmit interrupt enable 2" ] # [ inline ( always ) ] pub fn uctxie2 ( & mut self ) -> UCTXIE2_W { UCTXIE2_W { w : self } }
# [ doc = "Bit 12 - Receive interrupt enable 3" ] # [ inline ( always ) ] pub fn ucrxie3 ( & mut self ) -> UCRXIE3_W { UCRXIE3_W { w : self } }
# [ doc = "Bit 13 - Transmit interrupt enable 3" ] # [ inline ( always ) ] pub fn uctxie3 ( & mut self ) -> UCTXIE3_W { UCTXIE3_W { w : self } }
# [ doc = "Bit 14 - Bit position 9 interrupt enable" ] # [ inline ( always ) ] pub fn ucbit9ie ( & mut self ) -> UCBIT9IE_W { UCBIT9IE_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1ie_spi](ucb1ie_spi) module" ] pub type UCB1IE_SPI = crate :: Reg < u16 , _UCB1IE_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1IE_SPI ;
# [ doc = "`read()` method returns [ucb1ie_spi::R](ucb1ie_spi::R) reader structure" ] impl crate :: Readable for UCB1IE_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb1ie_spi::W](ucb1ie_spi::W) writer structure" ] impl crate :: Writable for UCB1IE_SPI { }
# [ doc = "eUSCI_Bx Interrupt Enable Register" ] pub mod ucb1ie_spi {
# [ doc = "Reader of register UCB1IE_SPI" ] pub type R = crate :: R < u16 , super :: UCB1IE_SPI > ;
# [ doc = "Writer for register UCB1IE_SPI" ] pub type W = crate :: W < u16 , super :: UCB1IE_SPI > ;
# [ doc = "Register UCB1IE_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1IE_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIE_A { # [ doc = "0: Interrupt disabled" ] UCRXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCRXIE_1 = 1 } impl From < UCRXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIE`" ] pub type UCRXIE_R = crate :: R < bool , UCRXIE_A > ; impl UCRXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIE_A { match self . bits { false => UCRXIE_A :: UCRXIE_0 , true => UCRXIE_A :: UCRXIE_1 } } # [ doc = "Checks if the value of the field is `UCRXIE_0`" ] # [ inline ( always ) ] pub fn is_ucrxie_0 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_0 } # [ doc = "Checks if the value of the field is `UCRXIE_1`" ] # [ inline ( always ) ] pub fn is_ucrxie_1 ( & self ) -> bool { * self == UCRXIE_A :: UCRXIE_1 } }
# [ doc = "Write proxy for field `UCRXIE`" ] pub struct UCRXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn ucrxie_0 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn ucrxie_1 ( self ) -> & 'a mut W { self . variant ( UCRXIE_A :: UCRXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIE_A { # [ doc = "0: Interrupt disabled" ] UCTXIE_0 = 0 , # [ doc = "1: Interrupt enabled" ] UCTXIE_1 = 1 } impl From < UCTXIE_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIE`" ] pub type UCTXIE_R = crate :: R < bool , UCTXIE_A > ; impl UCTXIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIE_A { match self . bits { false => UCTXIE_A :: UCTXIE_0 , true => UCTXIE_A :: UCTXIE_1 } } # [ doc = "Checks if the value of the field is `UCTXIE_0`" ] # [ inline ( always ) ] pub fn is_uctxie_0 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_0 } # [ doc = "Checks if the value of the field is `UCTXIE_1`" ] # [ inline ( always ) ] pub fn is_uctxie_1 ( & self ) -> bool { * self == UCTXIE_A :: UCTXIE_1 } }
# [ doc = "Write proxy for field `UCTXIE`" ] pub struct UCTXIE_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt disabled" ] # [ inline ( always ) ] pub fn uctxie_0 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_0 ) } # [ doc = "Interrupt enabled" ] # [ inline ( always ) ] pub fn uctxie_1 ( self ) -> & 'a mut W { self . variant ( UCTXIE_A :: UCTXIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & self ) -> UCRXIE_R { UCRXIE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & self ) -> UCTXIE_R { UCTXIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt enable" ] # [ inline ( always ) ] pub fn ucrxie ( & mut self ) -> UCRXIE_W { UCRXIE_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt enable" ] # [ inline ( always ) ] pub fn uctxie ( & mut self ) -> UCTXIE_W { UCTXIE_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1ifg](ucb1ifg) module" ] pub type UCB1IFG = crate :: Reg < u16 , _UCB1IFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1IFG ;
# [ doc = "`read()` method returns [ucb1ifg::R](ucb1ifg::R) reader structure" ] impl crate :: Readable for UCB1IFG { }
# [ doc = "`write(|w| ..)` method takes [ucb1ifg::W](ucb1ifg::W) writer structure" ] impl crate :: Writable for UCB1IFG { }
# [ doc = "eUSCI_Bx Interrupt Flag Register" ] pub mod ucb1ifg {
# [ doc = "Reader of register UCB1IFG" ] pub type R = crate :: R < u16 , super :: UCB1IFG > ;
# [ doc = "Writer for register UCB1IFG" ] pub type W = crate :: W < u16 , super :: UCB1IFG > ;
# [ doc = "Register UCB1IFG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1IFG { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "eUSCI_B receive interrupt flag 0\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG0_A { # [ doc = "0: No interrupt pending" ] UCRXIFG0_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG0_1 = 1 } impl From < UCRXIFG0_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG0`" ] pub type UCRXIFG0_R = crate :: R < bool , UCRXIFG0_A > ; impl UCRXIFG0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG0_A { match self . bits { false => UCRXIFG0_A :: UCRXIFG0_0 , true => UCRXIFG0_A :: UCRXIFG0_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG0_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg0_0 ( & self ) -> bool { * self == UCRXIFG0_A :: UCRXIFG0_0 } # [ doc = "Checks if the value of the field is `UCRXIFG0_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg0_1 ( & self ) -> bool { * self == UCRXIFG0_A :: UCRXIFG0_1 } }
# [ doc = "Write proxy for field `UCRXIFG0`" ] pub struct UCRXIFG0_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg0_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG0_A :: UCRXIFG0_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg0_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG0_A :: UCRXIFG0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "eUSCI_B transmit interrupt flag 0\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG0_A { # [ doc = "0: No interrupt pending" ] UCTXIFG0_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG0_1 = 1 } impl From < UCTXIFG0_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG0`" ] pub type UCTXIFG0_R = crate :: R < bool , UCTXIFG0_A > ; impl UCTXIFG0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG0_A { match self . bits { false => UCTXIFG0_A :: UCTXIFG0_0 , true => UCTXIFG0_A :: UCTXIFG0_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG0_0`" ] # [ inline ( always ) ] pub fn is_uctxifg0_0 ( & self ) -> bool { * self == UCTXIFG0_A :: UCTXIFG0_0 } # [ doc = "Checks if the value of the field is `UCTXIFG0_1`" ] # [ inline ( always ) ] pub fn is_uctxifg0_1 ( & self ) -> bool { * self == UCTXIFG0_A :: UCTXIFG0_1 } }
# [ doc = "Write proxy for field `UCTXIFG0`" ] pub struct UCTXIFG0_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg0_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG0_A :: UCTXIFG0_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg0_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG0_A :: UCTXIFG0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "START condition interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTTIFG_A { # [ doc = "0: No interrupt pending" ] UCSTTIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCSTTIFG_1 = 1 } impl From < UCSTTIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTTIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTTIFG`" ] pub type UCSTTIFG_R = crate :: R < bool , UCSTTIFG_A > ; impl UCSTTIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTTIFG_A { match self . bits { false => UCSTTIFG_A :: UCSTTIFG_0 , true => UCSTTIFG_A :: UCSTTIFG_1 } } # [ doc = "Checks if the value of the field is `UCSTTIFG_0`" ] # [ inline ( always ) ] pub fn is_ucsttifg_0 ( & self ) -> bool { * self == UCSTTIFG_A :: UCSTTIFG_0 } # [ doc = "Checks if the value of the field is `UCSTTIFG_1`" ] # [ inline ( always ) ] pub fn is_ucsttifg_1 ( & self ) -> bool { * self == UCSTTIFG_A :: UCSTTIFG_1 } }
# [ doc = "Write proxy for field `UCSTTIFG`" ] pub struct UCSTTIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTTIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTTIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucsttifg_0 ( self ) -> & 'a mut W { self . variant ( UCSTTIFG_A :: UCSTTIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucsttifg_1 ( self ) -> & 'a mut W { self . variant ( UCSTTIFG_A :: UCSTTIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "STOP condition interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCSTPIFG_A { # [ doc = "0: No interrupt pending" ] UCSTPIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCSTPIFG_1 = 1 } impl From < UCSTPIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCSTPIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCSTPIFG`" ] pub type UCSTPIFG_R = crate :: R < bool , UCSTPIFG_A > ; impl UCSTPIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCSTPIFG_A { match self . bits { false => UCSTPIFG_A :: UCSTPIFG_0 , true => UCSTPIFG_A :: UCSTPIFG_1 } } # [ doc = "Checks if the value of the field is `UCSTPIFG_0`" ] # [ inline ( always ) ] pub fn is_ucstpifg_0 ( & self ) -> bool { * self == UCSTPIFG_A :: UCSTPIFG_0 } # [ doc = "Checks if the value of the field is `UCSTPIFG_1`" ] # [ inline ( always ) ] pub fn is_ucstpifg_1 ( & self ) -> bool { * self == UCSTPIFG_A :: UCSTPIFG_1 } }
# [ doc = "Write proxy for field `UCSTPIFG`" ] pub struct UCSTPIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCSTPIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCSTPIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucstpifg_0 ( self ) -> & 'a mut W { self . variant ( UCSTPIFG_A :: UCSTPIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucstpifg_1 ( self ) -> & 'a mut W { self . variant ( UCSTPIFG_A :: UCSTPIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Arbitration lost interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCALIFG_A { # [ doc = "0: No interrupt pending" ] UCALIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCALIFG_1 = 1 } impl From < UCALIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCALIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCALIFG`" ] pub type UCALIFG_R = crate :: R < bool , UCALIFG_A > ; impl UCALIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCALIFG_A { match self . bits { false => UCALIFG_A :: UCALIFG_0 , true => UCALIFG_A :: UCALIFG_1 } } # [ doc = "Checks if the value of the field is `UCALIFG_0`" ] # [ inline ( always ) ] pub fn is_ucalifg_0 ( & self ) -> bool { * self == UCALIFG_A :: UCALIFG_0 } # [ doc = "Checks if the value of the field is `UCALIFG_1`" ] # [ inline ( always ) ] pub fn is_ucalifg_1 ( & self ) -> bool { * self == UCALIFG_A :: UCALIFG_1 } }
# [ doc = "Write proxy for field `UCALIFG`" ] pub struct UCALIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCALIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCALIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucalifg_0 ( self ) -> & 'a mut W { self . variant ( UCALIFG_A :: UCALIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucalifg_1 ( self ) -> & 'a mut W { self . variant ( UCALIFG_A :: UCALIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Not-acknowledge received interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCNACKIFG_A { # [ doc = "0: No interrupt pending" ] UCNACKIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCNACKIFG_1 = 1 } impl From < UCNACKIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCNACKIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCNACKIFG`" ] pub type UCNACKIFG_R = crate :: R < bool , UCNACKIFG_A > ; impl UCNACKIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCNACKIFG_A { match self . bits { false => UCNACKIFG_A :: UCNACKIFG_0 , true => UCNACKIFG_A :: UCNACKIFG_1 } } # [ doc = "Checks if the value of the field is `UCNACKIFG_0`" ] # [ inline ( always ) ] pub fn is_ucnackifg_0 ( & self ) -> bool { * self == UCNACKIFG_A :: UCNACKIFG_0 } # [ doc = "Checks if the value of the field is `UCNACKIFG_1`" ] # [ inline ( always ) ] pub fn is_ucnackifg_1 ( & self ) -> bool { * self == UCNACKIFG_A :: UCNACKIFG_1 } }
# [ doc = "Write proxy for field `UCNACKIFG`" ] pub struct UCNACKIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCNACKIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCNACKIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucnackifg_0 ( self ) -> & 'a mut W { self . variant ( UCNACKIFG_A :: UCNACKIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucnackifg_1 ( self ) -> & 'a mut W { self . variant ( UCNACKIFG_A :: UCNACKIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Byte counter interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBCNTIFG_A { # [ doc = "0: No interrupt pending" ] UCBCNTIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCBCNTIFG_1 = 1 } impl From < UCBCNTIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBCNTIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBCNTIFG`" ] pub type UCBCNTIFG_R = crate :: R < bool , UCBCNTIFG_A > ; impl UCBCNTIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBCNTIFG_A { match self . bits { false => UCBCNTIFG_A :: UCBCNTIFG_0 , true => UCBCNTIFG_A :: UCBCNTIFG_1 } } # [ doc = "Checks if the value of the field is `UCBCNTIFG_0`" ] # [ inline ( always ) ] pub fn is_ucbcntifg_0 ( & self ) -> bool { * self == UCBCNTIFG_A :: UCBCNTIFG_0 } # [ doc = "Checks if the value of the field is `UCBCNTIFG_1`" ] # [ inline ( always ) ] pub fn is_ucbcntifg_1 ( & self ) -> bool { * self == UCBCNTIFG_A :: UCBCNTIFG_1 } }
# [ doc = "Write proxy for field `UCBCNTIFG`" ] pub struct UCBCNTIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCBCNTIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBCNTIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucbcntifg_0 ( self ) -> & 'a mut W { self . variant ( UCBCNTIFG_A :: UCBCNTIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucbcntifg_1 ( self ) -> & 'a mut W { self . variant ( UCBCNTIFG_A :: UCBCNTIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Clock low timeout interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCCLTOIFG_A { # [ doc = "0: No interrupt pending" ] UCCLTOIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCCLTOIFG_1 = 1 } impl From < UCCLTOIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCCLTOIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCCLTOIFG`" ] pub type UCCLTOIFG_R = crate :: R < bool , UCCLTOIFG_A > ; impl UCCLTOIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCCLTOIFG_A { match self . bits { false => UCCLTOIFG_A :: UCCLTOIFG_0 , true => UCCLTOIFG_A :: UCCLTOIFG_1 } } # [ doc = "Checks if the value of the field is `UCCLTOIFG_0`" ] # [ inline ( always ) ] pub fn is_uccltoifg_0 ( & self ) -> bool { * self == UCCLTOIFG_A :: UCCLTOIFG_0 } # [ doc = "Checks if the value of the field is `UCCLTOIFG_1`" ] # [ inline ( always ) ] pub fn is_uccltoifg_1 ( & self ) -> bool { * self == UCCLTOIFG_A :: UCCLTOIFG_1 } }
# [ doc = "Write proxy for field `UCCLTOIFG`" ] pub struct UCCLTOIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCCLTOIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCCLTOIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uccltoifg_0 ( self ) -> & 'a mut W { self . variant ( UCCLTOIFG_A :: UCCLTOIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uccltoifg_1 ( self ) -> & 'a mut W { self . variant ( UCCLTOIFG_A :: UCCLTOIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "eUSCI_B receive interrupt flag 1\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG1_A { # [ doc = "0: No interrupt pending" ] UCRXIFG1_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG1_1 = 1 } impl From < UCRXIFG1_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG1_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG1`" ] pub type UCRXIFG1_R = crate :: R < bool , UCRXIFG1_A > ; impl UCRXIFG1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG1_A { match self . bits { false => UCRXIFG1_A :: UCRXIFG1_0 , true => UCRXIFG1_A :: UCRXIFG1_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG1_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg1_0 ( & self ) -> bool { * self == UCRXIFG1_A :: UCRXIFG1_0 } # [ doc = "Checks if the value of the field is `UCRXIFG1_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg1_1 ( & self ) -> bool { * self == UCRXIFG1_A :: UCRXIFG1_1 } }
# [ doc = "Write proxy for field `UCRXIFG1`" ] pub struct UCRXIFG1_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG1_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg1_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG1_A :: UCRXIFG1_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg1_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG1_A :: UCRXIFG1_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "eUSCI_B transmit interrupt flag 1\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG1_A { # [ doc = "0: No interrupt pending" ] UCTXIFG1_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG1_1 = 1 } impl From < UCTXIFG1_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG1_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG1`" ] pub type UCTXIFG1_R = crate :: R < bool , UCTXIFG1_A > ; impl UCTXIFG1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG1_A { match self . bits { false => UCTXIFG1_A :: UCTXIFG1_0 , true => UCTXIFG1_A :: UCTXIFG1_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG1_0`" ] # [ inline ( always ) ] pub fn is_uctxifg1_0 ( & self ) -> bool { * self == UCTXIFG1_A :: UCTXIFG1_0 } # [ doc = "Checks if the value of the field is `UCTXIFG1_1`" ] # [ inline ( always ) ] pub fn is_uctxifg1_1 ( & self ) -> bool { * self == UCTXIFG1_A :: UCTXIFG1_1 } }
# [ doc = "Write proxy for field `UCTXIFG1`" ] pub struct UCTXIFG1_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG1_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg1_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG1_A :: UCTXIFG1_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg1_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG1_A :: UCTXIFG1_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "eUSCI_B receive interrupt flag 2\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG2_A { # [ doc = "0: No interrupt pending" ] UCRXIFG2_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG2_1 = 1 } impl From < UCRXIFG2_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG2_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG2`" ] pub type UCRXIFG2_R = crate :: R < bool , UCRXIFG2_A > ; impl UCRXIFG2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG2_A { match self . bits { false => UCRXIFG2_A :: UCRXIFG2_0 , true => UCRXIFG2_A :: UCRXIFG2_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG2_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg2_0 ( & self ) -> bool { * self == UCRXIFG2_A :: UCRXIFG2_0 } # [ doc = "Checks if the value of the field is `UCRXIFG2_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg2_1 ( & self ) -> bool { * self == UCRXIFG2_A :: UCRXIFG2_1 } }
# [ doc = "Write proxy for field `UCRXIFG2`" ] pub struct UCRXIFG2_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG2_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg2_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG2_A :: UCRXIFG2_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg2_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG2_A :: UCRXIFG2_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "eUSCI_B transmit interrupt flag 2\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG2_A { # [ doc = "0: No interrupt pending" ] UCTXIFG2_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG2_1 = 1 } impl From < UCTXIFG2_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG2_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG2`" ] pub type UCTXIFG2_R = crate :: R < bool , UCTXIFG2_A > ; impl UCTXIFG2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG2_A { match self . bits { false => UCTXIFG2_A :: UCTXIFG2_0 , true => UCTXIFG2_A :: UCTXIFG2_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG2_0`" ] # [ inline ( always ) ] pub fn is_uctxifg2_0 ( & self ) -> bool { * self == UCTXIFG2_A :: UCTXIFG2_0 } # [ doc = "Checks if the value of the field is `UCTXIFG2_1`" ] # [ inline ( always ) ] pub fn is_uctxifg2_1 ( & self ) -> bool { * self == UCTXIFG2_A :: UCTXIFG2_1 } }
# [ doc = "Write proxy for field `UCTXIFG2`" ] pub struct UCTXIFG2_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG2_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg2_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG2_A :: UCTXIFG2_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg2_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG2_A :: UCTXIFG2_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "eUSCI_B receive interrupt flag 3\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG3_A { # [ doc = "0: No interrupt pending" ] UCRXIFG3_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG3_1 = 1 } impl From < UCRXIFG3_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG3_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG3`" ] pub type UCRXIFG3_R = crate :: R < bool , UCRXIFG3_A > ; impl UCRXIFG3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG3_A { match self . bits { false => UCRXIFG3_A :: UCRXIFG3_0 , true => UCRXIFG3_A :: UCRXIFG3_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG3_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg3_0 ( & self ) -> bool { * self == UCRXIFG3_A :: UCRXIFG3_0 } # [ doc = "Checks if the value of the field is `UCRXIFG3_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg3_1 ( & self ) -> bool { * self == UCRXIFG3_A :: UCRXIFG3_1 } }
# [ doc = "Write proxy for field `UCRXIFG3`" ] pub struct UCRXIFG3_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG3_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG3_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg3_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG3_A :: UCRXIFG3_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg3_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG3_A :: UCRXIFG3_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "eUSCI_B transmit interrupt flag 3\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG3_A { # [ doc = "0: No interrupt pending" ] UCTXIFG3_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG3_1 = 1 } impl From < UCTXIFG3_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG3_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG3`" ] pub type UCTXIFG3_R = crate :: R < bool , UCTXIFG3_A > ; impl UCTXIFG3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG3_A { match self . bits { false => UCTXIFG3_A :: UCTXIFG3_0 , true => UCTXIFG3_A :: UCTXIFG3_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG3_0`" ] # [ inline ( always ) ] pub fn is_uctxifg3_0 ( & self ) -> bool { * self == UCTXIFG3_A :: UCTXIFG3_0 } # [ doc = "Checks if the value of the field is `UCTXIFG3_1`" ] # [ inline ( always ) ] pub fn is_uctxifg3_1 ( & self ) -> bool { * self == UCTXIFG3_A :: UCTXIFG3_1 } }
# [ doc = "Write proxy for field `UCTXIFG3`" ] pub struct UCTXIFG3_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG3_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG3_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg3_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG3_A :: UCTXIFG3_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg3_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG3_A :: UCTXIFG3_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Bit position 9 interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCBIT9IFG_A { # [ doc = "0: No interrupt pending" ] UCBIT9IFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCBIT9IFG_1 = 1 } impl From < UCBIT9IFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCBIT9IFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCBIT9IFG`" ] pub type UCBIT9IFG_R = crate :: R < bool , UCBIT9IFG_A > ; impl UCBIT9IFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCBIT9IFG_A { match self . bits { false => UCBIT9IFG_A :: UCBIT9IFG_0 , true => UCBIT9IFG_A :: UCBIT9IFG_1 } } # [ doc = "Checks if the value of the field is `UCBIT9IFG_0`" ] # [ inline ( always ) ] pub fn is_ucbit9ifg_0 ( & self ) -> bool { * self == UCBIT9IFG_A :: UCBIT9IFG_0 } # [ doc = "Checks if the value of the field is `UCBIT9IFG_1`" ] # [ inline ( always ) ] pub fn is_ucbit9ifg_1 ( & self ) -> bool { * self == UCBIT9IFG_A :: UCBIT9IFG_1 } }
# [ doc = "Write proxy for field `UCBIT9IFG`" ] pub struct UCBIT9IFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCBIT9IFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCBIT9IFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucbit9ifg_0 ( self ) -> & 'a mut W { self . variant ( UCBIT9IFG_A :: UCBIT9IFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucbit9ifg_1 ( self ) -> & 'a mut W { self . variant ( UCBIT9IFG_A :: UCBIT9IFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - eUSCI_B receive interrupt flag 0" ] # [ inline ( always ) ] pub fn ucrxifg0 ( & self ) -> UCRXIFG0_R { UCRXIFG0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - eUSCI_B transmit interrupt flag 0" ] # [ inline ( always ) ] pub fn uctxifg0 ( & self ) -> UCTXIFG0_R { UCTXIFG0_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - START condition interrupt flag" ] # [ inline ( always ) ] pub fn ucsttifg ( & self ) -> UCSTTIFG_R { UCSTTIFG_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - STOP condition interrupt flag" ] # [ inline ( always ) ] pub fn ucstpifg ( & self ) -> UCSTPIFG_R { UCSTPIFG_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Arbitration lost interrupt flag" ] # [ inline ( always ) ] pub fn ucalifg ( & self ) -> UCALIFG_R { UCALIFG_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Not-acknowledge received interrupt flag" ] # [ inline ( always ) ] pub fn ucnackifg ( & self ) -> UCNACKIFG_R { UCNACKIFG_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Byte counter interrupt flag" ] # [ inline ( always ) ] pub fn ucbcntifg ( & self ) -> UCBCNTIFG_R { UCBCNTIFG_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Clock low timeout interrupt flag" ] # [ inline ( always ) ] pub fn uccltoifg ( & self ) -> UCCLTOIFG_R { UCCLTOIFG_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - eUSCI_B receive interrupt flag 1" ] # [ inline ( always ) ] pub fn ucrxifg1 ( & self ) -> UCRXIFG1_R { UCRXIFG1_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - eUSCI_B transmit interrupt flag 1" ] # [ inline ( always ) ] pub fn uctxifg1 ( & self ) -> UCTXIFG1_R { UCTXIFG1_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - eUSCI_B receive interrupt flag 2" ] # [ inline ( always ) ] pub fn ucrxifg2 ( & self ) -> UCRXIFG2_R { UCRXIFG2_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - eUSCI_B transmit interrupt flag 2" ] # [ inline ( always ) ] pub fn uctxifg2 ( & self ) -> UCTXIFG2_R { UCTXIFG2_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - eUSCI_B receive interrupt flag 3" ] # [ inline ( always ) ] pub fn ucrxifg3 ( & self ) -> UCRXIFG3_R { UCRXIFG3_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - eUSCI_B transmit interrupt flag 3" ] # [ inline ( always ) ] pub fn uctxifg3 ( & self ) -> UCTXIFG3_R { UCTXIFG3_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Bit position 9 interrupt flag" ] # [ inline ( always ) ] pub fn ucbit9ifg ( & self ) -> UCBIT9IFG_R { UCBIT9IFG_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - eUSCI_B receive interrupt flag 0" ] # [ inline ( always ) ] pub fn ucrxifg0 ( & mut self ) -> UCRXIFG0_W { UCRXIFG0_W { w : self } }
# [ doc = "Bit 1 - eUSCI_B transmit interrupt flag 0" ] # [ inline ( always ) ] pub fn uctxifg0 ( & mut self ) -> UCTXIFG0_W { UCTXIFG0_W { w : self } }
# [ doc = "Bit 2 - START condition interrupt flag" ] # [ inline ( always ) ] pub fn ucsttifg ( & mut self ) -> UCSTTIFG_W { UCSTTIFG_W { w : self } }
# [ doc = "Bit 3 - STOP condition interrupt flag" ] # [ inline ( always ) ] pub fn ucstpifg ( & mut self ) -> UCSTPIFG_W { UCSTPIFG_W { w : self } }
# [ doc = "Bit 4 - Arbitration lost interrupt flag" ] # [ inline ( always ) ] pub fn ucalifg ( & mut self ) -> UCALIFG_W { UCALIFG_W { w : self } }
# [ doc = "Bit 5 - Not-acknowledge received interrupt flag" ] # [ inline ( always ) ] pub fn ucnackifg ( & mut self ) -> UCNACKIFG_W { UCNACKIFG_W { w : self } }
# [ doc = "Bit 6 - Byte counter interrupt flag" ] # [ inline ( always ) ] pub fn ucbcntifg ( & mut self ) -> UCBCNTIFG_W { UCBCNTIFG_W { w : self } }
# [ doc = "Bit 7 - Clock low timeout interrupt flag" ] # [ inline ( always ) ] pub fn uccltoifg ( & mut self ) -> UCCLTOIFG_W { UCCLTOIFG_W { w : self } }
# [ doc = "Bit 8 - eUSCI_B receive interrupt flag 1" ] # [ inline ( always ) ] pub fn ucrxifg1 ( & mut self ) -> UCRXIFG1_W { UCRXIFG1_W { w : self } }
# [ doc = "Bit 9 - eUSCI_B transmit interrupt flag 1" ] # [ inline ( always ) ] pub fn uctxifg1 ( & mut self ) -> UCTXIFG1_W { UCTXIFG1_W { w : self } }
# [ doc = "Bit 10 - eUSCI_B receive interrupt flag 2" ] # [ inline ( always ) ] pub fn ucrxifg2 ( & mut self ) -> UCRXIFG2_W { UCRXIFG2_W { w : self } }
# [ doc = "Bit 11 - eUSCI_B transmit interrupt flag 2" ] # [ inline ( always ) ] pub fn uctxifg2 ( & mut self ) -> UCTXIFG2_W { UCTXIFG2_W { w : self } }
# [ doc = "Bit 12 - eUSCI_B receive interrupt flag 3" ] # [ inline ( always ) ] pub fn ucrxifg3 ( & mut self ) -> UCRXIFG3_W { UCRXIFG3_W { w : self } }
# [ doc = "Bit 13 - eUSCI_B transmit interrupt flag 3" ] # [ inline ( always ) ] pub fn uctxifg3 ( & mut self ) -> UCTXIFG3_W { UCTXIFG3_W { w : self } }
# [ doc = "Bit 14 - Bit position 9 interrupt flag" ] # [ inline ( always ) ] pub fn ucbit9ifg ( & mut self ) -> UCBIT9IFG_W { UCBIT9IFG_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1ifg_spi](ucb1ifg_spi) module" ] pub type UCB1IFG_SPI = crate :: Reg < u16 , _UCB1IFG_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1IFG_SPI ;
# [ doc = "`read()` method returns [ucb1ifg_spi::R](ucb1ifg_spi::R) reader structure" ] impl crate :: Readable for UCB1IFG_SPI { }
# [ doc = "`write(|w| ..)` method takes [ucb1ifg_spi::W](ucb1ifg_spi::W) writer structure" ] impl crate :: Writable for UCB1IFG_SPI { }
# [ doc = "eUSCI_Bx Interrupt Flag Register" ] pub mod ucb1ifg_spi {
# [ doc = "Reader of register UCB1IFG_SPI" ] pub type R = crate :: R < u16 , super :: UCB1IFG_SPI > ;
# [ doc = "Writer for register UCB1IFG_SPI" ] pub type W = crate :: W < u16 , super :: UCB1IFG_SPI > ;
# [ doc = "Register UCB1IFG_SPI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: UCB1IFG_SPI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Receive interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCRXIFG_A { # [ doc = "0: No interrupt pending" ] UCRXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCRXIFG_1 = 1 } impl From < UCRXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCRXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCRXIFG`" ] pub type UCRXIFG_R = crate :: R < bool , UCRXIFG_A > ; impl UCRXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCRXIFG_A { match self . bits { false => UCRXIFG_A :: UCRXIFG_0 , true => UCRXIFG_A :: UCRXIFG_1 } } # [ doc = "Checks if the value of the field is `UCRXIFG_0`" ] # [ inline ( always ) ] pub fn is_ucrxifg_0 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_0 } # [ doc = "Checks if the value of the field is `UCRXIFG_1`" ] # [ inline ( always ) ] pub fn is_ucrxifg_1 ( & self ) -> bool { * self == UCRXIFG_A :: UCRXIFG_1 } }
# [ doc = "Write proxy for field `UCRXIFG`" ] pub struct UCRXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCRXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCRXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_0 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn ucrxifg_1 ( self ) -> & 'a mut W { self . variant ( UCRXIFG_A :: UCRXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Transmit interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UCTXIFG_A { # [ doc = "0: No interrupt pending" ] UCTXIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] UCTXIFG_1 = 1 } impl From < UCTXIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : UCTXIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `UCTXIFG`" ] pub type UCTXIFG_R = crate :: R < bool , UCTXIFG_A > ; impl UCTXIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UCTXIFG_A { match self . bits { false => UCTXIFG_A :: UCTXIFG_0 , true => UCTXIFG_A :: UCTXIFG_1 } } # [ doc = "Checks if the value of the field is `UCTXIFG_0`" ] # [ inline ( always ) ] pub fn is_uctxifg_0 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_0 } # [ doc = "Checks if the value of the field is `UCTXIFG_1`" ] # [ inline ( always ) ] pub fn is_uctxifg_1 ( & self ) -> bool { * self == UCTXIFG_A :: UCTXIFG_1 } }
# [ doc = "Write proxy for field `UCTXIFG`" ] pub struct UCTXIFG_W < 'a > { w : & 'a mut W , } impl < 'a > UCTXIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : UCTXIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_0 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn uctxifg_1 ( self ) -> & 'a mut W { self . variant ( UCTXIFG_A :: UCTXIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & self ) -> UCRXIFG_R { UCRXIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & self ) -> UCTXIFG_R { UCTXIFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Receive interrupt flag" ] # [ inline ( always ) ] pub fn ucrxifg ( & mut self ) -> UCRXIFG_W { UCRXIFG_W { w : self } }
# [ doc = "Bit 1 - Transmit interrupt flag" ] # [ inline ( always ) ] pub fn uctxifg ( & mut self ) -> UCTXIFG_W { UCTXIFG_W { w : self } }
}
}
# [ doc = "eUSCI_Bx Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1iv](ucb1iv) module" ] pub type UCB1IV = crate :: Reg < u16 , _UCB1IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1IV ;
# [ doc = "`read()` method returns [ucb1iv::R](ucb1iv::R) reader structure" ] impl crate :: Readable for UCB1IV { }
# [ doc = "eUSCI_Bx Interrupt Vector Register" ] pub mod ucb1iv {
# [ doc = "Reader of register UCB1IV" ] pub type R = crate :: R < u16 , super :: UCB1IV > ;
# [ doc = "eUSCI_B interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum UCIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Arbitration lost; Interrupt Flag: UCALIFG; Interrupt Priority: Highest" ] UCALIFG = 2 , # [ doc = "4: Interrupt Source: Not acknowledgment; Interrupt Flag: UCNACKIFG" ] UCNACKIFG = 4 , # [ doc = "6: Interrupt Source: Start condition received; Interrupt Flag: UCSTTIFG" ] UCSTTIFG = 6 , # [ doc = "8: Interrupt Source: Stop condition received; Interrupt Flag: UCSTPIFG" ] UCSTPIFG = 8 , # [ doc = "10: Interrupt Source: Slave 3 Data received; Interrupt Flag: UCRXIFG3" ] UCRXIFG3 = 10 , # [ doc = "12: Interrupt Source: Slave 3 Transmit buffer empty; Interrupt Flag: UCTXIFG3" ] UCTXIFG3 = 12 , # [ doc = "14: Interrupt Source: Slave 2 Data received; Interrupt Flag: UCRXIFG2" ] UCRXIFG2 = 14 , # [ doc = "16: Interrupt Source: Slave 2 Transmit buffer empty; Interrupt Flag: UCTXIFG2" ] UCTXIFG2 = 16 , # [ doc = "18: Interrupt Source: Slave 1 Data received; Interrupt Flag: UCRXIFG1" ] UCRXIFG1 = 18 , # [ doc = "20: Interrupt Source: Slave 1 Transmit buffer empty; Interrupt Flag: UCTXIFG1" ] UCTXIFG1 = 20 , # [ doc = "22: Interrupt Source: Data received; Interrupt Flag: UCRXIFG0" ] UCRXIFG0 = 22 , # [ doc = "24: Interrupt Source: Transmit buffer empty; Interrupt Flag: UCTXIFG0" ] UCTXIFG0 = 24 , # [ doc = "26: Interrupt Source: Byte counter zero; Interrupt Flag: UCBCNTIFG" ] UCBCNTIFG = 26 , # [ doc = "28: Interrupt Source: Clock low timeout; Interrupt Flag: UCCLTOIFG" ] UCCLTOIFG = 28 , # [ doc = "30: Interrupt Source: Nineth bit position; Interrupt Flag: UCBIT9IFG; Priority: Lowest" ] UCBIT9IFG = 30 } impl From < UCIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : UCIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCIV`" ] pub type UCIV_R = crate :: R < u16 , UCIV_A > ; impl UCIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , UCIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( UCIV_A :: NONE ) , 2 => Val ( UCIV_A :: UCALIFG ) , 4 => Val ( UCIV_A :: UCNACKIFG ) , 6 => Val ( UCIV_A :: UCSTTIFG ) , 8 => Val ( UCIV_A :: UCSTPIFG ) , 10 => Val ( UCIV_A :: UCRXIFG3 ) , 12 => Val ( UCIV_A :: UCTXIFG3 ) , 14 => Val ( UCIV_A :: UCRXIFG2 ) , 16 => Val ( UCIV_A :: UCTXIFG2 ) , 18 => Val ( UCIV_A :: UCRXIFG1 ) , 20 => Val ( UCIV_A :: UCTXIFG1 ) , 22 => Val ( UCIV_A :: UCRXIFG0 ) , 24 => Val ( UCIV_A :: UCTXIFG0 ) , 26 => Val ( UCIV_A :: UCBCNTIFG ) , 28 => Val ( UCIV_A :: UCCLTOIFG ) , 30 => Val ( UCIV_A :: UCBIT9IFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == UCIV_A :: NONE } # [ doc = "Checks if the value of the field is `UCALIFG`" ] # [ inline ( always ) ] pub fn is_ucalifg ( & self ) -> bool { * self == UCIV_A :: UCALIFG } # [ doc = "Checks if the value of the field is `UCNACKIFG`" ] # [ inline ( always ) ] pub fn is_ucnackifg ( & self ) -> bool { * self == UCIV_A :: UCNACKIFG } # [ doc = "Checks if the value of the field is `UCSTTIFG`" ] # [ inline ( always ) ] pub fn is_ucsttifg ( & self ) -> bool { * self == UCIV_A :: UCSTTIFG } # [ doc = "Checks if the value of the field is `UCSTPIFG`" ] # [ inline ( always ) ] pub fn is_ucstpifg ( & self ) -> bool { * self == UCIV_A :: UCSTPIFG } # [ doc = "Checks if the value of the field is `UCRXIFG3`" ] # [ inline ( always ) ] pub fn is_ucrxifg3 ( & self ) -> bool { * self == UCIV_A :: UCRXIFG3 } # [ doc = "Checks if the value of the field is `UCTXIFG3`" ] # [ inline ( always ) ] pub fn is_uctxifg3 ( & self ) -> bool { * self == UCIV_A :: UCTXIFG3 } # [ doc = "Checks if the value of the field is `UCRXIFG2`" ] # [ inline ( always ) ] pub fn is_ucrxifg2 ( & self ) -> bool { * self == UCIV_A :: UCRXIFG2 } # [ doc = "Checks if the value of the field is `UCTXIFG2`" ] # [ inline ( always ) ] pub fn is_uctxifg2 ( & self ) -> bool { * self == UCIV_A :: UCTXIFG2 } # [ doc = "Checks if the value of the field is `UCRXIFG1`" ] # [ inline ( always ) ] pub fn is_ucrxifg1 ( & self ) -> bool { * self == UCIV_A :: UCRXIFG1 } # [ doc = "Checks if the value of the field is `UCTXIFG1`" ] # [ inline ( always ) ] pub fn is_uctxifg1 ( & self ) -> bool { * self == UCIV_A :: UCTXIFG1 } # [ doc = "Checks if the value of the field is `UCRXIFG0`" ] # [ inline ( always ) ] pub fn is_ucrxifg0 ( & self ) -> bool { * self == UCIV_A :: UCRXIFG0 } # [ doc = "Checks if the value of the field is `UCTXIFG0`" ] # [ inline ( always ) ] pub fn is_uctxifg0 ( & self ) -> bool { * self == UCIV_A :: UCTXIFG0 } # [ doc = "Checks if the value of the field is `UCBCNTIFG`" ] # [ inline ( always ) ] pub fn is_ucbcntifg ( & self ) -> bool { * self == UCIV_A :: UCBCNTIFG } # [ doc = "Checks if the value of the field is `UCCLTOIFG`" ] # [ inline ( always ) ] pub fn is_uccltoifg ( & self ) -> bool { * self == UCIV_A :: UCCLTOIFG } # [ doc = "Checks if the value of the field is `UCBIT9IFG`" ] # [ inline ( always ) ] pub fn is_ucbit9ifg ( & self ) -> bool { * self == UCIV_A :: UCBIT9IFG } }
impl R {
# [ doc = "Bits 0:15 - eUSCI_B interrupt vector value" ] # [ inline ( always ) ] pub fn uciv ( & self ) -> UCIV_R { UCIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
# [ doc = "eUSCI_Bx Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb1iv_spi](ucb1iv_spi) module" ] pub type UCB1IV_SPI = crate :: Reg < u16 , _UCB1IV_SPI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _UCB1IV_SPI ;
# [ doc = "`read()` method returns [ucb1iv_spi::R](ucb1iv_spi::R) reader structure" ] impl crate :: Readable for UCB1IV_SPI { }
# [ doc = "eUSCI_Bx Interrupt Vector Register" ] pub mod ucb1iv_spi {
# [ doc = "Reader of register UCB1IV_SPI" ] pub type R = crate :: R < u16 , super :: UCB1IV_SPI > ;
# [ doc = "eUSCI_B interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum UCIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: Data received; Interrupt Flag: UCRXIFG; Interrupt Priority: Highest" ] UCRXIFG = 2 , # [ doc = "4: Interrupt Source: Transmit buffer empty; Interrupt Flag: UCTXIFG; Interrupt Priority: Lowest" ] UCTXIFG = 4 } impl From < UCIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : UCIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `UCIV`" ] pub type UCIV_R = crate :: R < u16 , UCIV_A > ; impl UCIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , UCIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( UCIV_A :: NONE ) , 2 => Val ( UCIV_A :: UCRXIFG ) , 4 => Val ( UCIV_A :: UCTXIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == UCIV_A :: NONE } # [ doc = "Checks if the value of the field is `UCRXIFG`" ] # [ inline ( always ) ] pub fn is_ucrxifg ( & self ) -> bool { * self == UCIV_A :: UCRXIFG } # [ doc = "Checks if the value of the field is `UCTXIFG`" ] # [ inline ( always ) ] pub fn is_uctxifg ( & self ) -> bool { * self == UCIV_A :: UCTXIFG } }
impl R {
# [ doc = "Bits 0:15 - eUSCI_B interrupt vector value" ] # [ inline ( always ) ] pub fn uciv ( & self ) -> UCIV_R { UCIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "BKMEM" ] pub struct BKMEM { _marker : PhantomData < * const ( ) > } unsafe impl Send for BKMEM { } impl BKMEM { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const bkmem :: RegisterBlock { 0x0660 as * const _ } } impl Deref for BKMEM { type Target = bkmem :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * BKMEM :: ptr ( ) } } }
# [ doc = "BKMEM" ] pub mod bkmem {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Backup Memory registers. Backup Memory 0." ] pub bakmem0 : BAKMEM0 , # [ doc = "0x02 - Backup Memory 1." ] pub bakmem1 : BAKMEM1 , # [ doc = "0x04 - Backup Memory 2." ] pub bakmem2 : BAKMEM2 , # [ doc = "0x06 - Backup Memory 3." ] pub bakmem3 : BAKMEM3 , # [ doc = "0x08 - Backup Memory 4." ] pub bakmem4 : BAKMEM4 , # [ doc = "0x0a - Backup Memory 5." ] pub bakmem5 : BAKMEM5 , # [ doc = "0x0c - Backup Memory 6." ] pub bakmem6 : BAKMEM6 , # [ doc = "0x0e - Backup Memory 7." ] pub bakmem7 : BAKMEM7 , # [ doc = "0x10 - Backup Memory 8." ] pub bakmem8 : BAKMEM8 , # [ doc = "0x12 - Backup Memory 9." ] pub bakmem9 : BAKMEM9 , # [ doc = "0x14 - Backup Memory registers. Backup Memory 10." ] pub bakmem10 : BAKMEM10 , # [ doc = "0x16 - Backup Memory 11." ] pub bakmem11 : BAKMEM11 , # [ doc = "0x18 - Backup Memory 12." ] pub bakmem12 : BAKMEM12 , # [ doc = "0x1a - Backup Memory 13." ] pub bakmem13 : BAKMEM13 , # [ doc = "0x1c - Backup Memory 14." ] pub bakmem14 : BAKMEM14 , # [ doc = "0x1e - Backup Memory 15." ] pub bakmem15 : BAKMEM15 , }
# [ doc = "Backup Memory registers. Backup Memory 0.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem0](bakmem0) module" ] pub type BAKMEM0 = crate :: Reg < u16 , _BAKMEM0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM0 ;
# [ doc = "`read()` method returns [bakmem0::R](bakmem0::R) reader structure" ] impl crate :: Readable for BAKMEM0 { }
# [ doc = "`write(|w| ..)` method takes [bakmem0::W](bakmem0::W) writer structure" ] impl crate :: Writable for BAKMEM0 { }
# [ doc = "Backup Memory registers. Backup Memory 0." ] pub mod bakmem0 {
# [ doc = "Reader of register BAKMEM0" ] pub type R = crate :: R < u16 , super :: BAKMEM0 > ;
# [ doc = "Writer for register BAKMEM0" ] pub type W = crate :: W < u16 , super :: BAKMEM0 > ;
# [ doc = "Register BAKMEM0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 1.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem1](bakmem1) module" ] pub type BAKMEM1 = crate :: Reg < u16 , _BAKMEM1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM1 ;
# [ doc = "`read()` method returns [bakmem1::R](bakmem1::R) reader structure" ] impl crate :: Readable for BAKMEM1 { }
# [ doc = "`write(|w| ..)` method takes [bakmem1::W](bakmem1::W) writer structure" ] impl crate :: Writable for BAKMEM1 { }
# [ doc = "Backup Memory 1." ] pub mod bakmem1 {
# [ doc = "Reader of register BAKMEM1" ] pub type R = crate :: R < u16 , super :: BAKMEM1 > ;
# [ doc = "Writer for register BAKMEM1" ] pub type W = crate :: W < u16 , super :: BAKMEM1 > ;
# [ doc = "Register BAKMEM1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 2.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem2](bakmem2) module" ] pub type BAKMEM2 = crate :: Reg < u16 , _BAKMEM2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM2 ;
# [ doc = "`read()` method returns [bakmem2::R](bakmem2::R) reader structure" ] impl crate :: Readable for BAKMEM2 { }
# [ doc = "`write(|w| ..)` method takes [bakmem2::W](bakmem2::W) writer structure" ] impl crate :: Writable for BAKMEM2 { }
# [ doc = "Backup Memory 2." ] pub mod bakmem2 {
# [ doc = "Reader of register BAKMEM2" ] pub type R = crate :: R < u16 , super :: BAKMEM2 > ;
# [ doc = "Writer for register BAKMEM2" ] pub type W = crate :: W < u16 , super :: BAKMEM2 > ;
# [ doc = "Register BAKMEM2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 3.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem3](bakmem3) module" ] pub type BAKMEM3 = crate :: Reg < u16 , _BAKMEM3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM3 ;
# [ doc = "`read()` method returns [bakmem3::R](bakmem3::R) reader structure" ] impl crate :: Readable for BAKMEM3 { }
# [ doc = "`write(|w| ..)` method takes [bakmem3::W](bakmem3::W) writer structure" ] impl crate :: Writable for BAKMEM3 { }
# [ doc = "Backup Memory 3." ] pub mod bakmem3 {
# [ doc = "Reader of register BAKMEM3" ] pub type R = crate :: R < u16 , super :: BAKMEM3 > ;
# [ doc = "Writer for register BAKMEM3" ] pub type W = crate :: W < u16 , super :: BAKMEM3 > ;
# [ doc = "Register BAKMEM3 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM3 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 4.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem4](bakmem4) module" ] pub type BAKMEM4 = crate :: Reg < u16 , _BAKMEM4 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM4 ;
# [ doc = "`read()` method returns [bakmem4::R](bakmem4::R) reader structure" ] impl crate :: Readable for BAKMEM4 { }
# [ doc = "`write(|w| ..)` method takes [bakmem4::W](bakmem4::W) writer structure" ] impl crate :: Writable for BAKMEM4 { }
# [ doc = "Backup Memory 4." ] pub mod bakmem4 {
# [ doc = "Reader of register BAKMEM4" ] pub type R = crate :: R < u16 , super :: BAKMEM4 > ;
# [ doc = "Writer for register BAKMEM4" ] pub type W = crate :: W < u16 , super :: BAKMEM4 > ;
# [ doc = "Register BAKMEM4 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM4 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 5.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem5](bakmem5) module" ] pub type BAKMEM5 = crate :: Reg < u16 , _BAKMEM5 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM5 ;
# [ doc = "`read()` method returns [bakmem5::R](bakmem5::R) reader structure" ] impl crate :: Readable for BAKMEM5 { }
# [ doc = "`write(|w| ..)` method takes [bakmem5::W](bakmem5::W) writer structure" ] impl crate :: Writable for BAKMEM5 { }
# [ doc = "Backup Memory 5." ] pub mod bakmem5 {
# [ doc = "Reader of register BAKMEM5" ] pub type R = crate :: R < u16 , super :: BAKMEM5 > ;
# [ doc = "Writer for register BAKMEM5" ] pub type W = crate :: W < u16 , super :: BAKMEM5 > ;
# [ doc = "Register BAKMEM5 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM5 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 6.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem6](bakmem6) module" ] pub type BAKMEM6 = crate :: Reg < u16 , _BAKMEM6 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM6 ;
# [ doc = "`read()` method returns [bakmem6::R](bakmem6::R) reader structure" ] impl crate :: Readable for BAKMEM6 { }
# [ doc = "`write(|w| ..)` method takes [bakmem6::W](bakmem6::W) writer structure" ] impl crate :: Writable for BAKMEM6 { }
# [ doc = "Backup Memory 6." ] pub mod bakmem6 {
# [ doc = "Reader of register BAKMEM6" ] pub type R = crate :: R < u16 , super :: BAKMEM6 > ;
# [ doc = "Writer for register BAKMEM6" ] pub type W = crate :: W < u16 , super :: BAKMEM6 > ;
# [ doc = "Register BAKMEM6 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM6 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 7.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem7](bakmem7) module" ] pub type BAKMEM7 = crate :: Reg < u16 , _BAKMEM7 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM7 ;
# [ doc = "`read()` method returns [bakmem7::R](bakmem7::R) reader structure" ] impl crate :: Readable for BAKMEM7 { }
# [ doc = "`write(|w| ..)` method takes [bakmem7::W](bakmem7::W) writer structure" ] impl crate :: Writable for BAKMEM7 { }
# [ doc = "Backup Memory 7." ] pub mod bakmem7 {
# [ doc = "Reader of register BAKMEM7" ] pub type R = crate :: R < u16 , super :: BAKMEM7 > ;
# [ doc = "Writer for register BAKMEM7" ] pub type W = crate :: W < u16 , super :: BAKMEM7 > ;
# [ doc = "Register BAKMEM7 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM7 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 8.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem8](bakmem8) module" ] pub type BAKMEM8 = crate :: Reg < u16 , _BAKMEM8 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM8 ;
# [ doc = "`read()` method returns [bakmem8::R](bakmem8::R) reader structure" ] impl crate :: Readable for BAKMEM8 { }
# [ doc = "`write(|w| ..)` method takes [bakmem8::W](bakmem8::W) writer structure" ] impl crate :: Writable for BAKMEM8 { }
# [ doc = "Backup Memory 8." ] pub mod bakmem8 {
# [ doc = "Reader of register BAKMEM8" ] pub type R = crate :: R < u16 , super :: BAKMEM8 > ;
# [ doc = "Writer for register BAKMEM8" ] pub type W = crate :: W < u16 , super :: BAKMEM8 > ;
# [ doc = "Register BAKMEM8 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM8 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 9.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem9](bakmem9) module" ] pub type BAKMEM9 = crate :: Reg < u16 , _BAKMEM9 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM9 ;
# [ doc = "`read()` method returns [bakmem9::R](bakmem9::R) reader structure" ] impl crate :: Readable for BAKMEM9 { }
# [ doc = "`write(|w| ..)` method takes [bakmem9::W](bakmem9::W) writer structure" ] impl crate :: Writable for BAKMEM9 { }
# [ doc = "Backup Memory 9." ] pub mod bakmem9 {
# [ doc = "Reader of register BAKMEM9" ] pub type R = crate :: R < u16 , super :: BAKMEM9 > ;
# [ doc = "Writer for register BAKMEM9" ] pub type W = crate :: W < u16 , super :: BAKMEM9 > ;
# [ doc = "Register BAKMEM9 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM9 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory registers. Backup Memory 10.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem10](bakmem10) module" ] pub type BAKMEM10 = crate :: Reg < u16 , _BAKMEM10 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM10 ;
# [ doc = "`read()` method returns [bakmem10::R](bakmem10::R) reader structure" ] impl crate :: Readable for BAKMEM10 { }
# [ doc = "`write(|w| ..)` method takes [bakmem10::W](bakmem10::W) writer structure" ] impl crate :: Writable for BAKMEM10 { }
# [ doc = "Backup Memory registers. Backup Memory 10." ] pub mod bakmem10 {
# [ doc = "Reader of register BAKMEM10" ] pub type R = crate :: R < u16 , super :: BAKMEM10 > ;
# [ doc = "Writer for register BAKMEM10" ] pub type W = crate :: W < u16 , super :: BAKMEM10 > ;
# [ doc = "Register BAKMEM10 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM10 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 11.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem11](bakmem11) module" ] pub type BAKMEM11 = crate :: Reg < u16 , _BAKMEM11 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM11 ;
# [ doc = "`read()` method returns [bakmem11::R](bakmem11::R) reader structure" ] impl crate :: Readable for BAKMEM11 { }
# [ doc = "`write(|w| ..)` method takes [bakmem11::W](bakmem11::W) writer structure" ] impl crate :: Writable for BAKMEM11 { }
# [ doc = "Backup Memory 11." ] pub mod bakmem11 {
# [ doc = "Reader of register BAKMEM11" ] pub type R = crate :: R < u16 , super :: BAKMEM11 > ;
# [ doc = "Writer for register BAKMEM11" ] pub type W = crate :: W < u16 , super :: BAKMEM11 > ;
# [ doc = "Register BAKMEM11 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM11 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 12.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem12](bakmem12) module" ] pub type BAKMEM12 = crate :: Reg < u16 , _BAKMEM12 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM12 ;
# [ doc = "`read()` method returns [bakmem12::R](bakmem12::R) reader structure" ] impl crate :: Readable for BAKMEM12 { }
# [ doc = "`write(|w| ..)` method takes [bakmem12::W](bakmem12::W) writer structure" ] impl crate :: Writable for BAKMEM12 { }
# [ doc = "Backup Memory 12." ] pub mod bakmem12 {
# [ doc = "Reader of register BAKMEM12" ] pub type R = crate :: R < u16 , super :: BAKMEM12 > ;
# [ doc = "Writer for register BAKMEM12" ] pub type W = crate :: W < u16 , super :: BAKMEM12 > ;
# [ doc = "Register BAKMEM12 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM12 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 13.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem13](bakmem13) module" ] pub type BAKMEM13 = crate :: Reg < u16 , _BAKMEM13 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM13 ;
# [ doc = "`read()` method returns [bakmem13::R](bakmem13::R) reader structure" ] impl crate :: Readable for BAKMEM13 { }
# [ doc = "`write(|w| ..)` method takes [bakmem13::W](bakmem13::W) writer structure" ] impl crate :: Writable for BAKMEM13 { }
# [ doc = "Backup Memory 13." ] pub mod bakmem13 {
# [ doc = "Reader of register BAKMEM13" ] pub type R = crate :: R < u16 , super :: BAKMEM13 > ;
# [ doc = "Writer for register BAKMEM13" ] pub type W = crate :: W < u16 , super :: BAKMEM13 > ;
# [ doc = "Register BAKMEM13 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM13 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 14.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem14](bakmem14) module" ] pub type BAKMEM14 = crate :: Reg < u16 , _BAKMEM14 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM14 ;
# [ doc = "`read()` method returns [bakmem14::R](bakmem14::R) reader structure" ] impl crate :: Readable for BAKMEM14 { }
# [ doc = "`write(|w| ..)` method takes [bakmem14::W](bakmem14::W) writer structure" ] impl crate :: Writable for BAKMEM14 { }
# [ doc = "Backup Memory 14." ] pub mod bakmem14 {
# [ doc = "Reader of register BAKMEM14" ] pub type R = crate :: R < u16 , super :: BAKMEM14 > ;
# [ doc = "Writer for register BAKMEM14" ] pub type W = crate :: W < u16 , super :: BAKMEM14 > ;
# [ doc = "Register BAKMEM14 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM14 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "Backup Memory 15.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem15](bakmem15) module" ] pub type BAKMEM15 = crate :: Reg < u16 , _BAKMEM15 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAKMEM15 ;
# [ doc = "`read()` method returns [bakmem15::R](bakmem15::R) reader structure" ] impl crate :: Readable for BAKMEM15 { }
# [ doc = "`write(|w| ..)` method takes [bakmem15::W](bakmem15::W) writer structure" ] impl crate :: Writable for BAKMEM15 { }
# [ doc = "Backup Memory 15." ] pub mod bakmem15 {
# [ doc = "Reader of register BAKMEM15" ] pub type R = crate :: R < u16 , super :: BAKMEM15 > ;
# [ doc = "Writer for register BAKMEM15" ] pub type W = crate :: W < u16 , super :: BAKMEM15 > ;
# [ doc = "Register BAKMEM15 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAKMEM15 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
}
# [ doc = "ICC" ] pub struct ICC { _marker : PhantomData < * const ( ) > } unsafe impl Send for ICC { } impl ICC { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const icc :: RegisterBlock { 0x06c0 as * const _ } } impl Deref for ICC { type Target = icc :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * ICC :: ptr ( ) } } }
# [ doc = "ICC" ] pub mod icc {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - ICCSC" ] pub iccsc : ICCSC , # [ doc = "0x02 - ICCMVS" ] pub iccmvs : ICCMVS , # [ doc = "0x04 - ICCILSR0" ] pub iccilsr0 : ICCILSR0 , # [ doc = "0x06 - ICCILSR1" ] pub iccilsr1 : ICCILSR1 , # [ doc = "0x08 - ICCILSR2" ] pub iccilsr2 : ICCILSR2 , # [ doc = "0x0a - ICCILSR3" ] pub iccilsr3 : ICCILSR3 , }
# [ doc = "ICCSC\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [iccsc](iccsc) module" ] pub type ICCSC = crate :: Reg < u16 , _ICCSC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ICCSC ;
# [ doc = "`read()` method returns [iccsc::R](iccsc::R) reader structure" ] impl crate :: Readable for ICCSC { }
# [ doc = "`write(|w| ..)` method takes [iccsc::W](iccsc::W) writer structure" ] impl crate :: Writable for ICCSC { }
# [ doc = "ICCSC" ] pub mod iccsc {
# [ doc = "Reader of register ICCSC" ] pub type R = crate :: R < u16 , super :: ICCSC > ;
# [ doc = "Writer for register ICCSC" ] pub type W = crate :: W < u16 , super :: ICCSC > ;
# [ doc = "Register ICCSC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ICCSC { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ICMC`" ] pub type ICMC_R = crate :: R < u8 , u8 > ;
# [ doc = "Virtual stack full flag This bit indicates whether or not the virtual stack is full. It is automatically updated when the stack is pushed or popped.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum VSFFLG_A { # [ doc = "0: ICCMVS register is not full" ] VSFFLG_0 = 0 , # [ doc = "1: ICCMVS register is full" ] VSFFLG_1 = 1 } impl From < VSFFLG_A > for bool { # [ inline ( always ) ] fn from ( variant : VSFFLG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `VSFFLG`" ] pub type VSFFLG_R = crate :: R < bool , VSFFLG_A > ; impl VSFFLG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> VSFFLG_A { match self . bits { false => VSFFLG_A :: VSFFLG_0 , true => VSFFLG_A :: VSFFLG_1 } } # [ doc = "Checks if the value of the field is `VSFFLG_0`" ] # [ inline ( always ) ] pub fn is_vsfflg_0 ( & self ) -> bool { * self == VSFFLG_A :: VSFFLG_0 } # [ doc = "Checks if the value of the field is `VSFFLG_1`" ] # [ inline ( always ) ] pub fn is_vsfflg_1 ( & self ) -> bool { * self == VSFFLG_A :: VSFFLG_1 } }
# [ doc = "Virtual stack empty flag.This bit indicates whether or not the virtual stack is empty. It is automatically updated when the stack is pushed or popped.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum VSEFLG_A { # [ doc = "0: Stack has valid data" ] VSEFLG_0 = 0 , # [ doc = "1: Stack has no valid data" ] VSEFLG_1 = 1 } impl From < VSEFLG_A > for bool { # [ inline ( always ) ] fn from ( variant : VSEFLG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `VSEFLG`" ] pub type VSEFLG_R = crate :: R < bool , VSEFLG_A > ; impl VSEFLG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> VSEFLG_A { match self . bits { false => VSEFLG_A :: VSEFLG_0 , true => VSEFLG_A :: VSEFLG_1 } } # [ doc = "Checks if the value of the field is `VSEFLG_0`" ] # [ inline ( always ) ] pub fn is_vseflg_0 ( & self ) -> bool { * self == VSEFLG_A :: VSEFLG_0 } # [ doc = "Checks if the value of the field is `VSEFLG_1`" ] # [ inline ( always ) ] pub fn is_vseflg_1 ( & self ) -> bool { * self == VSEFLG_A :: VSEFLG_1 } }
# [ doc = "ICC enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ICCEN_A { # [ doc = "0: ICC module disabled" ] ICCEN_0 = 0 , # [ doc = "1: ICC module enabled" ] ICCEN_1 = 1 } impl From < ICCEN_A > for bool { # [ inline ( always ) ] fn from ( variant : ICCEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ICCEN`" ] pub type ICCEN_R = crate :: R < bool , ICCEN_A > ; impl ICCEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ICCEN_A { match self . bits { false => ICCEN_A :: ICCEN_0 , true => ICCEN_A :: ICCEN_1 } } # [ doc = "Checks if the value of the field is `ICCEN_0`" ] # [ inline ( always ) ] pub fn is_iccen_0 ( & self ) -> bool { * self == ICCEN_A :: ICCEN_0 } # [ doc = "Checks if the value of the field is `ICCEN_1`" ] # [ inline ( always ) ] pub fn is_iccen_1 ( & self ) -> bool { * self == ICCEN_A :: ICCEN_1 } }
# [ doc = "Write proxy for field `ICCEN`" ] pub struct ICCEN_W < 'a > { w : & 'a mut W , } impl < 'a > ICCEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ICCEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "ICC module disabled" ] # [ inline ( always ) ] pub fn iccen_0 ( self ) -> & 'a mut W { self . variant ( ICCEN_A :: ICCEN_0 ) } # [ doc = "ICC module enabled" ] # [ inline ( always ) ] pub fn iccen_1 ( self ) -> & 'a mut W { self . variant ( ICCEN_A :: ICCEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Current Interrupt Compare Mask of virtual stack specifies the current ICM at the top of virtual stack If ICM\\[1:0\\] is less than the priority level (ILSRx\\[1:0\\]) of the new interrupt, the corresponding source is sent to the CPU. Note that the ICMC is the element stack that the stack pointer is pointing to." ] # [ inline ( always ) ] pub fn icmc ( & self ) -> ICMC_R { ICMC_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bit 4 - Virtual stack full flag This bit indicates whether or not the virtual stack is full. It is automatically updated when the stack is pushed or popped." ] # [ inline ( always ) ] pub fn vsfflg ( & self ) -> VSFFLG_R { VSFFLG_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Virtual stack empty flag.This bit indicates whether or not the virtual stack is empty. It is automatically updated when the stack is pushed or popped." ] # [ inline ( always ) ] pub fn vseflg ( & self ) -> VSEFLG_R { VSEFLG_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - ICC enable" ] # [ inline ( always ) ] pub fn iccen ( & self ) -> ICCEN_R { ICCEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 7 - ICC enable" ] # [ inline ( always ) ] pub fn iccen ( & mut self ) -> ICCEN_W { ICCEN_W { w : self } }
}
}
# [ doc = "ICCMVS\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [iccmvs](iccmvs) module" ] pub type ICCMVS = crate :: Reg < u16 , _ICCMVS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ICCMVS ;
# [ doc = "`read()` method returns [iccmvs::R](iccmvs::R) reader structure" ] impl crate :: Readable for ICCMVS { }
# [ doc = "ICCMVS" ] pub mod iccmvs {
# [ doc = "Reader of register ICCMVS" ] pub type R = crate :: R < u16 , super :: ICCMVS > ;
# [ doc = "Reader of field `ICM0`" ] pub type ICM0_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `ICM1`" ] pub type ICM1_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `ICM3`" ] pub type ICM3_R = crate :: R < u8 , u8 > ;
# [ doc = "MVS stack pointer indicate register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum MVSSP_A { # [ doc = "0: 000b = Stack empty" ] MVSSP_0 = 0 , # [ doc = "1: 001b = ICM0 affected" ] MVSSP_1 = 1 , # [ doc = "2: 010b = ICM0 and ICM1 affected" ] MVSSP_2 = 2 , # [ doc = "3: 011b = ICM0, ICM1, and ICM2 affected" ] MVSSP_3 = 3 , # [ doc = "4: 100b = ICM0, ICM1, ICM2, and ICM3 affected. Also means the stack is full." ] MVSSP_4 = 4 } impl From < MVSSP_A > for u8 { # [ inline ( always ) ] fn from ( variant : MVSSP_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `MVSSP`" ] pub type MVSSP_R = crate :: R < u8 , MVSSP_A > ; impl MVSSP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , MVSSP_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( MVSSP_A :: MVSSP_0 ) , 1 => Val ( MVSSP_A :: MVSSP_1 ) , 2 => Val ( MVSSP_A :: MVSSP_2 ) , 3 => Val ( MVSSP_A :: MVSSP_3 ) , 4 => Val ( MVSSP_A :: MVSSP_4 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `MVSSP_0`" ] # [ inline ( always ) ] pub fn is_mvssp_0 ( & self ) -> bool { * self == MVSSP_A :: MVSSP_0 } # [ doc = "Checks if the value of the field is `MVSSP_1`" ] # [ inline ( always ) ] pub fn is_mvssp_1 ( & self ) -> bool { * self == MVSSP_A :: MVSSP_1 } # [ doc = "Checks if the value of the field is `MVSSP_2`" ] # [ inline ( always ) ] pub fn is_mvssp_2 ( & self ) -> bool { * self == MVSSP_A :: MVSSP_2 } # [ doc = "Checks if the value of the field is `MVSSP_3`" ] # [ inline ( always ) ] pub fn is_mvssp_3 ( & self ) -> bool { * self == MVSSP_A :: MVSSP_3 } # [ doc = "Checks if the value of the field is `MVSSP_4`" ] # [ inline ( always ) ] pub fn is_mvssp_4 ( & self ) -> bool { * self == MVSSP_A :: MVSSP_4 } }
# [ doc = "Reader of field `ICM2`" ] pub type ICM2_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:1 - Interrupt compare mask virtual stack position 0 This field is the virtual stack register for ICM0." ] # [ inline ( always ) ] pub fn icm0 ( & self ) -> ICM0_R { ICM0_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 2:3 - Interrupt compare mask virtual stack position 1 This field is the virtual stack register for ICM1." ] # [ inline ( always ) ] pub fn icm1 ( & self ) -> ICM1_R { ICM1_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 6:7 - Interrupt compare mask virtual stack position 3 This field is the virtual stack register for ICM3." ] # [ inline ( always ) ] pub fn icm3 ( & self ) -> ICM3_R { ICM3_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:10 - MVS stack pointer indicate register" ] # [ inline ( always ) ] pub fn mvssp ( & self ) -> MVSSP_R { MVSSP_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) }
# [ doc = "Bits 4:5 - Interrupt compare mask virtual stack position 2 This field is the virtual stack register for ICM2." ] # [ inline ( always ) ] pub fn icm2 ( & self ) -> ICM2_R { ICM2_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
}
}
# [ doc = "ICCILSR0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [iccilsr0](iccilsr0) module" ] pub type ICCILSR0 = crate :: Reg < u16 , _ICCILSR0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ICCILSR0 ;
# [ doc = "`read()` method returns [iccilsr0::R](iccilsr0::R) reader structure" ] impl crate :: Readable for ICCILSR0 { }
# [ doc = "`write(|w| ..)` method takes [iccilsr0::W](iccilsr0::W) writer structure" ] impl crate :: Writable for ICCILSR0 { }
# [ doc = "ICCILSR0" ] pub mod iccilsr0 {
# [ doc = "Reader of register ICCILSR0" ] pub type R = crate :: R < u16 , super :: ICCILSR0 > ;
# [ doc = "Writer for register ICCILSR0" ] pub type W = crate :: W < u16 , super :: ICCILSR0 > ;
# [ doc = "Register ICCILSR0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ICCILSR0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ILSR0`" ] pub type ILSR0_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR0`" ] pub struct ILSR0_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR0_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `ILSR1`" ] pub type ILSR1_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR1`" ] pub struct ILSR1_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR1_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u16 ) & 0x03 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `ILSR2`" ] pub type ILSR2_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR2`" ] pub struct ILSR2_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR2_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `ILSR3`" ] pub type ILSR3_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR3`" ] pub struct ILSR3_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR3_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `ILSR4`" ] pub type ILSR4_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR4`" ] pub struct ILSR4_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR4_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `ILSR5`" ] pub type ILSR5_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR5`" ] pub struct ILSR5_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR5_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u16 ) & 0x03 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `ILSR6`" ] pub type ILSR6_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR6`" ] pub struct ILSR6_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR6_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `ILSR7`" ] pub type ILSR7_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR7`" ] pub struct ILSR7_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR7_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr0 ( & self ) -> ILSR0_R { ILSR0_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 2:3 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr1 ( & self ) -> ILSR1_R { ILSR1_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 4:5 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr2 ( & self ) -> ILSR2_R { ILSR2_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 6:7 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr3 ( & self ) -> ILSR3_R { ILSR3_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:9 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr4 ( & self ) -> ILSR4_R { ILSR4_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 10:11 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr5 ( & self ) -> ILSR5_R { ILSR5_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 12:13 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr6 ( & self ) -> ILSR6_R { ILSR6_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr7 ( & self ) -> ILSR7_R { ILSR7_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr0 ( & mut self ) -> ILSR0_W { ILSR0_W { w : self } }
# [ doc = "Bits 2:3 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr1 ( & mut self ) -> ILSR1_W { ILSR1_W { w : self } }
# [ doc = "Bits 4:5 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr2 ( & mut self ) -> ILSR2_W { ILSR2_W { w : self } }
# [ doc = "Bits 6:7 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr3 ( & mut self ) -> ILSR3_W { ILSR3_W { w : self } }
# [ doc = "Bits 8:9 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr4 ( & mut self ) -> ILSR4_W { ILSR4_W { w : self } }
# [ doc = "Bits 10:11 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr5 ( & mut self ) -> ILSR5_W { ILSR5_W { w : self } }
# [ doc = "Bits 12:13 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr6 ( & mut self ) -> ILSR6_W { ILSR6_W { w : self } }
# [ doc = "Bits 14:15 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRx bit." ] # [ inline ( always ) ] pub fn ilsr7 ( & mut self ) -> ILSR7_W { ILSR7_W { w : self } }
}
}
# [ doc = "ICCILSR1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [iccilsr1](iccilsr1) module" ] pub type ICCILSR1 = crate :: Reg < u16 , _ICCILSR1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ICCILSR1 ;
# [ doc = "`read()` method returns [iccilsr1::R](iccilsr1::R) reader structure" ] impl crate :: Readable for ICCILSR1 { }
# [ doc = "`write(|w| ..)` method takes [iccilsr1::W](iccilsr1::W) writer structure" ] impl crate :: Writable for ICCILSR1 { }
# [ doc = "ICCILSR1" ] pub mod iccilsr1 {
# [ doc = "Reader of register ICCILSR1" ] pub type R = crate :: R < u16 , super :: ICCILSR1 > ;
# [ doc = "Writer for register ICCILSR1" ] pub type W = crate :: W < u16 , super :: ICCILSR1 > ;
# [ doc = "Register ICCILSR1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ICCILSR1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ILSR8`" ] pub type ILSR8_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR8`" ] pub struct ILSR8_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR8_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `ILSR9`" ] pub type ILSR9_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR9`" ] pub struct ILSR9_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR9_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u16 ) & 0x03 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `ILSR10`" ] pub type ILSR10_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR10`" ] pub struct ILSR10_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR10_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `ILSR11`" ] pub type ILSR11_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR11`" ] pub struct ILSR11_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR11_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `ILSR12`" ] pub type ILSR12_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR12`" ] pub struct ILSR12_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR12_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `ILSR13`" ] pub type ILSR13_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR13`" ] pub struct ILSR13_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR13_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u16 ) & 0x03 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `ILSR14`" ] pub type ILSR14_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR14`" ] pub struct ILSR14_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR14_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `ILSR15`" ] pub type ILSR15_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR15`" ] pub struct ILSR15_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR15_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr8 ( & self ) -> ILSR8_R { ILSR8_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 2:3 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr9 ( & self ) -> ILSR9_R { ILSR9_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 4:5 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr10 ( & self ) -> ILSR10_R { ILSR10_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 6:7 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit" ] # [ inline ( always ) ] pub fn ilsr11 ( & self ) -> ILSR11_R { ILSR11_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:9 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr12 ( & self ) -> ILSR12_R { ILSR12_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 10:11 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr13 ( & self ) -> ILSR13_R { ILSR13_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 12:13 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr14 ( & self ) -> ILSR14_R { ILSR14_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr15 ( & self ) -> ILSR15_R { ILSR15_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr8 ( & mut self ) -> ILSR8_W { ILSR8_W { w : self } }
# [ doc = "Bits 2:3 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr9 ( & mut self ) -> ILSR9_W { ILSR9_W { w : self } }
# [ doc = "Bits 4:5 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr10 ( & mut self ) -> ILSR10_W { ILSR10_W { w : self } }
# [ doc = "Bits 6:7 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit" ] # [ inline ( always ) ] pub fn ilsr11 ( & mut self ) -> ILSR11_W { ILSR11_W { w : self } }
# [ doc = "Bits 8:9 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr12 ( & mut self ) -> ILSR12_W { ILSR12_W { w : self } }
# [ doc = "Bits 10:11 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr13 ( & mut self ) -> ILSR13_W { ILSR13_W { w : self } }
# [ doc = "Bits 12:13 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr14 ( & mut self ) -> ILSR14_W { ILSR14_W { w : self } }
# [ doc = "Bits 14:15 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr15 ( & mut self ) -> ILSR15_W { ILSR15_W { w : self } }
}
}
# [ doc = "ICCILSR2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [iccilsr2](iccilsr2) module" ] pub type ICCILSR2 = crate :: Reg < u16 , _ICCILSR2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ICCILSR2 ;
# [ doc = "`read()` method returns [iccilsr2::R](iccilsr2::R) reader structure" ] impl crate :: Readable for ICCILSR2 { }
# [ doc = "`write(|w| ..)` method takes [iccilsr2::W](iccilsr2::W) writer structure" ] impl crate :: Writable for ICCILSR2 { }
# [ doc = "ICCILSR2" ] pub mod iccilsr2 {
# [ doc = "Reader of register ICCILSR2" ] pub type R = crate :: R < u16 , super :: ICCILSR2 > ;
# [ doc = "Writer for register ICCILSR2" ] pub type W = crate :: W < u16 , super :: ICCILSR2 > ;
# [ doc = "Register ICCILSR2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ICCILSR2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ILSR16`" ] pub type ILSR16_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR16`" ] pub struct ILSR16_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR16_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `ILSR17`" ] pub type ILSR17_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR17`" ] pub struct ILSR17_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR17_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u16 ) & 0x03 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `ILSR18`" ] pub type ILSR18_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR18`" ] pub struct ILSR18_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR18_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `ILSR19`" ] pub type ILSR19_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR19`" ] pub struct ILSR19_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR19_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `ILSR20`" ] pub type ILSR20_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR20`" ] pub struct ILSR20_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR20_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `ILSR21`" ] pub type ILSR21_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR21`" ] pub struct ILSR21_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR21_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u16 ) & 0x03 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `ILSR22`" ] pub type ILSR22_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR22`" ] pub struct ILSR22_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR22_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `ILSR23`" ] pub type ILSR23_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR23`" ] pub struct ILSR23_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR23_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr16 ( & self ) -> ILSR16_R { ILSR16_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 2:3 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit" ] # [ inline ( always ) ] pub fn ilsr17 ( & self ) -> ILSR17_R { ILSR17_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 4:5 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr18 ( & self ) -> ILSR18_R { ILSR18_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 6:7 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr19 ( & self ) -> ILSR19_R { ILSR19_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:9 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr20 ( & self ) -> ILSR20_R { ILSR20_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 10:11 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr21 ( & self ) -> ILSR21_R { ILSR21_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 12:13 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each" ] # [ inline ( always ) ] pub fn ilsr22 ( & self ) -> ILSR22_R { ILSR22_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each" ] # [ inline ( always ) ] pub fn ilsr23 ( & self ) -> ILSR23_R { ILSR23_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr16 ( & mut self ) -> ILSR16_W { ILSR16_W { w : self } }
# [ doc = "Bits 2:3 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit" ] # [ inline ( always ) ] pub fn ilsr17 ( & mut self ) -> ILSR17_W { ILSR17_W { w : self } }
# [ doc = "Bits 4:5 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr18 ( & mut self ) -> ILSR18_W { ILSR18_W { w : self } }
# [ doc = "Bits 6:7 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr19 ( & mut self ) -> ILSR19_W { ILSR19_W { w : self } }
# [ doc = "Bits 8:9 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr20 ( & mut self ) -> ILSR20_W { ILSR20_W { w : self } }
# [ doc = "Bits 10:11 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr21 ( & mut self ) -> ILSR21_W { ILSR21_W { w : self } }
# [ doc = "Bits 12:13 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each" ] # [ inline ( always ) ] pub fn ilsr22 ( & mut self ) -> ILSR22_W { ILSR22_W { w : self } }
# [ doc = "Bits 14:15 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each" ] # [ inline ( always ) ] pub fn ilsr23 ( & mut self ) -> ILSR23_W { ILSR23_W { w : self } }
}
}
# [ doc = "ICCILSR3\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [iccilsr3](iccilsr3) module" ] pub type ICCILSR3 = crate :: Reg < u16 , _ICCILSR3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ICCILSR3 ;
# [ doc = "`read()` method returns [iccilsr3::R](iccilsr3::R) reader structure" ] impl crate :: Readable for ICCILSR3 { }
# [ doc = "`write(|w| ..)` method takes [iccilsr3::W](iccilsr3::W) writer structure" ] impl crate :: Writable for ICCILSR3 { }
# [ doc = "ICCILSR3" ] pub mod iccilsr3 {
# [ doc = "Reader of register ICCILSR3" ] pub type R = crate :: R < u16 , super :: ICCILSR3 > ;
# [ doc = "Writer for register ICCILSR3" ] pub type W = crate :: W < u16 , super :: ICCILSR3 > ;
# [ doc = "Register ICCILSR3 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ICCILSR3 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ILSR24`" ] pub type ILSR24_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR24`" ] pub struct ILSR24_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR24_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `ILSR25`" ] pub type ILSR25_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR25`" ] pub struct ILSR25_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR25_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u16 ) & 0x03 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `ILSR26`" ] pub type ILSR26_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR26`" ] pub struct ILSR26_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR26_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `ILSR27`" ] pub type ILSR27_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR27`" ] pub struct ILSR27_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR27_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `ILSR28`" ] pub type ILSR28_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR28`" ] pub struct ILSR28_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR28_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `ILSR29`" ] pub type ILSR29_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR29`" ] pub struct ILSR29_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR29_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u16 ) & 0x03 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `ILSR30`" ] pub type ILSR30_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR30`" ] pub struct ILSR30_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR30_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `ILSR31`" ] pub type ILSR31_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ILSR31`" ] pub struct ILSR31_W < 'a > { w : & 'a mut W , } impl < 'a > ILSR31_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u16 ) & 0x03 ) << 14 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr24 ( & self ) -> ILSR24_R { ILSR24_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 2:3 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr25 ( & self ) -> ILSR25_R { ILSR25_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 4:5 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr26 ( & self ) -> ILSR26_R { ILSR26_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 6:7 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr27 ( & self ) -> ILSR27_R { ILSR27_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:9 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr28 ( & self ) -> ILSR28_R { ILSR28_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 10:11 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr29 ( & self ) -> ILSR29_R { ILSR29_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 12:13 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr30 ( & self ) -> ILSR30_R { ILSR30_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 14:15 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr31 ( & self ) -> ILSR31_R { ILSR31_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr24 ( & mut self ) -> ILSR24_W { ILSR24_W { w : self } }
# [ doc = "Bits 2:3 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr25 ( & mut self ) -> ILSR25_W { ILSR25_W { w : self } }
# [ doc = "Bits 4:5 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr26 ( & mut self ) -> ILSR26_W { ILSR26_W { w : self } }
# [ doc = "Bits 6:7 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr27 ( & mut self ) -> ILSR27_W { ILSR27_W { w : self } }
# [ doc = "Bits 8:9 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr28 ( & mut self ) -> ILSR28_W { ILSR28_W { w : self } }
# [ doc = "Bits 10:11 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr29 ( & mut self ) -> ILSR29_W { ILSR29_W { w : self } }
# [ doc = "Bits 12:13 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr30 ( & mut self ) -> ILSR30_W { ILSR30_W { w : self } }
# [ doc = "Bits 14:15 - Sets the interrupt level for this interrupt source. Maskable interrupt sources only. See the device-specific data sheet to determine the interrupt source for each ILSRxx bit." ] # [ inline ( always ) ] pub fn ilsr31 ( & mut self ) -> ILSR31_W { ILSR31_W { w : self } }
}
}
}
# [ doc = "ADC" ] pub struct ADC { _marker : PhantomData < * const ( ) > } unsafe impl Send for ADC { } impl ADC { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const adc :: RegisterBlock { 0x0700 as * const _ } } impl Deref for ADC { type Target = adc :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * ADC :: ptr ( ) } } }
# [ doc = "ADC" ] pub mod adc {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - ADC Control 0" ] pub adcctl0 : ADCCTL0 , # [ doc = "0x02 - ADC Control 1" ] pub adcctl1 : ADCCTL1 , # [ doc = "0x04 - ADC Control 2" ] pub adcctl2 : ADCCTL2 , # [ doc = "0x06 - ADC Window Comparator Low Threshold Register" ] pub adclo : ADCLO , # [ doc = "0x08 - ADC Window Comparator High Threshold Register" ] pub adchi : ADCHI , # [ doc = "0x0a - ADC Conversion Memory Control Register" ] pub adcmctl0 : ADCMCTL0 , _reserved6 : [ u8 ; 6usize ] , # [ doc = "0x12 - ADC Conversion Memory Register" ] pub adcmem0 : ADCMEM0 , _reserved7 : [ u8 ; 6usize ] , # [ doc = "0x1a - ADC Interrupt Enable 0" ] pub adcie : ADCIE , # [ doc = "0x1c - ADC Interrupt Flag" ] pub adcifg : ADCIFG , # [ doc = "0x1e - ADC Interrupt Vector" ] pub adciv : ADCIV , }
# [ doc = "ADC Control 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcctl0](adcctl0) module" ] pub type ADCCTL0 = crate :: Reg < u16 , _ADCCTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADCCTL0 ;
# [ doc = "`read()` method returns [adcctl0::R](adcctl0::R) reader structure" ] impl crate :: Readable for ADCCTL0 { }
# [ doc = "`write(|w| ..)` method takes [adcctl0::W](adcctl0::W) writer structure" ] impl crate :: Writable for ADCCTL0 { }
# [ doc = "ADC Control 0" ] pub mod adcctl0 {
# [ doc = "Reader of register ADCCTL0" ] pub type R = crate :: R < u16 , super :: ADCCTL0 > ;
# [ doc = "Writer for register ADCCTL0" ] pub type W = crate :: W < u16 , super :: ADCCTL0 > ;
# [ doc = "Register ADCCTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADCCTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "start conversion\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCSC_A { # [ doc = "0: No sample-and-conversion-start" ] ADCSC_0 = 0 , # [ doc = "1: Start sample-and-conversion" ] ADCSC_1 = 1 } impl From < ADCSC_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCSC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCSC`" ] pub type ADCSC_R = crate :: R < bool , ADCSC_A > ; impl ADCSC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCSC_A { match self . bits { false => ADCSC_A :: ADCSC_0 , true => ADCSC_A :: ADCSC_1 } } # [ doc = "Checks if the value of the field is `ADCSC_0`" ] # [ inline ( always ) ] pub fn is_adcsc_0 ( & self ) -> bool { * self == ADCSC_A :: ADCSC_0 } # [ doc = "Checks if the value of the field is `ADCSC_1`" ] # [ inline ( always ) ] pub fn is_adcsc_1 ( & self ) -> bool { * self == ADCSC_A :: ADCSC_1 } }
# [ doc = "Write proxy for field `ADCSC`" ] pub struct ADCSC_W < 'a > { w : & 'a mut W , } impl < 'a > ADCSC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCSC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No sample-and-conversion-start" ] # [ inline ( always ) ] pub fn adcsc_0 ( self ) -> & 'a mut W { self . variant ( ADCSC_A :: ADCSC_0 ) } # [ doc = "Start sample-and-conversion" ] # [ inline ( always ) ] pub fn adcsc_1 ( self ) -> & 'a mut W { self . variant ( ADCSC_A :: ADCSC_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "enable conversion\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCENC_A { # [ doc = "0: ADC disabled" ] ADCENC_0 = 0 , # [ doc = "1: ADC enabled" ] ADCENC_1 = 1 } impl From < ADCENC_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCENC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCENC`" ] pub type ADCENC_R = crate :: R < bool , ADCENC_A > ; impl ADCENC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCENC_A { match self . bits { false => ADCENC_A :: ADCENC_0 , true => ADCENC_A :: ADCENC_1 } } # [ doc = "Checks if the value of the field is `ADCENC_0`" ] # [ inline ( always ) ] pub fn is_adcenc_0 ( & self ) -> bool { * self == ADCENC_A :: ADCENC_0 } # [ doc = "Checks if the value of the field is `ADCENC_1`" ] # [ inline ( always ) ] pub fn is_adcenc_1 ( & self ) -> bool { * self == ADCENC_A :: ADCENC_1 } }
# [ doc = "Write proxy for field `ADCENC`" ] pub struct ADCENC_W < 'a > { w : & 'a mut W , } impl < 'a > ADCENC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCENC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "ADC disabled" ] # [ inline ( always ) ] pub fn adcenc_0 ( self ) -> & 'a mut W { self . variant ( ADCENC_A :: ADCENC_0 ) } # [ doc = "ADC enabled" ] # [ inline ( always ) ] pub fn adcenc_1 ( self ) -> & 'a mut W { self . variant ( ADCENC_A :: ADCENC_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "ADC on\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCON_A { # [ doc = "0: ADC off" ] ADCON_0 = 0 , # [ doc = "1: ADC on" ] ADCON_1 = 1 } impl From < ADCON_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCON_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCON`" ] pub type ADCON_R = crate :: R < bool , ADCON_A > ; impl ADCON_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCON_A { match self . bits { false => ADCON_A :: ADCON_0 , true => ADCON_A :: ADCON_1 } } # [ doc = "Checks if the value of the field is `ADCON_0`" ] # [ inline ( always ) ] pub fn is_adcon_0 ( & self ) -> bool { * self == ADCON_A :: ADCON_0 } # [ doc = "Checks if the value of the field is `ADCON_1`" ] # [ inline ( always ) ] pub fn is_adcon_1 ( & self ) -> bool { * self == ADCON_A :: ADCON_1 } }
# [ doc = "Write proxy for field `ADCON`" ] pub struct ADCON_W < 'a > { w : & 'a mut W , } impl < 'a > ADCON_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCON_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "ADC off" ] # [ inline ( always ) ] pub fn adcon_0 ( self ) -> & 'a mut W { self . variant ( ADCON_A :: ADCON_0 ) } # [ doc = "ADC on" ] # [ inline ( always ) ] pub fn adcon_1 ( self ) -> & 'a mut W { self . variant ( ADCON_A :: ADCON_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "sample-and-hold time.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCMSC_A { # [ doc = "0: The sampling timer requires a rising edge of the SHI signal to trigger each sample-and-convert." ] ADCMSC_0 = 0 , # [ doc = "1: The incidence of a positive(or for devices first rising edge of the) SHI signal triggers the sampling timer, but further sample-and-conversions are performed automatically as soon as the prior conversion is completed." ] ADCMSC_1 = 1 } impl From < ADCMSC_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCMSC_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCMSC`" ] pub type ADCMSC_R = crate :: R < bool , ADCMSC_A > ; impl ADCMSC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCMSC_A { match self . bits { false => ADCMSC_A :: ADCMSC_0 , true => ADCMSC_A :: ADCMSC_1 } } # [ doc = "Checks if the value of the field is `ADCMSC_0`" ] # [ inline ( always ) ] pub fn is_adcmsc_0 ( & self ) -> bool { * self == ADCMSC_A :: ADCMSC_0 } # [ doc = "Checks if the value of the field is `ADCMSC_1`" ] # [ inline ( always ) ] pub fn is_adcmsc_1 ( & self ) -> bool { * self == ADCMSC_A :: ADCMSC_1 } }
# [ doc = "Write proxy for field `ADCMSC`" ] pub struct ADCMSC_W < 'a > { w : & 'a mut W , } impl < 'a > ADCMSC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCMSC_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The sampling timer requires a rising edge of the SHI signal to trigger each sample-and-convert." ] # [ inline ( always ) ] pub fn adcmsc_0 ( self ) -> & 'a mut W { self . variant ( ADCMSC_A :: ADCMSC_0 ) } # [ doc = "The incidence of a positive(or for devices first rising edge of the) SHI signal triggers the sampling timer, but further sample-and-conversions are performed automatically as soon as the prior conversion is completed." ] # [ inline ( always ) ] pub fn adcmsc_1 ( self ) -> & 'a mut W { self . variant ( ADCMSC_A :: ADCMSC_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "sample-and-hold time.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ADCSHT_A { # [ doc = "0: 4 ADCCLK cycles" ] ADCSHT_0 = 0 , # [ doc = "1: 8 ADCCLK cycles" ] ADCSHT_1 = 1 , # [ doc = "2: 16 ADCCLK cycles" ] ADCSHT_2 = 2 , # [ doc = "3: 32 ADCCLK cycles" ] ADCSHT_3 = 3 , # [ doc = "4: 64 ADCCLK cycles" ] ADCSHT_4 = 4 , # [ doc = "5: 96 ADCCLK cycles" ] ADCSHT_5 = 5 , # [ doc = "6: 128 ADCCLK cycles" ] ADCSHT_6 = 6 , # [ doc = "7: 192 ADCCLK cycles" ] ADCSHT_7 = 7 , # [ doc = "8: 256 ADCCLK cycles" ] ADCSHT_8 = 8 , # [ doc = "9: 384 ADCCLK cycles" ] ADCSHT_9 = 9 , # [ doc = "10: 512 ADCCLK cycles" ] ADCSHT_10 = 10 , # [ doc = "11: 768 ADCCLK cycles" ] ADCSHT_11 = 11 , # [ doc = "12: 1024 ADCCLK cycles" ] ADCSHT_12 = 12 , # [ doc = "13: 1024 ADCCLK cycles" ] ADCSHT_13 = 13 , # [ doc = "14: 1024 ADCCLK cycles" ] ADCSHT_14 = 14 , # [ doc = "15: 1024 ADCCLK cycles" ] ADCSHT_15 = 15 } impl From < ADCSHT_A > for u8 { # [ inline ( always ) ] fn from ( variant : ADCSHT_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ADCSHT`" ] pub type ADCSHT_R = crate :: R < u8 , ADCSHT_A > ; impl ADCSHT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCSHT_A { match self . bits { 0 => ADCSHT_A :: ADCSHT_0 , 1 => ADCSHT_A :: ADCSHT_1 , 2 => ADCSHT_A :: ADCSHT_2 , 3 => ADCSHT_A :: ADCSHT_3 , 4 => ADCSHT_A :: ADCSHT_4 , 5 => ADCSHT_A :: ADCSHT_5 , 6 => ADCSHT_A :: ADCSHT_6 , 7 => ADCSHT_A :: ADCSHT_7 , 8 => ADCSHT_A :: ADCSHT_8 , 9 => ADCSHT_A :: ADCSHT_9 , 10 => ADCSHT_A :: ADCSHT_10 , 11 => ADCSHT_A :: ADCSHT_11 , 12 => ADCSHT_A :: ADCSHT_12 , 13 => ADCSHT_A :: ADCSHT_13 , 14 => ADCSHT_A :: ADCSHT_14 , 15 => ADCSHT_A :: ADCSHT_15 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `ADCSHT_0`" ] # [ inline ( always ) ] pub fn is_adcsht_0 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_0 } # [ doc = "Checks if the value of the field is `ADCSHT_1`" ] # [ inline ( always ) ] pub fn is_adcsht_1 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_1 } # [ doc = "Checks if the value of the field is `ADCSHT_2`" ] # [ inline ( always ) ] pub fn is_adcsht_2 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_2 } # [ doc = "Checks if the value of the field is `ADCSHT_3`" ] # [ inline ( always ) ] pub fn is_adcsht_3 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_3 } # [ doc = "Checks if the value of the field is `ADCSHT_4`" ] # [ inline ( always ) ] pub fn is_adcsht_4 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_4 } # [ doc = "Checks if the value of the field is `ADCSHT_5`" ] # [ inline ( always ) ] pub fn is_adcsht_5 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_5 } # [ doc = "Checks if the value of the field is `ADCSHT_6`" ] # [ inline ( always ) ] pub fn is_adcsht_6 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_6 } # [ doc = "Checks if the value of the field is `ADCSHT_7`" ] # [ inline ( always ) ] pub fn is_adcsht_7 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_7 } # [ doc = "Checks if the value of the field is `ADCSHT_8`" ] # [ inline ( always ) ] pub fn is_adcsht_8 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_8 } # [ doc = "Checks if the value of the field is `ADCSHT_9`" ] # [ inline ( always ) ] pub fn is_adcsht_9 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_9 } # [ doc = "Checks if the value of the field is `ADCSHT_10`" ] # [ inline ( always ) ] pub fn is_adcsht_10 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_10 } # [ doc = "Checks if the value of the field is `ADCSHT_11`" ] # [ inline ( always ) ] pub fn is_adcsht_11 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_11 } # [ doc = "Checks if the value of the field is `ADCSHT_12`" ] # [ inline ( always ) ] pub fn is_adcsht_12 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_12 } # [ doc = "Checks if the value of the field is `ADCSHT_13`" ] # [ inline ( always ) ] pub fn is_adcsht_13 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_13 } # [ doc = "Checks if the value of the field is `ADCSHT_14`" ] # [ inline ( always ) ] pub fn is_adcsht_14 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_14 } # [ doc = "Checks if the value of the field is `ADCSHT_15`" ] # [ inline ( always ) ] pub fn is_adcsht_15 ( & self ) -> bool { * self == ADCSHT_A :: ADCSHT_15 } }
# [ doc = "Write proxy for field `ADCSHT`" ] pub struct ADCSHT_W < 'a > { w : & 'a mut W , } impl < 'a > ADCSHT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCSHT_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "4 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_0 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_0 ) } # [ doc = "8 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_1 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_1 ) } # [ doc = "16 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_2 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_2 ) } # [ doc = "32 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_3 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_3 ) } # [ doc = "64 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_4 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_4 ) } # [ doc = "96 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_5 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_5 ) } # [ doc = "128 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_6 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_6 ) } # [ doc = "192 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_7 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_7 ) } # [ doc = "256 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_8 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_8 ) } # [ doc = "384 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_9 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_9 ) } # [ doc = "512 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_10 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_10 ) } # [ doc = "768 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_11 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_11 ) } # [ doc = "1024 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_12 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_12 ) } # [ doc = "1024 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_13 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_13 ) } # [ doc = "1024 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_14 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_14 ) } # [ doc = "1024 ADCCLK cycles" ] # [ inline ( always ) ] pub fn adcsht_15 ( self ) -> & 'a mut W { self . variant ( ADCSHT_A :: ADCSHT_15 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 8 ) ) | ( ( ( value as u16 ) & 0x0f ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - start conversion" ] # [ inline ( always ) ] pub fn adcsc ( & self ) -> ADCSC_R { ADCSC_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - enable conversion" ] # [ inline ( always ) ] pub fn adcenc ( & self ) -> ADCENC_R { ADCENC_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - ADC on" ] # [ inline ( always ) ] pub fn adcon ( & self ) -> ADCON_R { ADCON_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - sample-and-hold time." ] # [ inline ( always ) ] pub fn adcmsc ( & self ) -> ADCMSC_R { ADCMSC_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:11 - sample-and-hold time." ] # [ inline ( always ) ] pub fn adcsht ( & self ) -> ADCSHT_R { ADCSHT_R :: new ( ( ( self . bits >> 8 ) & 0x0f ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - start conversion" ] # [ inline ( always ) ] pub fn adcsc ( & mut self ) -> ADCSC_W { ADCSC_W { w : self } }
# [ doc = "Bit 1 - enable conversion" ] # [ inline ( always ) ] pub fn adcenc ( & mut self ) -> ADCENC_W { ADCENC_W { w : self } }
# [ doc = "Bit 4 - ADC on" ] # [ inline ( always ) ] pub fn adcon ( & mut self ) -> ADCON_W { ADCON_W { w : self } }
# [ doc = "Bit 7 - sample-and-hold time." ] # [ inline ( always ) ] pub fn adcmsc ( & mut self ) -> ADCMSC_W { ADCMSC_W { w : self } }
# [ doc = "Bits 8:11 - sample-and-hold time." ] # [ inline ( always ) ] pub fn adcsht ( & mut self ) -> ADCSHT_W { ADCSHT_W { w : self } }
}
}
# [ doc = "ADC Control 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcctl1](adcctl1) module" ] pub type ADCCTL1 = crate :: Reg < u16 , _ADCCTL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADCCTL1 ;
# [ doc = "`read()` method returns [adcctl1::R](adcctl1::R) reader structure" ] impl crate :: Readable for ADCCTL1 { }
# [ doc = "`write(|w| ..)` method takes [adcctl1::W](adcctl1::W) writer structure" ] impl crate :: Writable for ADCCTL1 { }
# [ doc = "ADC Control 1" ] pub mod adcctl1 {
# [ doc = "Reader of register ADCCTL1" ] pub type R = crate :: R < u16 , super :: ADCCTL1 > ;
# [ doc = "Writer for register ADCCTL1" ] pub type W = crate :: W < u16 , super :: ADCCTL1 > ;
# [ doc = "Register ADCCTL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADCCTL1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "ADC busy\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCBUSY_A { # [ doc = "0: No operation is active." ] ADCBUSY_0 = 0 , # [ doc = "1: A sequence, sample, or conversion is active." ] ADCBUSY_1 = 1 } impl From < ADCBUSY_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCBUSY_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCBUSY`" ] pub type ADCBUSY_R = crate :: R < bool , ADCBUSY_A > ; impl ADCBUSY_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCBUSY_A { match self . bits { false => ADCBUSY_A :: ADCBUSY_0 , true => ADCBUSY_A :: ADCBUSY_1 } } # [ doc = "Checks if the value of the field is `ADCBUSY_0`" ] # [ inline ( always ) ] pub fn is_adcbusy_0 ( & self ) -> bool { * self == ADCBUSY_A :: ADCBUSY_0 } # [ doc = "Checks if the value of the field is `ADCBUSY_1`" ] # [ inline ( always ) ] pub fn is_adcbusy_1 ( & self ) -> bool { * self == ADCBUSY_A :: ADCBUSY_1 } }
# [ doc = "conversion sequence mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ADCCONSEQ_A { # [ doc = "0: Single-channel, single-conversion" ] ADCCONSEQ_0 = 0 , # [ doc = "1: Sequence-of-channels" ] ADCCONSEQ_1 = 1 , # [ doc = "2: Repeat-single-channel" ] ADCCONSEQ_2 = 2 , # [ doc = "3: Repeat-sequence-of-channels" ] ADCCONSEQ_3 = 3 } impl From < ADCCONSEQ_A > for u8 { # [ inline ( always ) ] fn from ( variant : ADCCONSEQ_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ADCCONSEQ`" ] pub type ADCCONSEQ_R = crate :: R < u8 , ADCCONSEQ_A > ; impl ADCCONSEQ_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCCONSEQ_A { match self . bits { 0 => ADCCONSEQ_A :: ADCCONSEQ_0 , 1 => ADCCONSEQ_A :: ADCCONSEQ_1 , 2 => ADCCONSEQ_A :: ADCCONSEQ_2 , 3 => ADCCONSEQ_A :: ADCCONSEQ_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `ADCCONSEQ_0`" ] # [ inline ( always ) ] pub fn is_adcconseq_0 ( & self ) -> bool { * self == ADCCONSEQ_A :: ADCCONSEQ_0 } # [ doc = "Checks if the value of the field is `ADCCONSEQ_1`" ] # [ inline ( always ) ] pub fn is_adcconseq_1 ( & self ) -> bool { * self == ADCCONSEQ_A :: ADCCONSEQ_1 } # [ doc = "Checks if the value of the field is `ADCCONSEQ_2`" ] # [ inline ( always ) ] pub fn is_adcconseq_2 ( & self ) -> bool { * self == ADCCONSEQ_A :: ADCCONSEQ_2 } # [ doc = "Checks if the value of the field is `ADCCONSEQ_3`" ] # [ inline ( always ) ] pub fn is_adcconseq_3 ( & self ) -> bool { * self == ADCCONSEQ_A :: ADCCONSEQ_3 } }
# [ doc = "Write proxy for field `ADCCONSEQ`" ] pub struct ADCCONSEQ_W < 'a > { w : & 'a mut W , } impl < 'a > ADCCONSEQ_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCCONSEQ_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Single-channel, single-conversion" ] # [ inline ( always ) ] pub fn adcconseq_0 ( self ) -> & 'a mut W { self . variant ( ADCCONSEQ_A :: ADCCONSEQ_0 ) } # [ doc = "Sequence-of-channels" ] # [ inline ( always ) ] pub fn adcconseq_1 ( self ) -> & 'a mut W { self . variant ( ADCCONSEQ_A :: ADCCONSEQ_1 ) } # [ doc = "Repeat-single-channel" ] # [ inline ( always ) ] pub fn adcconseq_2 ( self ) -> & 'a mut W { self . variant ( ADCCONSEQ_A :: ADCCONSEQ_2 ) } # [ doc = "Repeat-sequence-of-channels" ] # [ inline ( always ) ] pub fn adcconseq_3 ( self ) -> & 'a mut W { self . variant ( ADCCONSEQ_A :: ADCCONSEQ_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 1 ) ) | ( ( ( value as u16 ) & 0x03 ) << 1 ) ; self . w } }
# [ doc = "clock source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ADCSSEL_A { # [ doc = "0: ADCOSC (MODOSC)" ] ADCSSEL_0 = 0 , # [ doc = "1: ACLK" ] ADCSSEL_1 = 1 , # [ doc = "2: MCLK" ] ADCSSEL_2 = 2 , # [ doc = "3: SMCLK" ] ADCSSEL_3 = 3 } impl From < ADCSSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : ADCSSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ADCSSEL`" ] pub type ADCSSEL_R = crate :: R < u8 , ADCSSEL_A > ; impl ADCSSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCSSEL_A { match self . bits { 0 => ADCSSEL_A :: ADCSSEL_0 , 1 => ADCSSEL_A :: ADCSSEL_1 , 2 => ADCSSEL_A :: ADCSSEL_2 , 3 => ADCSSEL_A :: ADCSSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `ADCSSEL_0`" ] # [ inline ( always ) ] pub fn is_adcssel_0 ( & self ) -> bool { * self == ADCSSEL_A :: ADCSSEL_0 } # [ doc = "Checks if the value of the field is `ADCSSEL_1`" ] # [ inline ( always ) ] pub fn is_adcssel_1 ( & self ) -> bool { * self == ADCSSEL_A :: ADCSSEL_1 } # [ doc = "Checks if the value of the field is `ADCSSEL_2`" ] # [ inline ( always ) ] pub fn is_adcssel_2 ( & self ) -> bool { * self == ADCSSEL_A :: ADCSSEL_2 } # [ doc = "Checks if the value of the field is `ADCSSEL_3`" ] # [ inline ( always ) ] pub fn is_adcssel_3 ( & self ) -> bool { * self == ADCSSEL_A :: ADCSSEL_3 } }
# [ doc = "Write proxy for field `ADCSSEL`" ] pub struct ADCSSEL_W < 'a > { w : & 'a mut W , } impl < 'a > ADCSSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCSSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "ADCOSC (MODOSC)" ] # [ inline ( always ) ] pub fn adcssel_0 ( self ) -> & 'a mut W { self . variant ( ADCSSEL_A :: ADCSSEL_0 ) } # [ doc = "ACLK" ] # [ inline ( always ) ] pub fn adcssel_1 ( self ) -> & 'a mut W { self . variant ( ADCSSEL_A :: ADCSSEL_1 ) } # [ doc = "MCLK" ] # [ inline ( always ) ] pub fn adcssel_2 ( self ) -> & 'a mut W { self . variant ( ADCSSEL_A :: ADCSSEL_2 ) } # [ doc = "SMCLK" ] # [ inline ( always ) ] pub fn adcssel_3 ( self ) -> & 'a mut W { self . variant ( ADCSSEL_A :: ADCSSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 3 ) ) | ( ( ( value as u16 ) & 0x03 ) << 3 ) ; self . w } }
# [ doc = "clock divider\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ADCDIV_A { # [ doc = "0: /1" ] ADCDIV_0 = 0 , # [ doc = "1: /2" ] ADCDIV_1 = 1 , # [ doc = "2: /3" ] ADCDIV_2 = 2 , # [ doc = "3: /4" ] ADCDIV_3 = 3 , # [ doc = "4: /5" ] ADCDIV_4 = 4 , # [ doc = "5: /6" ] ADCDIV_5 = 5 , # [ doc = "6: /7" ] ADCDIV_6 = 6 , # [ doc = "7: /8" ] ADCDIV_7 = 7 } impl From < ADCDIV_A > for u8 { # [ inline ( always ) ] fn from ( variant : ADCDIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ADCDIV`" ] pub type ADCDIV_R = crate :: R < u8 , ADCDIV_A > ; impl ADCDIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCDIV_A { match self . bits { 0 => ADCDIV_A :: ADCDIV_0 , 1 => ADCDIV_A :: ADCDIV_1 , 2 => ADCDIV_A :: ADCDIV_2 , 3 => ADCDIV_A :: ADCDIV_3 , 4 => ADCDIV_A :: ADCDIV_4 , 5 => ADCDIV_A :: ADCDIV_5 , 6 => ADCDIV_A :: ADCDIV_6 , 7 => ADCDIV_A :: ADCDIV_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `ADCDIV_0`" ] # [ inline ( always ) ] pub fn is_adcdiv_0 ( & self ) -> bool { * self == ADCDIV_A :: ADCDIV_0 } # [ doc = "Checks if the value of the field is `ADCDIV_1`" ] # [ inline ( always ) ] pub fn is_adcdiv_1 ( & self ) -> bool { * self == ADCDIV_A :: ADCDIV_1 } # [ doc = "Checks if the value of the field is `ADCDIV_2`" ] # [ inline ( always ) ] pub fn is_adcdiv_2 ( & self ) -> bool { * self == ADCDIV_A :: ADCDIV_2 } # [ doc = "Checks if the value of the field is `ADCDIV_3`" ] # [ inline ( always ) ] pub fn is_adcdiv_3 ( & self ) -> bool { * self == ADCDIV_A :: ADCDIV_3 } # [ doc = "Checks if the value of the field is `ADCDIV_4`" ] # [ inline ( always ) ] pub fn is_adcdiv_4 ( & self ) -> bool { * self == ADCDIV_A :: ADCDIV_4 } # [ doc = "Checks if the value of the field is `ADCDIV_5`" ] # [ inline ( always ) ] pub fn is_adcdiv_5 ( & self ) -> bool { * self == ADCDIV_A :: ADCDIV_5 } # [ doc = "Checks if the value of the field is `ADCDIV_6`" ] # [ inline ( always ) ] pub fn is_adcdiv_6 ( & self ) -> bool { * self == ADCDIV_A :: ADCDIV_6 } # [ doc = "Checks if the value of the field is `ADCDIV_7`" ] # [ inline ( always ) ] pub fn is_adcdiv_7 ( & self ) -> bool { * self == ADCDIV_A :: ADCDIV_7 } }
# [ doc = "Write proxy for field `ADCDIV`" ] pub struct ADCDIV_W < 'a > { w : & 'a mut W , } impl < 'a > ADCDIV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCDIV_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "/1" ] # [ inline ( always ) ] pub fn adcdiv_0 ( self ) -> & 'a mut W { self . variant ( ADCDIV_A :: ADCDIV_0 ) } # [ doc = "/2" ] # [ inline ( always ) ] pub fn adcdiv_1 ( self ) -> & 'a mut W { self . variant ( ADCDIV_A :: ADCDIV_1 ) } # [ doc = "/3" ] # [ inline ( always ) ] pub fn adcdiv_2 ( self ) -> & 'a mut W { self . variant ( ADCDIV_A :: ADCDIV_2 ) } # [ doc = "/4" ] # [ inline ( always ) ] pub fn adcdiv_3 ( self ) -> & 'a mut W { self . variant ( ADCDIV_A :: ADCDIV_3 ) } # [ doc = "/5" ] # [ inline ( always ) ] pub fn adcdiv_4 ( self ) -> & 'a mut W { self . variant ( ADCDIV_A :: ADCDIV_4 ) } # [ doc = "/6" ] # [ inline ( always ) ] pub fn adcdiv_5 ( self ) -> & 'a mut W { self . variant ( ADCDIV_A :: ADCDIV_5 ) } # [ doc = "/7" ] # [ inline ( always ) ] pub fn adcdiv_6 ( self ) -> & 'a mut W { self . variant ( ADCDIV_A :: ADCDIV_6 ) } # [ doc = "/8" ] # [ inline ( always ) ] pub fn adcdiv_7 ( self ) -> & 'a mut W { self . variant ( ADCDIV_A :: ADCDIV_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u16 ) & 0x07 ) << 5 ) ; self . w } }
# [ doc = "invert signal sample-and-hold\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCISSH_A { # [ doc = "0: The sample-input signal is not inverted." ] ADCISSH_0 = 0 , # [ doc = "1: The sample-input signal is inverted." ] ADCISSH_1 = 1 } impl From < ADCISSH_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCISSH_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCISSH`" ] pub type ADCISSH_R = crate :: R < bool , ADCISSH_A > ; impl ADCISSH_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCISSH_A { match self . bits { false => ADCISSH_A :: ADCISSH_0 , true => ADCISSH_A :: ADCISSH_1 } } # [ doc = "Checks if the value of the field is `ADCISSH_0`" ] # [ inline ( always ) ] pub fn is_adcissh_0 ( & self ) -> bool { * self == ADCISSH_A :: ADCISSH_0 } # [ doc = "Checks if the value of the field is `ADCISSH_1`" ] # [ inline ( always ) ] pub fn is_adcissh_1 ( & self ) -> bool { * self == ADCISSH_A :: ADCISSH_1 } }
# [ doc = "Write proxy for field `ADCISSH`" ] pub struct ADCISSH_W < 'a > { w : & 'a mut W , } impl < 'a > ADCISSH_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCISSH_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "The sample-input signal is not inverted." ] # [ inline ( always ) ] pub fn adcissh_0 ( self ) -> & 'a mut W { self . variant ( ADCISSH_A :: ADCISSH_0 ) } # [ doc = "The sample-input signal is inverted." ] # [ inline ( always ) ] pub fn adcissh_1 ( self ) -> & 'a mut W { self . variant ( ADCISSH_A :: ADCISSH_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "sample-and-hold pulse-mode select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCSHP_A { # [ doc = "0: SAMPCON signal is sourced from the sample-input signal." ] ADCSHP_0 = 0 , # [ doc = "1: SAMPCON signal is sourced from the sampling timer." ] ADCSHP_1 = 1 } impl From < ADCSHP_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCSHP_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCSHP`" ] pub type ADCSHP_R = crate :: R < bool , ADCSHP_A > ; impl ADCSHP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCSHP_A { match self . bits { false => ADCSHP_A :: ADCSHP_0 , true => ADCSHP_A :: ADCSHP_1 } } # [ doc = "Checks if the value of the field is `ADCSHP_0`" ] # [ inline ( always ) ] pub fn is_adcshp_0 ( & self ) -> bool { * self == ADCSHP_A :: ADCSHP_0 } # [ doc = "Checks if the value of the field is `ADCSHP_1`" ] # [ inline ( always ) ] pub fn is_adcshp_1 ( & self ) -> bool { * self == ADCSHP_A :: ADCSHP_1 } }
# [ doc = "Write proxy for field `ADCSHP`" ] pub struct ADCSHP_W < 'a > { w : & 'a mut W , } impl < 'a > ADCSHP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCSHP_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SAMPCON signal is sourced from the sample-input signal." ] # [ inline ( always ) ] pub fn adcshp_0 ( self ) -> & 'a mut W { self . variant ( ADCSHP_A :: ADCSHP_0 ) } # [ doc = "SAMPCON signal is sourced from the sampling timer." ] # [ inline ( always ) ] pub fn adcshp_1 ( self ) -> & 'a mut W { self . variant ( ADCSHP_A :: ADCSHP_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "sample-and-hold source select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ADCSHS_A { # [ doc = "0: ADCSC bit" ] ADCSHS_0 = 0 , # [ doc = "1: see the device-specific data sheet for source" ] ADCSHS_1 = 1 , # [ doc = "2: see the device-specific data sheet for source" ] ADCSHS_2 = 2 , # [ doc = "3: see the device-specific data sheet for source" ] ADCSHS_3 = 3 } impl From < ADCSHS_A > for u8 { # [ inline ( always ) ] fn from ( variant : ADCSHS_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ADCSHS`" ] pub type ADCSHS_R = crate :: R < u8 , ADCSHS_A > ; impl ADCSHS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCSHS_A { match self . bits { 0 => ADCSHS_A :: ADCSHS_0 , 1 => ADCSHS_A :: ADCSHS_1 , 2 => ADCSHS_A :: ADCSHS_2 , 3 => ADCSHS_A :: ADCSHS_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `ADCSHS_0`" ] # [ inline ( always ) ] pub fn is_adcshs_0 ( & self ) -> bool { * self == ADCSHS_A :: ADCSHS_0 } # [ doc = "Checks if the value of the field is `ADCSHS_1`" ] # [ inline ( always ) ] pub fn is_adcshs_1 ( & self ) -> bool { * self == ADCSHS_A :: ADCSHS_1 } # [ doc = "Checks if the value of the field is `ADCSHS_2`" ] # [ inline ( always ) ] pub fn is_adcshs_2 ( & self ) -> bool { * self == ADCSHS_A :: ADCSHS_2 } # [ doc = "Checks if the value of the field is `ADCSHS_3`" ] # [ inline ( always ) ] pub fn is_adcshs_3 ( & self ) -> bool { * self == ADCSHS_A :: ADCSHS_3 } }
# [ doc = "Write proxy for field `ADCSHS`" ] pub struct ADCSHS_W < 'a > { w : & 'a mut W , } impl < 'a > ADCSHS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCSHS_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "ADCSC bit" ] # [ inline ( always ) ] pub fn adcshs_0 ( self ) -> & 'a mut W { self . variant ( ADCSHS_A :: ADCSHS_0 ) } # [ doc = "see the device-specific data sheet for source" ] # [ inline ( always ) ] pub fn adcshs_1 ( self ) -> & 'a mut W { self . variant ( ADCSHS_A :: ADCSHS_1 ) } # [ doc = "see the device-specific data sheet for source" ] # [ inline ( always ) ] pub fn adcshs_2 ( self ) -> & 'a mut W { self . variant ( ADCSHS_A :: ADCSHS_2 ) } # [ doc = "see the device-specific data sheet for source" ] # [ inline ( always ) ] pub fn adcshs_3 ( self ) -> & 'a mut W { self . variant ( ADCSHS_A :: ADCSHS_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u16 ) & 0x03 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - ADC busy" ] # [ inline ( always ) ] pub fn adcbusy ( & self ) -> ADCBUSY_R { ADCBUSY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bits 1:2 - conversion sequence mode select" ] # [ inline ( always ) ] pub fn adcconseq ( & self ) -> ADCCONSEQ_R { ADCCONSEQ_R :: new ( ( ( self . bits >> 1 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 3:4 - clock source select" ] # [ inline ( always ) ] pub fn adcssel ( & self ) -> ADCSSEL_R { ADCSSEL_R :: new ( ( ( self . bits >> 3 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 5:7 - clock divider" ] # [ inline ( always ) ] pub fn adcdiv ( & self ) -> ADCDIV_R { ADCDIV_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - invert signal sample-and-hold" ] # [ inline ( always ) ] pub fn adcissh ( & self ) -> ADCISSH_R { ADCISSH_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - sample-and-hold pulse-mode select" ] # [ inline ( always ) ] pub fn adcshp ( & self ) -> ADCSHP_R { ADCSHP_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 10:11 - sample-and-hold source select" ] # [ inline ( always ) ] pub fn adcshs ( & self ) -> ADCSHS_R { ADCSHS_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 1:2 - conversion sequence mode select" ] # [ inline ( always ) ] pub fn adcconseq ( & mut self ) -> ADCCONSEQ_W { ADCCONSEQ_W { w : self } }
# [ doc = "Bits 3:4 - clock source select" ] # [ inline ( always ) ] pub fn adcssel ( & mut self ) -> ADCSSEL_W { ADCSSEL_W { w : self } }
# [ doc = "Bits 5:7 - clock divider" ] # [ inline ( always ) ] pub fn adcdiv ( & mut self ) -> ADCDIV_W { ADCDIV_W { w : self } }
# [ doc = "Bit 8 - invert signal sample-and-hold" ] # [ inline ( always ) ] pub fn adcissh ( & mut self ) -> ADCISSH_W { ADCISSH_W { w : self } }
# [ doc = "Bit 9 - sample-and-hold pulse-mode select" ] # [ inline ( always ) ] pub fn adcshp ( & mut self ) -> ADCSHP_W { ADCSHP_W { w : self } }
# [ doc = "Bits 10:11 - sample-and-hold source select" ] # [ inline ( always ) ] pub fn adcshs ( & mut self ) -> ADCSHS_W { ADCSHS_W { w : self } }
}
}
# [ doc = "ADC Control 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcctl2](adcctl2) module" ] pub type ADCCTL2 = crate :: Reg < u16 , _ADCCTL2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADCCTL2 ;
# [ doc = "`read()` method returns [adcctl2::R](adcctl2::R) reader structure" ] impl crate :: Readable for ADCCTL2 { }
# [ doc = "`write(|w| ..)` method takes [adcctl2::W](adcctl2::W) writer structure" ] impl crate :: Writable for ADCCTL2 { }
# [ doc = "ADC Control 2" ] pub mod adcctl2 {
# [ doc = "Reader of register ADCCTL2" ] pub type R = crate :: R < u16 , super :: ADCCTL2 > ;
# [ doc = "Writer for register ADCCTL2" ] pub type W = crate :: W < u16 , super :: ADCCTL2 > ;
# [ doc = "Register ADCCTL2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADCCTL2 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "data read-back format\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCDF_A { # [ doc = "0: Binary unsigned. Theoretically the analog input voltage V(REF) results in 0000h, the analog input voltage +V(REF) results in 03FFh." ] ADCDF_0 = 0 , # [ doc = "1: Signed binary (2s complement), left aligned. Theoretically the analog input voltage V(REF) results in 8000h, the analog input voltage +V(REF) results in 7FC0h." ] ADCDF_1 = 1 } impl From < ADCDF_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCDF_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCDF`" ] pub type ADCDF_R = crate :: R < bool , ADCDF_A > ; impl ADCDF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCDF_A { match self . bits { false => ADCDF_A :: ADCDF_0 , true => ADCDF_A :: ADCDF_1 } } # [ doc = "Checks if the value of the field is `ADCDF_0`" ] # [ inline ( always ) ] pub fn is_adcdf_0 ( & self ) -> bool { * self == ADCDF_A :: ADCDF_0 } # [ doc = "Checks if the value of the field is `ADCDF_1`" ] # [ inline ( always ) ] pub fn is_adcdf_1 ( & self ) -> bool { * self == ADCDF_A :: ADCDF_1 } }
# [ doc = "Write proxy for field `ADCDF`" ] pub struct ADCDF_W < 'a > { w : & 'a mut W , } impl < 'a > ADCDF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCDF_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Binary unsigned. Theoretically the analog input voltage V(REF) results in 0000h, the analog input voltage +V(REF) results in 03FFh." ] # [ inline ( always ) ] pub fn adcdf_0 ( self ) -> & 'a mut W { self . variant ( ADCDF_A :: ADCDF_0 ) } # [ doc = "Signed binary (2s complement), left aligned. Theoretically the analog input voltage V(REF) results in 8000h, the analog input voltage +V(REF) results in 7FC0h." ] # [ inline ( always ) ] pub fn adcdf_1 ( self ) -> & 'a mut W { self . variant ( ADCDF_A :: ADCDF_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "resolution\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ADCRES_A { # [ doc = "0: 8 bit" ] ADCRES_0 = 0 , # [ doc = "1: 10 bit" ] ADCRES_1 = 1 , # [ doc = "2: 12 bit" ] ADCRES_2 = 2 , # [ doc = "3: Reserved" ] ADCRES_3 = 3 } impl From < ADCRES_A > for u8 { # [ inline ( always ) ] fn from ( variant : ADCRES_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ADCRES`" ] pub type ADCRES_R = crate :: R < u8 , ADCRES_A > ; impl ADCRES_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCRES_A { match self . bits { 0 => ADCRES_A :: ADCRES_0 , 1 => ADCRES_A :: ADCRES_1 , 2 => ADCRES_A :: ADCRES_2 , 3 => ADCRES_A :: ADCRES_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `ADCRES_0`" ] # [ inline ( always ) ] pub fn is_adcres_0 ( & self ) -> bool { * self == ADCRES_A :: ADCRES_0 } # [ doc = "Checks if the value of the field is `ADCRES_1`" ] # [ inline ( always ) ] pub fn is_adcres_1 ( & self ) -> bool { * self == ADCRES_A :: ADCRES_1 } # [ doc = "Checks if the value of the field is `ADCRES_2`" ] # [ inline ( always ) ] pub fn is_adcres_2 ( & self ) -> bool { * self == ADCRES_A :: ADCRES_2 } # [ doc = "Checks if the value of the field is `ADCRES_3`" ] # [ inline ( always ) ] pub fn is_adcres_3 ( & self ) -> bool { * self == ADCRES_A :: ADCRES_3 } }
# [ doc = "Write proxy for field `ADCRES`" ] pub struct ADCRES_W < 'a > { w : & 'a mut W , } impl < 'a > ADCRES_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCRES_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "8 bit" ] # [ inline ( always ) ] pub fn adcres_0 ( self ) -> & 'a mut W { self . variant ( ADCRES_A :: ADCRES_0 ) } # [ doc = "10 bit" ] # [ inline ( always ) ] pub fn adcres_1 ( self ) -> & 'a mut W { self . variant ( ADCRES_A :: ADCRES_1 ) } # [ doc = "12 bit" ] # [ inline ( always ) ] pub fn adcres_2 ( self ) -> & 'a mut W { self . variant ( ADCRES_A :: ADCRES_2 ) } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn adcres_3 ( self ) -> & 'a mut W { self . variant ( ADCRES_A :: ADCRES_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `ADCSR`" ] pub type ADCSR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ADCSR`" ] pub struct ADCSR_W < 'a > { w : & 'a mut W , } impl < 'a > ADCSR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "ADC predivider. This bit predivides the selected ADC clock source before it gets divided again using ADCDIVx.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ADCPDIV_A { # [ doc = "0: Predivide by 1" ] _1 = 0 , # [ doc = "1: Predivide by 4" ] _4 = 1 , # [ doc = "2: Predivide by 64" ] _64 = 2 , # [ doc = "3: Reserved" ] ADCPDIV_3 = 3 } impl From < ADCPDIV_A > for u8 { # [ inline ( always ) ] fn from ( variant : ADCPDIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ADCPDIV`" ] pub type ADCPDIV_R = crate :: R < u8 , ADCPDIV_A > ; impl ADCPDIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCPDIV_A { match self . bits { 0 => ADCPDIV_A :: _1 , 1 => ADCPDIV_A :: _4 , 2 => ADCPDIV_A :: _64 , 3 => ADCPDIV_A :: ADCPDIV_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == ADCPDIV_A :: _1 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == ADCPDIV_A :: _4 } # [ doc = "Checks if the value of the field is `_64`" ] # [ inline ( always ) ] pub fn is_64 ( & self ) -> bool { * self == ADCPDIV_A :: _64 } # [ doc = "Checks if the value of the field is `ADCPDIV_3`" ] # [ inline ( always ) ] pub fn is_adcpdiv_3 ( & self ) -> bool { * self == ADCPDIV_A :: ADCPDIV_3 } }
# [ doc = "Write proxy for field `ADCPDIV`" ] pub struct ADCPDIV_W < 'a > { w : & 'a mut W , } impl < 'a > ADCPDIV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCPDIV_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Predivide by 1" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( ADCPDIV_A :: _1 ) } # [ doc = "Predivide by 4" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( ADCPDIV_A :: _4 ) } # [ doc = "Predivide by 64" ] # [ inline ( always ) ] pub fn _64 ( self ) -> & 'a mut W { self . variant ( ADCPDIV_A :: _64 ) } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn adcpdiv_3 ( self ) -> & 'a mut W { self . variant ( ADCPDIV_A :: ADCPDIV_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bit 3 - data read-back format" ] # [ inline ( always ) ] pub fn adcdf ( & self ) -> ADCDF_R { ADCDF_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - resolution" ] # [ inline ( always ) ] pub fn adcres ( & self ) -> ADCRES_R { ADCRES_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 2 - ADC sampling rate." ] # [ inline ( always ) ] pub fn adcsr ( & self ) -> ADCSR_R { ADCSR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:9 - ADC predivider. This bit predivides the selected ADC clock source before it gets divided again using ADCDIVx." ] # [ inline ( always ) ] pub fn adcpdiv ( & self ) -> ADCPDIV_R { ADCPDIV_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 3 - data read-back format" ] # [ inline ( always ) ] pub fn adcdf ( & mut self ) -> ADCDF_W { ADCDF_W { w : self } }
# [ doc = "Bits 4:5 - resolution" ] # [ inline ( always ) ] pub fn adcres ( & mut self ) -> ADCRES_W { ADCRES_W { w : self } }
# [ doc = "Bit 2 - ADC sampling rate." ] # [ inline ( always ) ] pub fn adcsr ( & mut self ) -> ADCSR_W { ADCSR_W { w : self } }
# [ doc = "Bits 8:9 - ADC predivider. This bit predivides the selected ADC clock source before it gets divided again using ADCDIVx." ] # [ inline ( always ) ] pub fn adcpdiv ( & mut self ) -> ADCPDIV_W { ADCPDIV_W { w : self } }
}
}
# [ doc = "ADC Window Comparator Low Threshold Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adclo](adclo) module" ] pub type ADCLO = crate :: Reg < u16 , _ADCLO > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADCLO ;
# [ doc = "`read()` method returns [adclo::R](adclo::R) reader structure" ] impl crate :: Readable for ADCLO { }
# [ doc = "`write(|w| ..)` method takes [adclo::W](adclo::W) writer structure" ] impl crate :: Writable for ADCLO { }
# [ doc = "ADC Window Comparator Low Threshold Register" ] pub mod adclo {
# [ doc = "Reader of register ADCLO" ] pub type R = crate :: R < u16 , super :: ADCLO > ;
# [ doc = "Writer for register ADCLO" ] pub type W = crate :: W < u16 , super :: ADCLO > ;
# [ doc = "Register ADCLO `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADCLO { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "ADC Window Comparator High Threshold Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adchi](adchi) module" ] pub type ADCHI = crate :: Reg < u16 , _ADCHI > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADCHI ;
# [ doc = "`read()` method returns [adchi::R](adchi::R) reader structure" ] impl crate :: Readable for ADCHI { }
# [ doc = "`write(|w| ..)` method takes [adchi::W](adchi::W) writer structure" ] impl crate :: Writable for ADCHI { }
# [ doc = "ADC Window Comparator High Threshold Register" ] pub mod adchi {
# [ doc = "Reader of register ADCHI" ] pub type R = crate :: R < u16 , super :: ADCHI > ;
# [ doc = "Writer for register ADCHI" ] pub type W = crate :: W < u16 , super :: ADCHI > ;
# [ doc = "Register ADCHI `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADCHI { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "ADC Conversion Memory Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcmctl0](adcmctl0) module" ] pub type ADCMCTL0 = crate :: Reg < u16 , _ADCMCTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADCMCTL0 ;
# [ doc = "`read()` method returns [adcmctl0::R](adcmctl0::R) reader structure" ] impl crate :: Readable for ADCMCTL0 { }
# [ doc = "`write(|w| ..)` method takes [adcmctl0::W](adcmctl0::W) writer structure" ] impl crate :: Writable for ADCMCTL0 { }
# [ doc = "ADC Conversion Memory Control Register" ] pub mod adcmctl0 {
# [ doc = "Reader of register ADCMCTL0" ] pub type R = crate :: R < u16 , super :: ADCMCTL0 > ;
# [ doc = "Writer for register ADCMCTL0" ] pub type W = crate :: W < u16 , super :: ADCMCTL0 > ;
# [ doc = "Register ADCMCTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADCMCTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Input channel select\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ADCINCH_A { # [ doc = "0: A0 - see device-specific data sheet" ] ADCINCH_0 = 0 , # [ doc = "1: A1 - see device-specific data sheet" ] ADCINCH_1 = 1 , # [ doc = "2: A2 - see device-specific data sheet" ] ADCINCH_2 = 2 , # [ doc = "3: A3 - see device-specific data sheet" ] ADCINCH_3 = 3 , # [ doc = "4: A4 - see device-specific data sheet" ] ADCINCH_4 = 4 , # [ doc = "5: A5 - see device-specific data sheet" ] ADCINCH_5 = 5 , # [ doc = "6: A2 - see device-specific data sheet" ] ADCINCH_6 = 6 , # [ doc = "7: A7 - see device-specific data sheet" ] ADCINCH_7 = 7 , # [ doc = "8: A8 - see device-specific data sheet" ] ADCINCH_8 = 8 , # [ doc = "9: A9 - see device-specific data sheet" ] ADCINCH_9 = 9 , # [ doc = "10: A10 - see device-specific data sheet" ] ADCINCH_10 = 10 , # [ doc = "11: A11 - see device-specific data sheet" ] ADCINCH_11 = 11 , # [ doc = "12: A12 - see device-specific data sheet" ] ADCINCH_12 = 12 , # [ doc = "13: A13 - see device-specific data sheet" ] ADCINCH_13 = 13 , # [ doc = "14: A14 - see device-specific data sheet" ] ADCINCH_14 = 14 , # [ doc = "15: A15 - see device-specific data sheet" ] ADCINCH_15 = 15 } impl From < ADCINCH_A > for u8 { # [ inline ( always ) ] fn from ( variant : ADCINCH_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ADCINCH`" ] pub type ADCINCH_R = crate :: R < u8 , ADCINCH_A > ; impl ADCINCH_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCINCH_A { match self . bits { 0 => ADCINCH_A :: ADCINCH_0 , 1 => ADCINCH_A :: ADCINCH_1 , 2 => ADCINCH_A :: ADCINCH_2 , 3 => ADCINCH_A :: ADCINCH_3 , 4 => ADCINCH_A :: ADCINCH_4 , 5 => ADCINCH_A :: ADCINCH_5 , 6 => ADCINCH_A :: ADCINCH_6 , 7 => ADCINCH_A :: ADCINCH_7 , 8 => ADCINCH_A :: ADCINCH_8 , 9 => ADCINCH_A :: ADCINCH_9 , 10 => ADCINCH_A :: ADCINCH_10 , 11 => ADCINCH_A :: ADCINCH_11 , 12 => ADCINCH_A :: ADCINCH_12 , 13 => ADCINCH_A :: ADCINCH_13 , 14 => ADCINCH_A :: ADCINCH_14 , 15 => ADCINCH_A :: ADCINCH_15 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `ADCINCH_0`" ] # [ inline ( always ) ] pub fn is_adcinch_0 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_0 } # [ doc = "Checks if the value of the field is `ADCINCH_1`" ] # [ inline ( always ) ] pub fn is_adcinch_1 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_1 } # [ doc = "Checks if the value of the field is `ADCINCH_2`" ] # [ inline ( always ) ] pub fn is_adcinch_2 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_2 } # [ doc = "Checks if the value of the field is `ADCINCH_3`" ] # [ inline ( always ) ] pub fn is_adcinch_3 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_3 } # [ doc = "Checks if the value of the field is `ADCINCH_4`" ] # [ inline ( always ) ] pub fn is_adcinch_4 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_4 } # [ doc = "Checks if the value of the field is `ADCINCH_5`" ] # [ inline ( always ) ] pub fn is_adcinch_5 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_5 } # [ doc = "Checks if the value of the field is `ADCINCH_6`" ] # [ inline ( always ) ] pub fn is_adcinch_6 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_6 } # [ doc = "Checks if the value of the field is `ADCINCH_7`" ] # [ inline ( always ) ] pub fn is_adcinch_7 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_7 } # [ doc = "Checks if the value of the field is `ADCINCH_8`" ] # [ inline ( always ) ] pub fn is_adcinch_8 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_8 } # [ doc = "Checks if the value of the field is `ADCINCH_9`" ] # [ inline ( always ) ] pub fn is_adcinch_9 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_9 } # [ doc = "Checks if the value of the field is `ADCINCH_10`" ] # [ inline ( always ) ] pub fn is_adcinch_10 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_10 } # [ doc = "Checks if the value of the field is `ADCINCH_11`" ] # [ inline ( always ) ] pub fn is_adcinch_11 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_11 } # [ doc = "Checks if the value of the field is `ADCINCH_12`" ] # [ inline ( always ) ] pub fn is_adcinch_12 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_12 } # [ doc = "Checks if the value of the field is `ADCINCH_13`" ] # [ inline ( always ) ] pub fn is_adcinch_13 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_13 } # [ doc = "Checks if the value of the field is `ADCINCH_14`" ] # [ inline ( always ) ] pub fn is_adcinch_14 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_14 } # [ doc = "Checks if the value of the field is `ADCINCH_15`" ] # [ inline ( always ) ] pub fn is_adcinch_15 ( & self ) -> bool { * self == ADCINCH_A :: ADCINCH_15 } }
# [ doc = "Write proxy for field `ADCINCH`" ] pub struct ADCINCH_W < 'a > { w : & 'a mut W , } impl < 'a > ADCINCH_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCINCH_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "A0 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_0 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_0 ) } # [ doc = "A1 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_1 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_1 ) } # [ doc = "A2 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_2 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_2 ) } # [ doc = "A3 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_3 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_3 ) } # [ doc = "A4 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_4 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_4 ) } # [ doc = "A5 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_5 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_5 ) } # [ doc = "A2 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_6 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_6 ) } # [ doc = "A7 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_7 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_7 ) } # [ doc = "A8 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_8 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_8 ) } # [ doc = "A9 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_9 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_9 ) } # [ doc = "A10 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_10 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_10 ) } # [ doc = "A11 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_11 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_11 ) } # [ doc = "A12 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_12 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_12 ) } # [ doc = "A13 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_13 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_13 ) } # [ doc = "A14 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_14 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_14 ) } # [ doc = "A15 - see device-specific data sheet" ] # [ inline ( always ) ] pub fn adcinch_15 ( self ) -> & 'a mut W { self . variant ( ADCINCH_A :: ADCINCH_15 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u16 ) & 0x0f ) ; self . w } }
# [ doc = "Select reference. It is not recommended to change this setting while a conversion is ongoing. Can be modified only when ADCENC = 0. Resetting ADCENC = 0 by software and changing these fields immediately shows an effect when a conversion is active.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum ADCSREF_A { # [ doc = "0: 000b = V(R+) = AVCC and V(R-) = AVSS" ] ADCSREF_0 = 0 , # [ doc = "1: 001b = V(R+) = VREF and V(R-) = AVSS" ] ADCSREF_1 = 1 , # [ doc = "2: 010b = V(R+) = VEREF+ buffered and V(R-) = AVSS" ] ADCSREF_2 = 2 , # [ doc = "3: 011b =V(R+) = VEREF+ and V(R-) = AVSS" ] ADCSREF_3 = 3 , # [ doc = "4: 100b = V(R+) = AVCC and V(R-) = VEREF-" ] ADCSREF_4 = 4 , # [ doc = "5: 101b = V(R+) = VREF and V(R-) = VEREF-" ] ADCSREF_5 = 5 , # [ doc = "6: 110b = V(R+) = VEREF+ buffered and V(R-) = VEREF-" ] ADCSREF_6 = 6 , # [ doc = "7: 111b = V(R+) = VEREF+ and V(R-) = VEREF-" ] ADCSREF_7 = 7 } impl From < ADCSREF_A > for u8 { # [ inline ( always ) ] fn from ( variant : ADCSREF_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ADCSREF`" ] pub type ADCSREF_R = crate :: R < u8 , ADCSREF_A > ; impl ADCSREF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCSREF_A { match self . bits { 0 => ADCSREF_A :: ADCSREF_0 , 1 => ADCSREF_A :: ADCSREF_1 , 2 => ADCSREF_A :: ADCSREF_2 , 3 => ADCSREF_A :: ADCSREF_3 , 4 => ADCSREF_A :: ADCSREF_4 , 5 => ADCSREF_A :: ADCSREF_5 , 6 => ADCSREF_A :: ADCSREF_6 , 7 => ADCSREF_A :: ADCSREF_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `ADCSREF_0`" ] # [ inline ( always ) ] pub fn is_adcsref_0 ( & self ) -> bool { * self == ADCSREF_A :: ADCSREF_0 } # [ doc = "Checks if the value of the field is `ADCSREF_1`" ] # [ inline ( always ) ] pub fn is_adcsref_1 ( & self ) -> bool { * self == ADCSREF_A :: ADCSREF_1 } # [ doc = "Checks if the value of the field is `ADCSREF_2`" ] # [ inline ( always ) ] pub fn is_adcsref_2 ( & self ) -> bool { * self == ADCSREF_A :: ADCSREF_2 } # [ doc = "Checks if the value of the field is `ADCSREF_3`" ] # [ inline ( always ) ] pub fn is_adcsref_3 ( & self ) -> bool { * self == ADCSREF_A :: ADCSREF_3 } # [ doc = "Checks if the value of the field is `ADCSREF_4`" ] # [ inline ( always ) ] pub fn is_adcsref_4 ( & self ) -> bool { * self == ADCSREF_A :: ADCSREF_4 } # [ doc = "Checks if the value of the field is `ADCSREF_5`" ] # [ inline ( always ) ] pub fn is_adcsref_5 ( & self ) -> bool { * self == ADCSREF_A :: ADCSREF_5 } # [ doc = "Checks if the value of the field is `ADCSREF_6`" ] # [ inline ( always ) ] pub fn is_adcsref_6 ( & self ) -> bool { * self == ADCSREF_A :: ADCSREF_6 } # [ doc = "Checks if the value of the field is `ADCSREF_7`" ] # [ inline ( always ) ] pub fn is_adcsref_7 ( & self ) -> bool { * self == ADCSREF_A :: ADCSREF_7 } }
# [ doc = "Write proxy for field `ADCSREF`" ] pub struct ADCSREF_W < 'a > { w : & 'a mut W , } impl < 'a > ADCSREF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCSREF_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "000b = V(R+) = AVCC and V(R-) = AVSS" ] # [ inline ( always ) ] pub fn adcsref_0 ( self ) -> & 'a mut W { self . variant ( ADCSREF_A :: ADCSREF_0 ) } # [ doc = "001b = V(R+) = VREF and V(R-) = AVSS" ] # [ inline ( always ) ] pub fn adcsref_1 ( self ) -> & 'a mut W { self . variant ( ADCSREF_A :: ADCSREF_1 ) } # [ doc = "010b = V(R+) = VEREF+ buffered and V(R-) = AVSS" ] # [ inline ( always ) ] pub fn adcsref_2 ( self ) -> & 'a mut W { self . variant ( ADCSREF_A :: ADCSREF_2 ) } # [ doc = "011b =V(R+) = VEREF+ and V(R-) = AVSS" ] # [ inline ( always ) ] pub fn adcsref_3 ( self ) -> & 'a mut W { self . variant ( ADCSREF_A :: ADCSREF_3 ) } # [ doc = "100b = V(R+) = AVCC and V(R-) = VEREF-" ] # [ inline ( always ) ] pub fn adcsref_4 ( self ) -> & 'a mut W { self . variant ( ADCSREF_A :: ADCSREF_4 ) } # [ doc = "101b = V(R+) = VREF and V(R-) = VEREF-" ] # [ inline ( always ) ] pub fn adcsref_5 ( self ) -> & 'a mut W { self . variant ( ADCSREF_A :: ADCSREF_5 ) } # [ doc = "110b = V(R+) = VEREF+ buffered and V(R-) = VEREF-" ] # [ inline ( always ) ] pub fn adcsref_6 ( self ) -> & 'a mut W { self . variant ( ADCSREF_A :: ADCSREF_6 ) } # [ doc = "111b = V(R+) = VEREF+ and V(R-) = VEREF-" ] # [ inline ( always ) ] pub fn adcsref_7 ( self ) -> & 'a mut W { self . variant ( ADCSREF_A :: ADCSREF_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 4 ) ) | ( ( ( value as u16 ) & 0x07 ) << 4 ) ; self . w } }
# [ doc = "ADC input channels expanded\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EXPCHEN_A { # [ doc = "0: ADC channel expanded disable" ] EXPCHEN_0 = 0 , # [ doc = "1: ADC channel expanded enable" ] EXPCHEN_1 = 1 } impl From < EXPCHEN_A > for bool { # [ inline ( always ) ] fn from ( variant : EXPCHEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `EXPCHEN`" ] pub type EXPCHEN_R = crate :: R < bool , EXPCHEN_A > ; impl EXPCHEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> EXPCHEN_A { match self . bits { false => EXPCHEN_A :: EXPCHEN_0 , true => EXPCHEN_A :: EXPCHEN_1 } } # [ doc = "Checks if the value of the field is `EXPCHEN_0`" ] # [ inline ( always ) ] pub fn is_expchen_0 ( & self ) -> bool { * self == EXPCHEN_A :: EXPCHEN_0 } # [ doc = "Checks if the value of the field is `EXPCHEN_1`" ] # [ inline ( always ) ] pub fn is_expchen_1 ( & self ) -> bool { * self == EXPCHEN_A :: EXPCHEN_1 } }
# [ doc = "Write proxy for field `EXPCHEN`" ] pub struct EXPCHEN_W < 'a > { w : & 'a mut W , } impl < 'a > EXPCHEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : EXPCHEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "ADC channel expanded disable" ] # [ inline ( always ) ] pub fn expchen_0 ( self ) -> & 'a mut W { self . variant ( EXPCHEN_A :: EXPCHEN_0 ) } # [ doc = "ADC channel expanded enable" ] # [ inline ( always ) ] pub fn expchen_1 ( self ) -> & 'a mut W { self . variant ( EXPCHEN_A :: EXPCHEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:3 - Input channel select" ] # [ inline ( always ) ] pub fn adcinch ( & self ) -> ADCINCH_R { ADCINCH_R :: new ( ( self . bits & 0x0f ) as u8 ) }
# [ doc = "Bits 4:6 - Select reference. It is not recommended to change this setting while a conversion is ongoing. Can be modified only when ADCENC = 0. Resetting ADCENC = 0 by software and changing these fields immediately shows an effect when a conversion is active." ] # [ inline ( always ) ] pub fn adcsref ( & self ) -> ADCSREF_R { ADCSREF_R :: new ( ( ( self . bits >> 4 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - ADC input channels expanded" ] # [ inline ( always ) ] pub fn expchen ( & self ) -> EXPCHEN_R { EXPCHEN_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:3 - Input channel select" ] # [ inline ( always ) ] pub fn adcinch ( & mut self ) -> ADCINCH_W { ADCINCH_W { w : self } }
# [ doc = "Bits 4:6 - Select reference. It is not recommended to change this setting while a conversion is ongoing. Can be modified only when ADCENC = 0. Resetting ADCENC = 0 by software and changing these fields immediately shows an effect when a conversion is active." ] # [ inline ( always ) ] pub fn adcsref ( & mut self ) -> ADCSREF_W { ADCSREF_W { w : self } }
# [ doc = "Bit 8 - ADC input channels expanded" ] # [ inline ( always ) ] pub fn expchen ( & mut self ) -> EXPCHEN_W { EXPCHEN_W { w : self } }
}
}
# [ doc = "ADC Conversion Memory Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcmem0](adcmem0) module" ] pub type ADCMEM0 = crate :: Reg < u16 , _ADCMEM0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADCMEM0 ;
# [ doc = "`read()` method returns [adcmem0::R](adcmem0::R) reader structure" ] impl crate :: Readable for ADCMEM0 { }
# [ doc = "`write(|w| ..)` method takes [adcmem0::W](adcmem0::W) writer structure" ] impl crate :: Writable for ADCMEM0 { }
# [ doc = "ADC Conversion Memory Register" ] pub mod adcmem0 {
# [ doc = "Reader of register ADCMEM0" ] pub type R = crate :: R < u16 , super :: ADCMEM0 > ;
# [ doc = "Writer for register ADCMEM0" ] pub type W = crate :: W < u16 , super :: ADCMEM0 > ;
# [ doc = "Register ADCMEM0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADCMEM0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "ADC Interrupt Enable 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcie](adcie) module" ] pub type ADCIE = crate :: Reg < u16 , _ADCIE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADCIE ;
# [ doc = "`read()` method returns [adcie::R](adcie::R) reader structure" ] impl crate :: Readable for ADCIE { }
# [ doc = "`write(|w| ..)` method takes [adcie::W](adcie::W) writer structure" ] impl crate :: Writable for ADCIE { }
# [ doc = "ADC Interrupt Enable 0" ] pub mod adcie {
# [ doc = "Reader of register ADCIE" ] pub type R = crate :: R < u16 , super :: ADCIE > ;
# [ doc = "Writer for register ADCIE" ] pub type W = crate :: W < u16 , super :: ADCIE > ;
# [ doc = "Register ADCIE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADCIE { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Interrupt enable. This bits enable or disable the interrupt request for a completed ADC conversion.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCIE0_A { # [ doc = "0: 0b = Interrupt disabled" ] ADCIE0_0 = 0 , # [ doc = "1: 1b = Interrupt enabled" ] ADCIE0_1 = 1 } impl From < ADCIE0_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCIE0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCIE0`" ] pub type ADCIE0_R = crate :: R < bool , ADCIE0_A > ; impl ADCIE0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCIE0_A { match self . bits { false => ADCIE0_A :: ADCIE0_0 , true => ADCIE0_A :: ADCIE0_1 } } # [ doc = "Checks if the value of the field is `ADCIE0_0`" ] # [ inline ( always ) ] pub fn is_adcie0_0 ( & self ) -> bool { * self == ADCIE0_A :: ADCIE0_0 } # [ doc = "Checks if the value of the field is `ADCIE0_1`" ] # [ inline ( always ) ] pub fn is_adcie0_1 ( & self ) -> bool { * self == ADCIE0_A :: ADCIE0_1 } }
# [ doc = "Write proxy for field `ADCIE0`" ] pub struct ADCIE0_W < 'a > { w : & 'a mut W , } impl < 'a > ADCIE0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCIE0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "0b = Interrupt disabled" ] # [ inline ( always ) ] pub fn adcie0_0 ( self ) -> & 'a mut W { self . variant ( ADCIE0_A :: ADCIE0_0 ) } # [ doc = "1b = Interrupt enabled" ] # [ inline ( always ) ] pub fn adcie0_1 ( self ) -> & 'a mut W { self . variant ( ADCIE0_A :: ADCIE0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Interrupt enable for the inside of window interrupt of the window comparator.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCINIE_A { # [ doc = "0: 0b = Inside of window interrupt disabled" ] ADCINIE_0 = 0 , # [ doc = "1: 1b = Inside of window interrupt enabled" ] ADCINIE_1 = 1 } impl From < ADCINIE_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCINIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCINIE`" ] pub type ADCINIE_R = crate :: R < bool , ADCINIE_A > ; impl ADCINIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCINIE_A { match self . bits { false => ADCINIE_A :: ADCINIE_0 , true => ADCINIE_A :: ADCINIE_1 } } # [ doc = "Checks if the value of the field is `ADCINIE_0`" ] # [ inline ( always ) ] pub fn is_adcinie_0 ( & self ) -> bool { * self == ADCINIE_A :: ADCINIE_0 } # [ doc = "Checks if the value of the field is `ADCINIE_1`" ] # [ inline ( always ) ] pub fn is_adcinie_1 ( & self ) -> bool { * self == ADCINIE_A :: ADCINIE_1 } }
# [ doc = "Write proxy for field `ADCINIE`" ] pub struct ADCINIE_W < 'a > { w : & 'a mut W , } impl < 'a > ADCINIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCINIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "0b = Inside of window interrupt disabled" ] # [ inline ( always ) ] pub fn adcinie_0 ( self ) -> & 'a mut W { self . variant ( ADCINIE_A :: ADCINIE_0 ) } # [ doc = "1b = Inside of window interrupt enabled" ] # [ inline ( always ) ] pub fn adcinie_1 ( self ) -> & 'a mut W { self . variant ( ADCINIE_A :: ADCINIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Interrupt enable for the below lower threshold interrupt of the window comparator.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCLOIE_A { # [ doc = "0: 0b = Below lower threshold interrupt disabled" ] ADCLOIE_0 = 0 , # [ doc = "1: 1b = Below lower threshold interrupt enabled" ] ADCLOIE_1 = 1 } impl From < ADCLOIE_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCLOIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCLOIE`" ] pub type ADCLOIE_R = crate :: R < bool , ADCLOIE_A > ; impl ADCLOIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCLOIE_A { match self . bits { false => ADCLOIE_A :: ADCLOIE_0 , true => ADCLOIE_A :: ADCLOIE_1 } } # [ doc = "Checks if the value of the field is `ADCLOIE_0`" ] # [ inline ( always ) ] pub fn is_adcloie_0 ( & self ) -> bool { * self == ADCLOIE_A :: ADCLOIE_0 } # [ doc = "Checks if the value of the field is `ADCLOIE_1`" ] # [ inline ( always ) ] pub fn is_adcloie_1 ( & self ) -> bool { * self == ADCLOIE_A :: ADCLOIE_1 } }
# [ doc = "Write proxy for field `ADCLOIE`" ] pub struct ADCLOIE_W < 'a > { w : & 'a mut W , } impl < 'a > ADCLOIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCLOIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "0b = Below lower threshold interrupt disabled" ] # [ inline ( always ) ] pub fn adcloie_0 ( self ) -> & 'a mut W { self . variant ( ADCLOIE_A :: ADCLOIE_0 ) } # [ doc = "1b = Below lower threshold interrupt enabled" ] # [ inline ( always ) ] pub fn adcloie_1 ( self ) -> & 'a mut W { self . variant ( ADCLOIE_A :: ADCLOIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Interrupt enable for the above upper threshold interrupt of the window comparator.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCHIIE_A { # [ doc = "0: 0b = Above upper threshold interrupt disabled" ] ADCHIIE_0 = 0 , # [ doc = "1: 1b = Above upper threshold interrupt enabled" ] ADCHIIE_1 = 1 } impl From < ADCHIIE_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCHIIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCHIIE`" ] pub type ADCHIIE_R = crate :: R < bool , ADCHIIE_A > ; impl ADCHIIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCHIIE_A { match self . bits { false => ADCHIIE_A :: ADCHIIE_0 , true => ADCHIIE_A :: ADCHIIE_1 } } # [ doc = "Checks if the value of the field is `ADCHIIE_0`" ] # [ inline ( always ) ] pub fn is_adchiie_0 ( & self ) -> bool { * self == ADCHIIE_A :: ADCHIIE_0 } # [ doc = "Checks if the value of the field is `ADCHIIE_1`" ] # [ inline ( always ) ] pub fn is_adchiie_1 ( & self ) -> bool { * self == ADCHIIE_A :: ADCHIIE_1 } }
# [ doc = "Write proxy for field `ADCHIIE`" ] pub struct ADCHIIE_W < 'a > { w : & 'a mut W , } impl < 'a > ADCHIIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCHIIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "0b = Above upper threshold interrupt disabled" ] # [ inline ( always ) ] pub fn adchiie_0 ( self ) -> & 'a mut W { self . variant ( ADCHIIE_A :: ADCHIIE_0 ) } # [ doc = "1b = Above upper threshold interrupt enabled" ] # [ inline ( always ) ] pub fn adchiie_1 ( self ) -> & 'a mut W { self . variant ( ADCHIIE_A :: ADCHIIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "ADCMEM0 overflow interrupt enable.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCOVIE_A { # [ doc = "0: 0b = Overflow interrupt disabled" ] ADCOVIE_0 = 0 , # [ doc = "1: 1b = Overflow interrupt enabled" ] ADCOVIE_1 = 1 } impl From < ADCOVIE_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCOVIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCOVIE`" ] pub type ADCOVIE_R = crate :: R < bool , ADCOVIE_A > ; impl ADCOVIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCOVIE_A { match self . bits { false => ADCOVIE_A :: ADCOVIE_0 , true => ADCOVIE_A :: ADCOVIE_1 } } # [ doc = "Checks if the value of the field is `ADCOVIE_0`" ] # [ inline ( always ) ] pub fn is_adcovie_0 ( & self ) -> bool { * self == ADCOVIE_A :: ADCOVIE_0 } # [ doc = "Checks if the value of the field is `ADCOVIE_1`" ] # [ inline ( always ) ] pub fn is_adcovie_1 ( & self ) -> bool { * self == ADCOVIE_A :: ADCOVIE_1 } }
# [ doc = "Write proxy for field `ADCOVIE`" ] pub struct ADCOVIE_W < 'a > { w : & 'a mut W , } impl < 'a > ADCOVIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCOVIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "0b = Overflow interrupt disabled" ] # [ inline ( always ) ] pub fn adcovie_0 ( self ) -> & 'a mut W { self . variant ( ADCOVIE_A :: ADCOVIE_0 ) } # [ doc = "1b = Overflow interrupt enabled" ] # [ inline ( always ) ] pub fn adcovie_1 ( self ) -> & 'a mut W { self . variant ( ADCOVIE_A :: ADCOVIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "ADC conversion-time-overflow interrupt enable.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCTOVIE_A { # [ doc = "0: 0b = Conversion time overflow interrupt disabled" ] ADCTOVIE_0 = 0 , # [ doc = "1: 1b = Conversion time overflow interrupt enabled" ] ADCTOVIE_1 = 1 } impl From < ADCTOVIE_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCTOVIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCTOVIE`" ] pub type ADCTOVIE_R = crate :: R < bool , ADCTOVIE_A > ; impl ADCTOVIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCTOVIE_A { match self . bits { false => ADCTOVIE_A :: ADCTOVIE_0 , true => ADCTOVIE_A :: ADCTOVIE_1 } } # [ doc = "Checks if the value of the field is `ADCTOVIE_0`" ] # [ inline ( always ) ] pub fn is_adctovie_0 ( & self ) -> bool { * self == ADCTOVIE_A :: ADCTOVIE_0 } # [ doc = "Checks if the value of the field is `ADCTOVIE_1`" ] # [ inline ( always ) ] pub fn is_adctovie_1 ( & self ) -> bool { * self == ADCTOVIE_A :: ADCTOVIE_1 } }
# [ doc = "Write proxy for field `ADCTOVIE`" ] pub struct ADCTOVIE_W < 'a > { w : & 'a mut W , } impl < 'a > ADCTOVIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCTOVIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "0b = Conversion time overflow interrupt disabled" ] # [ inline ( always ) ] pub fn adctovie_0 ( self ) -> & 'a mut W { self . variant ( ADCTOVIE_A :: ADCTOVIE_0 ) } # [ doc = "1b = Conversion time overflow interrupt enabled" ] # [ inline ( always ) ] pub fn adctovie_1 ( self ) -> & 'a mut W { self . variant ( ADCTOVIE_A :: ADCTOVIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Interrupt enable. This bits enable or disable the interrupt request for a completed ADC conversion." ] # [ inline ( always ) ] pub fn adcie0 ( & self ) -> ADCIE0_R { ADCIE0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Interrupt enable for the inside of window interrupt of the window comparator." ] # [ inline ( always ) ] pub fn adcinie ( & self ) -> ADCINIE_R { ADCINIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Interrupt enable for the below lower threshold interrupt of the window comparator." ] # [ inline ( always ) ] pub fn adcloie ( & self ) -> ADCLOIE_R { ADCLOIE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Interrupt enable for the above upper threshold interrupt of the window comparator." ] # [ inline ( always ) ] pub fn adchiie ( & self ) -> ADCHIIE_R { ADCHIIE_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - ADCMEM0 overflow interrupt enable." ] # [ inline ( always ) ] pub fn adcovie ( & self ) -> ADCOVIE_R { ADCOVIE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - ADC conversion-time-overflow interrupt enable." ] # [ inline ( always ) ] pub fn adctovie ( & self ) -> ADCTOVIE_R { ADCTOVIE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Interrupt enable. This bits enable or disable the interrupt request for a completed ADC conversion." ] # [ inline ( always ) ] pub fn adcie0 ( & mut self ) -> ADCIE0_W { ADCIE0_W { w : self } }
# [ doc = "Bit 1 - Interrupt enable for the inside of window interrupt of the window comparator." ] # [ inline ( always ) ] pub fn adcinie ( & mut self ) -> ADCINIE_W { ADCINIE_W { w : self } }
# [ doc = "Bit 2 - Interrupt enable for the below lower threshold interrupt of the window comparator." ] # [ inline ( always ) ] pub fn adcloie ( & mut self ) -> ADCLOIE_W { ADCLOIE_W { w : self } }
# [ doc = "Bit 3 - Interrupt enable for the above upper threshold interrupt of the window comparator." ] # [ inline ( always ) ] pub fn adchiie ( & mut self ) -> ADCHIIE_W { ADCHIIE_W { w : self } }
# [ doc = "Bit 4 - ADCMEM0 overflow interrupt enable." ] # [ inline ( always ) ] pub fn adcovie ( & mut self ) -> ADCOVIE_W { ADCOVIE_W { w : self } }
# [ doc = "Bit 5 - ADC conversion-time-overflow interrupt enable." ] # [ inline ( always ) ] pub fn adctovie ( & mut self ) -> ADCTOVIE_W { ADCTOVIE_W { w : self } }
}
}
# [ doc = "ADC Interrupt Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcifg](adcifg) module" ] pub type ADCIFG = crate :: Reg < u16 , _ADCIFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADCIFG ;
# [ doc = "`read()` method returns [adcifg::R](adcifg::R) reader structure" ] impl crate :: Readable for ADCIFG { }
# [ doc = "`write(|w| ..)` method takes [adcifg::W](adcifg::W) writer structure" ] impl crate :: Writable for ADCIFG { }
# [ doc = "ADC Interrupt Flag" ] pub mod adcifg {
# [ doc = "Reader of register ADCIFG" ] pub type R = crate :: R < u16 , super :: ADCIFG > ;
# [ doc = "Writer for register ADCIFG" ] pub type W = crate :: W < u16 , super :: ADCIFG > ;
# [ doc = "Register ADCIFG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADCIFG { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "ADCMEM0 interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCIFG0_A { # [ doc = "0: No interrupt pending" ] ADCIFG0_0 = 0 , # [ doc = "1: Interrupt pending" ] ADCIFG0_1 = 1 } impl From < ADCIFG0_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCIFG0_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCIFG0`" ] pub type ADCIFG0_R = crate :: R < bool , ADCIFG0_A > ; impl ADCIFG0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCIFG0_A { match self . bits { false => ADCIFG0_A :: ADCIFG0_0 , true => ADCIFG0_A :: ADCIFG0_1 } } # [ doc = "Checks if the value of the field is `ADCIFG0_0`" ] # [ inline ( always ) ] pub fn is_adcifg0_0 ( & self ) -> bool { * self == ADCIFG0_A :: ADCIFG0_0 } # [ doc = "Checks if the value of the field is `ADCIFG0_1`" ] # [ inline ( always ) ] pub fn is_adcifg0_1 ( & self ) -> bool { * self == ADCIFG0_A :: ADCIFG0_1 } }
# [ doc = "Write proxy for field `ADCIFG0`" ] pub struct ADCIFG0_W < 'a > { w : & 'a mut W , } impl < 'a > ADCIFG0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCIFG0_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn adcifg0_0 ( self ) -> & 'a mut W { self . variant ( ADCIFG0_A :: ADCIFG0_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn adcifg0_1 ( self ) -> & 'a mut W { self . variant ( ADCIFG0_A :: ADCIFG0_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "The ADCINIFG is set when the result of the current ADC conversion is within the thresholds defined by the window comparator threshold registers.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCINIFG_A { # [ doc = "0: No interrupt pending" ] ADCINIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] ADCINIFG_1 = 1 } impl From < ADCINIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCINIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCINIFG`" ] pub type ADCINIFG_R = crate :: R < bool , ADCINIFG_A > ; impl ADCINIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCINIFG_A { match self . bits { false => ADCINIFG_A :: ADCINIFG_0 , true => ADCINIFG_A :: ADCINIFG_1 } } # [ doc = "Checks if the value of the field is `ADCINIFG_0`" ] # [ inline ( always ) ] pub fn is_adcinifg_0 ( & self ) -> bool { * self == ADCINIFG_A :: ADCINIFG_0 } # [ doc = "Checks if the value of the field is `ADCINIFG_1`" ] # [ inline ( always ) ] pub fn is_adcinifg_1 ( & self ) -> bool { * self == ADCINIFG_A :: ADCINIFG_1 } }
# [ doc = "Write proxy for field `ADCINIFG`" ] pub struct ADCINIFG_W < 'a > { w : & 'a mut W , } impl < 'a > ADCINIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCINIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn adcinifg_0 ( self ) -> & 'a mut W { self . variant ( ADCINIFG_A :: ADCINIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn adcinifg_1 ( self ) -> & 'a mut W { self . variant ( ADCINIFG_A :: ADCINIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "The ADCLOIFG is set when the result of the current ADC conversion is below the lower threshold defined by the window comparator lower threshold register.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCLOIFG_A { # [ doc = "0: No interrupt pending" ] ADCLOIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] ADCLOIFG_1 = 1 } impl From < ADCLOIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCLOIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCLOIFG`" ] pub type ADCLOIFG_R = crate :: R < bool , ADCLOIFG_A > ; impl ADCLOIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCLOIFG_A { match self . bits { false => ADCLOIFG_A :: ADCLOIFG_0 , true => ADCLOIFG_A :: ADCLOIFG_1 } } # [ doc = "Checks if the value of the field is `ADCLOIFG_0`" ] # [ inline ( always ) ] pub fn is_adcloifg_0 ( & self ) -> bool { * self == ADCLOIFG_A :: ADCLOIFG_0 } # [ doc = "Checks if the value of the field is `ADCLOIFG_1`" ] # [ inline ( always ) ] pub fn is_adcloifg_1 ( & self ) -> bool { * self == ADCLOIFG_A :: ADCLOIFG_1 } }
# [ doc = "Write proxy for field `ADCLOIFG`" ] pub struct ADCLOIFG_W < 'a > { w : & 'a mut W , } impl < 'a > ADCLOIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCLOIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn adcloifg_0 ( self ) -> & 'a mut W { self . variant ( ADCLOIFG_A :: ADCLOIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn adcloifg_1 ( self ) -> & 'a mut W { self . variant ( ADCLOIFG_A :: ADCLOIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "The ADCHIIFG is set when the result of the current ADC conversion is greater than the upper threshold defined by the window comparator upper threshold register.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCHIIFG_A { # [ doc = "0: No interrupt pending" ] ADCHIIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] ADCHIIFG_1 = 1 } impl From < ADCHIIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCHIIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCHIIFG`" ] pub type ADCHIIFG_R = crate :: R < bool , ADCHIIFG_A > ; impl ADCHIIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCHIIFG_A { match self . bits { false => ADCHIIFG_A :: ADCHIIFG_0 , true => ADCHIIFG_A :: ADCHIIFG_1 } } # [ doc = "Checks if the value of the field is `ADCHIIFG_0`" ] # [ inline ( always ) ] pub fn is_adchiifg_0 ( & self ) -> bool { * self == ADCHIIFG_A :: ADCHIIFG_0 } # [ doc = "Checks if the value of the field is `ADCHIIFG_1`" ] # [ inline ( always ) ] pub fn is_adchiifg_1 ( & self ) -> bool { * self == ADCHIIFG_A :: ADCHIIFG_1 } }
# [ doc = "Write proxy for field `ADCHIIFG`" ] pub struct ADCHIIFG_W < 'a > { w : & 'a mut W , } impl < 'a > ADCHIIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCHIIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn adchiifg_0 ( self ) -> & 'a mut W { self . variant ( ADCHIIFG_A :: ADCHIIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn adchiifg_1 ( self ) -> & 'a mut W { self . variant ( ADCHIIFG_A :: ADCHIIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "The ADCOVIFG is set when the ADCMEM0 register is written before the last conversion result has been read.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCOVIFG_A { # [ doc = "0: No interrupt pending" ] ADCOVIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] ADCOVIFG_1 = 1 } impl From < ADCOVIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCOVIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCOVIFG`" ] pub type ADCOVIFG_R = crate :: R < bool , ADCOVIFG_A > ; impl ADCOVIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCOVIFG_A { match self . bits { false => ADCOVIFG_A :: ADCOVIFG_0 , true => ADCOVIFG_A :: ADCOVIFG_1 } } # [ doc = "Checks if the value of the field is `ADCOVIFG_0`" ] # [ inline ( always ) ] pub fn is_adcovifg_0 ( & self ) -> bool { * self == ADCOVIFG_A :: ADCOVIFG_0 } # [ doc = "Checks if the value of the field is `ADCOVIFG_1`" ] # [ inline ( always ) ] pub fn is_adcovifg_1 ( & self ) -> bool { * self == ADCOVIFG_A :: ADCOVIFG_1 } }
# [ doc = "Write proxy for field `ADCOVIFG`" ] pub struct ADCOVIFG_W < 'a > { w : & 'a mut W , } impl < 'a > ADCOVIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCOVIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn adcovifg_0 ( self ) -> & 'a mut W { self . variant ( ADCOVIFG_A :: ADCOVIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn adcovifg_1 ( self ) -> & 'a mut W { self . variant ( ADCOVIFG_A :: ADCOVIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "The ADCTOVIFG is set when an ADC conversion is triggered before the actual conversion has completed.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ADCTOVIFG_A { # [ doc = "0: No interrupt pending" ] ADCOVIFG_0 = 0 , # [ doc = "1: Interrupt pending" ] ADCTOVIFG_1 = 1 } impl From < ADCTOVIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : ADCTOVIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `ADCTOVIFG`" ] pub type ADCTOVIFG_R = crate :: R < bool , ADCTOVIFG_A > ; impl ADCTOVIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ADCTOVIFG_A { match self . bits { false => ADCTOVIFG_A :: ADCOVIFG_0 , true => ADCTOVIFG_A :: ADCTOVIFG_1 } } # [ doc = "Checks if the value of the field is `ADCOVIFG_0`" ] # [ inline ( always ) ] pub fn is_adcovifg_0 ( & self ) -> bool { * self == ADCTOVIFG_A :: ADCOVIFG_0 } # [ doc = "Checks if the value of the field is `ADCTOVIFG_1`" ] # [ inline ( always ) ] pub fn is_adctovifg_1 ( & self ) -> bool { * self == ADCTOVIFG_A :: ADCTOVIFG_1 } }
# [ doc = "Write proxy for field `ADCTOVIFG`" ] pub struct ADCTOVIFG_W < 'a > { w : & 'a mut W , } impl < 'a > ADCTOVIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCTOVIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn adcovifg_0 ( self ) -> & 'a mut W { self . variant ( ADCTOVIFG_A :: ADCOVIFG_0 ) } # [ doc = "Interrupt pending" ] # [ inline ( always ) ] pub fn adctovifg_1 ( self ) -> & 'a mut W { self . variant ( ADCTOVIFG_A :: ADCTOVIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - ADCMEM0 interrupt flag" ] # [ inline ( always ) ] pub fn adcifg0 ( & self ) -> ADCIFG0_R { ADCIFG0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - The ADCINIFG is set when the result of the current ADC conversion is within the thresholds defined by the window comparator threshold registers." ] # [ inline ( always ) ] pub fn adcinifg ( & self ) -> ADCINIFG_R { ADCINIFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - The ADCLOIFG is set when the result of the current ADC conversion is below the lower threshold defined by the window comparator lower threshold register." ] # [ inline ( always ) ] pub fn adcloifg ( & self ) -> ADCLOIFG_R { ADCLOIFG_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - The ADCHIIFG is set when the result of the current ADC conversion is greater than the upper threshold defined by the window comparator upper threshold register." ] # [ inline ( always ) ] pub fn adchiifg ( & self ) -> ADCHIIFG_R { ADCHIIFG_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - The ADCOVIFG is set when the ADCMEM0 register is written before the last conversion result has been read." ] # [ inline ( always ) ] pub fn adcovifg ( & self ) -> ADCOVIFG_R { ADCOVIFG_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - The ADCTOVIFG is set when an ADC conversion is triggered before the actual conversion has completed." ] # [ inline ( always ) ] pub fn adctovifg ( & self ) -> ADCTOVIFG_R { ADCTOVIFG_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - ADCMEM0 interrupt flag" ] # [ inline ( always ) ] pub fn adcifg0 ( & mut self ) -> ADCIFG0_W { ADCIFG0_W { w : self } }
# [ doc = "Bit 1 - The ADCINIFG is set when the result of the current ADC conversion is within the thresholds defined by the window comparator threshold registers." ] # [ inline ( always ) ] pub fn adcinifg ( & mut self ) -> ADCINIFG_W { ADCINIFG_W { w : self } }
# [ doc = "Bit 2 - The ADCLOIFG is set when the result of the current ADC conversion is below the lower threshold defined by the window comparator lower threshold register." ] # [ inline ( always ) ] pub fn adcloifg ( & mut self ) -> ADCLOIFG_W { ADCLOIFG_W { w : self } }
# [ doc = "Bit 3 - The ADCHIIFG is set when the result of the current ADC conversion is greater than the upper threshold defined by the window comparator upper threshold register." ] # [ inline ( always ) ] pub fn adchiifg ( & mut self ) -> ADCHIIFG_W { ADCHIIFG_W { w : self } }
# [ doc = "Bit 4 - The ADCOVIFG is set when the ADCMEM0 register is written before the last conversion result has been read." ] # [ inline ( always ) ] pub fn adcovifg ( & mut self ) -> ADCOVIFG_W { ADCOVIFG_W { w : self } }
# [ doc = "Bit 5 - The ADCTOVIFG is set when an ADC conversion is triggered before the actual conversion has completed." ] # [ inline ( always ) ] pub fn adctovifg ( & mut self ) -> ADCTOVIFG_W { ADCTOVIFG_W { w : self } }
}
}
# [ doc = "ADC Interrupt Vector\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adciv](adciv) module" ] pub type ADCIV = crate :: Reg < u16 , _ADCIV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADCIV ;
# [ doc = "`read()` method returns [adciv::R](adciv::R) reader structure" ] impl crate :: Readable for ADCIV { }
# [ doc = "`write(|w| ..)` method takes [adciv::W](adciv::W) writer structure" ] impl crate :: Writable for ADCIV { }
# [ doc = "ADC Interrupt Vector" ] pub mod adciv {
# [ doc = "Reader of register ADCIV" ] pub type R = crate :: R < u16 , super :: ADCIV > ;
# [ doc = "Writer for register ADCIV" ] pub type W = crate :: W < u16 , super :: ADCIV > ;
# [ doc = "Register ADCIV `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADCIV { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "interrupt vector value\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum ADCIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: Interrupt Source: ADCMEM0 overflow; Interrupt Flag: ADCOVIFG; Interrupt Priority: Highest" ] ADCOVIFG = 2 , # [ doc = "4: Interrupt Source: Conversion time overflow; Interrupt Flag: ADCTOVIFG" ] ADCTOVIFG = 4 , # [ doc = "6: Interrupt Source: ADCHI Interrupt flag; Interrupt Flag: ADCHIIFG" ] ADCHIIFG = 6 , # [ doc = "8: Interrupt Source: ADCLO Interrupt flag; Interrupt Flag: ADCLOIFG" ] ADCLOIFG = 8 , # [ doc = "10: nterrupt Source: ADCIN Interrupt flag; Interrupt Flag: ADCINIFG" ] ADCINIFG = 10 , # [ doc = "12: Interrupt Source: ADC memory Interrupt flag; Interrupt Flag: ADCIFG0; Interrupt Priority: Lowest" ] ADCIFG0 = 12 } impl From < ADCIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : ADCIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `ADCIV`" ] pub type ADCIV_R = crate :: R < u16 , ADCIV_A > ; impl ADCIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , ADCIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( ADCIV_A :: NONE ) , 2 => Val ( ADCIV_A :: ADCOVIFG ) , 4 => Val ( ADCIV_A :: ADCTOVIFG ) , 6 => Val ( ADCIV_A :: ADCHIIFG ) , 8 => Val ( ADCIV_A :: ADCLOIFG ) , 10 => Val ( ADCIV_A :: ADCINIFG ) , 12 => Val ( ADCIV_A :: ADCIFG0 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == ADCIV_A :: NONE } # [ doc = "Checks if the value of the field is `ADCOVIFG`" ] # [ inline ( always ) ] pub fn is_adcovifg ( & self ) -> bool { * self == ADCIV_A :: ADCOVIFG } # [ doc = "Checks if the value of the field is `ADCTOVIFG`" ] # [ inline ( always ) ] pub fn is_adctovifg ( & self ) -> bool { * self == ADCIV_A :: ADCTOVIFG } # [ doc = "Checks if the value of the field is `ADCHIIFG`" ] # [ inline ( always ) ] pub fn is_adchiifg ( & self ) -> bool { * self == ADCIV_A :: ADCHIIFG } # [ doc = "Checks if the value of the field is `ADCLOIFG`" ] # [ inline ( always ) ] pub fn is_adcloifg ( & self ) -> bool { * self == ADCIV_A :: ADCLOIFG } # [ doc = "Checks if the value of the field is `ADCINIFG`" ] # [ inline ( always ) ] pub fn is_adcinifg ( & self ) -> bool { * self == ADCIV_A :: ADCINIFG } # [ doc = "Checks if the value of the field is `ADCIFG0`" ] # [ inline ( always ) ] pub fn is_adcifg0 ( & self ) -> bool { * self == ADCIV_A :: ADCIFG0 } }
# [ doc = "Write proxy for field `ADCIV`" ] pub struct ADCIV_W < 'a > { w : & 'a mut W , } impl < 'a > ADCIV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ADCIV_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "No interrupt pending" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( ADCIV_A :: NONE ) } # [ doc = "Interrupt Source: ADCMEM0 overflow; Interrupt Flag: ADCOVIFG; Interrupt Priority: Highest" ] # [ inline ( always ) ] pub fn adcovifg ( self ) -> & 'a mut W { self . variant ( ADCIV_A :: ADCOVIFG ) } # [ doc = "Interrupt Source: Conversion time overflow; Interrupt Flag: ADCTOVIFG" ] # [ inline ( always ) ] pub fn adctovifg ( self ) -> & 'a mut W { self . variant ( ADCIV_A :: ADCTOVIFG ) } # [ doc = "Interrupt Source: ADCHI Interrupt flag; Interrupt Flag: ADCHIIFG" ] # [ inline ( always ) ] pub fn adchiifg ( self ) -> & 'a mut W { self . variant ( ADCIV_A :: ADCHIIFG ) } # [ doc = "Interrupt Source: ADCLO Interrupt flag; Interrupt Flag: ADCLOIFG" ] # [ inline ( always ) ] pub fn adcloifg ( self ) -> & 'a mut W { self . variant ( ADCIV_A :: ADCLOIFG ) } # [ doc = "nterrupt Source: ADCIN Interrupt flag; Interrupt Flag: ADCINIFG" ] # [ inline ( always ) ] pub fn adcinifg ( self ) -> & 'a mut W { self . variant ( ADCIV_A :: ADCINIFG ) } # [ doc = "Interrupt Source: ADC memory Interrupt flag; Interrupt Flag: ADCIFG0; Interrupt Priority: Lowest" ] # [ inline ( always ) ] pub fn adcifg0 ( self ) -> & 'a mut W { self . variant ( ADCIV_A :: ADCIFG0 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u16 ) & 0xffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - interrupt vector value" ] # [ inline ( always ) ] pub fn adciv ( & self ) -> ADCIV_R { ADCIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:15 - interrupt vector value" ] # [ inline ( always ) ] pub fn adciv ( & mut self ) -> ADCIV_W { ADCIV_W { w : self } }
}
}
}
# [ doc = "eCOMP0" ] pub struct E_COMP0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for E_COMP0 { } impl E_COMP0 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const e_comp0 :: RegisterBlock { 0x08e0 as * const _ } } impl Deref for E_COMP0 { type Target = e_comp0 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * E_COMP0 :: ptr ( ) } } }
# [ doc = "eCOMP0" ] pub mod e_comp0 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Comparator Control Register 0" ] pub cpctl0 : CPCTL0 , # [ doc = "0x02 - Comparator Control Register 1" ] pub cpctl1 : CPCTL1 , _reserved2 : [ u8 ; 2usize ] , # [ doc = "0x06 - Comparator Interrupt Control Register" ] pub cpint : CPINT , # [ doc = "0x08 - Comparator Interrupt Vector Word Register" ] pub cpiv : CPIV , _reserved4 : [ u8 ; 6usize ] , # [ doc = "0x10 - 6-bit Comparator built-in DAC Control Register" ] pub cpdacctl : CPDACCTL , # [ doc = "0x12 - 6-bit Comparator built-in DAC Data Register" ] pub cpdacdata : CPDACDATA , }
# [ doc = "Comparator Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cpctl0](cpctl0) module" ] pub type CPCTL0 = crate :: Reg < u16 , _CPCTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CPCTL0 ;
# [ doc = "`read()` method returns [cpctl0::R](cpctl0::R) reader structure" ] impl crate :: Readable for CPCTL0 { }
# [ doc = "`write(|w| ..)` method takes [cpctl0::W](cpctl0::W) writer structure" ] impl crate :: Writable for CPCTL0 { }
# [ doc = "Comparator Control Register 0" ] pub mod cpctl0 {
# [ doc = "Reader of register CPCTL0" ] pub type R = crate :: R < u16 , super :: CPCTL0 > ;
# [ doc = "Writer for register CPCTL0" ] pub type W = crate :: W < u16 , super :: CPCTL0 > ;
# [ doc = "Register CPCTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CPCTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Channel input enable for the V+ terminal\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPPEN_A { # [ doc = "0: Selected analog input channel for V+ terminal is disabled." ] CPPEN_0 = 0 , # [ doc = "1: Selected analog input channel for V+ terminal is enabled." ] CPPEN_1 = 1 } impl From < CPPEN_A > for bool { # [ inline ( always ) ] fn from ( variant : CPPEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPPEN`" ] pub type CPPEN_R = crate :: R < bool , CPPEN_A > ; impl CPPEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPPEN_A { match self . bits { false => CPPEN_A :: CPPEN_0 , true => CPPEN_A :: CPPEN_1 } } # [ doc = "Checks if the value of the field is `CPPEN_0`" ] # [ inline ( always ) ] pub fn is_cppen_0 ( & self ) -> bool { * self == CPPEN_A :: CPPEN_0 } # [ doc = "Checks if the value of the field is `CPPEN_1`" ] # [ inline ( always ) ] pub fn is_cppen_1 ( & self ) -> bool { * self == CPPEN_A :: CPPEN_1 } }
# [ doc = "Write proxy for field `CPPEN`" ] pub struct CPPEN_W < 'a > { w : & 'a mut W , } impl < 'a > CPPEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPPEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Selected analog input channel for V+ terminal is disabled." ] # [ inline ( always ) ] pub fn cppen_0 ( self ) -> & 'a mut W { self . variant ( CPPEN_A :: CPPEN_0 ) } # [ doc = "Selected analog input channel for V+ terminal is enabled." ] # [ inline ( always ) ] pub fn cppen_1 ( self ) -> & 'a mut W { self . variant ( CPPEN_A :: CPPEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Channel input selected for the - terminal\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPNSEL_A { # [ doc = "0: select external input source" ] CPNSEL_0 = 0 , # [ doc = "1: select external input source" ] CPNSEL_1 = 1 , # [ doc = "2: select external input source" ] CPNSEL_2 = 2 , # [ doc = "3: select external input source" ] CPNSEL_3 = 3 , # [ doc = "4: device specific, please refer to device data sheet for details" ] CPNSEL_4 = 4 , # [ doc = "5: device specific, please refer to device data sheet for details" ] CPNSEL_5 = 5 , # [ doc = "6: 6-bit DAC" ] CPNSEL_6 = 6 , # [ doc = "7: Reserved" ] CPNSEL_7 = 7 } impl From < CPNSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPNSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPNSEL`" ] pub type CPNSEL_R = crate :: R < u8 , CPNSEL_A > ; impl CPNSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPNSEL_A { match self . bits { 0 => CPNSEL_A :: CPNSEL_0 , 1 => CPNSEL_A :: CPNSEL_1 , 2 => CPNSEL_A :: CPNSEL_2 , 3 => CPNSEL_A :: CPNSEL_3 , 4 => CPNSEL_A :: CPNSEL_4 , 5 => CPNSEL_A :: CPNSEL_5 , 6 => CPNSEL_A :: CPNSEL_6 , 7 => CPNSEL_A :: CPNSEL_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPNSEL_0`" ] # [ inline ( always ) ] pub fn is_cpnsel_0 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_0 } # [ doc = "Checks if the value of the field is `CPNSEL_1`" ] # [ inline ( always ) ] pub fn is_cpnsel_1 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_1 } # [ doc = "Checks if the value of the field is `CPNSEL_2`" ] # [ inline ( always ) ] pub fn is_cpnsel_2 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_2 } # [ doc = "Checks if the value of the field is `CPNSEL_3`" ] # [ inline ( always ) ] pub fn is_cpnsel_3 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_3 } # [ doc = "Checks if the value of the field is `CPNSEL_4`" ] # [ inline ( always ) ] pub fn is_cpnsel_4 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_4 } # [ doc = "Checks if the value of the field is `CPNSEL_5`" ] # [ inline ( always ) ] pub fn is_cpnsel_5 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_5 } # [ doc = "Checks if the value of the field is `CPNSEL_6`" ] # [ inline ( always ) ] pub fn is_cpnsel_6 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_6 } # [ doc = "Checks if the value of the field is `CPNSEL_7`" ] # [ inline ( always ) ] pub fn is_cpnsel_7 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_7 } }
# [ doc = "Write proxy for field `CPNSEL`" ] pub struct CPNSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CPNSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPNSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cpnsel_0 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_0 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cpnsel_1 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_1 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cpnsel_2 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_2 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cpnsel_3 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_3 ) } # [ doc = "device specific, please refer to device data sheet for details" ] # [ inline ( always ) ] pub fn cpnsel_4 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_4 ) } # [ doc = "device specific, please refer to device data sheet for details" ] # [ inline ( always ) ] pub fn cpnsel_5 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_5 ) } # [ doc = "6-bit DAC" ] # [ inline ( always ) ] pub fn cpnsel_6 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_6 ) } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn cpnsel_7 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 8 ) ) | ( ( ( value as u16 ) & 0x07 ) << 8 ) ; self . w } }
# [ doc = "Channel input enable for the - terminal\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPNEN_A { # [ doc = "0: Selected analog input channel for V- terminal is disabled." ] CPNEN_0 = 0 , # [ doc = "1: Selected analog input channel for V- terminal is enabled." ] CPNEN_1 = 1 } impl From < CPNEN_A > for bool { # [ inline ( always ) ] fn from ( variant : CPNEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPNEN`" ] pub type CPNEN_R = crate :: R < bool , CPNEN_A > ; impl CPNEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPNEN_A { match self . bits { false => CPNEN_A :: CPNEN_0 , true => CPNEN_A :: CPNEN_1 } } # [ doc = "Checks if the value of the field is `CPNEN_0`" ] # [ inline ( always ) ] pub fn is_cpnen_0 ( & self ) -> bool { * self == CPNEN_A :: CPNEN_0 } # [ doc = "Checks if the value of the field is `CPNEN_1`" ] # [ inline ( always ) ] pub fn is_cpnen_1 ( & self ) -> bool { * self == CPNEN_A :: CPNEN_1 } }
# [ doc = "Write proxy for field `CPNEN`" ] pub struct CPNEN_W < 'a > { w : & 'a mut W , } impl < 'a > CPNEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPNEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Selected analog input channel for V- terminal is disabled." ] # [ inline ( always ) ] pub fn cpnen_0 ( self ) -> & 'a mut W { self . variant ( CPNEN_A :: CPNEN_0 ) } # [ doc = "Selected analog input channel for V- terminal is enabled." ] # [ inline ( always ) ] pub fn cpnen_1 ( self ) -> & 'a mut W { self . variant ( CPNEN_A :: CPNEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Channel input selected for the V+ terminal\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPPSEL_A { # [ doc = "0: select external input source" ] CPPSEL_0 = 0 , # [ doc = "1: select external input source" ] CPPSEL_1 = 1 , # [ doc = "2: select external input source" ] CPPSEL_2 = 2 , # [ doc = "3: select external input source" ] CPPSEL_3 = 3 , # [ doc = "4: device specific, please refer to device data sheet for details" ] CPPSEL_4 = 4 , # [ doc = "5: device specific, please refer to device data sheet for details" ] CPPSEL_5 = 5 , # [ doc = "6: 6-bit DAC" ] CPPSEL_6 = 6 , # [ doc = "7: Reserved" ] CPPSEL_7 = 7 } impl From < CPPSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPPSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPPSEL`" ] pub type CPPSEL_R = crate :: R < u8 , CPPSEL_A > ; impl CPPSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPPSEL_A { match self . bits { 0 => CPPSEL_A :: CPPSEL_0 , 1 => CPPSEL_A :: CPPSEL_1 , 2 => CPPSEL_A :: CPPSEL_2 , 3 => CPPSEL_A :: CPPSEL_3 , 4 => CPPSEL_A :: CPPSEL_4 , 5 => CPPSEL_A :: CPPSEL_5 , 6 => CPPSEL_A :: CPPSEL_6 , 7 => CPPSEL_A :: CPPSEL_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPPSEL_0`" ] # [ inline ( always ) ] pub fn is_cppsel_0 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_0 } # [ doc = "Checks if the value of the field is `CPPSEL_1`" ] # [ inline ( always ) ] pub fn is_cppsel_1 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_1 } # [ doc = "Checks if the value of the field is `CPPSEL_2`" ] # [ inline ( always ) ] pub fn is_cppsel_2 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_2 } # [ doc = "Checks if the value of the field is `CPPSEL_3`" ] # [ inline ( always ) ] pub fn is_cppsel_3 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_3 } # [ doc = "Checks if the value of the field is `CPPSEL_4`" ] # [ inline ( always ) ] pub fn is_cppsel_4 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_4 } # [ doc = "Checks if the value of the field is `CPPSEL_5`" ] # [ inline ( always ) ] pub fn is_cppsel_5 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_5 } # [ doc = "Checks if the value of the field is `CPPSEL_6`" ] # [ inline ( always ) ] pub fn is_cppsel_6 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_6 } # [ doc = "Checks if the value of the field is `CPPSEL_7`" ] # [ inline ( always ) ] pub fn is_cppsel_7 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_7 } }
# [ doc = "Write proxy for field `CPPSEL`" ] pub struct CPPSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CPPSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPPSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cppsel_0 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_0 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cppsel_1 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_1 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cppsel_2 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_2 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cppsel_3 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_3 ) } # [ doc = "device specific, please refer to device data sheet for details" ] # [ inline ( always ) ] pub fn cppsel_4 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_4 ) } # [ doc = "device specific, please refer to device data sheet for details" ] # [ inline ( always ) ] pub fn cppsel_5 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_5 ) } # [ doc = "6-bit DAC" ] # [ inline ( always ) ] pub fn cppsel_6 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_6 ) } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn cppsel_7 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u16 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bit 4 - Channel input enable for the V+ terminal" ] # [ inline ( always ) ] pub fn cppen ( & self ) -> CPPEN_R { CPPEN_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:10 - Channel input selected for the - terminal" ] # [ inline ( always ) ] pub fn cpnsel ( & self ) -> CPNSEL_R { CPNSEL_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 12 - Channel input enable for the - terminal" ] # [ inline ( always ) ] pub fn cpnen ( & self ) -> CPNEN_R { CPNEN_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 0:2 - Channel input selected for the V+ terminal" ] # [ inline ( always ) ] pub fn cppsel ( & self ) -> CPPSEL_R { CPPSEL_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bit 4 - Channel input enable for the V+ terminal" ] # [ inline ( always ) ] pub fn cppen ( & mut self ) -> CPPEN_W { CPPEN_W { w : self } }
# [ doc = "Bits 8:10 - Channel input selected for the - terminal" ] # [ inline ( always ) ] pub fn cpnsel ( & mut self ) -> CPNSEL_W { CPNSEL_W { w : self } }
# [ doc = "Bit 12 - Channel input enable for the - terminal" ] # [ inline ( always ) ] pub fn cpnen ( & mut self ) -> CPNEN_W { CPNEN_W { w : self } }
# [ doc = "Bits 0:2 - Channel input selected for the V+ terminal" ] # [ inline ( always ) ] pub fn cppsel ( & mut self ) -> CPPSEL_W { CPPSEL_W { w : self } }
}
}
# [ doc = "Comparator Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cpctl1](cpctl1) module" ] pub type CPCTL1 = crate :: Reg < u16 , _CPCTL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CPCTL1 ;
# [ doc = "`read()` method returns [cpctl1::R](cpctl1::R) reader structure" ] impl crate :: Readable for CPCTL1 { }
# [ doc = "`write(|w| ..)` method takes [cpctl1::W](cpctl1::W) writer structure" ] impl crate :: Writable for CPCTL1 { }
# [ doc = "Comparator Control Register 1" ] pub mod cpctl1 {
# [ doc = "Reader of register CPCTL1" ] pub type R = crate :: R < u16 , super :: CPCTL1 > ;
# [ doc = "Writer for register CPCTL1" ] pub type W = crate :: W < u16 , super :: CPCTL1 > ;
# [ doc = "Register CPCTL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CPCTL1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CPOUT`" ] pub type CPOUT_R = crate :: R < bool , bool > ;
# [ doc = "Comparator output polarity\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPINV_A { # [ doc = "0: Comparator output is non-inverted" ] CPINV_0 = 0 , # [ doc = "1: Comparator output is inverted" ] CPINV_1 = 1 } impl From < CPINV_A > for bool { # [ inline ( always ) ] fn from ( variant : CPINV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPINV`" ] pub type CPINV_R = crate :: R < bool , CPINV_A > ; impl CPINV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPINV_A { match self . bits { false => CPINV_A :: CPINV_0 , true => CPINV_A :: CPINV_1 } } # [ doc = "Checks if the value of the field is `CPINV_0`" ] # [ inline ( always ) ] pub fn is_cpinv_0 ( & self ) -> bool { * self == CPINV_A :: CPINV_0 } # [ doc = "Checks if the value of the field is `CPINV_1`" ] # [ inline ( always ) ] pub fn is_cpinv_1 ( & self ) -> bool { * self == CPINV_A :: CPINV_1 } }
# [ doc = "Write proxy for field `CPINV`" ] pub struct CPINV_W < 'a > { w : & 'a mut W , } impl < 'a > CPINV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPINV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Comparator output is non-inverted" ] # [ inline ( always ) ] pub fn cpinv_0 ( self ) -> & 'a mut W { self . variant ( CPINV_A :: CPINV_0 ) } # [ doc = "Comparator output is inverted" ] # [ inline ( always ) ] pub fn cpinv_1 ( self ) -> & 'a mut W { self . variant ( CPINV_A :: CPINV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Interrupt edge select for CEIIFG and CEIFG\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPIES_A { # [ doc = "0: Rising edge for CPIFG, falling edge for CPIIFG" ] CPIES_0 = 0 , # [ doc = "1: Falling edge for CPIFG, rising edge for CPIIFG" ] CPIES_1 = 1 } impl From < CPIES_A > for bool { # [ inline ( always ) ] fn from ( variant : CPIES_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPIES`" ] pub type CPIES_R = crate :: R < bool , CPIES_A > ; impl CPIES_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPIES_A { match self . bits { false => CPIES_A :: CPIES_0 , true => CPIES_A :: CPIES_1 } } # [ doc = "Checks if the value of the field is `CPIES_0`" ] # [ inline ( always ) ] pub fn is_cpies_0 ( & self ) -> bool { * self == CPIES_A :: CPIES_0 } # [ doc = "Checks if the value of the field is `CPIES_1`" ] # [ inline ( always ) ] pub fn is_cpies_1 ( & self ) -> bool { * self == CPIES_A :: CPIES_1 } }
# [ doc = "Write proxy for field `CPIES`" ] pub struct CPIES_W < 'a > { w : & 'a mut W , } impl < 'a > CPIES_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPIES_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Rising edge for CPIFG, falling edge for CPIIFG" ] # [ inline ( always ) ] pub fn cpies_0 ( self ) -> & 'a mut W { self . variant ( CPIES_A :: CPIES_0 ) } # [ doc = "Falling edge for CPIFG, rising edge for CPIIFG" ] # [ inline ( always ) ] pub fn cpies_1 ( self ) -> & 'a mut W { self . variant ( CPIES_A :: CPIES_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Analog Output Low Pass filter Selection. Changing CPFLT might set interrupt flag.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPFLT_A { # [ doc = "0: Comparator output is not filtered" ] CPFLT_0 = 0 , # [ doc = "1: Comparator output is filtered" ] CPFLT_1 = 1 } impl From < CPFLT_A > for bool { # [ inline ( always ) ] fn from ( variant : CPFLT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPFLT`" ] pub type CPFLT_R = crate :: R < bool , CPFLT_A > ; impl CPFLT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPFLT_A { match self . bits { false => CPFLT_A :: CPFLT_0 , true => CPFLT_A :: CPFLT_1 } } # [ doc = "Checks if the value of the field is `CPFLT_0`" ] # [ inline ( always ) ] pub fn is_cpflt_0 ( & self ) -> bool { * self == CPFLT_A :: CPFLT_0 } # [ doc = "Checks if the value of the field is `CPFLT_1`" ] # [ inline ( always ) ] pub fn is_cpflt_1 ( & self ) -> bool { * self == CPFLT_A :: CPFLT_1 } }
# [ doc = "Write proxy for field `CPFLT`" ] pub struct CPFLT_W < 'a > { w : & 'a mut W , } impl < 'a > CPFLT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPFLT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Comparator output is not filtered" ] # [ inline ( always ) ] pub fn cpflt_0 ( self ) -> & 'a mut W { self . variant ( CPFLT_A :: CPFLT_0 ) } # [ doc = "Comparator output is filtered" ] # [ inline ( always ) ] pub fn cpflt_1 ( self ) -> & 'a mut W { self . variant ( CPFLT_A :: CPFLT_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Analog Filter Delay selection. These bits are used to select the analog filter delay\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPFLTDLY_A { # [ doc = "0: Typical filter delay of 450ns" ] CPFLTDLY_0 = 0 , # [ doc = "1: Typical filter delay of 900ns" ] CPFLTDLY_1 = 1 , # [ doc = "2: Typical filter delay of 1800ns" ] CPFLTDLY_2 = 2 , # [ doc = "3: Typical filter delay of 3600ns" ] CPFLTDLY_3 = 3 } impl From < CPFLTDLY_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPFLTDLY_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPFLTDLY`" ] pub type CPFLTDLY_R = crate :: R < u8 , CPFLTDLY_A > ; impl CPFLTDLY_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPFLTDLY_A { match self . bits { 0 => CPFLTDLY_A :: CPFLTDLY_0 , 1 => CPFLTDLY_A :: CPFLTDLY_1 , 2 => CPFLTDLY_A :: CPFLTDLY_2 , 3 => CPFLTDLY_A :: CPFLTDLY_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPFLTDLY_0`" ] # [ inline ( always ) ] pub fn is_cpfltdly_0 ( & self ) -> bool { * self == CPFLTDLY_A :: CPFLTDLY_0 } # [ doc = "Checks if the value of the field is `CPFLTDLY_1`" ] # [ inline ( always ) ] pub fn is_cpfltdly_1 ( & self ) -> bool { * self == CPFLTDLY_A :: CPFLTDLY_1 } # [ doc = "Checks if the value of the field is `CPFLTDLY_2`" ] # [ inline ( always ) ] pub fn is_cpfltdly_2 ( & self ) -> bool { * self == CPFLTDLY_A :: CPFLTDLY_2 } # [ doc = "Checks if the value of the field is `CPFLTDLY_3`" ] # [ inline ( always ) ] pub fn is_cpfltdly_3 ( & self ) -> bool { * self == CPFLTDLY_A :: CPFLTDLY_3 } }
# [ doc = "Write proxy for field `CPFLTDLY`" ] pub struct CPFLTDLY_W < 'a > { w : & 'a mut W , } impl < 'a > CPFLTDLY_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPFLTDLY_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Typical filter delay of 450ns" ] # [ inline ( always ) ] pub fn cpfltdly_0 ( self ) -> & 'a mut W { self . variant ( CPFLTDLY_A :: CPFLTDLY_0 ) } # [ doc = "Typical filter delay of 900ns" ] # [ inline ( always ) ] pub fn cpfltdly_1 ( self ) -> & 'a mut W { self . variant ( CPFLTDLY_A :: CPFLTDLY_1 ) } # [ doc = "Typical filter delay of 1800ns" ] # [ inline ( always ) ] pub fn cpfltdly_2 ( self ) -> & 'a mut W { self . variant ( CPFLTDLY_A :: CPFLTDLY_2 ) } # [ doc = "Typical filter delay of 3600ns" ] # [ inline ( always ) ] pub fn cpfltdly_3 ( self ) -> & 'a mut W { self . variant ( CPFLTDLY_A :: CPFLTDLY_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Power mode selection.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPMSEL_A { # [ doc = "0: High-power & High speed mode (500nA)" ] CPMSEL_0 = 0 , # [ doc = "1: Low-power & Low speed mode (10nA)" ] CPMSEL_1 = 1 } impl From < CPMSEL_A > for bool { # [ inline ( always ) ] fn from ( variant : CPMSEL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPMSEL`" ] pub type CPMSEL_R = crate :: R < bool , CPMSEL_A > ; impl CPMSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPMSEL_A { match self . bits { false => CPMSEL_A :: CPMSEL_0 , true => CPMSEL_A :: CPMSEL_1 } } # [ doc = "Checks if the value of the field is `CPMSEL_0`" ] # [ inline ( always ) ] pub fn is_cpmsel_0 ( & self ) -> bool { * self == CPMSEL_A :: CPMSEL_0 } # [ doc = "Checks if the value of the field is `CPMSEL_1`" ] # [ inline ( always ) ] pub fn is_cpmsel_1 ( & self ) -> bool { * self == CPMSEL_A :: CPMSEL_1 } }
# [ doc = "Write proxy for field `CPMSEL`" ] pub struct CPMSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CPMSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPMSEL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "High-power & High speed mode (500nA)" ] # [ inline ( always ) ] pub fn cpmsel_0 ( self ) -> & 'a mut W { self . variant ( CPMSEL_A :: CPMSEL_0 ) } # [ doc = "Low-power & Low speed mode (10nA)" ] # [ inline ( always ) ] pub fn cpmsel_1 ( self ) -> & 'a mut W { self . variant ( CPMSEL_A :: CPMSEL_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Comparator enable/disable. This bit is used to disable/enable the comparator. When the comparator is disabled, the Comparator consumes no power.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPEN_A { # [ doc = "0: Comparator is disabled" ] CPEN_0 = 0 , # [ doc = "1: Comparator is enabled" ] CPEN_1 = 1 } impl From < CPEN_A > for bool { # [ inline ( always ) ] fn from ( variant : CPEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPEN`" ] pub type CPEN_R = crate :: R < bool , CPEN_A > ; impl CPEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPEN_A { match self . bits { false => CPEN_A :: CPEN_0 , true => CPEN_A :: CPEN_1 } } # [ doc = "Checks if the value of the field is `CPEN_0`" ] # [ inline ( always ) ] pub fn is_cpen_0 ( & self ) -> bool { * self == CPEN_A :: CPEN_0 } # [ doc = "Checks if the value of the field is `CPEN_1`" ] # [ inline ( always ) ] pub fn is_cpen_1 ( & self ) -> bool { * self == CPEN_A :: CPEN_1 } }
# [ doc = "Write proxy for field `CPEN`" ] pub struct CPEN_W < 'a > { w : & 'a mut W , } impl < 'a > CPEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Comparator is disabled" ] # [ inline ( always ) ] pub fn cpen_0 ( self ) -> & 'a mut W { self . variant ( CPEN_A :: CPEN_0 ) } # [ doc = "Comparator is enabled" ] # [ inline ( always ) ] pub fn cpen_1 ( self ) -> & 'a mut W { self . variant ( CPEN_A :: CPEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Programable Hysteresis mode. These bits are used to select the Hysteresis mode.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPHSEL_A { # [ doc = "0: disable" ] CPHSEL_0 = 0 , # [ doc = "1: 10mV" ] CPHSEL_1 = 1 , # [ doc = "2: 20mV" ] CPHSEL_2 = 2 , # [ doc = "3: 30mV" ] CPHSEL_3 = 3 } impl From < CPHSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPHSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPHSEL`" ] pub type CPHSEL_R = crate :: R < u8 , CPHSEL_A > ; impl CPHSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPHSEL_A { match self . bits { 0 => CPHSEL_A :: CPHSEL_0 , 1 => CPHSEL_A :: CPHSEL_1 , 2 => CPHSEL_A :: CPHSEL_2 , 3 => CPHSEL_A :: CPHSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPHSEL_0`" ] # [ inline ( always ) ] pub fn is_cphsel_0 ( & self ) -> bool { * self == CPHSEL_A :: CPHSEL_0 } # [ doc = "Checks if the value of the field is `CPHSEL_1`" ] # [ inline ( always ) ] pub fn is_cphsel_1 ( & self ) -> bool { * self == CPHSEL_A :: CPHSEL_1 } # [ doc = "Checks if the value of the field is `CPHSEL_2`" ] # [ inline ( always ) ] pub fn is_cphsel_2 ( & self ) -> bool { * self == CPHSEL_A :: CPHSEL_2 } # [ doc = "Checks if the value of the field is `CPHSEL_3`" ] # [ inline ( always ) ] pub fn is_cphsel_3 ( & self ) -> bool { * self == CPHSEL_A :: CPHSEL_3 } }
# [ doc = "Write proxy for field `CPHSEL`" ] pub struct CPHSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CPHSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPHSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "disable" ] # [ inline ( always ) ] pub fn cphsel_0 ( self ) -> & 'a mut W { self . variant ( CPHSEL_A :: CPHSEL_0 ) } # [ doc = "10mV" ] # [ inline ( always ) ] pub fn cphsel_1 ( self ) -> & 'a mut W { self . variant ( CPHSEL_A :: CPHSEL_1 ) } # [ doc = "20mV" ] # [ inline ( always ) ] pub fn cphsel_2 ( self ) -> & 'a mut W { self . variant ( CPHSEL_A :: CPHSEL_2 ) } # [ doc = "30mV" ] # [ inline ( always ) ] pub fn cphsel_3 ( self ) -> & 'a mut W { self . variant ( CPHSEL_A :: CPHSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u16 ) & 0x03 ) << 10 ) ; self . w } }
# [ doc = "Comparator interrupt output enable bit\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPIE_A { # [ doc = "0: Interrupt output is disabled" ] CPIE_0 = 0 , # [ doc = "1: Interrupt output is enabled" ] CPIE_1 = 1 } impl From < CPIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CPIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPIE`" ] pub type CPIE_R = crate :: R < bool , CPIE_A > ; impl CPIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPIE_A { match self . bits { false => CPIE_A :: CPIE_0 , true => CPIE_A :: CPIE_1 } } # [ doc = "Checks if the value of the field is `CPIE_0`" ] # [ inline ( always ) ] pub fn is_cpie_0 ( & self ) -> bool { * self == CPIE_A :: CPIE_0 } # [ doc = "Checks if the value of the field is `CPIE_1`" ] # [ inline ( always ) ] pub fn is_cpie_1 ( & self ) -> bool { * self == CPIE_A :: CPIE_1 } }
# [ doc = "Write proxy for field `CPIE`" ] pub struct CPIE_W < 'a > { w : & 'a mut W , } impl < 'a > CPIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt output is disabled" ] # [ inline ( always ) ] pub fn cpie_0 ( self ) -> & 'a mut W { self . variant ( CPIE_A :: CPIE_0 ) } # [ doc = "Interrupt output is enabled" ] # [ inline ( always ) ] pub fn cpie_1 ( self ) -> & 'a mut W { self . variant ( CPIE_A :: CPIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Comparator inverted interrupt output enable bit\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPIIE_A { # [ doc = "0: Interrupt inverted output is disabled" ] CPIIE_0 = 0 , # [ doc = "1: Interrupt inverted output is enabled" ] CPIIE_1 = 1 } impl From < CPIIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CPIIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPIIE`" ] pub type CPIIE_R = crate :: R < bool , CPIIE_A > ; impl CPIIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPIIE_A { match self . bits { false => CPIIE_A :: CPIIE_0 , true => CPIIE_A :: CPIIE_1 } } # [ doc = "Checks if the value of the field is `CPIIE_0`" ] # [ inline ( always ) ] pub fn is_cpiie_0 ( & self ) -> bool { * self == CPIIE_A :: CPIIE_0 } # [ doc = "Checks if the value of the field is `CPIIE_1`" ] # [ inline ( always ) ] pub fn is_cpiie_1 ( & self ) -> bool { * self == CPIIE_A :: CPIIE_1 } }
# [ doc = "Write proxy for field `CPIIE`" ] pub struct CPIIE_W < 'a > { w : & 'a mut W , } impl < 'a > CPIIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPIIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt inverted output is disabled" ] # [ inline ( always ) ] pub fn cpiie_0 ( self ) -> & 'a mut W { self . variant ( CPIIE_A :: CPIIE_0 ) } # [ doc = "Interrupt inverted output is enabled" ] # [ inline ( always ) ] pub fn cpiie_1 ( self ) -> & 'a mut W { self . variant ( CPIIE_A :: CPIIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Comparator output value" ] # [ inline ( always ) ] pub fn cpout ( & self ) -> CPOUT_R { CPOUT_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Comparator output polarity" ] # [ inline ( always ) ] pub fn cpinv ( & self ) -> CPINV_R { CPINV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Interrupt edge select for CEIIFG and CEIFG" ] # [ inline ( always ) ] pub fn cpies ( & self ) -> CPIES_R { CPIES_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Analog Output Low Pass filter Selection. Changing CPFLT might set interrupt flag." ] # [ inline ( always ) ] pub fn cpflt ( & self ) -> CPFLT_R { CPFLT_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - Analog Filter Delay selection. These bits are used to select the analog filter delay" ] # [ inline ( always ) ] pub fn cpfltdly ( & self ) -> CPFLTDLY_R { CPFLTDLY_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Power mode selection." ] # [ inline ( always ) ] pub fn cpmsel ( & self ) -> CPMSEL_R { CPMSEL_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Comparator enable/disable. This bit is used to disable/enable the comparator. When the comparator is disabled, the Comparator consumes no power." ] # [ inline ( always ) ] pub fn cpen ( & self ) -> CPEN_R { CPEN_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 10:11 - Programable Hysteresis mode. These bits are used to select the Hysteresis mode." ] # [ inline ( always ) ] pub fn cphsel ( & self ) -> CPHSEL_R { CPHSEL_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 14 - Comparator interrupt output enable bit" ] # [ inline ( always ) ] pub fn cpie ( & self ) -> CPIE_R { CPIE_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Comparator inverted interrupt output enable bit" ] # [ inline ( always ) ] pub fn cpiie ( & self ) -> CPIIE_R { CPIIE_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 1 - Comparator output polarity" ] # [ inline ( always ) ] pub fn cpinv ( & mut self ) -> CPINV_W { CPINV_W { w : self } }
# [ doc = "Bit 4 - Interrupt edge select for CEIIFG and CEIFG" ] # [ inline ( always ) ] pub fn cpies ( & mut self ) -> CPIES_W { CPIES_W { w : self } }
# [ doc = "Bit 5 - Analog Output Low Pass filter Selection. Changing CPFLT might set interrupt flag." ] # [ inline ( always ) ] pub fn cpflt ( & mut self ) -> CPFLT_W { CPFLT_W { w : self } }
# [ doc = "Bits 6:7 - Analog Filter Delay selection. These bits are used to select the analog filter delay" ] # [ inline ( always ) ] pub fn cpfltdly ( & mut self ) -> CPFLTDLY_W { CPFLTDLY_W { w : self } }
# [ doc = "Bit 8 - Power mode selection." ] # [ inline ( always ) ] pub fn cpmsel ( & mut self ) -> CPMSEL_W { CPMSEL_W { w : self } }
# [ doc = "Bit 9 - Comparator enable/disable. This bit is used to disable/enable the comparator. When the comparator is disabled, the Comparator consumes no power." ] # [ inline ( always ) ] pub fn cpen ( & mut self ) -> CPEN_W { CPEN_W { w : self } }
# [ doc = "Bits 10:11 - Programable Hysteresis mode. These bits are used to select the Hysteresis mode." ] # [ inline ( always ) ] pub fn cphsel ( & mut self ) -> CPHSEL_W { CPHSEL_W { w : self } }
# [ doc = "Bit 14 - Comparator interrupt output enable bit" ] # [ inline ( always ) ] pub fn cpie ( & mut self ) -> CPIE_W { CPIE_W { w : self } }
# [ doc = "Bit 15 - Comparator inverted interrupt output enable bit" ] # [ inline ( always ) ] pub fn cpiie ( & mut self ) -> CPIIE_W { CPIIE_W { w : self } }
}
}
# [ doc = "Comparator Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cpint](cpint) module" ] pub type CPINT = crate :: Reg < u16 , _CPINT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CPINT ;
# [ doc = "`read()` method returns [cpint::R](cpint::R) reader structure" ] impl crate :: Readable for CPINT { }
# [ doc = "`write(|w| ..)` method takes [cpint::W](cpint::W) writer structure" ] impl crate :: Writable for CPINT { }
# [ doc = "Comparator Interrupt Control Register" ] pub mod cpint {
# [ doc = "Reader of register CPINT" ] pub type R = crate :: R < u16 , super :: CPINT > ;
# [ doc = "Writer for register CPINT" ] pub type W = crate :: W < u16 , super :: CPINT > ;
# [ doc = "Register CPINT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CPINT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Comparator output interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPIFG_A { # [ doc = "0: No interrupt pending." ] CPIFG_0 = 0 , # [ doc = "1: Output interrupt pending." ] CPIFG_1 = 1 } impl From < CPIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CPIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPIFG`" ] pub type CPIFG_R = crate :: R < bool , CPIFG_A > ; impl CPIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPIFG_A { match self . bits { false => CPIFG_A :: CPIFG_0 , true => CPIFG_A :: CPIFG_1 } } # [ doc = "Checks if the value of the field is `CPIFG_0`" ] # [ inline ( always ) ] pub fn is_cpifg_0 ( & self ) -> bool { * self == CPIFG_A :: CPIFG_0 } # [ doc = "Checks if the value of the field is `CPIFG_1`" ] # [ inline ( always ) ] pub fn is_cpifg_1 ( & self ) -> bool { * self == CPIFG_A :: CPIFG_1 } }
# [ doc = "Write proxy for field `CPIFG`" ] pub struct CPIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CPIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending." ] # [ inline ( always ) ] pub fn cpifg_0 ( self ) -> & 'a mut W { self . variant ( CPIFG_A :: CPIFG_0 ) } # [ doc = "Output interrupt pending." ] # [ inline ( always ) ] pub fn cpifg_1 ( self ) -> & 'a mut W { self . variant ( CPIFG_A :: CPIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Comparator output inverted interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPIIFG_A { # [ doc = "0: No interrupt pending." ] CPIIFG_0 = 0 , # [ doc = "1: Output interrupt pending." ] CPIIFG_1 = 1 } impl From < CPIIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CPIIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPIIFG`" ] pub type CPIIFG_R = crate :: R < bool , CPIIFG_A > ; impl CPIIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPIIFG_A { match self . bits { false => CPIIFG_A :: CPIIFG_0 , true => CPIIFG_A :: CPIIFG_1 } } # [ doc = "Checks if the value of the field is `CPIIFG_0`" ] # [ inline ( always ) ] pub fn is_cpiifg_0 ( & self ) -> bool { * self == CPIIFG_A :: CPIIFG_0 } # [ doc = "Checks if the value of the field is `CPIIFG_1`" ] # [ inline ( always ) ] pub fn is_cpiifg_1 ( & self ) -> bool { * self == CPIIFG_A :: CPIIFG_1 } }
# [ doc = "Write proxy for field `CPIIFG`" ] pub struct CPIIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CPIIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPIIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending." ] # [ inline ( always ) ] pub fn cpiifg_0 ( self ) -> & 'a mut W { self . variant ( CPIIFG_A :: CPIIFG_0 ) } # [ doc = "Output interrupt pending." ] # [ inline ( always ) ] pub fn cpiifg_1 ( self ) -> & 'a mut W { self . variant ( CPIIFG_A :: CPIIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Comparator output interrupt flag" ] # [ inline ( always ) ] pub fn cpifg ( & self ) -> CPIFG_R { CPIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Comparator output inverted interrupt flag" ] # [ inline ( always ) ] pub fn cpiifg ( & self ) -> CPIIFG_R { CPIIFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Comparator output interrupt flag" ] # [ inline ( always ) ] pub fn cpifg ( & mut self ) -> CPIFG_W { CPIFG_W { w : self } }
# [ doc = "Bit 1 - Comparator output inverted interrupt flag" ] # [ inline ( always ) ] pub fn cpiifg ( & mut self ) -> CPIIFG_W { CPIIFG_W { w : self } }
}
}
# [ doc = "Comparator Interrupt Vector Word Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cpiv](cpiv) module" ] pub type CPIV = crate :: Reg < u16 , _CPIV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CPIV ;
# [ doc = "`read()` method returns [cpiv::R](cpiv::R) reader structure" ] impl crate :: Readable for CPIV { }
# [ doc = "Comparator Interrupt Vector Word Register" ] pub mod cpiv {
# [ doc = "Reader of register CPIV" ] pub type R = crate :: R < u16 , super :: CPIV > ;
# [ doc = "Comparator interrupt vector word register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum CPIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: CPIFG" ] CPIFG = 2 , # [ doc = "4: CPIIFG" ] CPIIFG = 4 } impl From < CPIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : CPIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPIV`" ] pub type CPIV_R = crate :: R < u16 , CPIV_A > ; impl CPIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , CPIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CPIV_A :: NONE ) , 2 => Val ( CPIV_A :: CPIFG ) , 4 => Val ( CPIV_A :: CPIIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CPIV_A :: NONE } # [ doc = "Checks if the value of the field is `CPIFG`" ] # [ inline ( always ) ] pub fn is_cpifg ( & self ) -> bool { * self == CPIV_A :: CPIFG } # [ doc = "Checks if the value of the field is `CPIIFG`" ] # [ inline ( always ) ] pub fn is_cpiifg ( & self ) -> bool { * self == CPIV_A :: CPIIFG } }
impl R {
# [ doc = "Bits 0:15 - Comparator interrupt vector word register" ] # [ inline ( always ) ] pub fn cpiv ( & self ) -> CPIV_R { CPIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
# [ doc = "6-bit Comparator built-in DAC Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cpdacctl](cpdacctl) module" ] pub type CPDACCTL = crate :: Reg < u16 , _CPDACCTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CPDACCTL ;
# [ doc = "`read()` method returns [cpdacctl::R](cpdacctl::R) reader structure" ] impl crate :: Readable for CPDACCTL { }
# [ doc = "`write(|w| ..)` method takes [cpdacctl::W](cpdacctl::W) writer structure" ] impl crate :: Writable for CPDACCTL { }
# [ doc = "6-bit Comparator built-in DAC Control Register" ] pub mod cpdacctl {
# [ doc = "Reader of register CPDACCTL" ] pub type R = crate :: R < u16 , super :: CPDACCTL > ;
# [ doc = "Writer for register CPDACCTL" ] pub type W = crate :: W < u16 , super :: CPDACCTL > ;
# [ doc = "Register CPDACCTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CPDACCTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "This bit is only valid when CPDACBUFS is set to 1.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPDACSW_A { # [ doc = "0: CPDACBUF1 selected" ] CPDACSW_0 = 0 , # [ doc = "1: CPDACBUF2 selected" ] CPDACSW_1 = 1 } impl From < CPDACSW_A > for bool { # [ inline ( always ) ] fn from ( variant : CPDACSW_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPDACSW`" ] pub type CPDACSW_R = crate :: R < bool , CPDACSW_A > ; impl CPDACSW_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACSW_A { match self . bits { false => CPDACSW_A :: CPDACSW_0 , true => CPDACSW_A :: CPDACSW_1 } } # [ doc = "Checks if the value of the field is `CPDACSW_0`" ] # [ inline ( always ) ] pub fn is_cpdacsw_0 ( & self ) -> bool { * self == CPDACSW_A :: CPDACSW_0 } # [ doc = "Checks if the value of the field is `CPDACSW_1`" ] # [ inline ( always ) ] pub fn is_cpdacsw_1 ( & self ) -> bool { * self == CPDACSW_A :: CPDACSW_1 } }
# [ doc = "Write proxy for field `CPDACSW`" ] pub struct CPDACSW_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACSW_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACSW_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "CPDACBUF1 selected" ] # [ inline ( always ) ] pub fn cpdacsw_0 ( self ) -> & 'a mut W { self . variant ( CPDACSW_A :: CPDACSW_0 ) } # [ doc = "CPDACBUF2 selected" ] # [ inline ( always ) ] pub fn cpdacsw_1 ( self ) -> & 'a mut W { self . variant ( CPDACSW_A :: CPDACSW_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Comparator built-in DAC buffer controlled source selection.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPDACBUFS_A { # [ doc = "0: Comparator output is selected as the buffer control source" ] CPDACBUFS_0 = 0 , # [ doc = "1: CPDACSW bit is selected as the buffer control source" ] CPDACBUFS_1 = 1 } impl From < CPDACBUFS_A > for bool { # [ inline ( always ) ] fn from ( variant : CPDACBUFS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPDACBUFS`" ] pub type CPDACBUFS_R = crate :: R < bool , CPDACBUFS_A > ; impl CPDACBUFS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACBUFS_A { match self . bits { false => CPDACBUFS_A :: CPDACBUFS_0 , true => CPDACBUFS_A :: CPDACBUFS_1 } } # [ doc = "Checks if the value of the field is `CPDACBUFS_0`" ] # [ inline ( always ) ] pub fn is_cpdacbufs_0 ( & self ) -> bool { * self == CPDACBUFS_A :: CPDACBUFS_0 } # [ doc = "Checks if the value of the field is `CPDACBUFS_1`" ] # [ inline ( always ) ] pub fn is_cpdacbufs_1 ( & self ) -> bool { * self == CPDACBUFS_A :: CPDACBUFS_1 } }
# [ doc = "Write proxy for field `CPDACBUFS`" ] pub struct CPDACBUFS_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACBUFS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACBUFS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Comparator output is selected as the buffer control source" ] # [ inline ( always ) ] pub fn cpdacbufs_0 ( self ) -> & 'a mut W { self . variant ( CPDACBUFS_A :: CPDACBUFS_0 ) } # [ doc = "CPDACSW bit is selected as the buffer control source" ] # [ inline ( always ) ] pub fn cpdacbufs_1 ( self ) -> & 'a mut W { self . variant ( CPDACBUFS_A :: CPDACBUFS_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Comparator built-in DAC reference voltage selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPDACREFS_A { # [ doc = "0: VDD selected" ] CPDACREFS_0 = 0 , # [ doc = "1: on-chip VREF selected" ] CPDACREFS_1 = 1 } impl From < CPDACREFS_A > for bool { # [ inline ( always ) ] fn from ( variant : CPDACREFS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPDACREFS`" ] pub type CPDACREFS_R = crate :: R < bool , CPDACREFS_A > ; impl CPDACREFS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACREFS_A { match self . bits { false => CPDACREFS_A :: CPDACREFS_0 , true => CPDACREFS_A :: CPDACREFS_1 } } # [ doc = "Checks if the value of the field is `CPDACREFS_0`" ] # [ inline ( always ) ] pub fn is_cpdacrefs_0 ( & self ) -> bool { * self == CPDACREFS_A :: CPDACREFS_0 } # [ doc = "Checks if the value of the field is `CPDACREFS_1`" ] # [ inline ( always ) ] pub fn is_cpdacrefs_1 ( & self ) -> bool { * self == CPDACREFS_A :: CPDACREFS_1 } }
# [ doc = "Write proxy for field `CPDACREFS`" ] pub struct CPDACREFS_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACREFS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACREFS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "VDD selected" ] # [ inline ( always ) ] pub fn cpdacrefs_0 ( self ) -> & 'a mut W { self . variant ( CPDACREFS_A :: CPDACREFS_0 ) } # [ doc = "on-chip VREF selected" ] # [ inline ( always ) ] pub fn cpdacrefs_1 ( self ) -> & 'a mut W { self . variant ( CPDACREFS_A :: CPDACREFS_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Comparator built-in DAC output control bit.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPDACEN_A { # [ doc = "0: DAC output is disabled." ] CPDACEN_0 = 0 , # [ doc = "1: DAC output is enabled." ] CPDACEN_1 = 1 } impl From < CPDACEN_A > for bool { # [ inline ( always ) ] fn from ( variant : CPDACEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPDACEN`" ] pub type CPDACEN_R = crate :: R < bool , CPDACEN_A > ; impl CPDACEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACEN_A { match self . bits { false => CPDACEN_A :: CPDACEN_0 , true => CPDACEN_A :: CPDACEN_1 } } # [ doc = "Checks if the value of the field is `CPDACEN_0`" ] # [ inline ( always ) ] pub fn is_cpdacen_0 ( & self ) -> bool { * self == CPDACEN_A :: CPDACEN_0 } # [ doc = "Checks if the value of the field is `CPDACEN_1`" ] # [ inline ( always ) ] pub fn is_cpdacen_1 ( & self ) -> bool { * self == CPDACEN_A :: CPDACEN_1 } }
# [ doc = "Write proxy for field `CPDACEN`" ] pub struct CPDACEN_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "DAC output is disabled." ] # [ inline ( always ) ] pub fn cpdacen_0 ( self ) -> & 'a mut W { self . variant ( CPDACEN_A :: CPDACEN_0 ) } # [ doc = "DAC output is enabled." ] # [ inline ( always ) ] pub fn cpdacen_1 ( self ) -> & 'a mut W { self . variant ( CPDACEN_A :: CPDACEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - This bit is only valid when CPDACBUFS is set to 1." ] # [ inline ( always ) ] pub fn cpdacsw ( & self ) -> CPDACSW_R { CPDACSW_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Comparator built-in DAC buffer controlled source selection." ] # [ inline ( always ) ] pub fn cpdacbufs ( & self ) -> CPDACBUFS_R { CPDACBUFS_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Comparator built-in DAC reference voltage selection" ] # [ inline ( always ) ] pub fn cpdacrefs ( & self ) -> CPDACREFS_R { CPDACREFS_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Comparator built-in DAC output control bit." ] # [ inline ( always ) ] pub fn cpdacen ( & self ) -> CPDACEN_R { CPDACEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - This bit is only valid when CPDACBUFS is set to 1." ] # [ inline ( always ) ] pub fn cpdacsw ( & mut self ) -> CPDACSW_W { CPDACSW_W { w : self } }
# [ doc = "Bit 1 - Comparator built-in DAC buffer controlled source selection." ] # [ inline ( always ) ] pub fn cpdacbufs ( & mut self ) -> CPDACBUFS_W { CPDACBUFS_W { w : self } }
# [ doc = "Bit 2 - Comparator built-in DAC reference voltage selection" ] # [ inline ( always ) ] pub fn cpdacrefs ( & mut self ) -> CPDACREFS_W { CPDACREFS_W { w : self } }
# [ doc = "Bit 7 - Comparator built-in DAC output control bit." ] # [ inline ( always ) ] pub fn cpdacen ( & mut self ) -> CPDACEN_W { CPDACEN_W { w : self } }
}
}
# [ doc = "6-bit Comparator built-in DAC Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cpdacdata](cpdacdata) module" ] pub type CPDACDATA = crate :: Reg < u16 , _CPDACDATA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CPDACDATA ;
# [ doc = "`read()` method returns [cpdacdata::R](cpdacdata::R) reader structure" ] impl crate :: Readable for CPDACDATA { }
# [ doc = "`write(|w| ..)` method takes [cpdacdata::W](cpdacdata::W) writer structure" ] impl crate :: Writable for CPDACDATA { }
# [ doc = "6-bit Comparator built-in DAC Data Register" ] pub mod cpdacdata {
# [ doc = "Reader of register CPDACDATA" ] pub type R = crate :: R < u16 , super :: CPDACDATA > ;
# [ doc = "Writer for register CPDACDATA" ] pub type W = crate :: W < u16 , super :: CPDACDATA > ;
# [ doc = "Register CPDACDATA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CPDACDATA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "1st 6-bit DAC buffer Data\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPDACBUF1_A { # [ doc = "0: 0v" ] CPDACBUF1_0 = 0 , # [ doc = "1: selected reference voltage * 1/64" ] CPDACBUF1_1 = 1 , # [ doc = "2: selected reference voltage * 2/64" ] CPDACBUF1_2 = 2 , # [ doc = "3: selected reference voltage * 3/64" ] CPDACBUF1_3 = 3 , # [ doc = "4: selected reference voltage * 4/64" ] CPDACBUF1_4 = 4 , # [ doc = "5: selected reference voltage * 5/64" ] CPDACBUF1_5 = 5 , # [ doc = "6: selected reference voltage * 6/64" ] CPDACBUF1_6 = 6 , # [ doc = "7: selected reference voltage * 7/64" ] CPDACBUF1_7 = 7 , # [ doc = "8: selected reference voltage * 8/64" ] CPDACBUF1_8 = 8 , # [ doc = "9: selected reference voltage *9/64" ] CPDACBUF1_9 = 9 , # [ doc = "10: selected reference voltage * 10/64" ] CPDACBUF1_10 = 10 , # [ doc = "11: selected reference voltage * 11/64" ] CPDACBUF1_11 = 11 , # [ doc = "12: selected reference voltage * 12/64" ] CPDACBUF1_12 = 12 , # [ doc = "13: selected reference voltage * 13/64" ] CPDACBUF1_13 = 13 , # [ doc = "14: selected reference voltage * 14/64" ] CPDACBUF1_14 = 14 , # [ doc = "15: selected reference voltage * 15/64" ] CPDACBUF1_15 = 15 , # [ doc = "16: selected reference voltage * 16/64" ] CPDACBUF1_16 = 16 , # [ doc = "17: selected reference voltage * 17/64" ] CPDACBUF1_17 = 17 , # [ doc = "18: selected reference voltage * 18/64" ] CPDACBUF1_18 = 18 , # [ doc = "19: selected reference voltage * 19/64" ] CPDACBUF1_19 = 19 , # [ doc = "20: selected reference voltage * 20/64" ] CPDACBUF1_20 = 20 , # [ doc = "21: selected reference voltage * 21/64" ] CPDACBUF1_21 = 21 , # [ doc = "22: selected reference voltage * 22/64" ] CPDACBUF1_22 = 22 , # [ doc = "23: selected reference voltage * 23/64" ] CPDACBUF1_23 = 23 , # [ doc = "24: selected reference voltage * 24/64" ] CPDACBUF1_24 = 24 , # [ doc = "25: selected reference voltage * 25/64" ] CPDACBUF1_25 = 25 , # [ doc = "26: selected reference voltage * 26/64" ] CPDACBUF1_26 = 26 , # [ doc = "27: selected reference voltage * 27/64" ] CPDACBUF1_27 = 27 , # [ doc = "28: selected reference voltage * 28/64" ] CPDACBUF1_28 = 28 , # [ doc = "29: selected reference voltage * 29/64" ] CPDACBUF1_29 = 29 , # [ doc = "30: selected reference voltage * 30/64" ] CPDACBUF1_30 = 30 , # [ doc = "31: selected reference voltage * 31/64" ] CPDACBUF1_31 = 31 , # [ doc = "32: selected reference voltage * 32/64" ] CPDACBUF1_32 = 32 , # [ doc = "33: selected reference voltage * 33/64" ] CPDACBUF1_33 = 33 , # [ doc = "34: selected reference voltage * 34/64" ] CPDACBUF1_34 = 34 , # [ doc = "35: selected reference voltage * 35/64" ] CPDACBUF1_35 = 35 , # [ doc = "36: selected reference voltage * 36/64" ] CPDACBUF1_36 = 36 , # [ doc = "37: selected reference voltage * 37/64" ] CPDACBUF1_37 = 37 , # [ doc = "38: selected reference voltage * 38/64" ] CPDACBUF1_38 = 38 , # [ doc = "39: selected reference voltage * 39/64" ] CPDACBUF1_39 = 39 , # [ doc = "40: selected reference voltage * 40/64" ] CPDACBUF1_40 = 40 , # [ doc = "41: selected reference voltage * 41/64" ] CPDACBUF1_41 = 41 , # [ doc = "42: selected reference voltage * 42/64" ] CPDACBUF1_42 = 42 , # [ doc = "43: selected reference voltage * 43/64" ] CPDACBUF1_43 = 43 , # [ doc = "44: selected reference voltage * 44/64" ] CPDACBUF1_44 = 44 , # [ doc = "45: selected reference voltage * 45/64" ] CPDACBUF1_45 = 45 , # [ doc = "46: selected reference voltage * 46/64" ] CPDACBUF1_46 = 46 , # [ doc = "47: selected reference voltage * 47/64" ] CPDACBUF1_47 = 47 , # [ doc = "48: selected reference voltage * 48/64" ] CPDACBUF1_48 = 48 , # [ doc = "49: selected reference voltage * 49/64" ] CPDACBUF1_49 = 49 , # [ doc = "50: selected reference voltage * 50/64" ] CPDACBUF1_50 = 50 , # [ doc = "51: selected reference voltage * 51/64" ] CPDACBUF1_51 = 51 , # [ doc = "52: selected reference voltage * 52/64" ] CPDACBUF1_52 = 52 , # [ doc = "53: selected reference voltage * 53/64" ] CPDACBUF1_53 = 53 , # [ doc = "54: selected reference voltage * 54/64" ] CPDACBUF1_54 = 54 , # [ doc = "55: selected reference voltage * 55/64" ] CPDACBUF1_55 = 55 , # [ doc = "56: selected reference voltage * 56/64" ] CPDACBUF1_56 = 56 , # [ doc = "57: selected reference voltage * 57/64" ] CPDACBUF1_57 = 57 , # [ doc = "58: selected reference voltage * 58/64" ] CPDACBUF1_58 = 58 , # [ doc = "59: selected reference voltage * 59/64" ] CPDACBUF1_59 = 59 , # [ doc = "60: selected reference voltage * 60/64" ] CPDACBUF1_60 = 60 , # [ doc = "61: selected reference voltage * 61/64" ] CPDACBUF1_61 = 61 , # [ doc = "62: selected reference voltage * 62/64" ] CPDACBUF1_62 = 62 , # [ doc = "63: selected reference voltage * 63/64" ] CPDACBUF1_63 = 63 } impl From < CPDACBUF1_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPDACBUF1_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPDACBUF1`" ] pub type CPDACBUF1_R = crate :: R < u8 , CPDACBUF1_A > ; impl CPDACBUF1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACBUF1_A { match self . bits { 0 => CPDACBUF1_A :: CPDACBUF1_0 , 1 => CPDACBUF1_A :: CPDACBUF1_1 , 2 => CPDACBUF1_A :: CPDACBUF1_2 , 3 => CPDACBUF1_A :: CPDACBUF1_3 , 4 => CPDACBUF1_A :: CPDACBUF1_4 , 5 => CPDACBUF1_A :: CPDACBUF1_5 , 6 => CPDACBUF1_A :: CPDACBUF1_6 , 7 => CPDACBUF1_A :: CPDACBUF1_7 , 8 => CPDACBUF1_A :: CPDACBUF1_8 , 9 => CPDACBUF1_A :: CPDACBUF1_9 , 10 => CPDACBUF1_A :: CPDACBUF1_10 , 11 => CPDACBUF1_A :: CPDACBUF1_11 , 12 => CPDACBUF1_A :: CPDACBUF1_12 , 13 => CPDACBUF1_A :: CPDACBUF1_13 , 14 => CPDACBUF1_A :: CPDACBUF1_14 , 15 => CPDACBUF1_A :: CPDACBUF1_15 , 16 => CPDACBUF1_A :: CPDACBUF1_16 , 17 => CPDACBUF1_A :: CPDACBUF1_17 , 18 => CPDACBUF1_A :: CPDACBUF1_18 , 19 => CPDACBUF1_A :: CPDACBUF1_19 , 20 => CPDACBUF1_A :: CPDACBUF1_20 , 21 => CPDACBUF1_A :: CPDACBUF1_21 , 22 => CPDACBUF1_A :: CPDACBUF1_22 , 23 => CPDACBUF1_A :: CPDACBUF1_23 , 24 => CPDACBUF1_A :: CPDACBUF1_24 , 25 => CPDACBUF1_A :: CPDACBUF1_25 , 26 => CPDACBUF1_A :: CPDACBUF1_26 , 27 => CPDACBUF1_A :: CPDACBUF1_27 , 28 => CPDACBUF1_A :: CPDACBUF1_28 , 29 => CPDACBUF1_A :: CPDACBUF1_29 , 30 => CPDACBUF1_A :: CPDACBUF1_30 , 31 => CPDACBUF1_A :: CPDACBUF1_31 , 32 => CPDACBUF1_A :: CPDACBUF1_32 , 33 => CPDACBUF1_A :: CPDACBUF1_33 , 34 => CPDACBUF1_A :: CPDACBUF1_34 , 35 => CPDACBUF1_A :: CPDACBUF1_35 , 36 => CPDACBUF1_A :: CPDACBUF1_36 , 37 => CPDACBUF1_A :: CPDACBUF1_37 , 38 => CPDACBUF1_A :: CPDACBUF1_38 , 39 => CPDACBUF1_A :: CPDACBUF1_39 , 40 => CPDACBUF1_A :: CPDACBUF1_40 , 41 => CPDACBUF1_A :: CPDACBUF1_41 , 42 => CPDACBUF1_A :: CPDACBUF1_42 , 43 => CPDACBUF1_A :: CPDACBUF1_43 , 44 => CPDACBUF1_A :: CPDACBUF1_44 , 45 => CPDACBUF1_A :: CPDACBUF1_45 , 46 => CPDACBUF1_A :: CPDACBUF1_46 , 47 => CPDACBUF1_A :: CPDACBUF1_47 , 48 => CPDACBUF1_A :: CPDACBUF1_48 , 49 => CPDACBUF1_A :: CPDACBUF1_49 , 50 => CPDACBUF1_A :: CPDACBUF1_50 , 51 => CPDACBUF1_A :: CPDACBUF1_51 , 52 => CPDACBUF1_A :: CPDACBUF1_52 , 53 => CPDACBUF1_A :: CPDACBUF1_53 , 54 => CPDACBUF1_A :: CPDACBUF1_54 , 55 => CPDACBUF1_A :: CPDACBUF1_55 , 56 => CPDACBUF1_A :: CPDACBUF1_56 , 57 => CPDACBUF1_A :: CPDACBUF1_57 , 58 => CPDACBUF1_A :: CPDACBUF1_58 , 59 => CPDACBUF1_A :: CPDACBUF1_59 , 60 => CPDACBUF1_A :: CPDACBUF1_60 , 61 => CPDACBUF1_A :: CPDACBUF1_61 , 62 => CPDACBUF1_A :: CPDACBUF1_62 , 63 => CPDACBUF1_A :: CPDACBUF1_63 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPDACBUF1_0`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_0 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_0 } # [ doc = "Checks if the value of the field is `CPDACBUF1_1`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_1 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_1 } # [ doc = "Checks if the value of the field is `CPDACBUF1_2`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_2 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_2 } # [ doc = "Checks if the value of the field is `CPDACBUF1_3`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_3 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_3 } # [ doc = "Checks if the value of the field is `CPDACBUF1_4`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_4 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_4 } # [ doc = "Checks if the value of the field is `CPDACBUF1_5`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_5 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_5 } # [ doc = "Checks if the value of the field is `CPDACBUF1_6`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_6 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_6 } # [ doc = "Checks if the value of the field is `CPDACBUF1_7`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_7 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_7 } # [ doc = "Checks if the value of the field is `CPDACBUF1_8`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_8 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_8 } # [ doc = "Checks if the value of the field is `CPDACBUF1_9`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_9 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_9 } # [ doc = "Checks if the value of the field is `CPDACBUF1_10`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_10 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_10 } # [ doc = "Checks if the value of the field is `CPDACBUF1_11`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_11 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_11 } # [ doc = "Checks if the value of the field is `CPDACBUF1_12`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_12 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_12 } # [ doc = "Checks if the value of the field is `CPDACBUF1_13`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_13 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_13 } # [ doc = "Checks if the value of the field is `CPDACBUF1_14`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_14 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_14 } # [ doc = "Checks if the value of the field is `CPDACBUF1_15`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_15 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_15 } # [ doc = "Checks if the value of the field is `CPDACBUF1_16`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_16 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_16 } # [ doc = "Checks if the value of the field is `CPDACBUF1_17`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_17 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_17 } # [ doc = "Checks if the value of the field is `CPDACBUF1_18`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_18 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_18 } # [ doc = "Checks if the value of the field is `CPDACBUF1_19`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_19 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_19 } # [ doc = "Checks if the value of the field is `CPDACBUF1_20`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_20 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_20 } # [ doc = "Checks if the value of the field is `CPDACBUF1_21`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_21 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_21 } # [ doc = "Checks if the value of the field is `CPDACBUF1_22`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_22 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_22 } # [ doc = "Checks if the value of the field is `CPDACBUF1_23`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_23 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_23 } # [ doc = "Checks if the value of the field is `CPDACBUF1_24`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_24 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_24 } # [ doc = "Checks if the value of the field is `CPDACBUF1_25`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_25 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_25 } # [ doc = "Checks if the value of the field is `CPDACBUF1_26`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_26 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_26 } # [ doc = "Checks if the value of the field is `CPDACBUF1_27`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_27 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_27 } # [ doc = "Checks if the value of the field is `CPDACBUF1_28`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_28 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_28 } # [ doc = "Checks if the value of the field is `CPDACBUF1_29`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_29 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_29 } # [ doc = "Checks if the value of the field is `CPDACBUF1_30`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_30 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_30 } # [ doc = "Checks if the value of the field is `CPDACBUF1_31`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_31 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_31 } # [ doc = "Checks if the value of the field is `CPDACBUF1_32`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_32 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_32 } # [ doc = "Checks if the value of the field is `CPDACBUF1_33`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_33 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_33 } # [ doc = "Checks if the value of the field is `CPDACBUF1_34`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_34 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_34 } # [ doc = "Checks if the value of the field is `CPDACBUF1_35`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_35 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_35 } # [ doc = "Checks if the value of the field is `CPDACBUF1_36`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_36 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_36 } # [ doc = "Checks if the value of the field is `CPDACBUF1_37`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_37 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_37 } # [ doc = "Checks if the value of the field is `CPDACBUF1_38`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_38 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_38 } # [ doc = "Checks if the value of the field is `CPDACBUF1_39`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_39 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_39 } # [ doc = "Checks if the value of the field is `CPDACBUF1_40`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_40 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_40 } # [ doc = "Checks if the value of the field is `CPDACBUF1_41`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_41 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_41 } # [ doc = "Checks if the value of the field is `CPDACBUF1_42`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_42 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_42 } # [ doc = "Checks if the value of the field is `CPDACBUF1_43`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_43 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_43 } # [ doc = "Checks if the value of the field is `CPDACBUF1_44`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_44 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_44 } # [ doc = "Checks if the value of the field is `CPDACBUF1_45`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_45 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_45 } # [ doc = "Checks if the value of the field is `CPDACBUF1_46`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_46 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_46 } # [ doc = "Checks if the value of the field is `CPDACBUF1_47`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_47 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_47 } # [ doc = "Checks if the value of the field is `CPDACBUF1_48`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_48 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_48 } # [ doc = "Checks if the value of the field is `CPDACBUF1_49`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_49 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_49 } # [ doc = "Checks if the value of the field is `CPDACBUF1_50`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_50 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_50 } # [ doc = "Checks if the value of the field is `CPDACBUF1_51`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_51 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_51 } # [ doc = "Checks if the value of the field is `CPDACBUF1_52`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_52 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_52 } # [ doc = "Checks if the value of the field is `CPDACBUF1_53`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_53 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_53 } # [ doc = "Checks if the value of the field is `CPDACBUF1_54`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_54 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_54 } # [ doc = "Checks if the value of the field is `CPDACBUF1_55`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_55 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_55 } # [ doc = "Checks if the value of the field is `CPDACBUF1_56`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_56 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_56 } # [ doc = "Checks if the value of the field is `CPDACBUF1_57`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_57 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_57 } # [ doc = "Checks if the value of the field is `CPDACBUF1_58`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_58 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_58 } # [ doc = "Checks if the value of the field is `CPDACBUF1_59`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_59 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_59 } # [ doc = "Checks if the value of the field is `CPDACBUF1_60`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_60 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_60 } # [ doc = "Checks if the value of the field is `CPDACBUF1_61`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_61 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_61 } # [ doc = "Checks if the value of the field is `CPDACBUF1_62`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_62 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_62 } # [ doc = "Checks if the value of the field is `CPDACBUF1_63`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_63 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_63 } }
# [ doc = "Write proxy for field `CPDACBUF1`" ] pub struct CPDACBUF1_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACBUF1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACBUF1_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "0v" ] # [ inline ( always ) ] pub fn cpdacbuf1_0 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_0 ) } # [ doc = "selected reference voltage * 1/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_1 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_1 ) } # [ doc = "selected reference voltage * 2/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_2 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_2 ) } # [ doc = "selected reference voltage * 3/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_3 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_3 ) } # [ doc = "selected reference voltage * 4/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_4 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_4 ) } # [ doc = "selected reference voltage * 5/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_5 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_5 ) } # [ doc = "selected reference voltage * 6/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_6 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_6 ) } # [ doc = "selected reference voltage * 7/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_7 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_7 ) } # [ doc = "selected reference voltage * 8/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_8 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_8 ) } # [ doc = "selected reference voltage *9/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_9 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_9 ) } # [ doc = "selected reference voltage * 10/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_10 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_10 ) } # [ doc = "selected reference voltage * 11/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_11 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_11 ) } # [ doc = "selected reference voltage * 12/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_12 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_12 ) } # [ doc = "selected reference voltage * 13/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_13 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_13 ) } # [ doc = "selected reference voltage * 14/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_14 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_14 ) } # [ doc = "selected reference voltage * 15/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_15 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_15 ) } # [ doc = "selected reference voltage * 16/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_16 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_16 ) } # [ doc = "selected reference voltage * 17/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_17 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_17 ) } # [ doc = "selected reference voltage * 18/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_18 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_18 ) } # [ doc = "selected reference voltage * 19/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_19 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_19 ) } # [ doc = "selected reference voltage * 20/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_20 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_20 ) } # [ doc = "selected reference voltage * 21/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_21 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_21 ) } # [ doc = "selected reference voltage * 22/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_22 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_22 ) } # [ doc = "selected reference voltage * 23/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_23 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_23 ) } # [ doc = "selected reference voltage * 24/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_24 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_24 ) } # [ doc = "selected reference voltage * 25/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_25 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_25 ) } # [ doc = "selected reference voltage * 26/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_26 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_26 ) } # [ doc = "selected reference voltage * 27/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_27 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_27 ) } # [ doc = "selected reference voltage * 28/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_28 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_28 ) } # [ doc = "selected reference voltage * 29/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_29 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_29 ) } # [ doc = "selected reference voltage * 30/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_30 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_30 ) } # [ doc = "selected reference voltage * 31/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_31 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_31 ) } # [ doc = "selected reference voltage * 32/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_32 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_32 ) } # [ doc = "selected reference voltage * 33/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_33 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_33 ) } # [ doc = "selected reference voltage * 34/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_34 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_34 ) } # [ doc = "selected reference voltage * 35/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_35 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_35 ) } # [ doc = "selected reference voltage * 36/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_36 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_36 ) } # [ doc = "selected reference voltage * 37/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_37 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_37 ) } # [ doc = "selected reference voltage * 38/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_38 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_38 ) } # [ doc = "selected reference voltage * 39/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_39 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_39 ) } # [ doc = "selected reference voltage * 40/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_40 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_40 ) } # [ doc = "selected reference voltage * 41/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_41 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_41 ) } # [ doc = "selected reference voltage * 42/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_42 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_42 ) } # [ doc = "selected reference voltage * 43/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_43 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_43 ) } # [ doc = "selected reference voltage * 44/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_44 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_44 ) } # [ doc = "selected reference voltage * 45/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_45 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_45 ) } # [ doc = "selected reference voltage * 46/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_46 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_46 ) } # [ doc = "selected reference voltage * 47/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_47 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_47 ) } # [ doc = "selected reference voltage * 48/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_48 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_48 ) } # [ doc = "selected reference voltage * 49/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_49 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_49 ) } # [ doc = "selected reference voltage * 50/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_50 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_50 ) } # [ doc = "selected reference voltage * 51/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_51 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_51 ) } # [ doc = "selected reference voltage * 52/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_52 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_52 ) } # [ doc = "selected reference voltage * 53/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_53 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_53 ) } # [ doc = "selected reference voltage * 54/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_54 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_54 ) } # [ doc = "selected reference voltage * 55/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_55 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_55 ) } # [ doc = "selected reference voltage * 56/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_56 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_56 ) } # [ doc = "selected reference voltage * 57/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_57 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_57 ) } # [ doc = "selected reference voltage * 58/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_58 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_58 ) } # [ doc = "selected reference voltage * 59/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_59 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_59 ) } # [ doc = "selected reference voltage * 60/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_60 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_60 ) } # [ doc = "selected reference voltage * 61/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_61 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_61 ) } # [ doc = "selected reference voltage * 62/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_62 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_62 ) } # [ doc = "selected reference voltage * 63/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_63 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_63 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u16 ) & 0x3f ) ; self . w } }
# [ doc = "2nd 6-bit DAC buffer Data\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPDACBUF2_A { # [ doc = "0: 0v" ] CPDACBUF2_0 = 0 , # [ doc = "1: selected reference voltage * 1/64" ] CPDACBUF2_1 = 1 , # [ doc = "2: selected reference voltage * 2/64" ] CPDACBUF2_2 = 2 , # [ doc = "3: selected reference voltage * 3/64" ] CPDACBUF2_3 = 3 , # [ doc = "4: selected reference voltage * 4/64" ] CPDACBUF2_4 = 4 , # [ doc = "5: selected reference voltage * 5/64" ] CPDACBUF2_5 = 5 , # [ doc = "6: selected reference voltage * 6/64" ] CPDACBUF2_6 = 6 , # [ doc = "7: selected reference voltage * 7/64" ] CPDACBUF2_7 = 7 , # [ doc = "8: selected reference voltage * 8/64" ] CPDACBUF2_8 = 8 , # [ doc = "9: selected reference voltage * 9/64" ] CPDACBUF2_9 = 9 , # [ doc = "10: selected reference voltage * 10/64" ] CPDACBUF2_10 = 10 , # [ doc = "11: selected reference voltage * 11/64" ] CPDACBUF2_11 = 11 , # [ doc = "12: selected reference voltage * 12/64" ] CPDACBUF2_12 = 12 , # [ doc = "13: selected reference voltage * 13/64" ] CPDACBUF2_13 = 13 , # [ doc = "14: selected reference voltage * 14/64" ] CPDACBUF2_14 = 14 , # [ doc = "15: selected reference voltage * 15/64" ] CPDACBUF2_15 = 15 , # [ doc = "16: selected reference voltage * 16/64" ] CPDACBUF2_16 = 16 , # [ doc = "17: selected reference voltage * 17/64" ] CPDACBUF2_17 = 17 , # [ doc = "18: selected reference voltage * 18/64" ] CPDACBUF2_18 = 18 , # [ doc = "19: selected reference voltage * 19/64" ] CPDACBUF2_19 = 19 , # [ doc = "20: selected reference voltage * 20/64" ] CPDACBUF2_20 = 20 , # [ doc = "21: selected reference voltage * 21/64" ] CPDACBUF2_21 = 21 , # [ doc = "22: selected reference voltage * 22/64" ] CPDACBUF2_22 = 22 , # [ doc = "23: selected reference voltage * 23/64" ] CPDACBUF2_23 = 23 , # [ doc = "24: selected reference voltage * 24/64" ] CPDACBUF2_24 = 24 , # [ doc = "25: selected reference voltage * 25/64" ] CPDACBUF2_25 = 25 , # [ doc = "26: selected reference voltage * 26/64" ] CPDACBUF2_26 = 26 , # [ doc = "27: selected reference voltage * 27/64" ] CPDACBUF2_27 = 27 , # [ doc = "28: selected reference voltage * 28/64" ] CPDACBUF2_28 = 28 , # [ doc = "29: selected reference voltage * 29/64" ] CPDACBUF2_29 = 29 , # [ doc = "30: selected reference voltage * 30/64" ] CPDACBUF2_30 = 30 , # [ doc = "31: selected reference voltage * 31/64" ] CPDACBUF2_31 = 31 , # [ doc = "32: selected reference voltage * 32/64" ] CPDACBUF2_32 = 32 , # [ doc = "33: selected reference voltage * 33/64" ] CPDACBUF2_33 = 33 , # [ doc = "34: selected reference voltage * 34/64" ] CPDACBUF2_34 = 34 , # [ doc = "35: selected reference voltage * 35/64" ] CPDACBUF2_35 = 35 , # [ doc = "36: selected reference voltage * 36/64" ] CPDACBUF2_36 = 36 , # [ doc = "37: selected reference voltage * 37/64" ] CPDACBUF2_37 = 37 , # [ doc = "38: selected reference voltage * 38/64" ] CPDACBUF2_38 = 38 , # [ doc = "39: selected reference voltage * 39/64" ] CPDACBUF2_39 = 39 , # [ doc = "40: selected reference voltage * 40/64" ] CPDACBUF2_40 = 40 , # [ doc = "41: selected reference voltage * 41/64" ] CPDACBUF2_41 = 41 , # [ doc = "42: selected reference voltage * 42/64" ] CPDACBUF2_42 = 42 , # [ doc = "43: selected reference voltage * 43/64" ] CPDACBUF2_43 = 43 , # [ doc = "44: selected reference voltage * 44/64" ] CPDACBUF2_44 = 44 , # [ doc = "45: selected reference voltage * 45/64" ] CPDACBUF2_45 = 45 , # [ doc = "46: selected reference voltage * 46/64" ] CPDACBUF2_46 = 46 , # [ doc = "47: selected reference voltage * 47/64" ] CPDACBUF2_47 = 47 , # [ doc = "48: selected reference voltage * 48/64" ] CPDACBUF2_48 = 48 , # [ doc = "49: selected reference voltage * 49/64" ] CPDACBUF2_49 = 49 , # [ doc = "50: selected reference voltage * 50/64" ] CPDACBUF2_50 = 50 , # [ doc = "51: selected reference voltage * 51/64" ] CPDACBUF2_51 = 51 , # [ doc = "52: selected reference voltage * 52/64" ] CPDACBUF2_52 = 52 , # [ doc = "53: selected reference voltage * 53/64" ] CPDACBUF2_53 = 53 , # [ doc = "54: selected reference voltage * 54/64" ] CPDACBUF2_54 = 54 , # [ doc = "55: selected reference voltage * 55/64" ] CPDACBUF2_55 = 55 , # [ doc = "56: selected reference voltage * 56/64" ] CPDACBUF2_56 = 56 , # [ doc = "57: selected reference voltage * 57/64" ] CPDACBUF2_57 = 57 , # [ doc = "58: selected reference voltage * 58/64" ] CPDACBUF2_58 = 58 , # [ doc = "59: selected reference voltage * 59/64" ] CPDACBUF2_59 = 59 , # [ doc = "60: selected reference voltage * 60/64" ] CPDACBUF2_60 = 60 , # [ doc = "61: selected reference voltage * 61/64" ] CPDACBUF2_61 = 61 , # [ doc = "62: selected reference voltage * 62/64" ] CPDACBUF2_62 = 62 , # [ doc = "63: selected reference voltage * 63/64" ] CPDACBUF2_63 = 63 } impl From < CPDACBUF2_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPDACBUF2_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPDACBUF2`" ] pub type CPDACBUF2_R = crate :: R < u8 , CPDACBUF2_A > ; impl CPDACBUF2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACBUF2_A { match self . bits { 0 => CPDACBUF2_A :: CPDACBUF2_0 , 1 => CPDACBUF2_A :: CPDACBUF2_1 , 2 => CPDACBUF2_A :: CPDACBUF2_2 , 3 => CPDACBUF2_A :: CPDACBUF2_3 , 4 => CPDACBUF2_A :: CPDACBUF2_4 , 5 => CPDACBUF2_A :: CPDACBUF2_5 , 6 => CPDACBUF2_A :: CPDACBUF2_6 , 7 => CPDACBUF2_A :: CPDACBUF2_7 , 8 => CPDACBUF2_A :: CPDACBUF2_8 , 9 => CPDACBUF2_A :: CPDACBUF2_9 , 10 => CPDACBUF2_A :: CPDACBUF2_10 , 11 => CPDACBUF2_A :: CPDACBUF2_11 , 12 => CPDACBUF2_A :: CPDACBUF2_12 , 13 => CPDACBUF2_A :: CPDACBUF2_13 , 14 => CPDACBUF2_A :: CPDACBUF2_14 , 15 => CPDACBUF2_A :: CPDACBUF2_15 , 16 => CPDACBUF2_A :: CPDACBUF2_16 , 17 => CPDACBUF2_A :: CPDACBUF2_17 , 18 => CPDACBUF2_A :: CPDACBUF2_18 , 19 => CPDACBUF2_A :: CPDACBUF2_19 , 20 => CPDACBUF2_A :: CPDACBUF2_20 , 21 => CPDACBUF2_A :: CPDACBUF2_21 , 22 => CPDACBUF2_A :: CPDACBUF2_22 , 23 => CPDACBUF2_A :: CPDACBUF2_23 , 24 => CPDACBUF2_A :: CPDACBUF2_24 , 25 => CPDACBUF2_A :: CPDACBUF2_25 , 26 => CPDACBUF2_A :: CPDACBUF2_26 , 27 => CPDACBUF2_A :: CPDACBUF2_27 , 28 => CPDACBUF2_A :: CPDACBUF2_28 , 29 => CPDACBUF2_A :: CPDACBUF2_29 , 30 => CPDACBUF2_A :: CPDACBUF2_30 , 31 => CPDACBUF2_A :: CPDACBUF2_31 , 32 => CPDACBUF2_A :: CPDACBUF2_32 , 33 => CPDACBUF2_A :: CPDACBUF2_33 , 34 => CPDACBUF2_A :: CPDACBUF2_34 , 35 => CPDACBUF2_A :: CPDACBUF2_35 , 36 => CPDACBUF2_A :: CPDACBUF2_36 , 37 => CPDACBUF2_A :: CPDACBUF2_37 , 38 => CPDACBUF2_A :: CPDACBUF2_38 , 39 => CPDACBUF2_A :: CPDACBUF2_39 , 40 => CPDACBUF2_A :: CPDACBUF2_40 , 41 => CPDACBUF2_A :: CPDACBUF2_41 , 42 => CPDACBUF2_A :: CPDACBUF2_42 , 43 => CPDACBUF2_A :: CPDACBUF2_43 , 44 => CPDACBUF2_A :: CPDACBUF2_44 , 45 => CPDACBUF2_A :: CPDACBUF2_45 , 46 => CPDACBUF2_A :: CPDACBUF2_46 , 47 => CPDACBUF2_A :: CPDACBUF2_47 , 48 => CPDACBUF2_A :: CPDACBUF2_48 , 49 => CPDACBUF2_A :: CPDACBUF2_49 , 50 => CPDACBUF2_A :: CPDACBUF2_50 , 51 => CPDACBUF2_A :: CPDACBUF2_51 , 52 => CPDACBUF2_A :: CPDACBUF2_52 , 53 => CPDACBUF2_A :: CPDACBUF2_53 , 54 => CPDACBUF2_A :: CPDACBUF2_54 , 55 => CPDACBUF2_A :: CPDACBUF2_55 , 56 => CPDACBUF2_A :: CPDACBUF2_56 , 57 => CPDACBUF2_A :: CPDACBUF2_57 , 58 => CPDACBUF2_A :: CPDACBUF2_58 , 59 => CPDACBUF2_A :: CPDACBUF2_59 , 60 => CPDACBUF2_A :: CPDACBUF2_60 , 61 => CPDACBUF2_A :: CPDACBUF2_61 , 62 => CPDACBUF2_A :: CPDACBUF2_62 , 63 => CPDACBUF2_A :: CPDACBUF2_63 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPDACBUF2_0`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_0 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_0 } # [ doc = "Checks if the value of the field is `CPDACBUF2_1`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_1 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_1 } # [ doc = "Checks if the value of the field is `CPDACBUF2_2`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_2 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_2 } # [ doc = "Checks if the value of the field is `CPDACBUF2_3`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_3 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_3 } # [ doc = "Checks if the value of the field is `CPDACBUF2_4`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_4 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_4 } # [ doc = "Checks if the value of the field is `CPDACBUF2_5`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_5 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_5 } # [ doc = "Checks if the value of the field is `CPDACBUF2_6`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_6 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_6 } # [ doc = "Checks if the value of the field is `CPDACBUF2_7`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_7 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_7 } # [ doc = "Checks if the value of the field is `CPDACBUF2_8`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_8 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_8 } # [ doc = "Checks if the value of the field is `CPDACBUF2_9`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_9 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_9 } # [ doc = "Checks if the value of the field is `CPDACBUF2_10`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_10 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_10 } # [ doc = "Checks if the value of the field is `CPDACBUF2_11`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_11 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_11 } # [ doc = "Checks if the value of the field is `CPDACBUF2_12`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_12 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_12 } # [ doc = "Checks if the value of the field is `CPDACBUF2_13`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_13 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_13 } # [ doc = "Checks if the value of the field is `CPDACBUF2_14`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_14 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_14 } # [ doc = "Checks if the value of the field is `CPDACBUF2_15`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_15 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_15 } # [ doc = "Checks if the value of the field is `CPDACBUF2_16`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_16 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_16 } # [ doc = "Checks if the value of the field is `CPDACBUF2_17`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_17 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_17 } # [ doc = "Checks if the value of the field is `CPDACBUF2_18`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_18 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_18 } # [ doc = "Checks if the value of the field is `CPDACBUF2_19`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_19 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_19 } # [ doc = "Checks if the value of the field is `CPDACBUF2_20`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_20 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_20 } # [ doc = "Checks if the value of the field is `CPDACBUF2_21`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_21 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_21 } # [ doc = "Checks if the value of the field is `CPDACBUF2_22`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_22 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_22 } # [ doc = "Checks if the value of the field is `CPDACBUF2_23`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_23 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_23 } # [ doc = "Checks if the value of the field is `CPDACBUF2_24`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_24 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_24 } # [ doc = "Checks if the value of the field is `CPDACBUF2_25`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_25 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_25 } # [ doc = "Checks if the value of the field is `CPDACBUF2_26`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_26 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_26 } # [ doc = "Checks if the value of the field is `CPDACBUF2_27`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_27 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_27 } # [ doc = "Checks if the value of the field is `CPDACBUF2_28`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_28 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_28 } # [ doc = "Checks if the value of the field is `CPDACBUF2_29`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_29 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_29 } # [ doc = "Checks if the value of the field is `CPDACBUF2_30`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_30 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_30 } # [ doc = "Checks if the value of the field is `CPDACBUF2_31`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_31 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_31 } # [ doc = "Checks if the value of the field is `CPDACBUF2_32`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_32 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_32 } # [ doc = "Checks if the value of the field is `CPDACBUF2_33`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_33 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_33 } # [ doc = "Checks if the value of the field is `CPDACBUF2_34`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_34 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_34 } # [ doc = "Checks if the value of the field is `CPDACBUF2_35`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_35 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_35 } # [ doc = "Checks if the value of the field is `CPDACBUF2_36`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_36 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_36 } # [ doc = "Checks if the value of the field is `CPDACBUF2_37`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_37 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_37 } # [ doc = "Checks if the value of the field is `CPDACBUF2_38`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_38 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_38 } # [ doc = "Checks if the value of the field is `CPDACBUF2_39`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_39 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_39 } # [ doc = "Checks if the value of the field is `CPDACBUF2_40`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_40 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_40 } # [ doc = "Checks if the value of the field is `CPDACBUF2_41`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_41 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_41 } # [ doc = "Checks if the value of the field is `CPDACBUF2_42`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_42 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_42 } # [ doc = "Checks if the value of the field is `CPDACBUF2_43`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_43 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_43 } # [ doc = "Checks if the value of the field is `CPDACBUF2_44`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_44 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_44 } # [ doc = "Checks if the value of the field is `CPDACBUF2_45`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_45 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_45 } # [ doc = "Checks if the value of the field is `CPDACBUF2_46`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_46 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_46 } # [ doc = "Checks if the value of the field is `CPDACBUF2_47`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_47 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_47 } # [ doc = "Checks if the value of the field is `CPDACBUF2_48`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_48 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_48 } # [ doc = "Checks if the value of the field is `CPDACBUF2_49`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_49 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_49 } # [ doc = "Checks if the value of the field is `CPDACBUF2_50`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_50 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_50 } # [ doc = "Checks if the value of the field is `CPDACBUF2_51`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_51 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_51 } # [ doc = "Checks if the value of the field is `CPDACBUF2_52`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_52 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_52 } # [ doc = "Checks if the value of the field is `CPDACBUF2_53`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_53 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_53 } # [ doc = "Checks if the value of the field is `CPDACBUF2_54`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_54 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_54 } # [ doc = "Checks if the value of the field is `CPDACBUF2_55`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_55 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_55 } # [ doc = "Checks if the value of the field is `CPDACBUF2_56`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_56 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_56 } # [ doc = "Checks if the value of the field is `CPDACBUF2_57`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_57 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_57 } # [ doc = "Checks if the value of the field is `CPDACBUF2_58`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_58 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_58 } # [ doc = "Checks if the value of the field is `CPDACBUF2_59`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_59 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_59 } # [ doc = "Checks if the value of the field is `CPDACBUF2_60`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_60 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_60 } # [ doc = "Checks if the value of the field is `CPDACBUF2_61`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_61 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_61 } # [ doc = "Checks if the value of the field is `CPDACBUF2_62`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_62 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_62 } # [ doc = "Checks if the value of the field is `CPDACBUF2_63`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_63 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_63 } }
# [ doc = "Write proxy for field `CPDACBUF2`" ] pub struct CPDACBUF2_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACBUF2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACBUF2_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "0v" ] # [ inline ( always ) ] pub fn cpdacbuf2_0 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_0 ) } # [ doc = "selected reference voltage * 1/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_1 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_1 ) } # [ doc = "selected reference voltage * 2/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_2 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_2 ) } # [ doc = "selected reference voltage * 3/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_3 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_3 ) } # [ doc = "selected reference voltage * 4/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_4 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_4 ) } # [ doc = "selected reference voltage * 5/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_5 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_5 ) } # [ doc = "selected reference voltage * 6/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_6 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_6 ) } # [ doc = "selected reference voltage * 7/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_7 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_7 ) } # [ doc = "selected reference voltage * 8/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_8 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_8 ) } # [ doc = "selected reference voltage * 9/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_9 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_9 ) } # [ doc = "selected reference voltage * 10/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_10 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_10 ) } # [ doc = "selected reference voltage * 11/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_11 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_11 ) } # [ doc = "selected reference voltage * 12/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_12 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_12 ) } # [ doc = "selected reference voltage * 13/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_13 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_13 ) } # [ doc = "selected reference voltage * 14/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_14 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_14 ) } # [ doc = "selected reference voltage * 15/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_15 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_15 ) } # [ doc = "selected reference voltage * 16/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_16 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_16 ) } # [ doc = "selected reference voltage * 17/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_17 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_17 ) } # [ doc = "selected reference voltage * 18/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_18 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_18 ) } # [ doc = "selected reference voltage * 19/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_19 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_19 ) } # [ doc = "selected reference voltage * 20/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_20 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_20 ) } # [ doc = "selected reference voltage * 21/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_21 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_21 ) } # [ doc = "selected reference voltage * 22/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_22 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_22 ) } # [ doc = "selected reference voltage * 23/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_23 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_23 ) } # [ doc = "selected reference voltage * 24/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_24 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_24 ) } # [ doc = "selected reference voltage * 25/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_25 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_25 ) } # [ doc = "selected reference voltage * 26/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_26 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_26 ) } # [ doc = "selected reference voltage * 27/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_27 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_27 ) } # [ doc = "selected reference voltage * 28/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_28 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_28 ) } # [ doc = "selected reference voltage * 29/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_29 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_29 ) } # [ doc = "selected reference voltage * 30/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_30 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_30 ) } # [ doc = "selected reference voltage * 31/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_31 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_31 ) } # [ doc = "selected reference voltage * 32/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_32 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_32 ) } # [ doc = "selected reference voltage * 33/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_33 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_33 ) } # [ doc = "selected reference voltage * 34/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_34 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_34 ) } # [ doc = "selected reference voltage * 35/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_35 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_35 ) } # [ doc = "selected reference voltage * 36/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_36 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_36 ) } # [ doc = "selected reference voltage * 37/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_37 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_37 ) } # [ doc = "selected reference voltage * 38/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_38 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_38 ) } # [ doc = "selected reference voltage * 39/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_39 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_39 ) } # [ doc = "selected reference voltage * 40/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_40 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_40 ) } # [ doc = "selected reference voltage * 41/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_41 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_41 ) } # [ doc = "selected reference voltage * 42/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_42 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_42 ) } # [ doc = "selected reference voltage * 43/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_43 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_43 ) } # [ doc = "selected reference voltage * 44/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_44 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_44 ) } # [ doc = "selected reference voltage * 45/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_45 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_45 ) } # [ doc = "selected reference voltage * 46/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_46 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_46 ) } # [ doc = "selected reference voltage * 47/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_47 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_47 ) } # [ doc = "selected reference voltage * 48/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_48 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_48 ) } # [ doc = "selected reference voltage * 49/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_49 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_49 ) } # [ doc = "selected reference voltage * 50/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_50 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_50 ) } # [ doc = "selected reference voltage * 51/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_51 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_51 ) } # [ doc = "selected reference voltage * 52/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_52 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_52 ) } # [ doc = "selected reference voltage * 53/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_53 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_53 ) } # [ doc = "selected reference voltage * 54/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_54 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_54 ) } # [ doc = "selected reference voltage * 55/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_55 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_55 ) } # [ doc = "selected reference voltage * 56/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_56 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_56 ) } # [ doc = "selected reference voltage * 57/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_57 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_57 ) } # [ doc = "selected reference voltage * 58/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_58 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_58 ) } # [ doc = "selected reference voltage * 59/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_59 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_59 ) } # [ doc = "selected reference voltage * 60/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_60 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_60 ) } # [ doc = "selected reference voltage * 61/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_61 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_61 ) } # [ doc = "selected reference voltage * 62/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_62 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_62 ) } # [ doc = "selected reference voltage * 63/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_63 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_63 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 8 ) ) | ( ( ( value as u16 ) & 0x3f ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:5 - 1st 6-bit DAC buffer Data" ] # [ inline ( always ) ] pub fn cpdacbuf1 ( & self ) -> CPDACBUF1_R { CPDACBUF1_R :: new ( ( self . bits & 0x3f ) as u8 ) }
# [ doc = "Bits 8:13 - 2nd 6-bit DAC buffer Data" ] # [ inline ( always ) ] pub fn cpdacbuf2 ( & self ) -> CPDACBUF2_R { CPDACBUF2_R :: new ( ( ( self . bits >> 8 ) & 0x3f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:5 - 1st 6-bit DAC buffer Data" ] # [ inline ( always ) ] pub fn cpdacbuf1 ( & mut self ) -> CPDACBUF1_W { CPDACBUF1_W { w : self } }
# [ doc = "Bits 8:13 - 2nd 6-bit DAC buffer Data" ] # [ inline ( always ) ] pub fn cpdacbuf2 ( & mut self ) -> CPDACBUF2_W { CPDACBUF2_W { w : self } }
}
}
}
# [ doc = "eCOMP1" ] pub struct E_COMP1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for E_COMP1 { } impl E_COMP1 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const e_comp1 :: RegisterBlock { 0x0900 as * const _ } } impl Deref for E_COMP1 { type Target = e_comp1 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * E_COMP1 :: ptr ( ) } } }
# [ doc = "eCOMP1" ] pub mod e_comp1 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Comparator Control Register 0" ] pub cp1ctl0 : CP1CTL0 , # [ doc = "0x02 - Comparator Control Register 1" ] pub cp1ctl1 : CP1CTL1 , _reserved2 : [ u8 ; 2usize ] , # [ doc = "0x06 - Comparator Interrupt Control Register" ] pub cp1int : CP1INT , # [ doc = "0x08 - Comparator Interrupt Vector Word Register" ] pub cp1iv : CP1IV , _reserved4 : [ u8 ; 6usize ] , # [ doc = "0x10 - 6-bit Comparator built-in DAC Control Register" ] pub cp1dacctl : CP1DACCTL , # [ doc = "0x12 - 6-bit Comparator built-in DAC Data Register" ] pub cp1dacdata : CP1DACDATA , }
# [ doc = "Comparator Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cp1ctl0](cp1ctl0) module" ] pub type CP1CTL0 = crate :: Reg < u16 , _CP1CTL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CP1CTL0 ;
# [ doc = "`read()` method returns [cp1ctl0::R](cp1ctl0::R) reader structure" ] impl crate :: Readable for CP1CTL0 { }
# [ doc = "`write(|w| ..)` method takes [cp1ctl0::W](cp1ctl0::W) writer structure" ] impl crate :: Writable for CP1CTL0 { }
# [ doc = "Comparator Control Register 0" ] pub mod cp1ctl0 {
# [ doc = "Reader of register CP1CTL0" ] pub type R = crate :: R < u16 , super :: CP1CTL0 > ;
# [ doc = "Writer for register CP1CTL0" ] pub type W = crate :: W < u16 , super :: CP1CTL0 > ;
# [ doc = "Register CP1CTL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CP1CTL0 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Channel input enable for the V+ terminal\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPPEN_A { # [ doc = "0: Selected analog input channel for V+ terminal is disabled." ] CPPEN_0 = 0 , # [ doc = "1: Selected analog input channel for V+ terminal is enabled." ] CPPEN_1 = 1 } impl From < CPPEN_A > for bool { # [ inline ( always ) ] fn from ( variant : CPPEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPPEN`" ] pub type CPPEN_R = crate :: R < bool , CPPEN_A > ; impl CPPEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPPEN_A { match self . bits { false => CPPEN_A :: CPPEN_0 , true => CPPEN_A :: CPPEN_1 } } # [ doc = "Checks if the value of the field is `CPPEN_0`" ] # [ inline ( always ) ] pub fn is_cppen_0 ( & self ) -> bool { * self == CPPEN_A :: CPPEN_0 } # [ doc = "Checks if the value of the field is `CPPEN_1`" ] # [ inline ( always ) ] pub fn is_cppen_1 ( & self ) -> bool { * self == CPPEN_A :: CPPEN_1 } }
# [ doc = "Write proxy for field `CPPEN`" ] pub struct CPPEN_W < 'a > { w : & 'a mut W , } impl < 'a > CPPEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPPEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Selected analog input channel for V+ terminal is disabled." ] # [ inline ( always ) ] pub fn cppen_0 ( self ) -> & 'a mut W { self . variant ( CPPEN_A :: CPPEN_0 ) } # [ doc = "Selected analog input channel for V+ terminal is enabled." ] # [ inline ( always ) ] pub fn cppen_1 ( self ) -> & 'a mut W { self . variant ( CPPEN_A :: CPPEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Channel input selected for the - terminal\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPNSEL_A { # [ doc = "0: select external input source" ] CPNSEL_0 = 0 , # [ doc = "1: select external input source" ] CPNSEL_1 = 1 , # [ doc = "2: select external input source" ] CPNSEL_2 = 2 , # [ doc = "3: select external input source" ] CPNSEL_3 = 3 , # [ doc = "4: device specific, please refer to device data sheet for details" ] CPNSEL_4 = 4 , # [ doc = "5: device specific, please refer to device data sheet for details" ] CPNSEL_5 = 5 , # [ doc = "6: 6-bit DAC" ] CPNSEL_6 = 6 , # [ doc = "7: Reserved" ] CPNSEL_7 = 7 } impl From < CPNSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPNSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPNSEL`" ] pub type CPNSEL_R = crate :: R < u8 , CPNSEL_A > ; impl CPNSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPNSEL_A { match self . bits { 0 => CPNSEL_A :: CPNSEL_0 , 1 => CPNSEL_A :: CPNSEL_1 , 2 => CPNSEL_A :: CPNSEL_2 , 3 => CPNSEL_A :: CPNSEL_3 , 4 => CPNSEL_A :: CPNSEL_4 , 5 => CPNSEL_A :: CPNSEL_5 , 6 => CPNSEL_A :: CPNSEL_6 , 7 => CPNSEL_A :: CPNSEL_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPNSEL_0`" ] # [ inline ( always ) ] pub fn is_cpnsel_0 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_0 } # [ doc = "Checks if the value of the field is `CPNSEL_1`" ] # [ inline ( always ) ] pub fn is_cpnsel_1 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_1 } # [ doc = "Checks if the value of the field is `CPNSEL_2`" ] # [ inline ( always ) ] pub fn is_cpnsel_2 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_2 } # [ doc = "Checks if the value of the field is `CPNSEL_3`" ] # [ inline ( always ) ] pub fn is_cpnsel_3 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_3 } # [ doc = "Checks if the value of the field is `CPNSEL_4`" ] # [ inline ( always ) ] pub fn is_cpnsel_4 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_4 } # [ doc = "Checks if the value of the field is `CPNSEL_5`" ] # [ inline ( always ) ] pub fn is_cpnsel_5 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_5 } # [ doc = "Checks if the value of the field is `CPNSEL_6`" ] # [ inline ( always ) ] pub fn is_cpnsel_6 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_6 } # [ doc = "Checks if the value of the field is `CPNSEL_7`" ] # [ inline ( always ) ] pub fn is_cpnsel_7 ( & self ) -> bool { * self == CPNSEL_A :: CPNSEL_7 } }
# [ doc = "Write proxy for field `CPNSEL`" ] pub struct CPNSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CPNSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPNSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cpnsel_0 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_0 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cpnsel_1 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_1 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cpnsel_2 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_2 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cpnsel_3 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_3 ) } # [ doc = "device specific, please refer to device data sheet for details" ] # [ inline ( always ) ] pub fn cpnsel_4 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_4 ) } # [ doc = "device specific, please refer to device data sheet for details" ] # [ inline ( always ) ] pub fn cpnsel_5 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_5 ) } # [ doc = "6-bit DAC" ] # [ inline ( always ) ] pub fn cpnsel_6 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_6 ) } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn cpnsel_7 ( self ) -> & 'a mut W { self . variant ( CPNSEL_A :: CPNSEL_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 8 ) ) | ( ( ( value as u16 ) & 0x07 ) << 8 ) ; self . w } }
# [ doc = "Channel input enable for the - terminal\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPNEN_A { # [ doc = "0: Selected analog input channel for V- terminal is disabled." ] CPNEN_0 = 0 , # [ doc = "1: Selected analog input channel for V- terminal is enabled." ] CPNEN_1 = 1 } impl From < CPNEN_A > for bool { # [ inline ( always ) ] fn from ( variant : CPNEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPNEN`" ] pub type CPNEN_R = crate :: R < bool , CPNEN_A > ; impl CPNEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPNEN_A { match self . bits { false => CPNEN_A :: CPNEN_0 , true => CPNEN_A :: CPNEN_1 } } # [ doc = "Checks if the value of the field is `CPNEN_0`" ] # [ inline ( always ) ] pub fn is_cpnen_0 ( & self ) -> bool { * self == CPNEN_A :: CPNEN_0 } # [ doc = "Checks if the value of the field is `CPNEN_1`" ] # [ inline ( always ) ] pub fn is_cpnen_1 ( & self ) -> bool { * self == CPNEN_A :: CPNEN_1 } }
# [ doc = "Write proxy for field `CPNEN`" ] pub struct CPNEN_W < 'a > { w : & 'a mut W , } impl < 'a > CPNEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPNEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Selected analog input channel for V- terminal is disabled." ] # [ inline ( always ) ] pub fn cpnen_0 ( self ) -> & 'a mut W { self . variant ( CPNEN_A :: CPNEN_0 ) } # [ doc = "Selected analog input channel for V- terminal is enabled." ] # [ inline ( always ) ] pub fn cpnen_1 ( self ) -> & 'a mut W { self . variant ( CPNEN_A :: CPNEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Channel input selected for the V+ terminal\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPPSEL_A { # [ doc = "0: select external input source" ] CPPSEL_0 = 0 , # [ doc = "1: select external input source" ] CPPSEL_1 = 1 , # [ doc = "2: select external input source" ] CPPSEL_2 = 2 , # [ doc = "3: select external input source" ] CPPSEL_3 = 3 , # [ doc = "4: device specific, please refer to device data sheet for details" ] CPPSEL_4 = 4 , # [ doc = "5: device specific, please refer to device data sheet for details" ] CPPSEL_5 = 5 , # [ doc = "6: 6-bit DAC" ] CPPSEL_6 = 6 , # [ doc = "7: Reserved" ] CPPSEL_7 = 7 } impl From < CPPSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPPSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPPSEL`" ] pub type CPPSEL_R = crate :: R < u8 , CPPSEL_A > ; impl CPPSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPPSEL_A { match self . bits { 0 => CPPSEL_A :: CPPSEL_0 , 1 => CPPSEL_A :: CPPSEL_1 , 2 => CPPSEL_A :: CPPSEL_2 , 3 => CPPSEL_A :: CPPSEL_3 , 4 => CPPSEL_A :: CPPSEL_4 , 5 => CPPSEL_A :: CPPSEL_5 , 6 => CPPSEL_A :: CPPSEL_6 , 7 => CPPSEL_A :: CPPSEL_7 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPPSEL_0`" ] # [ inline ( always ) ] pub fn is_cppsel_0 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_0 } # [ doc = "Checks if the value of the field is `CPPSEL_1`" ] # [ inline ( always ) ] pub fn is_cppsel_1 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_1 } # [ doc = "Checks if the value of the field is `CPPSEL_2`" ] # [ inline ( always ) ] pub fn is_cppsel_2 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_2 } # [ doc = "Checks if the value of the field is `CPPSEL_3`" ] # [ inline ( always ) ] pub fn is_cppsel_3 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_3 } # [ doc = "Checks if the value of the field is `CPPSEL_4`" ] # [ inline ( always ) ] pub fn is_cppsel_4 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_4 } # [ doc = "Checks if the value of the field is `CPPSEL_5`" ] # [ inline ( always ) ] pub fn is_cppsel_5 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_5 } # [ doc = "Checks if the value of the field is `CPPSEL_6`" ] # [ inline ( always ) ] pub fn is_cppsel_6 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_6 } # [ doc = "Checks if the value of the field is `CPPSEL_7`" ] # [ inline ( always ) ] pub fn is_cppsel_7 ( & self ) -> bool { * self == CPPSEL_A :: CPPSEL_7 } }
# [ doc = "Write proxy for field `CPPSEL`" ] pub struct CPPSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CPPSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPPSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cppsel_0 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_0 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cppsel_1 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_1 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cppsel_2 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_2 ) } # [ doc = "select external input source" ] # [ inline ( always ) ] pub fn cppsel_3 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_3 ) } # [ doc = "device specific, please refer to device data sheet for details" ] # [ inline ( always ) ] pub fn cppsel_4 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_4 ) } # [ doc = "device specific, please refer to device data sheet for details" ] # [ inline ( always ) ] pub fn cppsel_5 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_5 ) } # [ doc = "6-bit DAC" ] # [ inline ( always ) ] pub fn cppsel_6 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_6 ) } # [ doc = "Reserved" ] # [ inline ( always ) ] pub fn cppsel_7 ( self ) -> & 'a mut W { self . variant ( CPPSEL_A :: CPPSEL_7 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u16 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bit 4 - Channel input enable for the V+ terminal" ] # [ inline ( always ) ] pub fn cppen ( & self ) -> CPPEN_R { CPPEN_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:10 - Channel input selected for the - terminal" ] # [ inline ( always ) ] pub fn cpnsel ( & self ) -> CPNSEL_R { CPNSEL_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 12 - Channel input enable for the - terminal" ] # [ inline ( always ) ] pub fn cpnen ( & self ) -> CPNEN_R { CPNEN_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 0:2 - Channel input selected for the V+ terminal" ] # [ inline ( always ) ] pub fn cppsel ( & self ) -> CPPSEL_R { CPPSEL_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bit 4 - Channel input enable for the V+ terminal" ] # [ inline ( always ) ] pub fn cppen ( & mut self ) -> CPPEN_W { CPPEN_W { w : self } }
# [ doc = "Bits 8:10 - Channel input selected for the - terminal" ] # [ inline ( always ) ] pub fn cpnsel ( & mut self ) -> CPNSEL_W { CPNSEL_W { w : self } }
# [ doc = "Bit 12 - Channel input enable for the - terminal" ] # [ inline ( always ) ] pub fn cpnen ( & mut self ) -> CPNEN_W { CPNEN_W { w : self } }
# [ doc = "Bits 0:2 - Channel input selected for the V+ terminal" ] # [ inline ( always ) ] pub fn cppsel ( & mut self ) -> CPPSEL_W { CPPSEL_W { w : self } }
}
}
# [ doc = "Comparator Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cp1ctl1](cp1ctl1) module" ] pub type CP1CTL1 = crate :: Reg < u16 , _CP1CTL1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CP1CTL1 ;
# [ doc = "`read()` method returns [cp1ctl1::R](cp1ctl1::R) reader structure" ] impl crate :: Readable for CP1CTL1 { }
# [ doc = "`write(|w| ..)` method takes [cp1ctl1::W](cp1ctl1::W) writer structure" ] impl crate :: Writable for CP1CTL1 { }
# [ doc = "Comparator Control Register 1" ] pub mod cp1ctl1 {
# [ doc = "Reader of register CP1CTL1" ] pub type R = crate :: R < u16 , super :: CP1CTL1 > ;
# [ doc = "Writer for register CP1CTL1" ] pub type W = crate :: W < u16 , super :: CP1CTL1 > ;
# [ doc = "Register CP1CTL1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CP1CTL1 { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CPOUT`" ] pub type CPOUT_R = crate :: R < bool , bool > ;
# [ doc = "Comparator output polarity\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPINV_A { # [ doc = "0: Comparator output is non-inverted" ] CPINV_0 = 0 , # [ doc = "1: Comparator output is inverted" ] CPINV_1 = 1 } impl From < CPINV_A > for bool { # [ inline ( always ) ] fn from ( variant : CPINV_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPINV`" ] pub type CPINV_R = crate :: R < bool , CPINV_A > ; impl CPINV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPINV_A { match self . bits { false => CPINV_A :: CPINV_0 , true => CPINV_A :: CPINV_1 } } # [ doc = "Checks if the value of the field is `CPINV_0`" ] # [ inline ( always ) ] pub fn is_cpinv_0 ( & self ) -> bool { * self == CPINV_A :: CPINV_0 } # [ doc = "Checks if the value of the field is `CPINV_1`" ] # [ inline ( always ) ] pub fn is_cpinv_1 ( & self ) -> bool { * self == CPINV_A :: CPINV_1 } }
# [ doc = "Write proxy for field `CPINV`" ] pub struct CPINV_W < 'a > { w : & 'a mut W , } impl < 'a > CPINV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPINV_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Comparator output is non-inverted" ] # [ inline ( always ) ] pub fn cpinv_0 ( self ) -> & 'a mut W { self . variant ( CPINV_A :: CPINV_0 ) } # [ doc = "Comparator output is inverted" ] # [ inline ( always ) ] pub fn cpinv_1 ( self ) -> & 'a mut W { self . variant ( CPINV_A :: CPINV_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Interrupt edge select for CEIIFG and CEIFG\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPIES_A { # [ doc = "0: Rising edge for CPIFG, falling edge for CPIIFG" ] CPIES_0 = 0 , # [ doc = "1: Falling edge for CPIFG, rising edge for CPIIFG" ] CPIES_1 = 1 } impl From < CPIES_A > for bool { # [ inline ( always ) ] fn from ( variant : CPIES_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPIES`" ] pub type CPIES_R = crate :: R < bool , CPIES_A > ; impl CPIES_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPIES_A { match self . bits { false => CPIES_A :: CPIES_0 , true => CPIES_A :: CPIES_1 } } # [ doc = "Checks if the value of the field is `CPIES_0`" ] # [ inline ( always ) ] pub fn is_cpies_0 ( & self ) -> bool { * self == CPIES_A :: CPIES_0 } # [ doc = "Checks if the value of the field is `CPIES_1`" ] # [ inline ( always ) ] pub fn is_cpies_1 ( & self ) -> bool { * self == CPIES_A :: CPIES_1 } }
# [ doc = "Write proxy for field `CPIES`" ] pub struct CPIES_W < 'a > { w : & 'a mut W , } impl < 'a > CPIES_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPIES_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Rising edge for CPIFG, falling edge for CPIIFG" ] # [ inline ( always ) ] pub fn cpies_0 ( self ) -> & 'a mut W { self . variant ( CPIES_A :: CPIES_0 ) } # [ doc = "Falling edge for CPIFG, rising edge for CPIIFG" ] # [ inline ( always ) ] pub fn cpies_1 ( self ) -> & 'a mut W { self . variant ( CPIES_A :: CPIES_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Analog Output Low Pass filter Selection. Changing CPFLT might set interrupt flag.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPFLT_A { # [ doc = "0: Comparator output is not filtered" ] CPFLT_0 = 0 , # [ doc = "1: Comparator output is filtered" ] CPFLT_1 = 1 } impl From < CPFLT_A > for bool { # [ inline ( always ) ] fn from ( variant : CPFLT_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPFLT`" ] pub type CPFLT_R = crate :: R < bool , CPFLT_A > ; impl CPFLT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPFLT_A { match self . bits { false => CPFLT_A :: CPFLT_0 , true => CPFLT_A :: CPFLT_1 } } # [ doc = "Checks if the value of the field is `CPFLT_0`" ] # [ inline ( always ) ] pub fn is_cpflt_0 ( & self ) -> bool { * self == CPFLT_A :: CPFLT_0 } # [ doc = "Checks if the value of the field is `CPFLT_1`" ] # [ inline ( always ) ] pub fn is_cpflt_1 ( & self ) -> bool { * self == CPFLT_A :: CPFLT_1 } }
# [ doc = "Write proxy for field `CPFLT`" ] pub struct CPFLT_W < 'a > { w : & 'a mut W , } impl < 'a > CPFLT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPFLT_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Comparator output is not filtered" ] # [ inline ( always ) ] pub fn cpflt_0 ( self ) -> & 'a mut W { self . variant ( CPFLT_A :: CPFLT_0 ) } # [ doc = "Comparator output is filtered" ] # [ inline ( always ) ] pub fn cpflt_1 ( self ) -> & 'a mut W { self . variant ( CPFLT_A :: CPFLT_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Analog Filter Delay selection. These bits are used to select the analog filter delay\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPFLTDLY_A { # [ doc = "0: Typical filter delay of 450ns" ] CPFLTDLY_0 = 0 , # [ doc = "1: Typical filter delay of 900ns" ] CPFLTDLY_1 = 1 , # [ doc = "2: Typical filter delay of 1800ns" ] CPFLTDLY_2 = 2 , # [ doc = "3: Typical filter delay of 3600ns" ] CPFLTDLY_3 = 3 } impl From < CPFLTDLY_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPFLTDLY_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPFLTDLY`" ] pub type CPFLTDLY_R = crate :: R < u8 , CPFLTDLY_A > ; impl CPFLTDLY_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPFLTDLY_A { match self . bits { 0 => CPFLTDLY_A :: CPFLTDLY_0 , 1 => CPFLTDLY_A :: CPFLTDLY_1 , 2 => CPFLTDLY_A :: CPFLTDLY_2 , 3 => CPFLTDLY_A :: CPFLTDLY_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPFLTDLY_0`" ] # [ inline ( always ) ] pub fn is_cpfltdly_0 ( & self ) -> bool { * self == CPFLTDLY_A :: CPFLTDLY_0 } # [ doc = "Checks if the value of the field is `CPFLTDLY_1`" ] # [ inline ( always ) ] pub fn is_cpfltdly_1 ( & self ) -> bool { * self == CPFLTDLY_A :: CPFLTDLY_1 } # [ doc = "Checks if the value of the field is `CPFLTDLY_2`" ] # [ inline ( always ) ] pub fn is_cpfltdly_2 ( & self ) -> bool { * self == CPFLTDLY_A :: CPFLTDLY_2 } # [ doc = "Checks if the value of the field is `CPFLTDLY_3`" ] # [ inline ( always ) ] pub fn is_cpfltdly_3 ( & self ) -> bool { * self == CPFLTDLY_A :: CPFLTDLY_3 } }
# [ doc = "Write proxy for field `CPFLTDLY`" ] pub struct CPFLTDLY_W < 'a > { w : & 'a mut W , } impl < 'a > CPFLTDLY_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPFLTDLY_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Typical filter delay of 450ns" ] # [ inline ( always ) ] pub fn cpfltdly_0 ( self ) -> & 'a mut W { self . variant ( CPFLTDLY_A :: CPFLTDLY_0 ) } # [ doc = "Typical filter delay of 900ns" ] # [ inline ( always ) ] pub fn cpfltdly_1 ( self ) -> & 'a mut W { self . variant ( CPFLTDLY_A :: CPFLTDLY_1 ) } # [ doc = "Typical filter delay of 1800ns" ] # [ inline ( always ) ] pub fn cpfltdly_2 ( self ) -> & 'a mut W { self . variant ( CPFLTDLY_A :: CPFLTDLY_2 ) } # [ doc = "Typical filter delay of 3600ns" ] # [ inline ( always ) ] pub fn cpfltdly_3 ( self ) -> & 'a mut W { self . variant ( CPFLTDLY_A :: CPFLTDLY_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Power mode selection.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPMSEL_A { # [ doc = "0: High-power & High speed mode (500nA)" ] CPMSEL_0 = 0 , # [ doc = "1: Low-power & Low speed mode (10nA)" ] CPMSEL_1 = 1 } impl From < CPMSEL_A > for bool { # [ inline ( always ) ] fn from ( variant : CPMSEL_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPMSEL`" ] pub type CPMSEL_R = crate :: R < bool , CPMSEL_A > ; impl CPMSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPMSEL_A { match self . bits { false => CPMSEL_A :: CPMSEL_0 , true => CPMSEL_A :: CPMSEL_1 } } # [ doc = "Checks if the value of the field is `CPMSEL_0`" ] # [ inline ( always ) ] pub fn is_cpmsel_0 ( & self ) -> bool { * self == CPMSEL_A :: CPMSEL_0 } # [ doc = "Checks if the value of the field is `CPMSEL_1`" ] # [ inline ( always ) ] pub fn is_cpmsel_1 ( & self ) -> bool { * self == CPMSEL_A :: CPMSEL_1 } }
# [ doc = "Write proxy for field `CPMSEL`" ] pub struct CPMSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CPMSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPMSEL_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "High-power & High speed mode (500nA)" ] # [ inline ( always ) ] pub fn cpmsel_0 ( self ) -> & 'a mut W { self . variant ( CPMSEL_A :: CPMSEL_0 ) } # [ doc = "Low-power & Low speed mode (10nA)" ] # [ inline ( always ) ] pub fn cpmsel_1 ( self ) -> & 'a mut W { self . variant ( CPMSEL_A :: CPMSEL_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Comparator enable/disable. This bit is used to disable/enable the comparator. When the comparator is disabled, the Comparator consumes no power.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPEN_A { # [ doc = "0: Comparator is disabled" ] CPEN_0 = 0 , # [ doc = "1: Comparator is enabled" ] CPEN_1 = 1 } impl From < CPEN_A > for bool { # [ inline ( always ) ] fn from ( variant : CPEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPEN`" ] pub type CPEN_R = crate :: R < bool , CPEN_A > ; impl CPEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPEN_A { match self . bits { false => CPEN_A :: CPEN_0 , true => CPEN_A :: CPEN_1 } } # [ doc = "Checks if the value of the field is `CPEN_0`" ] # [ inline ( always ) ] pub fn is_cpen_0 ( & self ) -> bool { * self == CPEN_A :: CPEN_0 } # [ doc = "Checks if the value of the field is `CPEN_1`" ] # [ inline ( always ) ] pub fn is_cpen_1 ( & self ) -> bool { * self == CPEN_A :: CPEN_1 } }
# [ doc = "Write proxy for field `CPEN`" ] pub struct CPEN_W < 'a > { w : & 'a mut W , } impl < 'a > CPEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Comparator is disabled" ] # [ inline ( always ) ] pub fn cpen_0 ( self ) -> & 'a mut W { self . variant ( CPEN_A :: CPEN_0 ) } # [ doc = "Comparator is enabled" ] # [ inline ( always ) ] pub fn cpen_1 ( self ) -> & 'a mut W { self . variant ( CPEN_A :: CPEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Programable Hysteresis mode. These bits are used to select the Hysteresis mode.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPHSEL_A { # [ doc = "0: disable" ] CPHSEL_0 = 0 , # [ doc = "1: 10mV" ] CPHSEL_1 = 1 , # [ doc = "2: 20mV" ] CPHSEL_2 = 2 , # [ doc = "3: 30mV" ] CPHSEL_3 = 3 } impl From < CPHSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPHSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPHSEL`" ] pub type CPHSEL_R = crate :: R < u8 , CPHSEL_A > ; impl CPHSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPHSEL_A { match self . bits { 0 => CPHSEL_A :: CPHSEL_0 , 1 => CPHSEL_A :: CPHSEL_1 , 2 => CPHSEL_A :: CPHSEL_2 , 3 => CPHSEL_A :: CPHSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPHSEL_0`" ] # [ inline ( always ) ] pub fn is_cphsel_0 ( & self ) -> bool { * self == CPHSEL_A :: CPHSEL_0 } # [ doc = "Checks if the value of the field is `CPHSEL_1`" ] # [ inline ( always ) ] pub fn is_cphsel_1 ( & self ) -> bool { * self == CPHSEL_A :: CPHSEL_1 } # [ doc = "Checks if the value of the field is `CPHSEL_2`" ] # [ inline ( always ) ] pub fn is_cphsel_2 ( & self ) -> bool { * self == CPHSEL_A :: CPHSEL_2 } # [ doc = "Checks if the value of the field is `CPHSEL_3`" ] # [ inline ( always ) ] pub fn is_cphsel_3 ( & self ) -> bool { * self == CPHSEL_A :: CPHSEL_3 } }
# [ doc = "Write proxy for field `CPHSEL`" ] pub struct CPHSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CPHSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPHSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "disable" ] # [ inline ( always ) ] pub fn cphsel_0 ( self ) -> & 'a mut W { self . variant ( CPHSEL_A :: CPHSEL_0 ) } # [ doc = "10mV" ] # [ inline ( always ) ] pub fn cphsel_1 ( self ) -> & 'a mut W { self . variant ( CPHSEL_A :: CPHSEL_1 ) } # [ doc = "20mV" ] # [ inline ( always ) ] pub fn cphsel_2 ( self ) -> & 'a mut W { self . variant ( CPHSEL_A :: CPHSEL_2 ) } # [ doc = "30mV" ] # [ inline ( always ) ] pub fn cphsel_3 ( self ) -> & 'a mut W { self . variant ( CPHSEL_A :: CPHSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u16 ) & 0x03 ) << 10 ) ; self . w } }
# [ doc = "Comparator interrupt output enable bit\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPIE_A { # [ doc = "0: Interrupt output is disabled" ] CPIE_0 = 0 , # [ doc = "1: Interrupt output is enabled" ] CPIE_1 = 1 } impl From < CPIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CPIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPIE`" ] pub type CPIE_R = crate :: R < bool , CPIE_A > ; impl CPIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPIE_A { match self . bits { false => CPIE_A :: CPIE_0 , true => CPIE_A :: CPIE_1 } } # [ doc = "Checks if the value of the field is `CPIE_0`" ] # [ inline ( always ) ] pub fn is_cpie_0 ( & self ) -> bool { * self == CPIE_A :: CPIE_0 } # [ doc = "Checks if the value of the field is `CPIE_1`" ] # [ inline ( always ) ] pub fn is_cpie_1 ( & self ) -> bool { * self == CPIE_A :: CPIE_1 } }
# [ doc = "Write proxy for field `CPIE`" ] pub struct CPIE_W < 'a > { w : & 'a mut W , } impl < 'a > CPIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt output is disabled" ] # [ inline ( always ) ] pub fn cpie_0 ( self ) -> & 'a mut W { self . variant ( CPIE_A :: CPIE_0 ) } # [ doc = "Interrupt output is enabled" ] # [ inline ( always ) ] pub fn cpie_1 ( self ) -> & 'a mut W { self . variant ( CPIE_A :: CPIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Comparator inverted interrupt output enable bit\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPIIE_A { # [ doc = "0: Interrupt inverted output is disabled" ] CPIIE_0 = 0 , # [ doc = "1: Interrupt inverted output is enabled" ] CPIIE_1 = 1 } impl From < CPIIE_A > for bool { # [ inline ( always ) ] fn from ( variant : CPIIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPIIE`" ] pub type CPIIE_R = crate :: R < bool , CPIIE_A > ; impl CPIIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPIIE_A { match self . bits { false => CPIIE_A :: CPIIE_0 , true => CPIIE_A :: CPIIE_1 } } # [ doc = "Checks if the value of the field is `CPIIE_0`" ] # [ inline ( always ) ] pub fn is_cpiie_0 ( & self ) -> bool { * self == CPIIE_A :: CPIIE_0 } # [ doc = "Checks if the value of the field is `CPIIE_1`" ] # [ inline ( always ) ] pub fn is_cpiie_1 ( & self ) -> bool { * self == CPIIE_A :: CPIIE_1 } }
# [ doc = "Write proxy for field `CPIIE`" ] pub struct CPIIE_W < 'a > { w : & 'a mut W , } impl < 'a > CPIIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPIIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Interrupt inverted output is disabled" ] # [ inline ( always ) ] pub fn cpiie_0 ( self ) -> & 'a mut W { self . variant ( CPIIE_A :: CPIIE_0 ) } # [ doc = "Interrupt inverted output is enabled" ] # [ inline ( always ) ] pub fn cpiie_1 ( self ) -> & 'a mut W { self . variant ( CPIIE_A :: CPIIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Comparator output value" ] # [ inline ( always ) ] pub fn cpout ( & self ) -> CPOUT_R { CPOUT_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Comparator output polarity" ] # [ inline ( always ) ] pub fn cpinv ( & self ) -> CPINV_R { CPINV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Interrupt edge select for CEIIFG and CEIFG" ] # [ inline ( always ) ] pub fn cpies ( & self ) -> CPIES_R { CPIES_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Analog Output Low Pass filter Selection. Changing CPFLT might set interrupt flag." ] # [ inline ( always ) ] pub fn cpflt ( & self ) -> CPFLT_R { CPFLT_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - Analog Filter Delay selection. These bits are used to select the analog filter delay" ] # [ inline ( always ) ] pub fn cpfltdly ( & self ) -> CPFLTDLY_R { CPFLTDLY_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Power mode selection." ] # [ inline ( always ) ] pub fn cpmsel ( & self ) -> CPMSEL_R { CPMSEL_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Comparator enable/disable. This bit is used to disable/enable the comparator. When the comparator is disabled, the Comparator consumes no power." ] # [ inline ( always ) ] pub fn cpen ( & self ) -> CPEN_R { CPEN_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 10:11 - Programable Hysteresis mode. These bits are used to select the Hysteresis mode." ] # [ inline ( always ) ] pub fn cphsel ( & self ) -> CPHSEL_R { CPHSEL_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 14 - Comparator interrupt output enable bit" ] # [ inline ( always ) ] pub fn cpie ( & self ) -> CPIE_R { CPIE_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Comparator inverted interrupt output enable bit" ] # [ inline ( always ) ] pub fn cpiie ( & self ) -> CPIIE_R { CPIIE_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 1 - Comparator output polarity" ] # [ inline ( always ) ] pub fn cpinv ( & mut self ) -> CPINV_W { CPINV_W { w : self } }
# [ doc = "Bit 4 - Interrupt edge select for CEIIFG and CEIFG" ] # [ inline ( always ) ] pub fn cpies ( & mut self ) -> CPIES_W { CPIES_W { w : self } }
# [ doc = "Bit 5 - Analog Output Low Pass filter Selection. Changing CPFLT might set interrupt flag." ] # [ inline ( always ) ] pub fn cpflt ( & mut self ) -> CPFLT_W { CPFLT_W { w : self } }
# [ doc = "Bits 6:7 - Analog Filter Delay selection. These bits are used to select the analog filter delay" ] # [ inline ( always ) ] pub fn cpfltdly ( & mut self ) -> CPFLTDLY_W { CPFLTDLY_W { w : self } }
# [ doc = "Bit 8 - Power mode selection." ] # [ inline ( always ) ] pub fn cpmsel ( & mut self ) -> CPMSEL_W { CPMSEL_W { w : self } }
# [ doc = "Bit 9 - Comparator enable/disable. This bit is used to disable/enable the comparator. When the comparator is disabled, the Comparator consumes no power." ] # [ inline ( always ) ] pub fn cpen ( & mut self ) -> CPEN_W { CPEN_W { w : self } }
# [ doc = "Bits 10:11 - Programable Hysteresis mode. These bits are used to select the Hysteresis mode." ] # [ inline ( always ) ] pub fn cphsel ( & mut self ) -> CPHSEL_W { CPHSEL_W { w : self } }
# [ doc = "Bit 14 - Comparator interrupt output enable bit" ] # [ inline ( always ) ] pub fn cpie ( & mut self ) -> CPIE_W { CPIE_W { w : self } }
# [ doc = "Bit 15 - Comparator inverted interrupt output enable bit" ] # [ inline ( always ) ] pub fn cpiie ( & mut self ) -> CPIIE_W { CPIIE_W { w : self } }
}
}
# [ doc = "Comparator Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cp1int](cp1int) module" ] pub type CP1INT = crate :: Reg < u16 , _CP1INT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CP1INT ;
# [ doc = "`read()` method returns [cp1int::R](cp1int::R) reader structure" ] impl crate :: Readable for CP1INT { }
# [ doc = "`write(|w| ..)` method takes [cp1int::W](cp1int::W) writer structure" ] impl crate :: Writable for CP1INT { }
# [ doc = "Comparator Interrupt Control Register" ] pub mod cp1int {
# [ doc = "Reader of register CP1INT" ] pub type R = crate :: R < u16 , super :: CP1INT > ;
# [ doc = "Writer for register CP1INT" ] pub type W = crate :: W < u16 , super :: CP1INT > ;
# [ doc = "Register CP1INT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CP1INT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Comparator output interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPIFG_A { # [ doc = "0: No interrupt pending." ] CPIFG_0 = 0 , # [ doc = "1: Output interrupt pending." ] CPIFG_1 = 1 } impl From < CPIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CPIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPIFG`" ] pub type CPIFG_R = crate :: R < bool , CPIFG_A > ; impl CPIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPIFG_A { match self . bits { false => CPIFG_A :: CPIFG_0 , true => CPIFG_A :: CPIFG_1 } } # [ doc = "Checks if the value of the field is `CPIFG_0`" ] # [ inline ( always ) ] pub fn is_cpifg_0 ( & self ) -> bool { * self == CPIFG_A :: CPIFG_0 } # [ doc = "Checks if the value of the field is `CPIFG_1`" ] # [ inline ( always ) ] pub fn is_cpifg_1 ( & self ) -> bool { * self == CPIFG_A :: CPIFG_1 } }
# [ doc = "Write proxy for field `CPIFG`" ] pub struct CPIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CPIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending." ] # [ inline ( always ) ] pub fn cpifg_0 ( self ) -> & 'a mut W { self . variant ( CPIFG_A :: CPIFG_0 ) } # [ doc = "Output interrupt pending." ] # [ inline ( always ) ] pub fn cpifg_1 ( self ) -> & 'a mut W { self . variant ( CPIFG_A :: CPIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Comparator output inverted interrupt flag\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPIIFG_A { # [ doc = "0: No interrupt pending." ] CPIIFG_0 = 0 , # [ doc = "1: Output interrupt pending." ] CPIIFG_1 = 1 } impl From < CPIIFG_A > for bool { # [ inline ( always ) ] fn from ( variant : CPIIFG_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPIIFG`" ] pub type CPIIFG_R = crate :: R < bool , CPIIFG_A > ; impl CPIIFG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPIIFG_A { match self . bits { false => CPIIFG_A :: CPIIFG_0 , true => CPIIFG_A :: CPIIFG_1 } } # [ doc = "Checks if the value of the field is `CPIIFG_0`" ] # [ inline ( always ) ] pub fn is_cpiifg_0 ( & self ) -> bool { * self == CPIIFG_A :: CPIIFG_0 } # [ doc = "Checks if the value of the field is `CPIIFG_1`" ] # [ inline ( always ) ] pub fn is_cpiifg_1 ( & self ) -> bool { * self == CPIIFG_A :: CPIIFG_1 } }
# [ doc = "Write proxy for field `CPIIFG`" ] pub struct CPIIFG_W < 'a > { w : & 'a mut W , } impl < 'a > CPIIFG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPIIFG_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "No interrupt pending." ] # [ inline ( always ) ] pub fn cpiifg_0 ( self ) -> & 'a mut W { self . variant ( CPIIFG_A :: CPIIFG_0 ) } # [ doc = "Output interrupt pending." ] # [ inline ( always ) ] pub fn cpiifg_1 ( self ) -> & 'a mut W { self . variant ( CPIIFG_A :: CPIIFG_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Comparator output interrupt flag" ] # [ inline ( always ) ] pub fn cpifg ( & self ) -> CPIFG_R { CPIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Comparator output inverted interrupt flag" ] # [ inline ( always ) ] pub fn cpiifg ( & self ) -> CPIIFG_R { CPIIFG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Comparator output interrupt flag" ] # [ inline ( always ) ] pub fn cpifg ( & mut self ) -> CPIFG_W { CPIFG_W { w : self } }
# [ doc = "Bit 1 - Comparator output inverted interrupt flag" ] # [ inline ( always ) ] pub fn cpiifg ( & mut self ) -> CPIIFG_W { CPIIFG_W { w : self } }
}
}
# [ doc = "Comparator Interrupt Vector Word Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cp1iv](cp1iv) module" ] pub type CP1IV = crate :: Reg < u16 , _CP1IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CP1IV ;
# [ doc = "`read()` method returns [cp1iv::R](cp1iv::R) reader structure" ] impl crate :: Readable for CP1IV { }
# [ doc = "Comparator Interrupt Vector Word Register" ] pub mod cp1iv {
# [ doc = "Reader of register CP1IV" ] pub type R = crate :: R < u16 , super :: CP1IV > ;
# [ doc = "Comparator interrupt vector word register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum CPIV_A { # [ doc = "0: No interrupt pending" ] NONE = 0 , # [ doc = "2: CPIFG" ] CPIFG = 2 , # [ doc = "4: CPIIFG" ] CPIIFG = 4 } impl From < CPIV_A > for u16 { # [ inline ( always ) ] fn from ( variant : CPIV_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPIV`" ] pub type CPIV_R = crate :: R < u16 , CPIV_A > ; impl CPIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , CPIV_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CPIV_A :: NONE ) , 2 => Val ( CPIV_A :: CPIFG ) , 4 => Val ( CPIV_A :: CPIIFG ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CPIV_A :: NONE } # [ doc = "Checks if the value of the field is `CPIFG`" ] # [ inline ( always ) ] pub fn is_cpifg ( & self ) -> bool { * self == CPIV_A :: CPIFG } # [ doc = "Checks if the value of the field is `CPIIFG`" ] # [ inline ( always ) ] pub fn is_cpiifg ( & self ) -> bool { * self == CPIV_A :: CPIIFG } }
impl R {
# [ doc = "Bits 0:15 - Comparator interrupt vector word register" ] # [ inline ( always ) ] pub fn cpiv ( & self ) -> CPIV_R { CPIV_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
# [ doc = "6-bit Comparator built-in DAC Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cp1dacctl](cp1dacctl) module" ] pub type CP1DACCTL = crate :: Reg < u16 , _CP1DACCTL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CP1DACCTL ;
# [ doc = "`read()` method returns [cp1dacctl::R](cp1dacctl::R) reader structure" ] impl crate :: Readable for CP1DACCTL { }
# [ doc = "`write(|w| ..)` method takes [cp1dacctl::W](cp1dacctl::W) writer structure" ] impl crate :: Writable for CP1DACCTL { }
# [ doc = "6-bit Comparator built-in DAC Control Register" ] pub mod cp1dacctl {
# [ doc = "Reader of register CP1DACCTL" ] pub type R = crate :: R < u16 , super :: CP1DACCTL > ;
# [ doc = "Writer for register CP1DACCTL" ] pub type W = crate :: W < u16 , super :: CP1DACCTL > ;
# [ doc = "Register CP1DACCTL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CP1DACCTL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "This bit is only valid when CPDACBUFS is set to 1.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPDACSW_A { # [ doc = "0: CPDACBUF1 selected" ] CPDACSW_0 = 0 , # [ doc = "1: CPDACBUF2 selected" ] CPDACSW_1 = 1 } impl From < CPDACSW_A > for bool { # [ inline ( always ) ] fn from ( variant : CPDACSW_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPDACSW`" ] pub type CPDACSW_R = crate :: R < bool , CPDACSW_A > ; impl CPDACSW_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACSW_A { match self . bits { false => CPDACSW_A :: CPDACSW_0 , true => CPDACSW_A :: CPDACSW_1 } } # [ doc = "Checks if the value of the field is `CPDACSW_0`" ] # [ inline ( always ) ] pub fn is_cpdacsw_0 ( & self ) -> bool { * self == CPDACSW_A :: CPDACSW_0 } # [ doc = "Checks if the value of the field is `CPDACSW_1`" ] # [ inline ( always ) ] pub fn is_cpdacsw_1 ( & self ) -> bool { * self == CPDACSW_A :: CPDACSW_1 } }
# [ doc = "Write proxy for field `CPDACSW`" ] pub struct CPDACSW_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACSW_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACSW_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "CPDACBUF1 selected" ] # [ inline ( always ) ] pub fn cpdacsw_0 ( self ) -> & 'a mut W { self . variant ( CPDACSW_A :: CPDACSW_0 ) } # [ doc = "CPDACBUF2 selected" ] # [ inline ( always ) ] pub fn cpdacsw_1 ( self ) -> & 'a mut W { self . variant ( CPDACSW_A :: CPDACSW_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Comparator built-in DAC buffer controlled source selection.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPDACBUFS_A { # [ doc = "0: Comparator output is selected as the buffer control source" ] CPDACBUFS_0 = 0 , # [ doc = "1: CPDACSW bit is selected as the buffer control source" ] CPDACBUFS_1 = 1 } impl From < CPDACBUFS_A > for bool { # [ inline ( always ) ] fn from ( variant : CPDACBUFS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPDACBUFS`" ] pub type CPDACBUFS_R = crate :: R < bool , CPDACBUFS_A > ; impl CPDACBUFS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACBUFS_A { match self . bits { false => CPDACBUFS_A :: CPDACBUFS_0 , true => CPDACBUFS_A :: CPDACBUFS_1 } } # [ doc = "Checks if the value of the field is `CPDACBUFS_0`" ] # [ inline ( always ) ] pub fn is_cpdacbufs_0 ( & self ) -> bool { * self == CPDACBUFS_A :: CPDACBUFS_0 } # [ doc = "Checks if the value of the field is `CPDACBUFS_1`" ] # [ inline ( always ) ] pub fn is_cpdacbufs_1 ( & self ) -> bool { * self == CPDACBUFS_A :: CPDACBUFS_1 } }
# [ doc = "Write proxy for field `CPDACBUFS`" ] pub struct CPDACBUFS_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACBUFS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACBUFS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Comparator output is selected as the buffer control source" ] # [ inline ( always ) ] pub fn cpdacbufs_0 ( self ) -> & 'a mut W { self . variant ( CPDACBUFS_A :: CPDACBUFS_0 ) } # [ doc = "CPDACSW bit is selected as the buffer control source" ] # [ inline ( always ) ] pub fn cpdacbufs_1 ( self ) -> & 'a mut W { self . variant ( CPDACBUFS_A :: CPDACBUFS_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Comparator built-in DAC reference voltage selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPDACREFS_A { # [ doc = "0: VDD selected" ] CPDACREFS_0 = 0 , # [ doc = "1: on-chip VREF selected" ] CPDACREFS_1 = 1 } impl From < CPDACREFS_A > for bool { # [ inline ( always ) ] fn from ( variant : CPDACREFS_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPDACREFS`" ] pub type CPDACREFS_R = crate :: R < bool , CPDACREFS_A > ; impl CPDACREFS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACREFS_A { match self . bits { false => CPDACREFS_A :: CPDACREFS_0 , true => CPDACREFS_A :: CPDACREFS_1 } } # [ doc = "Checks if the value of the field is `CPDACREFS_0`" ] # [ inline ( always ) ] pub fn is_cpdacrefs_0 ( & self ) -> bool { * self == CPDACREFS_A :: CPDACREFS_0 } # [ doc = "Checks if the value of the field is `CPDACREFS_1`" ] # [ inline ( always ) ] pub fn is_cpdacrefs_1 ( & self ) -> bool { * self == CPDACREFS_A :: CPDACREFS_1 } }
# [ doc = "Write proxy for field `CPDACREFS`" ] pub struct CPDACREFS_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACREFS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACREFS_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "VDD selected" ] # [ inline ( always ) ] pub fn cpdacrefs_0 ( self ) -> & 'a mut W { self . variant ( CPDACREFS_A :: CPDACREFS_0 ) } # [ doc = "on-chip VREF selected" ] # [ inline ( always ) ] pub fn cpdacrefs_1 ( self ) -> & 'a mut W { self . variant ( CPDACREFS_A :: CPDACREFS_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Comparator built-in DAC output control bit.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPDACEN_A { # [ doc = "0: DAC output is disabled." ] CPDACEN_0 = 0 , # [ doc = "1: DAC output is enabled." ] CPDACEN_1 = 1 } impl From < CPDACEN_A > for bool { # [ inline ( always ) ] fn from ( variant : CPDACEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `CPDACEN`" ] pub type CPDACEN_R = crate :: R < bool , CPDACEN_A > ; impl CPDACEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACEN_A { match self . bits { false => CPDACEN_A :: CPDACEN_0 , true => CPDACEN_A :: CPDACEN_1 } } # [ doc = "Checks if the value of the field is `CPDACEN_0`" ] # [ inline ( always ) ] pub fn is_cpdacen_0 ( & self ) -> bool { * self == CPDACEN_A :: CPDACEN_0 } # [ doc = "Checks if the value of the field is `CPDACEN_1`" ] # [ inline ( always ) ] pub fn is_cpdacen_1 ( & self ) -> bool { * self == CPDACEN_A :: CPDACEN_1 } }
# [ doc = "Write proxy for field `CPDACEN`" ] pub struct CPDACEN_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "DAC output is disabled." ] # [ inline ( always ) ] pub fn cpdacen_0 ( self ) -> & 'a mut W { self . variant ( CPDACEN_A :: CPDACEN_0 ) } # [ doc = "DAC output is enabled." ] # [ inline ( always ) ] pub fn cpdacen_1 ( self ) -> & 'a mut W { self . variant ( CPDACEN_A :: CPDACEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - This bit is only valid when CPDACBUFS is set to 1." ] # [ inline ( always ) ] pub fn cpdacsw ( & self ) -> CPDACSW_R { CPDACSW_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Comparator built-in DAC buffer controlled source selection." ] # [ inline ( always ) ] pub fn cpdacbufs ( & self ) -> CPDACBUFS_R { CPDACBUFS_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Comparator built-in DAC reference voltage selection" ] # [ inline ( always ) ] pub fn cpdacrefs ( & self ) -> CPDACREFS_R { CPDACREFS_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Comparator built-in DAC output control bit." ] # [ inline ( always ) ] pub fn cpdacen ( & self ) -> CPDACEN_R { CPDACEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - This bit is only valid when CPDACBUFS is set to 1." ] # [ inline ( always ) ] pub fn cpdacsw ( & mut self ) -> CPDACSW_W { CPDACSW_W { w : self } }
# [ doc = "Bit 1 - Comparator built-in DAC buffer controlled source selection." ] # [ inline ( always ) ] pub fn cpdacbufs ( & mut self ) -> CPDACBUFS_W { CPDACBUFS_W { w : self } }
# [ doc = "Bit 2 - Comparator built-in DAC reference voltage selection" ] # [ inline ( always ) ] pub fn cpdacrefs ( & mut self ) -> CPDACREFS_W { CPDACREFS_W { w : self } }
# [ doc = "Bit 7 - Comparator built-in DAC output control bit." ] # [ inline ( always ) ] pub fn cpdacen ( & mut self ) -> CPDACEN_W { CPDACEN_W { w : self } }
}
}
# [ doc = "6-bit Comparator built-in DAC Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cp1dacdata](cp1dacdata) module" ] pub type CP1DACDATA = crate :: Reg < u16 , _CP1DACDATA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CP1DACDATA ;
# [ doc = "`read()` method returns [cp1dacdata::R](cp1dacdata::R) reader structure" ] impl crate :: Readable for CP1DACDATA { }
# [ doc = "`write(|w| ..)` method takes [cp1dacdata::W](cp1dacdata::W) writer structure" ] impl crate :: Writable for CP1DACDATA { }
# [ doc = "6-bit Comparator built-in DAC Data Register" ] pub mod cp1dacdata {
# [ doc = "Reader of register CP1DACDATA" ] pub type R = crate :: R < u16 , super :: CP1DACDATA > ;
# [ doc = "Writer for register CP1DACDATA" ] pub type W = crate :: W < u16 , super :: CP1DACDATA > ;
# [ doc = "Register CP1DACDATA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CP1DACDATA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "1st 6-bit DAC buffer Data\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPDACBUF1_A { # [ doc = "0: 0v" ] CPDACBUF1_0 = 0 , # [ doc = "1: selected reference voltage * 1/64" ] CPDACBUF1_1 = 1 , # [ doc = "2: selected reference voltage * 2/64" ] CPDACBUF1_2 = 2 , # [ doc = "3: selected reference voltage * 3/64" ] CPDACBUF1_3 = 3 , # [ doc = "4: selected reference voltage * 4/64" ] CPDACBUF1_4 = 4 , # [ doc = "5: selected reference voltage * 5/64" ] CPDACBUF1_5 = 5 , # [ doc = "6: selected reference voltage * 6/64" ] CPDACBUF1_6 = 6 , # [ doc = "7: selected reference voltage * 7/64" ] CPDACBUF1_7 = 7 , # [ doc = "8: selected reference voltage * 8/64" ] CPDACBUF1_8 = 8 , # [ doc = "9: selected reference voltage *9/64" ] CPDACBUF1_9 = 9 , # [ doc = "10: selected reference voltage * 10/64" ] CPDACBUF1_10 = 10 , # [ doc = "11: selected reference voltage * 11/64" ] CPDACBUF1_11 = 11 , # [ doc = "12: selected reference voltage * 12/64" ] CPDACBUF1_12 = 12 , # [ doc = "13: selected reference voltage * 13/64" ] CPDACBUF1_13 = 13 , # [ doc = "14: selected reference voltage * 14/64" ] CPDACBUF1_14 = 14 , # [ doc = "15: selected reference voltage * 15/64" ] CPDACBUF1_15 = 15 , # [ doc = "16: selected reference voltage * 16/64" ] CPDACBUF1_16 = 16 , # [ doc = "17: selected reference voltage * 17/64" ] CPDACBUF1_17 = 17 , # [ doc = "18: selected reference voltage * 18/64" ] CPDACBUF1_18 = 18 , # [ doc = "19: selected reference voltage * 19/64" ] CPDACBUF1_19 = 19 , # [ doc = "20: selected reference voltage * 20/64" ] CPDACBUF1_20 = 20 , # [ doc = "21: selected reference voltage * 21/64" ] CPDACBUF1_21 = 21 , # [ doc = "22: selected reference voltage * 22/64" ] CPDACBUF1_22 = 22 , # [ doc = "23: selected reference voltage * 23/64" ] CPDACBUF1_23 = 23 , # [ doc = "24: selected reference voltage * 24/64" ] CPDACBUF1_24 = 24 , # [ doc = "25: selected reference voltage * 25/64" ] CPDACBUF1_25 = 25 , # [ doc = "26: selected reference voltage * 26/64" ] CPDACBUF1_26 = 26 , # [ doc = "27: selected reference voltage * 27/64" ] CPDACBUF1_27 = 27 , # [ doc = "28: selected reference voltage * 28/64" ] CPDACBUF1_28 = 28 , # [ doc = "29: selected reference voltage * 29/64" ] CPDACBUF1_29 = 29 , # [ doc = "30: selected reference voltage * 30/64" ] CPDACBUF1_30 = 30 , # [ doc = "31: selected reference voltage * 31/64" ] CPDACBUF1_31 = 31 , # [ doc = "32: selected reference voltage * 32/64" ] CPDACBUF1_32 = 32 , # [ doc = "33: selected reference voltage * 33/64" ] CPDACBUF1_33 = 33 , # [ doc = "34: selected reference voltage * 34/64" ] CPDACBUF1_34 = 34 , # [ doc = "35: selected reference voltage * 35/64" ] CPDACBUF1_35 = 35 , # [ doc = "36: selected reference voltage * 36/64" ] CPDACBUF1_36 = 36 , # [ doc = "37: selected reference voltage * 37/64" ] CPDACBUF1_37 = 37 , # [ doc = "38: selected reference voltage * 38/64" ] CPDACBUF1_38 = 38 , # [ doc = "39: selected reference voltage * 39/64" ] CPDACBUF1_39 = 39 , # [ doc = "40: selected reference voltage * 40/64" ] CPDACBUF1_40 = 40 , # [ doc = "41: selected reference voltage * 41/64" ] CPDACBUF1_41 = 41 , # [ doc = "42: selected reference voltage * 42/64" ] CPDACBUF1_42 = 42 , # [ doc = "43: selected reference voltage * 43/64" ] CPDACBUF1_43 = 43 , # [ doc = "44: selected reference voltage * 44/64" ] CPDACBUF1_44 = 44 , # [ doc = "45: selected reference voltage * 45/64" ] CPDACBUF1_45 = 45 , # [ doc = "46: selected reference voltage * 46/64" ] CPDACBUF1_46 = 46 , # [ doc = "47: selected reference voltage * 47/64" ] CPDACBUF1_47 = 47 , # [ doc = "48: selected reference voltage * 48/64" ] CPDACBUF1_48 = 48 , # [ doc = "49: selected reference voltage * 49/64" ] CPDACBUF1_49 = 49 , # [ doc = "50: selected reference voltage * 50/64" ] CPDACBUF1_50 = 50 , # [ doc = "51: selected reference voltage * 51/64" ] CPDACBUF1_51 = 51 , # [ doc = "52: selected reference voltage * 52/64" ] CPDACBUF1_52 = 52 , # [ doc = "53: selected reference voltage * 53/64" ] CPDACBUF1_53 = 53 , # [ doc = "54: selected reference voltage * 54/64" ] CPDACBUF1_54 = 54 , # [ doc = "55: selected reference voltage * 55/64" ] CPDACBUF1_55 = 55 , # [ doc = "56: selected reference voltage * 56/64" ] CPDACBUF1_56 = 56 , # [ doc = "57: selected reference voltage * 57/64" ] CPDACBUF1_57 = 57 , # [ doc = "58: selected reference voltage * 58/64" ] CPDACBUF1_58 = 58 , # [ doc = "59: selected reference voltage * 59/64" ] CPDACBUF1_59 = 59 , # [ doc = "60: selected reference voltage * 60/64" ] CPDACBUF1_60 = 60 , # [ doc = "61: selected reference voltage * 61/64" ] CPDACBUF1_61 = 61 , # [ doc = "62: selected reference voltage * 62/64" ] CPDACBUF1_62 = 62 , # [ doc = "63: selected reference voltage * 63/64" ] CPDACBUF1_63 = 63 } impl From < CPDACBUF1_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPDACBUF1_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPDACBUF1`" ] pub type CPDACBUF1_R = crate :: R < u8 , CPDACBUF1_A > ; impl CPDACBUF1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACBUF1_A { match self . bits { 0 => CPDACBUF1_A :: CPDACBUF1_0 , 1 => CPDACBUF1_A :: CPDACBUF1_1 , 2 => CPDACBUF1_A :: CPDACBUF1_2 , 3 => CPDACBUF1_A :: CPDACBUF1_3 , 4 => CPDACBUF1_A :: CPDACBUF1_4 , 5 => CPDACBUF1_A :: CPDACBUF1_5 , 6 => CPDACBUF1_A :: CPDACBUF1_6 , 7 => CPDACBUF1_A :: CPDACBUF1_7 , 8 => CPDACBUF1_A :: CPDACBUF1_8 , 9 => CPDACBUF1_A :: CPDACBUF1_9 , 10 => CPDACBUF1_A :: CPDACBUF1_10 , 11 => CPDACBUF1_A :: CPDACBUF1_11 , 12 => CPDACBUF1_A :: CPDACBUF1_12 , 13 => CPDACBUF1_A :: CPDACBUF1_13 , 14 => CPDACBUF1_A :: CPDACBUF1_14 , 15 => CPDACBUF1_A :: CPDACBUF1_15 , 16 => CPDACBUF1_A :: CPDACBUF1_16 , 17 => CPDACBUF1_A :: CPDACBUF1_17 , 18 => CPDACBUF1_A :: CPDACBUF1_18 , 19 => CPDACBUF1_A :: CPDACBUF1_19 , 20 => CPDACBUF1_A :: CPDACBUF1_20 , 21 => CPDACBUF1_A :: CPDACBUF1_21 , 22 => CPDACBUF1_A :: CPDACBUF1_22 , 23 => CPDACBUF1_A :: CPDACBUF1_23 , 24 => CPDACBUF1_A :: CPDACBUF1_24 , 25 => CPDACBUF1_A :: CPDACBUF1_25 , 26 => CPDACBUF1_A :: CPDACBUF1_26 , 27 => CPDACBUF1_A :: CPDACBUF1_27 , 28 => CPDACBUF1_A :: CPDACBUF1_28 , 29 => CPDACBUF1_A :: CPDACBUF1_29 , 30 => CPDACBUF1_A :: CPDACBUF1_30 , 31 => CPDACBUF1_A :: CPDACBUF1_31 , 32 => CPDACBUF1_A :: CPDACBUF1_32 , 33 => CPDACBUF1_A :: CPDACBUF1_33 , 34 => CPDACBUF1_A :: CPDACBUF1_34 , 35 => CPDACBUF1_A :: CPDACBUF1_35 , 36 => CPDACBUF1_A :: CPDACBUF1_36 , 37 => CPDACBUF1_A :: CPDACBUF1_37 , 38 => CPDACBUF1_A :: CPDACBUF1_38 , 39 => CPDACBUF1_A :: CPDACBUF1_39 , 40 => CPDACBUF1_A :: CPDACBUF1_40 , 41 => CPDACBUF1_A :: CPDACBUF1_41 , 42 => CPDACBUF1_A :: CPDACBUF1_42 , 43 => CPDACBUF1_A :: CPDACBUF1_43 , 44 => CPDACBUF1_A :: CPDACBUF1_44 , 45 => CPDACBUF1_A :: CPDACBUF1_45 , 46 => CPDACBUF1_A :: CPDACBUF1_46 , 47 => CPDACBUF1_A :: CPDACBUF1_47 , 48 => CPDACBUF1_A :: CPDACBUF1_48 , 49 => CPDACBUF1_A :: CPDACBUF1_49 , 50 => CPDACBUF1_A :: CPDACBUF1_50 , 51 => CPDACBUF1_A :: CPDACBUF1_51 , 52 => CPDACBUF1_A :: CPDACBUF1_52 , 53 => CPDACBUF1_A :: CPDACBUF1_53 , 54 => CPDACBUF1_A :: CPDACBUF1_54 , 55 => CPDACBUF1_A :: CPDACBUF1_55 , 56 => CPDACBUF1_A :: CPDACBUF1_56 , 57 => CPDACBUF1_A :: CPDACBUF1_57 , 58 => CPDACBUF1_A :: CPDACBUF1_58 , 59 => CPDACBUF1_A :: CPDACBUF1_59 , 60 => CPDACBUF1_A :: CPDACBUF1_60 , 61 => CPDACBUF1_A :: CPDACBUF1_61 , 62 => CPDACBUF1_A :: CPDACBUF1_62 , 63 => CPDACBUF1_A :: CPDACBUF1_63 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPDACBUF1_0`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_0 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_0 } # [ doc = "Checks if the value of the field is `CPDACBUF1_1`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_1 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_1 } # [ doc = "Checks if the value of the field is `CPDACBUF1_2`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_2 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_2 } # [ doc = "Checks if the value of the field is `CPDACBUF1_3`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_3 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_3 } # [ doc = "Checks if the value of the field is `CPDACBUF1_4`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_4 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_4 } # [ doc = "Checks if the value of the field is `CPDACBUF1_5`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_5 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_5 } # [ doc = "Checks if the value of the field is `CPDACBUF1_6`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_6 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_6 } # [ doc = "Checks if the value of the field is `CPDACBUF1_7`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_7 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_7 } # [ doc = "Checks if the value of the field is `CPDACBUF1_8`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_8 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_8 } # [ doc = "Checks if the value of the field is `CPDACBUF1_9`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_9 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_9 } # [ doc = "Checks if the value of the field is `CPDACBUF1_10`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_10 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_10 } # [ doc = "Checks if the value of the field is `CPDACBUF1_11`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_11 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_11 } # [ doc = "Checks if the value of the field is `CPDACBUF1_12`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_12 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_12 } # [ doc = "Checks if the value of the field is `CPDACBUF1_13`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_13 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_13 } # [ doc = "Checks if the value of the field is `CPDACBUF1_14`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_14 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_14 } # [ doc = "Checks if the value of the field is `CPDACBUF1_15`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_15 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_15 } # [ doc = "Checks if the value of the field is `CPDACBUF1_16`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_16 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_16 } # [ doc = "Checks if the value of the field is `CPDACBUF1_17`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_17 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_17 } # [ doc = "Checks if the value of the field is `CPDACBUF1_18`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_18 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_18 } # [ doc = "Checks if the value of the field is `CPDACBUF1_19`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_19 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_19 } # [ doc = "Checks if the value of the field is `CPDACBUF1_20`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_20 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_20 } # [ doc = "Checks if the value of the field is `CPDACBUF1_21`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_21 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_21 } # [ doc = "Checks if the value of the field is `CPDACBUF1_22`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_22 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_22 } # [ doc = "Checks if the value of the field is `CPDACBUF1_23`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_23 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_23 } # [ doc = "Checks if the value of the field is `CPDACBUF1_24`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_24 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_24 } # [ doc = "Checks if the value of the field is `CPDACBUF1_25`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_25 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_25 } # [ doc = "Checks if the value of the field is `CPDACBUF1_26`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_26 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_26 } # [ doc = "Checks if the value of the field is `CPDACBUF1_27`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_27 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_27 } # [ doc = "Checks if the value of the field is `CPDACBUF1_28`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_28 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_28 } # [ doc = "Checks if the value of the field is `CPDACBUF1_29`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_29 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_29 } # [ doc = "Checks if the value of the field is `CPDACBUF1_30`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_30 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_30 } # [ doc = "Checks if the value of the field is `CPDACBUF1_31`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_31 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_31 } # [ doc = "Checks if the value of the field is `CPDACBUF1_32`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_32 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_32 } # [ doc = "Checks if the value of the field is `CPDACBUF1_33`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_33 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_33 } # [ doc = "Checks if the value of the field is `CPDACBUF1_34`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_34 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_34 } # [ doc = "Checks if the value of the field is `CPDACBUF1_35`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_35 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_35 } # [ doc = "Checks if the value of the field is `CPDACBUF1_36`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_36 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_36 } # [ doc = "Checks if the value of the field is `CPDACBUF1_37`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_37 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_37 } # [ doc = "Checks if the value of the field is `CPDACBUF1_38`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_38 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_38 } # [ doc = "Checks if the value of the field is `CPDACBUF1_39`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_39 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_39 } # [ doc = "Checks if the value of the field is `CPDACBUF1_40`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_40 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_40 } # [ doc = "Checks if the value of the field is `CPDACBUF1_41`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_41 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_41 } # [ doc = "Checks if the value of the field is `CPDACBUF1_42`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_42 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_42 } # [ doc = "Checks if the value of the field is `CPDACBUF1_43`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_43 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_43 } # [ doc = "Checks if the value of the field is `CPDACBUF1_44`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_44 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_44 } # [ doc = "Checks if the value of the field is `CPDACBUF1_45`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_45 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_45 } # [ doc = "Checks if the value of the field is `CPDACBUF1_46`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_46 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_46 } # [ doc = "Checks if the value of the field is `CPDACBUF1_47`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_47 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_47 } # [ doc = "Checks if the value of the field is `CPDACBUF1_48`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_48 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_48 } # [ doc = "Checks if the value of the field is `CPDACBUF1_49`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_49 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_49 } # [ doc = "Checks if the value of the field is `CPDACBUF1_50`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_50 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_50 } # [ doc = "Checks if the value of the field is `CPDACBUF1_51`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_51 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_51 } # [ doc = "Checks if the value of the field is `CPDACBUF1_52`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_52 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_52 } # [ doc = "Checks if the value of the field is `CPDACBUF1_53`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_53 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_53 } # [ doc = "Checks if the value of the field is `CPDACBUF1_54`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_54 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_54 } # [ doc = "Checks if the value of the field is `CPDACBUF1_55`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_55 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_55 } # [ doc = "Checks if the value of the field is `CPDACBUF1_56`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_56 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_56 } # [ doc = "Checks if the value of the field is `CPDACBUF1_57`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_57 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_57 } # [ doc = "Checks if the value of the field is `CPDACBUF1_58`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_58 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_58 } # [ doc = "Checks if the value of the field is `CPDACBUF1_59`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_59 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_59 } # [ doc = "Checks if the value of the field is `CPDACBUF1_60`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_60 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_60 } # [ doc = "Checks if the value of the field is `CPDACBUF1_61`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_61 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_61 } # [ doc = "Checks if the value of the field is `CPDACBUF1_62`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_62 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_62 } # [ doc = "Checks if the value of the field is `CPDACBUF1_63`" ] # [ inline ( always ) ] pub fn is_cpdacbuf1_63 ( & self ) -> bool { * self == CPDACBUF1_A :: CPDACBUF1_63 } }
# [ doc = "Write proxy for field `CPDACBUF1`" ] pub struct CPDACBUF1_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACBUF1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACBUF1_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "0v" ] # [ inline ( always ) ] pub fn cpdacbuf1_0 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_0 ) } # [ doc = "selected reference voltage * 1/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_1 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_1 ) } # [ doc = "selected reference voltage * 2/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_2 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_2 ) } # [ doc = "selected reference voltage * 3/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_3 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_3 ) } # [ doc = "selected reference voltage * 4/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_4 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_4 ) } # [ doc = "selected reference voltage * 5/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_5 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_5 ) } # [ doc = "selected reference voltage * 6/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_6 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_6 ) } # [ doc = "selected reference voltage * 7/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_7 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_7 ) } # [ doc = "selected reference voltage * 8/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_8 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_8 ) } # [ doc = "selected reference voltage *9/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_9 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_9 ) } # [ doc = "selected reference voltage * 10/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_10 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_10 ) } # [ doc = "selected reference voltage * 11/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_11 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_11 ) } # [ doc = "selected reference voltage * 12/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_12 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_12 ) } # [ doc = "selected reference voltage * 13/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_13 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_13 ) } # [ doc = "selected reference voltage * 14/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_14 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_14 ) } # [ doc = "selected reference voltage * 15/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_15 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_15 ) } # [ doc = "selected reference voltage * 16/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_16 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_16 ) } # [ doc = "selected reference voltage * 17/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_17 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_17 ) } # [ doc = "selected reference voltage * 18/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_18 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_18 ) } # [ doc = "selected reference voltage * 19/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_19 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_19 ) } # [ doc = "selected reference voltage * 20/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_20 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_20 ) } # [ doc = "selected reference voltage * 21/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_21 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_21 ) } # [ doc = "selected reference voltage * 22/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_22 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_22 ) } # [ doc = "selected reference voltage * 23/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_23 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_23 ) } # [ doc = "selected reference voltage * 24/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_24 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_24 ) } # [ doc = "selected reference voltage * 25/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_25 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_25 ) } # [ doc = "selected reference voltage * 26/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_26 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_26 ) } # [ doc = "selected reference voltage * 27/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_27 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_27 ) } # [ doc = "selected reference voltage * 28/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_28 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_28 ) } # [ doc = "selected reference voltage * 29/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_29 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_29 ) } # [ doc = "selected reference voltage * 30/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_30 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_30 ) } # [ doc = "selected reference voltage * 31/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_31 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_31 ) } # [ doc = "selected reference voltage * 32/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_32 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_32 ) } # [ doc = "selected reference voltage * 33/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_33 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_33 ) } # [ doc = "selected reference voltage * 34/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_34 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_34 ) } # [ doc = "selected reference voltage * 35/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_35 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_35 ) } # [ doc = "selected reference voltage * 36/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_36 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_36 ) } # [ doc = "selected reference voltage * 37/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_37 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_37 ) } # [ doc = "selected reference voltage * 38/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_38 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_38 ) } # [ doc = "selected reference voltage * 39/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_39 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_39 ) } # [ doc = "selected reference voltage * 40/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_40 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_40 ) } # [ doc = "selected reference voltage * 41/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_41 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_41 ) } # [ doc = "selected reference voltage * 42/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_42 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_42 ) } # [ doc = "selected reference voltage * 43/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_43 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_43 ) } # [ doc = "selected reference voltage * 44/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_44 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_44 ) } # [ doc = "selected reference voltage * 45/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_45 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_45 ) } # [ doc = "selected reference voltage * 46/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_46 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_46 ) } # [ doc = "selected reference voltage * 47/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_47 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_47 ) } # [ doc = "selected reference voltage * 48/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_48 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_48 ) } # [ doc = "selected reference voltage * 49/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_49 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_49 ) } # [ doc = "selected reference voltage * 50/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_50 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_50 ) } # [ doc = "selected reference voltage * 51/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_51 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_51 ) } # [ doc = "selected reference voltage * 52/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_52 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_52 ) } # [ doc = "selected reference voltage * 53/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_53 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_53 ) } # [ doc = "selected reference voltage * 54/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_54 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_54 ) } # [ doc = "selected reference voltage * 55/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_55 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_55 ) } # [ doc = "selected reference voltage * 56/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_56 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_56 ) } # [ doc = "selected reference voltage * 57/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_57 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_57 ) } # [ doc = "selected reference voltage * 58/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_58 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_58 ) } # [ doc = "selected reference voltage * 59/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_59 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_59 ) } # [ doc = "selected reference voltage * 60/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_60 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_60 ) } # [ doc = "selected reference voltage * 61/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_61 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_61 ) } # [ doc = "selected reference voltage * 62/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_62 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_62 ) } # [ doc = "selected reference voltage * 63/64" ] # [ inline ( always ) ] pub fn cpdacbuf1_63 ( self ) -> & 'a mut W { self . variant ( CPDACBUF1_A :: CPDACBUF1_63 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u16 ) & 0x3f ) ; self . w } }
# [ doc = "2nd 6-bit DAC buffer Data\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum CPDACBUF2_A { # [ doc = "0: 0v" ] CPDACBUF2_0 = 0 , # [ doc = "1: selected reference voltage * 1/64" ] CPDACBUF2_1 = 1 , # [ doc = "2: selected reference voltage * 2/64" ] CPDACBUF2_2 = 2 , # [ doc = "3: selected reference voltage * 3/64" ] CPDACBUF2_3 = 3 , # [ doc = "4: selected reference voltage * 4/64" ] CPDACBUF2_4 = 4 , # [ doc = "5: selected reference voltage * 5/64" ] CPDACBUF2_5 = 5 , # [ doc = "6: selected reference voltage * 6/64" ] CPDACBUF2_6 = 6 , # [ doc = "7: selected reference voltage * 7/64" ] CPDACBUF2_7 = 7 , # [ doc = "8: selected reference voltage * 8/64" ] CPDACBUF2_8 = 8 , # [ doc = "9: selected reference voltage * 9/64" ] CPDACBUF2_9 = 9 , # [ doc = "10: selected reference voltage * 10/64" ] CPDACBUF2_10 = 10 , # [ doc = "11: selected reference voltage * 11/64" ] CPDACBUF2_11 = 11 , # [ doc = "12: selected reference voltage * 12/64" ] CPDACBUF2_12 = 12 , # [ doc = "13: selected reference voltage * 13/64" ] CPDACBUF2_13 = 13 , # [ doc = "14: selected reference voltage * 14/64" ] CPDACBUF2_14 = 14 , # [ doc = "15: selected reference voltage * 15/64" ] CPDACBUF2_15 = 15 , # [ doc = "16: selected reference voltage * 16/64" ] CPDACBUF2_16 = 16 , # [ doc = "17: selected reference voltage * 17/64" ] CPDACBUF2_17 = 17 , # [ doc = "18: selected reference voltage * 18/64" ] CPDACBUF2_18 = 18 , # [ doc = "19: selected reference voltage * 19/64" ] CPDACBUF2_19 = 19 , # [ doc = "20: selected reference voltage * 20/64" ] CPDACBUF2_20 = 20 , # [ doc = "21: selected reference voltage * 21/64" ] CPDACBUF2_21 = 21 , # [ doc = "22: selected reference voltage * 22/64" ] CPDACBUF2_22 = 22 , # [ doc = "23: selected reference voltage * 23/64" ] CPDACBUF2_23 = 23 , # [ doc = "24: selected reference voltage * 24/64" ] CPDACBUF2_24 = 24 , # [ doc = "25: selected reference voltage * 25/64" ] CPDACBUF2_25 = 25 , # [ doc = "26: selected reference voltage * 26/64" ] CPDACBUF2_26 = 26 , # [ doc = "27: selected reference voltage * 27/64" ] CPDACBUF2_27 = 27 , # [ doc = "28: selected reference voltage * 28/64" ] CPDACBUF2_28 = 28 , # [ doc = "29: selected reference voltage * 29/64" ] CPDACBUF2_29 = 29 , # [ doc = "30: selected reference voltage * 30/64" ] CPDACBUF2_30 = 30 , # [ doc = "31: selected reference voltage * 31/64" ] CPDACBUF2_31 = 31 , # [ doc = "32: selected reference voltage * 32/64" ] CPDACBUF2_32 = 32 , # [ doc = "33: selected reference voltage * 33/64" ] CPDACBUF2_33 = 33 , # [ doc = "34: selected reference voltage * 34/64" ] CPDACBUF2_34 = 34 , # [ doc = "35: selected reference voltage * 35/64" ] CPDACBUF2_35 = 35 , # [ doc = "36: selected reference voltage * 36/64" ] CPDACBUF2_36 = 36 , # [ doc = "37: selected reference voltage * 37/64" ] CPDACBUF2_37 = 37 , # [ doc = "38: selected reference voltage * 38/64" ] CPDACBUF2_38 = 38 , # [ doc = "39: selected reference voltage * 39/64" ] CPDACBUF2_39 = 39 , # [ doc = "40: selected reference voltage * 40/64" ] CPDACBUF2_40 = 40 , # [ doc = "41: selected reference voltage * 41/64" ] CPDACBUF2_41 = 41 , # [ doc = "42: selected reference voltage * 42/64" ] CPDACBUF2_42 = 42 , # [ doc = "43: selected reference voltage * 43/64" ] CPDACBUF2_43 = 43 , # [ doc = "44: selected reference voltage * 44/64" ] CPDACBUF2_44 = 44 , # [ doc = "45: selected reference voltage * 45/64" ] CPDACBUF2_45 = 45 , # [ doc = "46: selected reference voltage * 46/64" ] CPDACBUF2_46 = 46 , # [ doc = "47: selected reference voltage * 47/64" ] CPDACBUF2_47 = 47 , # [ doc = "48: selected reference voltage * 48/64" ] CPDACBUF2_48 = 48 , # [ doc = "49: selected reference voltage * 49/64" ] CPDACBUF2_49 = 49 , # [ doc = "50: selected reference voltage * 50/64" ] CPDACBUF2_50 = 50 , # [ doc = "51: selected reference voltage * 51/64" ] CPDACBUF2_51 = 51 , # [ doc = "52: selected reference voltage * 52/64" ] CPDACBUF2_52 = 52 , # [ doc = "53: selected reference voltage * 53/64" ] CPDACBUF2_53 = 53 , # [ doc = "54: selected reference voltage * 54/64" ] CPDACBUF2_54 = 54 , # [ doc = "55: selected reference voltage * 55/64" ] CPDACBUF2_55 = 55 , # [ doc = "56: selected reference voltage * 56/64" ] CPDACBUF2_56 = 56 , # [ doc = "57: selected reference voltage * 57/64" ] CPDACBUF2_57 = 57 , # [ doc = "58: selected reference voltage * 58/64" ] CPDACBUF2_58 = 58 , # [ doc = "59: selected reference voltage * 59/64" ] CPDACBUF2_59 = 59 , # [ doc = "60: selected reference voltage * 60/64" ] CPDACBUF2_60 = 60 , # [ doc = "61: selected reference voltage * 61/64" ] CPDACBUF2_61 = 61 , # [ doc = "62: selected reference voltage * 62/64" ] CPDACBUF2_62 = 62 , # [ doc = "63: selected reference voltage * 63/64" ] CPDACBUF2_63 = 63 } impl From < CPDACBUF2_A > for u8 { # [ inline ( always ) ] fn from ( variant : CPDACBUF2_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `CPDACBUF2`" ] pub type CPDACBUF2_R = crate :: R < u8 , CPDACBUF2_A > ; impl CPDACBUF2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPDACBUF2_A { match self . bits { 0 => CPDACBUF2_A :: CPDACBUF2_0 , 1 => CPDACBUF2_A :: CPDACBUF2_1 , 2 => CPDACBUF2_A :: CPDACBUF2_2 , 3 => CPDACBUF2_A :: CPDACBUF2_3 , 4 => CPDACBUF2_A :: CPDACBUF2_4 , 5 => CPDACBUF2_A :: CPDACBUF2_5 , 6 => CPDACBUF2_A :: CPDACBUF2_6 , 7 => CPDACBUF2_A :: CPDACBUF2_7 , 8 => CPDACBUF2_A :: CPDACBUF2_8 , 9 => CPDACBUF2_A :: CPDACBUF2_9 , 10 => CPDACBUF2_A :: CPDACBUF2_10 , 11 => CPDACBUF2_A :: CPDACBUF2_11 , 12 => CPDACBUF2_A :: CPDACBUF2_12 , 13 => CPDACBUF2_A :: CPDACBUF2_13 , 14 => CPDACBUF2_A :: CPDACBUF2_14 , 15 => CPDACBUF2_A :: CPDACBUF2_15 , 16 => CPDACBUF2_A :: CPDACBUF2_16 , 17 => CPDACBUF2_A :: CPDACBUF2_17 , 18 => CPDACBUF2_A :: CPDACBUF2_18 , 19 => CPDACBUF2_A :: CPDACBUF2_19 , 20 => CPDACBUF2_A :: CPDACBUF2_20 , 21 => CPDACBUF2_A :: CPDACBUF2_21 , 22 => CPDACBUF2_A :: CPDACBUF2_22 , 23 => CPDACBUF2_A :: CPDACBUF2_23 , 24 => CPDACBUF2_A :: CPDACBUF2_24 , 25 => CPDACBUF2_A :: CPDACBUF2_25 , 26 => CPDACBUF2_A :: CPDACBUF2_26 , 27 => CPDACBUF2_A :: CPDACBUF2_27 , 28 => CPDACBUF2_A :: CPDACBUF2_28 , 29 => CPDACBUF2_A :: CPDACBUF2_29 , 30 => CPDACBUF2_A :: CPDACBUF2_30 , 31 => CPDACBUF2_A :: CPDACBUF2_31 , 32 => CPDACBUF2_A :: CPDACBUF2_32 , 33 => CPDACBUF2_A :: CPDACBUF2_33 , 34 => CPDACBUF2_A :: CPDACBUF2_34 , 35 => CPDACBUF2_A :: CPDACBUF2_35 , 36 => CPDACBUF2_A :: CPDACBUF2_36 , 37 => CPDACBUF2_A :: CPDACBUF2_37 , 38 => CPDACBUF2_A :: CPDACBUF2_38 , 39 => CPDACBUF2_A :: CPDACBUF2_39 , 40 => CPDACBUF2_A :: CPDACBUF2_40 , 41 => CPDACBUF2_A :: CPDACBUF2_41 , 42 => CPDACBUF2_A :: CPDACBUF2_42 , 43 => CPDACBUF2_A :: CPDACBUF2_43 , 44 => CPDACBUF2_A :: CPDACBUF2_44 , 45 => CPDACBUF2_A :: CPDACBUF2_45 , 46 => CPDACBUF2_A :: CPDACBUF2_46 , 47 => CPDACBUF2_A :: CPDACBUF2_47 , 48 => CPDACBUF2_A :: CPDACBUF2_48 , 49 => CPDACBUF2_A :: CPDACBUF2_49 , 50 => CPDACBUF2_A :: CPDACBUF2_50 , 51 => CPDACBUF2_A :: CPDACBUF2_51 , 52 => CPDACBUF2_A :: CPDACBUF2_52 , 53 => CPDACBUF2_A :: CPDACBUF2_53 , 54 => CPDACBUF2_A :: CPDACBUF2_54 , 55 => CPDACBUF2_A :: CPDACBUF2_55 , 56 => CPDACBUF2_A :: CPDACBUF2_56 , 57 => CPDACBUF2_A :: CPDACBUF2_57 , 58 => CPDACBUF2_A :: CPDACBUF2_58 , 59 => CPDACBUF2_A :: CPDACBUF2_59 , 60 => CPDACBUF2_A :: CPDACBUF2_60 , 61 => CPDACBUF2_A :: CPDACBUF2_61 , 62 => CPDACBUF2_A :: CPDACBUF2_62 , 63 => CPDACBUF2_A :: CPDACBUF2_63 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CPDACBUF2_0`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_0 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_0 } # [ doc = "Checks if the value of the field is `CPDACBUF2_1`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_1 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_1 } # [ doc = "Checks if the value of the field is `CPDACBUF2_2`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_2 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_2 } # [ doc = "Checks if the value of the field is `CPDACBUF2_3`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_3 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_3 } # [ doc = "Checks if the value of the field is `CPDACBUF2_4`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_4 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_4 } # [ doc = "Checks if the value of the field is `CPDACBUF2_5`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_5 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_5 } # [ doc = "Checks if the value of the field is `CPDACBUF2_6`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_6 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_6 } # [ doc = "Checks if the value of the field is `CPDACBUF2_7`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_7 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_7 } # [ doc = "Checks if the value of the field is `CPDACBUF2_8`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_8 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_8 } # [ doc = "Checks if the value of the field is `CPDACBUF2_9`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_9 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_9 } # [ doc = "Checks if the value of the field is `CPDACBUF2_10`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_10 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_10 } # [ doc = "Checks if the value of the field is `CPDACBUF2_11`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_11 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_11 } # [ doc = "Checks if the value of the field is `CPDACBUF2_12`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_12 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_12 } # [ doc = "Checks if the value of the field is `CPDACBUF2_13`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_13 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_13 } # [ doc = "Checks if the value of the field is `CPDACBUF2_14`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_14 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_14 } # [ doc = "Checks if the value of the field is `CPDACBUF2_15`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_15 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_15 } # [ doc = "Checks if the value of the field is `CPDACBUF2_16`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_16 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_16 } # [ doc = "Checks if the value of the field is `CPDACBUF2_17`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_17 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_17 } # [ doc = "Checks if the value of the field is `CPDACBUF2_18`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_18 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_18 } # [ doc = "Checks if the value of the field is `CPDACBUF2_19`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_19 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_19 } # [ doc = "Checks if the value of the field is `CPDACBUF2_20`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_20 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_20 } # [ doc = "Checks if the value of the field is `CPDACBUF2_21`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_21 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_21 } # [ doc = "Checks if the value of the field is `CPDACBUF2_22`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_22 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_22 } # [ doc = "Checks if the value of the field is `CPDACBUF2_23`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_23 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_23 } # [ doc = "Checks if the value of the field is `CPDACBUF2_24`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_24 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_24 } # [ doc = "Checks if the value of the field is `CPDACBUF2_25`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_25 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_25 } # [ doc = "Checks if the value of the field is `CPDACBUF2_26`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_26 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_26 } # [ doc = "Checks if the value of the field is `CPDACBUF2_27`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_27 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_27 } # [ doc = "Checks if the value of the field is `CPDACBUF2_28`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_28 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_28 } # [ doc = "Checks if the value of the field is `CPDACBUF2_29`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_29 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_29 } # [ doc = "Checks if the value of the field is `CPDACBUF2_30`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_30 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_30 } # [ doc = "Checks if the value of the field is `CPDACBUF2_31`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_31 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_31 } # [ doc = "Checks if the value of the field is `CPDACBUF2_32`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_32 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_32 } # [ doc = "Checks if the value of the field is `CPDACBUF2_33`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_33 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_33 } # [ doc = "Checks if the value of the field is `CPDACBUF2_34`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_34 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_34 } # [ doc = "Checks if the value of the field is `CPDACBUF2_35`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_35 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_35 } # [ doc = "Checks if the value of the field is `CPDACBUF2_36`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_36 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_36 } # [ doc = "Checks if the value of the field is `CPDACBUF2_37`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_37 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_37 } # [ doc = "Checks if the value of the field is `CPDACBUF2_38`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_38 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_38 } # [ doc = "Checks if the value of the field is `CPDACBUF2_39`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_39 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_39 } # [ doc = "Checks if the value of the field is `CPDACBUF2_40`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_40 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_40 } # [ doc = "Checks if the value of the field is `CPDACBUF2_41`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_41 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_41 } # [ doc = "Checks if the value of the field is `CPDACBUF2_42`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_42 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_42 } # [ doc = "Checks if the value of the field is `CPDACBUF2_43`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_43 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_43 } # [ doc = "Checks if the value of the field is `CPDACBUF2_44`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_44 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_44 } # [ doc = "Checks if the value of the field is `CPDACBUF2_45`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_45 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_45 } # [ doc = "Checks if the value of the field is `CPDACBUF2_46`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_46 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_46 } # [ doc = "Checks if the value of the field is `CPDACBUF2_47`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_47 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_47 } # [ doc = "Checks if the value of the field is `CPDACBUF2_48`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_48 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_48 } # [ doc = "Checks if the value of the field is `CPDACBUF2_49`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_49 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_49 } # [ doc = "Checks if the value of the field is `CPDACBUF2_50`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_50 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_50 } # [ doc = "Checks if the value of the field is `CPDACBUF2_51`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_51 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_51 } # [ doc = "Checks if the value of the field is `CPDACBUF2_52`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_52 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_52 } # [ doc = "Checks if the value of the field is `CPDACBUF2_53`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_53 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_53 } # [ doc = "Checks if the value of the field is `CPDACBUF2_54`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_54 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_54 } # [ doc = "Checks if the value of the field is `CPDACBUF2_55`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_55 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_55 } # [ doc = "Checks if the value of the field is `CPDACBUF2_56`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_56 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_56 } # [ doc = "Checks if the value of the field is `CPDACBUF2_57`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_57 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_57 } # [ doc = "Checks if the value of the field is `CPDACBUF2_58`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_58 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_58 } # [ doc = "Checks if the value of the field is `CPDACBUF2_59`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_59 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_59 } # [ doc = "Checks if the value of the field is `CPDACBUF2_60`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_60 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_60 } # [ doc = "Checks if the value of the field is `CPDACBUF2_61`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_61 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_61 } # [ doc = "Checks if the value of the field is `CPDACBUF2_62`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_62 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_62 } # [ doc = "Checks if the value of the field is `CPDACBUF2_63`" ] # [ inline ( always ) ] pub fn is_cpdacbuf2_63 ( & self ) -> bool { * self == CPDACBUF2_A :: CPDACBUF2_63 } }
# [ doc = "Write proxy for field `CPDACBUF2`" ] pub struct CPDACBUF2_W < 'a > { w : & 'a mut W , } impl < 'a > CPDACBUF2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPDACBUF2_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "0v" ] # [ inline ( always ) ] pub fn cpdacbuf2_0 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_0 ) } # [ doc = "selected reference voltage * 1/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_1 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_1 ) } # [ doc = "selected reference voltage * 2/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_2 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_2 ) } # [ doc = "selected reference voltage * 3/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_3 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_3 ) } # [ doc = "selected reference voltage * 4/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_4 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_4 ) } # [ doc = "selected reference voltage * 5/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_5 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_5 ) } # [ doc = "selected reference voltage * 6/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_6 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_6 ) } # [ doc = "selected reference voltage * 7/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_7 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_7 ) } # [ doc = "selected reference voltage * 8/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_8 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_8 ) } # [ doc = "selected reference voltage * 9/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_9 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_9 ) } # [ doc = "selected reference voltage * 10/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_10 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_10 ) } # [ doc = "selected reference voltage * 11/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_11 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_11 ) } # [ doc = "selected reference voltage * 12/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_12 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_12 ) } # [ doc = "selected reference voltage * 13/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_13 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_13 ) } # [ doc = "selected reference voltage * 14/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_14 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_14 ) } # [ doc = "selected reference voltage * 15/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_15 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_15 ) } # [ doc = "selected reference voltage * 16/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_16 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_16 ) } # [ doc = "selected reference voltage * 17/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_17 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_17 ) } # [ doc = "selected reference voltage * 18/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_18 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_18 ) } # [ doc = "selected reference voltage * 19/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_19 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_19 ) } # [ doc = "selected reference voltage * 20/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_20 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_20 ) } # [ doc = "selected reference voltage * 21/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_21 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_21 ) } # [ doc = "selected reference voltage * 22/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_22 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_22 ) } # [ doc = "selected reference voltage * 23/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_23 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_23 ) } # [ doc = "selected reference voltage * 24/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_24 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_24 ) } # [ doc = "selected reference voltage * 25/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_25 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_25 ) } # [ doc = "selected reference voltage * 26/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_26 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_26 ) } # [ doc = "selected reference voltage * 27/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_27 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_27 ) } # [ doc = "selected reference voltage * 28/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_28 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_28 ) } # [ doc = "selected reference voltage * 29/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_29 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_29 ) } # [ doc = "selected reference voltage * 30/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_30 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_30 ) } # [ doc = "selected reference voltage * 31/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_31 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_31 ) } # [ doc = "selected reference voltage * 32/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_32 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_32 ) } # [ doc = "selected reference voltage * 33/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_33 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_33 ) } # [ doc = "selected reference voltage * 34/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_34 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_34 ) } # [ doc = "selected reference voltage * 35/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_35 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_35 ) } # [ doc = "selected reference voltage * 36/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_36 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_36 ) } # [ doc = "selected reference voltage * 37/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_37 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_37 ) } # [ doc = "selected reference voltage * 38/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_38 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_38 ) } # [ doc = "selected reference voltage * 39/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_39 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_39 ) } # [ doc = "selected reference voltage * 40/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_40 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_40 ) } # [ doc = "selected reference voltage * 41/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_41 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_41 ) } # [ doc = "selected reference voltage * 42/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_42 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_42 ) } # [ doc = "selected reference voltage * 43/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_43 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_43 ) } # [ doc = "selected reference voltage * 44/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_44 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_44 ) } # [ doc = "selected reference voltage * 45/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_45 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_45 ) } # [ doc = "selected reference voltage * 46/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_46 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_46 ) } # [ doc = "selected reference voltage * 47/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_47 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_47 ) } # [ doc = "selected reference voltage * 48/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_48 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_48 ) } # [ doc = "selected reference voltage * 49/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_49 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_49 ) } # [ doc = "selected reference voltage * 50/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_50 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_50 ) } # [ doc = "selected reference voltage * 51/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_51 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_51 ) } # [ doc = "selected reference voltage * 52/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_52 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_52 ) } # [ doc = "selected reference voltage * 53/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_53 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_53 ) } # [ doc = "selected reference voltage * 54/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_54 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_54 ) } # [ doc = "selected reference voltage * 55/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_55 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_55 ) } # [ doc = "selected reference voltage * 56/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_56 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_56 ) } # [ doc = "selected reference voltage * 57/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_57 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_57 ) } # [ doc = "selected reference voltage * 58/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_58 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_58 ) } # [ doc = "selected reference voltage * 59/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_59 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_59 ) } # [ doc = "selected reference voltage * 60/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_60 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_60 ) } # [ doc = "selected reference voltage * 61/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_61 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_61 ) } # [ doc = "selected reference voltage * 62/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_62 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_62 ) } # [ doc = "selected reference voltage * 63/64" ] # [ inline ( always ) ] pub fn cpdacbuf2_63 ( self ) -> & 'a mut W { self . variant ( CPDACBUF2_A :: CPDACBUF2_63 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 8 ) ) | ( ( ( value as u16 ) & 0x3f ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:5 - 1st 6-bit DAC buffer Data" ] # [ inline ( always ) ] pub fn cpdacbuf1 ( & self ) -> CPDACBUF1_R { CPDACBUF1_R :: new ( ( self . bits & 0x3f ) as u8 ) }
# [ doc = "Bits 8:13 - 2nd 6-bit DAC buffer Data" ] # [ inline ( always ) ] pub fn cpdacbuf2 ( & self ) -> CPDACBUF2_R { CPDACBUF2_R :: new ( ( ( self . bits >> 8 ) & 0x3f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:5 - 1st 6-bit DAC buffer Data" ] # [ inline ( always ) ] pub fn cpdacbuf1 ( & mut self ) -> CPDACBUF1_W { CPDACBUF1_W { w : self } }
# [ doc = "Bits 8:13 - 2nd 6-bit DAC buffer Data" ] # [ inline ( always ) ] pub fn cpdacbuf2 ( & mut self ) -> CPDACBUF2_W { CPDACBUF2_W { w : self } }
}
}
}
# [ doc = "SAC0" ] pub struct SAC0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SAC0 { } impl SAC0 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const sac0 :: RegisterBlock { 0x0c80 as * const _ } } impl Deref for SAC0 { type Target = sac0 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * SAC0 :: ptr ( ) } } }
# [ doc = "SAC0" ] pub mod sac0 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - SAC OA Control Register" ] pub sac0oa : SAC0OA , # [ doc = "0x02 - SAC PGA Control Register" ] pub sac0pga : SAC0PGA , # [ doc = "0x04 - SAC DAC Control Register" ] pub sac0dac : SAC0DAC , # [ doc = "0x06 - SAC DAC Data Register" ] pub sac0dat : SAC0DAT , # [ doc = "0x08 - SAC DAC Status Register" ] pub sac0dacsts : SAC0DACSTS , # [ doc = "0x0a - SAC Interrupt Vector Register" ] pub sac0iv : SAC0IV , }
# [ doc = "SAC OA Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac0oa](sac0oa) module" ] pub type SAC0OA = crate :: Reg < u16 , _SAC0OA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC0OA ;
# [ doc = "`read()` method returns [sac0oa::R](sac0oa::R) reader structure" ] impl crate :: Readable for SAC0OA { }
# [ doc = "`write(|w| ..)` method takes [sac0oa::W](sac0oa::W) writer structure" ] impl crate :: Writable for SAC0OA { }
# [ doc = "SAC OA Control Register" ] pub mod sac0oa {
# [ doc = "Reader of register SAC0OA" ] pub type R = crate :: R < u16 , super :: SAC0OA > ;
# [ doc = "Writer for register SAC0OA" ] pub type W = crate :: W < u16 , super :: SAC0OA > ;
# [ doc = "Register SAC0OA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC0OA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC OA Positive input source selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum PSEL_A { # [ doc = "0: External source selected" ] PSEL_0 = 0 , # [ doc = "1: 12-bit reference DAC source selected" ] PSEL_1 = 1 , # [ doc = "2: Pair OA source selected" ] PSEL_2 = 2 } impl From < PSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : PSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `PSEL`" ] pub type PSEL_R = crate :: R < u8 , PSEL_A > ; impl PSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , PSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( PSEL_A :: PSEL_0 ) , 1 => Val ( PSEL_A :: PSEL_1 ) , 2 => Val ( PSEL_A :: PSEL_2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `PSEL_0`" ] # [ inline ( always ) ] pub fn is_psel_0 ( & self ) -> bool { * self == PSEL_A :: PSEL_0 } # [ doc = "Checks if the value of the field is `PSEL_1`" ] # [ inline ( always ) ] pub fn is_psel_1 ( & self ) -> bool { * self == PSEL_A :: PSEL_1 } # [ doc = "Checks if the value of the field is `PSEL_2`" ] # [ inline ( always ) ] pub fn is_psel_2 ( & self ) -> bool { * self == PSEL_A :: PSEL_2 } }
# [ doc = "Write proxy for field `PSEL`" ] pub struct PSEL_W < 'a > { w : & 'a mut W , } impl < 'a > PSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "External source selected" ] # [ inline ( always ) ] pub fn psel_0 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_0 ) } # [ doc = "12-bit reference DAC source selected" ] # [ inline ( always ) ] pub fn psel_1 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_1 ) } # [ doc = "Pair OA source selected" ] # [ inline ( always ) ] pub fn psel_2 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_2 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "SAC Positive input MUX control.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PMUXEN_A { # [ doc = "0: All positive input sources are disconnected to OA positive port" ] PMUXEN_0 = 0 , # [ doc = "1: All positive input sources are connected to OA positive port" ] PMUXEN_1 = 1 } impl From < PMUXEN_A > for bool { # [ inline ( always ) ] fn from ( variant : PMUXEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `PMUXEN`" ] pub type PMUXEN_R = crate :: R < bool , PMUXEN_A > ; impl PMUXEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PMUXEN_A { match self . bits { false => PMUXEN_A :: PMUXEN_0 , true => PMUXEN_A :: PMUXEN_1 } } # [ doc = "Checks if the value of the field is `PMUXEN_0`" ] # [ inline ( always ) ] pub fn is_pmuxen_0 ( & self ) -> bool { * self == PMUXEN_A :: PMUXEN_0 } # [ doc = "Checks if the value of the field is `PMUXEN_1`" ] # [ inline ( always ) ] pub fn is_pmuxen_1 ( & self ) -> bool { * self == PMUXEN_A :: PMUXEN_1 } }
# [ doc = "Write proxy for field `PMUXEN`" ] pub struct PMUXEN_W < 'a > { w : & 'a mut W , } impl < 'a > PMUXEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PMUXEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "All positive input sources are disconnected to OA positive port" ] # [ inline ( always ) ] pub fn pmuxen_0 ( self ) -> & 'a mut W { self . variant ( PMUXEN_A :: PMUXEN_0 ) } # [ doc = "All positive input sources are connected to OA positive port" ] # [ inline ( always ) ] pub fn pmuxen_1 ( self ) -> & 'a mut W { self . variant ( PMUXEN_A :: PMUXEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "SAC OA Negative input source selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum NSEL_A { # [ doc = "0: External source selected" ] NSEL_0 = 0 , # [ doc = "1: PGA source selected" ] NSEL_1 = 1 , # [ doc = "2: Device Specific" ] NSEL_2 = 2 } impl From < NSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : NSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `NSEL`" ] pub type NSEL_R = crate :: R < u8 , NSEL_A > ; impl NSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , NSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( NSEL_A :: NSEL_0 ) , 1 => Val ( NSEL_A :: NSEL_1 ) , 2 => Val ( NSEL_A :: NSEL_2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NSEL_0`" ] # [ inline ( always ) ] pub fn is_nsel_0 ( & self ) -> bool { * self == NSEL_A :: NSEL_0 } # [ doc = "Checks if the value of the field is `NSEL_1`" ] # [ inline ( always ) ] pub fn is_nsel_1 ( & self ) -> bool { * self == NSEL_A :: NSEL_1 } # [ doc = "Checks if the value of the field is `NSEL_2`" ] # [ inline ( always ) ] pub fn is_nsel_2 ( & self ) -> bool { * self == NSEL_A :: NSEL_2 } }
# [ doc = "Write proxy for field `NSEL`" ] pub struct NSEL_W < 'a > { w : & 'a mut W , } impl < 'a > NSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "External source selected" ] # [ inline ( always ) ] pub fn nsel_0 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_0 ) } # [ doc = "PGA source selected" ] # [ inline ( always ) ] pub fn nsel_1 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_1 ) } # [ doc = "Device Specific" ] # [ inline ( always ) ] pub fn nsel_2 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_2 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "SAC Negative input MUX controL\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum NMUXEN_A { # [ doc = "0: All negative input sources are disconnected to OA negative port" ] NMUXEN_0 = 0 , # [ doc = "1: All negative input sources are connected to OA negative port" ] NMUXEN_1 = 1 } impl From < NMUXEN_A > for bool { # [ inline ( always ) ] fn from ( variant : NMUXEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `NMUXEN`" ] pub type NMUXEN_R = crate :: R < bool , NMUXEN_A > ; impl NMUXEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> NMUXEN_A { match self . bits { false => NMUXEN_A :: NMUXEN_0 , true => NMUXEN_A :: NMUXEN_1 } } # [ doc = "Checks if the value of the field is `NMUXEN_0`" ] # [ inline ( always ) ] pub fn is_nmuxen_0 ( & self ) -> bool { * self == NMUXEN_A :: NMUXEN_0 } # [ doc = "Checks if the value of the field is `NMUXEN_1`" ] # [ inline ( always ) ] pub fn is_nmuxen_1 ( & self ) -> bool { * self == NMUXEN_A :: NMUXEN_1 } }
# [ doc = "Write proxy for field `NMUXEN`" ] pub struct NMUXEN_W < 'a > { w : & 'a mut W , } impl < 'a > NMUXEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NMUXEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "All negative input sources are disconnected to OA negative port" ] # [ inline ( always ) ] pub fn nmuxen_0 ( self ) -> & 'a mut W { self . variant ( NMUXEN_A :: NMUXEN_0 ) } # [ doc = "All negative input sources are connected to OA negative port" ] # [ inline ( always ) ] pub fn nmuxen_1 ( self ) -> & 'a mut W { self . variant ( NMUXEN_A :: NMUXEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "SAC OA Enable selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OAEN_A { # [ doc = "0: SAC OA is disabled, then the SAC OA output high impedance" ] OAEN_0 = 0 , # [ doc = "1: SAC OA is enabled, normal mode" ] OAEN_1 = 1 } impl From < OAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : OAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OAEN`" ] pub type OAEN_R = crate :: R < bool , OAEN_A > ; impl OAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OAEN_A { match self . bits { false => OAEN_A :: OAEN_0 , true => OAEN_A :: OAEN_1 } } # [ doc = "Checks if the value of the field is `OAEN_0`" ] # [ inline ( always ) ] pub fn is_oaen_0 ( & self ) -> bool { * self == OAEN_A :: OAEN_0 } # [ doc = "Checks if the value of the field is `OAEN_1`" ] # [ inline ( always ) ] pub fn is_oaen_1 ( & self ) -> bool { * self == OAEN_A :: OAEN_1 } }
# [ doc = "Write proxy for field `OAEN`" ] pub struct OAEN_W < 'a > { w : & 'a mut W , } impl < 'a > OAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SAC OA is disabled, then the SAC OA output high impedance" ] # [ inline ( always ) ] pub fn oaen_0 ( self ) -> & 'a mut W { self . variant ( OAEN_A :: OAEN_0 ) } # [ doc = "SAC OA is enabled, normal mode" ] # [ inline ( always ) ] pub fn oaen_1 ( self ) -> & 'a mut W { self . variant ( OAEN_A :: OAEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "SAC OA power mode selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OAPM_A { # [ doc = "0: High speed and high power" ] OAPM_0 = 0 , # [ doc = "1: Llow speed and low power" ] OAPM_1 = 1 } impl From < OAPM_A > for bool { # [ inline ( always ) ] fn from ( variant : OAPM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OAPM`" ] pub type OAPM_R = crate :: R < bool , OAPM_A > ; impl OAPM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OAPM_A { match self . bits { false => OAPM_A :: OAPM_0 , true => OAPM_A :: OAPM_1 } } # [ doc = "Checks if the value of the field is `OAPM_0`" ] # [ inline ( always ) ] pub fn is_oapm_0 ( & self ) -> bool { * self == OAPM_A :: OAPM_0 } # [ doc = "Checks if the value of the field is `OAPM_1`" ] # [ inline ( always ) ] pub fn is_oapm_1 ( & self ) -> bool { * self == OAPM_A :: OAPM_1 } }
# [ doc = "Write proxy for field `OAPM`" ] pub struct OAPM_W < 'a > { w : & 'a mut W , } impl < 'a > OAPM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OAPM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "High speed and high power" ] # [ inline ( always ) ] pub fn oapm_0 ( self ) -> & 'a mut W { self . variant ( OAPM_A :: OAPM_0 ) } # [ doc = "Llow speed and low power" ] # [ inline ( always ) ] pub fn oapm_1 ( self ) -> & 'a mut W { self . variant ( OAPM_A :: OAPM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "SAC Enable selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SACEN_A { # [ doc = "0: SAC all modules are disabled, then the SAC output high impedance" ] SACEN_0 = 0 , # [ doc = "1: SAC all modules are enabled, normal mode" ] SACEN_1 = 1 } impl From < SACEN_A > for bool { # [ inline ( always ) ] fn from ( variant : SACEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SACEN`" ] pub type SACEN_R = crate :: R < bool , SACEN_A > ; impl SACEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SACEN_A { match self . bits { false => SACEN_A :: SACEN_0 , true => SACEN_A :: SACEN_1 } } # [ doc = "Checks if the value of the field is `SACEN_0`" ] # [ inline ( always ) ] pub fn is_sacen_0 ( & self ) -> bool { * self == SACEN_A :: SACEN_0 } # [ doc = "Checks if the value of the field is `SACEN_1`" ] # [ inline ( always ) ] pub fn is_sacen_1 ( & self ) -> bool { * self == SACEN_A :: SACEN_1 } }
# [ doc = "Write proxy for field `SACEN`" ] pub struct SACEN_W < 'a > { w : & 'a mut W , } impl < 'a > SACEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SACEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SAC all modules are disabled, then the SAC output high impedance" ] # [ inline ( always ) ] pub fn sacen_0 ( self ) -> & 'a mut W { self . variant ( SACEN_A :: SACEN_0 ) } # [ doc = "SAC all modules are enabled, normal mode" ] # [ inline ( always ) ] pub fn sacen_1 ( self ) -> & 'a mut W { self . variant ( SACEN_A :: SACEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - SAC OA Positive input source selection" ] # [ inline ( always ) ] pub fn psel ( & self ) -> PSEL_R { PSEL_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bit 3 - SAC Positive input MUX control." ] # [ inline ( always ) ] pub fn pmuxen ( & self ) -> PMUXEN_R { PMUXEN_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - SAC OA Negative input source selection" ] # [ inline ( always ) ] pub fn nsel ( & self ) -> NSEL_R { NSEL_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 7 - SAC Negative input MUX controL" ] # [ inline ( always ) ] pub fn nmuxen ( & self ) -> NMUXEN_R { NMUXEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - SAC OA Enable selection" ] # [ inline ( always ) ] pub fn oaen ( & self ) -> OAEN_R { OAEN_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - SAC OA power mode selection" ] # [ inline ( always ) ] pub fn oapm ( & self ) -> OAPM_R { OAPM_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - SAC Enable selection" ] # [ inline ( always ) ] pub fn sacen ( & self ) -> SACEN_R { SACEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:1 - SAC OA Positive input source selection" ] # [ inline ( always ) ] pub fn psel ( & mut self ) -> PSEL_W { PSEL_W { w : self } }
# [ doc = "Bit 3 - SAC Positive input MUX control." ] # [ inline ( always ) ] pub fn pmuxen ( & mut self ) -> PMUXEN_W { PMUXEN_W { w : self } }
# [ doc = "Bits 4:5 - SAC OA Negative input source selection" ] # [ inline ( always ) ] pub fn nsel ( & mut self ) -> NSEL_W { NSEL_W { w : self } }
# [ doc = "Bit 7 - SAC Negative input MUX controL" ] # [ inline ( always ) ] pub fn nmuxen ( & mut self ) -> NMUXEN_W { NMUXEN_W { w : self } }
# [ doc = "Bit 8 - SAC OA Enable selection" ] # [ inline ( always ) ] pub fn oaen ( & mut self ) -> OAEN_W { OAEN_W { w : self } }
# [ doc = "Bit 9 - SAC OA power mode selection" ] # [ inline ( always ) ] pub fn oapm ( & mut self ) -> OAPM_W { OAPM_W { w : self } }
# [ doc = "Bit 10 - SAC Enable selection" ] # [ inline ( always ) ] pub fn sacen ( & mut self ) -> SACEN_W { SACEN_W { w : self } }
}
}
# [ doc = "SAC PGA Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac0pga](sac0pga) module" ] pub type SAC0PGA = crate :: Reg < u16 , _SAC0PGA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC0PGA ;
# [ doc = "`read()` method returns [sac0pga::R](sac0pga::R) reader structure" ] impl crate :: Readable for SAC0PGA { }
# [ doc = "`write(|w| ..)` method takes [sac0pga::W](sac0pga::W) writer structure" ] impl crate :: Writable for SAC0PGA { }
# [ doc = "SAC PGA Control Register" ] pub mod sac0pga {
# [ doc = "Reader of register SAC0PGA" ] pub type R = crate :: R < u16 , super :: SAC0PGA > ;
# [ doc = "Writer for register SAC0PGA" ] pub type W = crate :: W < u16 , super :: SAC0PGA > ;
# [ doc = "Register SAC0PGA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC0PGA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC PGA Mode Selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum MSEL_A { # [ doc = "0: Inverting PGA mode (external pad IN- is selected)" ] MSEL_0 = 0 , # [ doc = "1: Buffer mode (floating is selected )" ] MSEL_1 = 1 , # [ doc = "2: Non-inverting mode" ] MSEL_2 = 2 , # [ doc = "3: Cascade OA Inverting mode" ] MSEL_3 = 3 } impl From < MSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : MSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `MSEL`" ] pub type MSEL_R = crate :: R < u8 , MSEL_A > ; impl MSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MSEL_A { match self . bits { 0 => MSEL_A :: MSEL_0 , 1 => MSEL_A :: MSEL_1 , 2 => MSEL_A :: MSEL_2 , 3 => MSEL_A :: MSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `MSEL_0`" ] # [ inline ( always ) ] pub fn is_msel_0 ( & self ) -> bool { * self == MSEL_A :: MSEL_0 } # [ doc = "Checks if the value of the field is `MSEL_1`" ] # [ inline ( always ) ] pub fn is_msel_1 ( & self ) -> bool { * self == MSEL_A :: MSEL_1 } # [ doc = "Checks if the value of the field is `MSEL_2`" ] # [ inline ( always ) ] pub fn is_msel_2 ( & self ) -> bool { * self == MSEL_A :: MSEL_2 } # [ doc = "Checks if the value of the field is `MSEL_3`" ] # [ inline ( always ) ] pub fn is_msel_3 ( & self ) -> bool { * self == MSEL_A :: MSEL_3 } }
# [ doc = "Write proxy for field `MSEL`" ] pub struct MSEL_W < 'a > { w : & 'a mut W , } impl < 'a > MSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Inverting PGA mode (external pad IN- is selected)" ] # [ inline ( always ) ] pub fn msel_0 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_0 ) } # [ doc = "Buffer mode (floating is selected )" ] # [ inline ( always ) ] pub fn msel_1 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_1 ) } # [ doc = "Non-inverting mode" ] # [ inline ( always ) ] pub fn msel_2 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_2 ) } # [ doc = "Cascade OA Inverting mode" ] # [ inline ( always ) ] pub fn msel_3 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `GAIN`" ] pub type GAIN_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `GAIN`" ] pub struct GAIN_W < 'a > { w : & 'a mut W , } impl < 'a > GAIN_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 4 ) ) | ( ( ( value as u16 ) & 0x07 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - SAC PGA Mode Selection" ] # [ inline ( always ) ] pub fn msel ( & self ) -> MSEL_R { MSEL_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 4:6 - SAC PGA Gain configuration" ] # [ inline ( always ) ] pub fn gain ( & self ) -> GAIN_R { GAIN_R :: new ( ( ( self . bits >> 4 ) & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - SAC PGA Mode Selection" ] # [ inline ( always ) ] pub fn msel ( & mut self ) -> MSEL_W { MSEL_W { w : self } }
# [ doc = "Bits 4:6 - SAC PGA Gain configuration" ] # [ inline ( always ) ] pub fn gain ( & mut self ) -> GAIN_W { GAIN_W { w : self } }
}
}
# [ doc = "SAC DAC Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac0dac](sac0dac) module" ] pub type SAC0DAC = crate :: Reg < u16 , _SAC0DAC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC0DAC ;
# [ doc = "`read()` method returns [sac0dac::R](sac0dac::R) reader structure" ] impl crate :: Readable for SAC0DAC { }
# [ doc = "`write(|w| ..)` method takes [sac0dac::W](sac0dac::W) writer structure" ] impl crate :: Writable for SAC0DAC { }
# [ doc = "SAC DAC Control Register" ] pub mod sac0dac {
# [ doc = "Reader of register SAC0DAC" ] pub type R = crate :: R < u16 , super :: SAC0DAC > ;
# [ doc = "Writer for register SAC0DAC" ] pub type W = crate :: W < u16 , super :: SAC0DAC > ;
# [ doc = "Register SAC0DAC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC0DAC { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC DAC enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACEN_A { # [ doc = "0: Disabled" ] DACEN_0 = 0 , # [ doc = "1: Enabled" ] DACEN_1 = 1 } impl From < DACEN_A > for bool { # [ inline ( always ) ] fn from ( variant : DACEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACEN`" ] pub type DACEN_R = crate :: R < bool , DACEN_A > ; impl DACEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACEN_A { match self . bits { false => DACEN_A :: DACEN_0 , true => DACEN_A :: DACEN_1 } } # [ doc = "Checks if the value of the field is `DACEN_0`" ] # [ inline ( always ) ] pub fn is_dacen_0 ( & self ) -> bool { * self == DACEN_A :: DACEN_0 } # [ doc = "Checks if the value of the field is `DACEN_1`" ] # [ inline ( always ) ] pub fn is_dacen_1 ( & self ) -> bool { * self == DACEN_A :: DACEN_1 } }
# [ doc = "Write proxy for field `DACEN`" ] pub struct DACEN_W < 'a > { w : & 'a mut W , } impl < 'a > DACEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn dacen_0 ( self ) -> & 'a mut W { self . variant ( DACEN_A :: DACEN_0 ) } # [ doc = "Enabled" ] # [ inline ( always ) ] pub fn dacen_1 ( self ) -> & 'a mut W { self . variant ( DACEN_A :: DACEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "SAC DAC interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACIE_A { # [ doc = "0: Disabled" ] DACIE_0 = 0 , # [ doc = "1: Enabled" ] DACIE_1 = 1 } impl From < DACIE_A > for bool { # [ inline ( always ) ] fn from ( variant : DACIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACIE`" ] pub type DACIE_R = crate :: R < bool , DACIE_A > ; impl DACIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACIE_A { match self . bits { false => DACIE_A :: DACIE_0 , true => DACIE_A :: DACIE_1 } } # [ doc = "Checks if the value of the field is `DACIE_0`" ] # [ inline ( always ) ] pub fn is_dacie_0 ( & self ) -> bool { * self == DACIE_A :: DACIE_0 } # [ doc = "Checks if the value of the field is `DACIE_1`" ] # [ inline ( always ) ] pub fn is_dacie_1 ( & self ) -> bool { * self == DACIE_A :: DACIE_1 } }
# [ doc = "Write proxy for field `DACIE`" ] pub struct DACIE_W < 'a > { w : & 'a mut W , } impl < 'a > DACIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn dacie_0 ( self ) -> & 'a mut W { self . variant ( DACIE_A :: DACIE_0 ) } # [ doc = "Enabled" ] # [ inline ( always ) ] pub fn dacie_1 ( self ) -> & 'a mut W { self . variant ( DACIE_A :: DACIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "SAC DAC DMA request enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACDMAE_A { # [ doc = "0: DMA request disabled" ] DACDMAE_0 = 0 , # [ doc = "1: DMA request enabled" ] DACDMAE_1 = 1 } impl From < DACDMAE_A > for bool { # [ inline ( always ) ] fn from ( variant : DACDMAE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACDMAE`" ] pub type DACDMAE_R = crate :: R < bool , DACDMAE_A > ; impl DACDMAE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACDMAE_A { match self . bits { false => DACDMAE_A :: DACDMAE_0 , true => DACDMAE_A :: DACDMAE_1 } } # [ doc = "Checks if the value of the field is `DACDMAE_0`" ] # [ inline ( always ) ] pub fn is_dacdmae_0 ( & self ) -> bool { * self == DACDMAE_A :: DACDMAE_0 } # [ doc = "Checks if the value of the field is `DACDMAE_1`" ] # [ inline ( always ) ] pub fn is_dacdmae_1 ( & self ) -> bool { * self == DACDMAE_A :: DACDMAE_1 } }
# [ doc = "Write proxy for field `DACDMAE`" ] pub struct DACDMAE_W < 'a > { w : & 'a mut W , } impl < 'a > DACDMAE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACDMAE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "DMA request disabled" ] # [ inline ( always ) ] pub fn dacdmae_0 ( self ) -> & 'a mut W { self . variant ( DACDMAE_A :: DACDMAE_0 ) } # [ doc = "DMA request enabled" ] # [ inline ( always ) ] pub fn dacdmae_1 ( self ) -> & 'a mut W { self . variant ( DACDMAE_A :: DACDMAE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "SAC DAC load select. Selects the load trigger for the DAC latch.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum DACLSEL_A { # [ doc = "0: DAC latch loads when DACDAT written" ] DACLSEL_0 = 0 , # [ doc = "2: Device specific 0. DAC always loads data from DACDAT at the positive edge of this signal" ] DACLSEL_2 = 2 , # [ doc = "3: Device specific 1. DAC always loads data from DACDAT at the positive edge of this signal" ] DACLSEL_3 = 3 } impl From < DACLSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : DACLSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `DACLSEL`" ] pub type DACLSEL_R = crate :: R < u8 , DACLSEL_A > ; impl DACLSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , DACLSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( DACLSEL_A :: DACLSEL_0 ) , 2 => Val ( DACLSEL_A :: DACLSEL_2 ) , 3 => Val ( DACLSEL_A :: DACLSEL_3 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DACLSEL_0`" ] # [ inline ( always ) ] pub fn is_daclsel_0 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_0 } # [ doc = "Checks if the value of the field is `DACLSEL_2`" ] # [ inline ( always ) ] pub fn is_daclsel_2 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_2 } # [ doc = "Checks if the value of the field is `DACLSEL_3`" ] # [ inline ( always ) ] pub fn is_daclsel_3 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_3 } }
# [ doc = "Write proxy for field `DACLSEL`" ] pub struct DACLSEL_W < 'a > { w : & 'a mut W , } impl < 'a > DACLSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACLSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "DAC latch loads when DACDAT written" ] # [ inline ( always ) ] pub fn daclsel_0 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_0 ) } # [ doc = "Device specific 0. DAC always loads data from DACDAT at the positive edge of this signal" ] # [ inline ( always ) ] pub fn daclsel_2 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_2 ) } # [ doc = "Device specific 1. DAC always loads data from DACDAT at the positive edge of this signal" ] # [ inline ( always ) ] pub fn daclsel_3 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "SAC DAC select reference voltage\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACSREF_A { # [ doc = "0: AVCC" ] DACSREF_0 = 0 , # [ doc = "1: Alternative reference" ] DACSREF_1 = 1 } impl From < DACSREF_A > for bool { # [ inline ( always ) ] fn from ( variant : DACSREF_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACSREF`" ] pub type DACSREF_R = crate :: R < bool , DACSREF_A > ; impl DACSREF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACSREF_A { match self . bits { false => DACSREF_A :: DACSREF_0 , true => DACSREF_A :: DACSREF_1 } } # [ doc = "Checks if the value of the field is `DACSREF_0`" ] # [ inline ( always ) ] pub fn is_dacsref_0 ( & self ) -> bool { * self == DACSREF_A :: DACSREF_0 } # [ doc = "Checks if the value of the field is `DACSREF_1`" ] # [ inline ( always ) ] pub fn is_dacsref_1 ( & self ) -> bool { * self == DACSREF_A :: DACSREF_1 } }
# [ doc = "Write proxy for field `DACSREF`" ] pub struct DACSREF_W < 'a > { w : & 'a mut W , } impl < 'a > DACSREF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACSREF_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "AVCC" ] # [ inline ( always ) ] pub fn dacsref_0 ( self ) -> & 'a mut W { self . variant ( DACSREF_A :: DACSREF_0 ) } # [ doc = "Alternative reference" ] # [ inline ( always ) ] pub fn dacsref_1 ( self ) -> & 'a mut W { self . variant ( DACSREF_A :: DACSREF_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - SAC DAC enable" ] # [ inline ( always ) ] pub fn dacen ( & self ) -> DACEN_R { DACEN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - SAC DAC interrupt enable" ] # [ inline ( always ) ] pub fn dacie ( & self ) -> DACIE_R { DACIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - SAC DAC DMA request enable" ] # [ inline ( always ) ] pub fn dacdmae ( & self ) -> DACDMAE_R { DACDMAE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:9 - SAC DAC load select. Selects the load trigger for the DAC latch." ] # [ inline ( always ) ] pub fn daclsel ( & self ) -> DACLSEL_R { DACLSEL_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 12 - SAC DAC select reference voltage" ] # [ inline ( always ) ] pub fn dacsref ( & self ) -> DACSREF_R { DACSREF_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - SAC DAC enable" ] # [ inline ( always ) ] pub fn dacen ( & mut self ) -> DACEN_W { DACEN_W { w : self } }
# [ doc = "Bit 1 - SAC DAC interrupt enable" ] # [ inline ( always ) ] pub fn dacie ( & mut self ) -> DACIE_W { DACIE_W { w : self } }
# [ doc = "Bit 2 - SAC DAC DMA request enable" ] # [ inline ( always ) ] pub fn dacdmae ( & mut self ) -> DACDMAE_W { DACDMAE_W { w : self } }
# [ doc = "Bits 8:9 - SAC DAC load select. Selects the load trigger for the DAC latch." ] # [ inline ( always ) ] pub fn daclsel ( & mut self ) -> DACLSEL_W { DACLSEL_W { w : self } }
# [ doc = "Bit 12 - SAC DAC select reference voltage" ] # [ inline ( always ) ] pub fn dacsref ( & mut self ) -> DACSREF_W { DACSREF_W { w : self } }
}
}
# [ doc = "SAC DAC Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac0dat](sac0dat) module" ] pub type SAC0DAT = crate :: Reg < u16 , _SAC0DAT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC0DAT ;
# [ doc = "`read()` method returns [sac0dat::R](sac0dat::R) reader structure" ] impl crate :: Readable for SAC0DAT { }
# [ doc = "`write(|w| ..)` method takes [sac0dat::W](sac0dat::W) writer structure" ] impl crate :: Writable for SAC0DAT { }
# [ doc = "SAC DAC Data Register" ] pub mod sac0dat {
# [ doc = "Reader of register SAC0DAT" ] pub type R = crate :: R < u16 , super :: SAC0DAT > ;
# [ doc = "Writer for register SAC0DAT" ] pub type W = crate :: W < u16 , super :: SAC0DAT > ;
# [ doc = "Register SAC0DAT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC0DAT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DACData`" ] pub type DACDATA_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `DACData`" ] pub struct DACDATA_W < 'a > { w : & 'a mut W , } impl < 'a > DACDATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0fff ) | ( ( value as u16 ) & 0x0fff ) ; self . w } }
impl R {
# [ doc = "Bits 0:11 - SAC DAC data in unsigned format." ] # [ inline ( always ) ] pub fn dacdata ( & self ) -> DACDATA_R { DACDATA_R :: new ( ( self . bits & 0x0fff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:11 - SAC DAC data in unsigned format." ] # [ inline ( always ) ] pub fn dacdata ( & mut self ) -> DACDATA_W { DACDATA_W { w : self } }
}
}
# [ doc = "SAC DAC Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac0dacsts](sac0dacsts) module" ] pub type SAC0DACSTS = crate :: Reg < u16 , _SAC0DACSTS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC0DACSTS ;
# [ doc = "`read()` method returns [sac0dacsts::R](sac0dacsts::R) reader structure" ] impl crate :: Readable for SAC0DACSTS { }
# [ doc = "`write(|w| ..)` method takes [sac0dacsts::W](sac0dacsts::W) writer structure" ] impl crate :: Writable for SAC0DACSTS { }
# [ doc = "SAC DAC Status Register" ] pub mod sac0dacsts {
# [ doc = "Reader of register SAC0DACSTS" ] pub type R = crate :: R < u16 , super :: SAC0DACSTS > ;
# [ doc = "Writer for register SAC0DACSTS" ] pub type W = crate :: W < u16 , super :: SAC0DACSTS > ;
# [ doc = "Register SAC0DACSTS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC0DACSTS { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DACIFG`" ] pub type DACIFG_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DACIFG`" ] pub struct DACIFG_W < 'a > { w : & 'a mut W , } impl < 'a > DACIFG_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - SAC DAC data update flag" ] # [ inline ( always ) ] pub fn dacifg ( & self ) -> DACIFG_R { DACIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - SAC DAC data update flag" ] # [ inline ( always ) ] pub fn dacifg ( & mut self ) -> DACIFG_W { DACIFG_W { w : self } }
}
}
# [ doc = "SAC Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac0iv](sac0iv) module" ] pub type SAC0IV = crate :: Reg < u16 , _SAC0IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC0IV ;
# [ doc = "`read()` method returns [sac0iv::R](sac0iv::R) reader structure" ] impl crate :: Readable for SAC0IV { }
# [ doc = "SAC Interrupt Vector Register" ] pub mod sac0iv {
# [ doc = "Reader of register SAC0IV" ] pub type R = crate :: R < u16 , super :: SAC0IV > ;
# [ doc = "SAC Interrupt Vector Register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum SACIV0_A { # [ doc = "0: No interrupt pending" ] SACIV_0 = 0 , # [ doc = "2: S&H completed interrupt flag (Highest priority)" ] SACIV_2 = 2 , # [ doc = "4: DAC channel update interrupt flag" ] SACIV_4 = 4 } impl From < SACIV0_A > for u16 { # [ inline ( always ) ] fn from ( variant : SACIV0_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `SACIV0`" ] pub type SACIV0_R = crate :: R < u16 , SACIV0_A > ; impl SACIV0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , SACIV0_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SACIV0_A :: SACIV_0 ) , 2 => Val ( SACIV0_A :: SACIV_2 ) , 4 => Val ( SACIV0_A :: SACIV_4 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `SACIV_0`" ] # [ inline ( always ) ] pub fn is_saciv_0 ( & self ) -> bool { * self == SACIV0_A :: SACIV_0 } # [ doc = "Checks if the value of the field is `SACIV_2`" ] # [ inline ( always ) ] pub fn is_saciv_2 ( & self ) -> bool { * self == SACIV0_A :: SACIV_2 } # [ doc = "Checks if the value of the field is `SACIV_4`" ] # [ inline ( always ) ] pub fn is_saciv_4 ( & self ) -> bool { * self == SACIV0_A :: SACIV_4 } }
impl R {
# [ doc = "Bits 0:15 - SAC Interrupt Vector Register" ] # [ inline ( always ) ] pub fn saciv0 ( & self ) -> SACIV0_R { SACIV0_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "SAC1" ] pub struct SAC1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SAC1 { } impl SAC1 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const sac1 :: RegisterBlock { 0x0c90 as * const _ } } impl Deref for SAC1 { type Target = sac1 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * SAC1 :: ptr ( ) } } }
# [ doc = "SAC1" ] pub mod sac1 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - SAC OA Control Register" ] pub sac1oa : SAC1OA , # [ doc = "0x02 - SAC PGA Control Register" ] pub sac1pga : SAC1PGA , # [ doc = "0x04 - SAC DAC Control Register" ] pub sac1dac : SAC1DAC , # [ doc = "0x06 - SAC DAC Data Register" ] pub sac1dat : SAC1DAT , # [ doc = "0x08 - SAC DAC Status Register" ] pub sac1dacsts : SAC1DACSTS , # [ doc = "0x0a - SAC Interrupt Vector Register" ] pub sac1iv : SAC1IV , }
# [ doc = "SAC OA Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac1oa](sac1oa) module" ] pub type SAC1OA = crate :: Reg < u16 , _SAC1OA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC1OA ;
# [ doc = "`read()` method returns [sac1oa::R](sac1oa::R) reader structure" ] impl crate :: Readable for SAC1OA { }
# [ doc = "`write(|w| ..)` method takes [sac1oa::W](sac1oa::W) writer structure" ] impl crate :: Writable for SAC1OA { }
# [ doc = "SAC OA Control Register" ] pub mod sac1oa {
# [ doc = "Reader of register SAC1OA" ] pub type R = crate :: R < u16 , super :: SAC1OA > ;
# [ doc = "Writer for register SAC1OA" ] pub type W = crate :: W < u16 , super :: SAC1OA > ;
# [ doc = "Register SAC1OA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC1OA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC OA Positive input source selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum PSEL_A { # [ doc = "0: External source selected" ] PSEL_0 = 0 , # [ doc = "1: 12-bit reference DAC source selected" ] PSEL_1 = 1 , # [ doc = "2: Pair OA source selected" ] PSEL_2 = 2 } impl From < PSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : PSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `PSEL`" ] pub type PSEL_R = crate :: R < u8 , PSEL_A > ; impl PSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , PSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( PSEL_A :: PSEL_0 ) , 1 => Val ( PSEL_A :: PSEL_1 ) , 2 => Val ( PSEL_A :: PSEL_2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `PSEL_0`" ] # [ inline ( always ) ] pub fn is_psel_0 ( & self ) -> bool { * self == PSEL_A :: PSEL_0 } # [ doc = "Checks if the value of the field is `PSEL_1`" ] # [ inline ( always ) ] pub fn is_psel_1 ( & self ) -> bool { * self == PSEL_A :: PSEL_1 } # [ doc = "Checks if the value of the field is `PSEL_2`" ] # [ inline ( always ) ] pub fn is_psel_2 ( & self ) -> bool { * self == PSEL_A :: PSEL_2 } }
# [ doc = "Write proxy for field `PSEL`" ] pub struct PSEL_W < 'a > { w : & 'a mut W , } impl < 'a > PSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "External source selected" ] # [ inline ( always ) ] pub fn psel_0 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_0 ) } # [ doc = "12-bit reference DAC source selected" ] # [ inline ( always ) ] pub fn psel_1 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_1 ) } # [ doc = "Pair OA source selected" ] # [ inline ( always ) ] pub fn psel_2 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_2 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "SAC Positive input MUX control.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PMUXEN_A { # [ doc = "0: All positive input sources are disconnected to OA positive port" ] PMUXEN_0 = 0 , # [ doc = "1: All positive input sources are connected to OA positive port" ] PMUXEN_1 = 1 } impl From < PMUXEN_A > for bool { # [ inline ( always ) ] fn from ( variant : PMUXEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `PMUXEN`" ] pub type PMUXEN_R = crate :: R < bool , PMUXEN_A > ; impl PMUXEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PMUXEN_A { match self . bits { false => PMUXEN_A :: PMUXEN_0 , true => PMUXEN_A :: PMUXEN_1 } } # [ doc = "Checks if the value of the field is `PMUXEN_0`" ] # [ inline ( always ) ] pub fn is_pmuxen_0 ( & self ) -> bool { * self == PMUXEN_A :: PMUXEN_0 } # [ doc = "Checks if the value of the field is `PMUXEN_1`" ] # [ inline ( always ) ] pub fn is_pmuxen_1 ( & self ) -> bool { * self == PMUXEN_A :: PMUXEN_1 } }
# [ doc = "Write proxy for field `PMUXEN`" ] pub struct PMUXEN_W < 'a > { w : & 'a mut W , } impl < 'a > PMUXEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PMUXEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "All positive input sources are disconnected to OA positive port" ] # [ inline ( always ) ] pub fn pmuxen_0 ( self ) -> & 'a mut W { self . variant ( PMUXEN_A :: PMUXEN_0 ) } # [ doc = "All positive input sources are connected to OA positive port" ] # [ inline ( always ) ] pub fn pmuxen_1 ( self ) -> & 'a mut W { self . variant ( PMUXEN_A :: PMUXEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "SAC OA Negative input source selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum NSEL_A { # [ doc = "0: External source selected" ] NSEL_0 = 0 , # [ doc = "1: PGA source selected" ] NSEL_1 = 1 , # [ doc = "2: Device Specific" ] NSEL_2 = 2 } impl From < NSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : NSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `NSEL`" ] pub type NSEL_R = crate :: R < u8 , NSEL_A > ; impl NSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , NSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( NSEL_A :: NSEL_0 ) , 1 => Val ( NSEL_A :: NSEL_1 ) , 2 => Val ( NSEL_A :: NSEL_2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NSEL_0`" ] # [ inline ( always ) ] pub fn is_nsel_0 ( & self ) -> bool { * self == NSEL_A :: NSEL_0 } # [ doc = "Checks if the value of the field is `NSEL_1`" ] # [ inline ( always ) ] pub fn is_nsel_1 ( & self ) -> bool { * self == NSEL_A :: NSEL_1 } # [ doc = "Checks if the value of the field is `NSEL_2`" ] # [ inline ( always ) ] pub fn is_nsel_2 ( & self ) -> bool { * self == NSEL_A :: NSEL_2 } }
# [ doc = "Write proxy for field `NSEL`" ] pub struct NSEL_W < 'a > { w : & 'a mut W , } impl < 'a > NSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "External source selected" ] # [ inline ( always ) ] pub fn nsel_0 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_0 ) } # [ doc = "PGA source selected" ] # [ inline ( always ) ] pub fn nsel_1 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_1 ) } # [ doc = "Device Specific" ] # [ inline ( always ) ] pub fn nsel_2 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_2 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "SAC Negative input MUX controL\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum NMUXEN_A { # [ doc = "0: All negative input sources are disconnected to OA negative port" ] NMUXEN_0 = 0 , # [ doc = "1: All negative input sources are connected to OA negative port" ] NMUXEN_1 = 1 } impl From < NMUXEN_A > for bool { # [ inline ( always ) ] fn from ( variant : NMUXEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `NMUXEN`" ] pub type NMUXEN_R = crate :: R < bool , NMUXEN_A > ; impl NMUXEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> NMUXEN_A { match self . bits { false => NMUXEN_A :: NMUXEN_0 , true => NMUXEN_A :: NMUXEN_1 } } # [ doc = "Checks if the value of the field is `NMUXEN_0`" ] # [ inline ( always ) ] pub fn is_nmuxen_0 ( & self ) -> bool { * self == NMUXEN_A :: NMUXEN_0 } # [ doc = "Checks if the value of the field is `NMUXEN_1`" ] # [ inline ( always ) ] pub fn is_nmuxen_1 ( & self ) -> bool { * self == NMUXEN_A :: NMUXEN_1 } }
# [ doc = "Write proxy for field `NMUXEN`" ] pub struct NMUXEN_W < 'a > { w : & 'a mut W , } impl < 'a > NMUXEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NMUXEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "All negative input sources are disconnected to OA negative port" ] # [ inline ( always ) ] pub fn nmuxen_0 ( self ) -> & 'a mut W { self . variant ( NMUXEN_A :: NMUXEN_0 ) } # [ doc = "All negative input sources are connected to OA negative port" ] # [ inline ( always ) ] pub fn nmuxen_1 ( self ) -> & 'a mut W { self . variant ( NMUXEN_A :: NMUXEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "SAC OA Enable selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OAEN_A { # [ doc = "0: SAC OA is disabled, then the SAC OA output high impedance" ] OAEN_0 = 0 , # [ doc = "1: SAC OA is enabled, normal mode" ] OAEN_1 = 1 } impl From < OAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : OAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OAEN`" ] pub type OAEN_R = crate :: R < bool , OAEN_A > ; impl OAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OAEN_A { match self . bits { false => OAEN_A :: OAEN_0 , true => OAEN_A :: OAEN_1 } } # [ doc = "Checks if the value of the field is `OAEN_0`" ] # [ inline ( always ) ] pub fn is_oaen_0 ( & self ) -> bool { * self == OAEN_A :: OAEN_0 } # [ doc = "Checks if the value of the field is `OAEN_1`" ] # [ inline ( always ) ] pub fn is_oaen_1 ( & self ) -> bool { * self == OAEN_A :: OAEN_1 } }
# [ doc = "Write proxy for field `OAEN`" ] pub struct OAEN_W < 'a > { w : & 'a mut W , } impl < 'a > OAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SAC OA is disabled, then the SAC OA output high impedance" ] # [ inline ( always ) ] pub fn oaen_0 ( self ) -> & 'a mut W { self . variant ( OAEN_A :: OAEN_0 ) } # [ doc = "SAC OA is enabled, normal mode" ] # [ inline ( always ) ] pub fn oaen_1 ( self ) -> & 'a mut W { self . variant ( OAEN_A :: OAEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "SAC OA power mode selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OAPM_A { # [ doc = "0: High speed and high power" ] OAPM_0 = 0 , # [ doc = "1: Llow speed and low power" ] OAPM_1 = 1 } impl From < OAPM_A > for bool { # [ inline ( always ) ] fn from ( variant : OAPM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OAPM`" ] pub type OAPM_R = crate :: R < bool , OAPM_A > ; impl OAPM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OAPM_A { match self . bits { false => OAPM_A :: OAPM_0 , true => OAPM_A :: OAPM_1 } } # [ doc = "Checks if the value of the field is `OAPM_0`" ] # [ inline ( always ) ] pub fn is_oapm_0 ( & self ) -> bool { * self == OAPM_A :: OAPM_0 } # [ doc = "Checks if the value of the field is `OAPM_1`" ] # [ inline ( always ) ] pub fn is_oapm_1 ( & self ) -> bool { * self == OAPM_A :: OAPM_1 } }
# [ doc = "Write proxy for field `OAPM`" ] pub struct OAPM_W < 'a > { w : & 'a mut W , } impl < 'a > OAPM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OAPM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "High speed and high power" ] # [ inline ( always ) ] pub fn oapm_0 ( self ) -> & 'a mut W { self . variant ( OAPM_A :: OAPM_0 ) } # [ doc = "Llow speed and low power" ] # [ inline ( always ) ] pub fn oapm_1 ( self ) -> & 'a mut W { self . variant ( OAPM_A :: OAPM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "SAC Enable selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SACEN_A { # [ doc = "0: SAC all modules are disabled, then the SAC output high impedance" ] SACEN_0 = 0 , # [ doc = "1: SAC all modules are enabled, normal mode" ] SACEN_1 = 1 } impl From < SACEN_A > for bool { # [ inline ( always ) ] fn from ( variant : SACEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SACEN`" ] pub type SACEN_R = crate :: R < bool , SACEN_A > ; impl SACEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SACEN_A { match self . bits { false => SACEN_A :: SACEN_0 , true => SACEN_A :: SACEN_1 } } # [ doc = "Checks if the value of the field is `SACEN_0`" ] # [ inline ( always ) ] pub fn is_sacen_0 ( & self ) -> bool { * self == SACEN_A :: SACEN_0 } # [ doc = "Checks if the value of the field is `SACEN_1`" ] # [ inline ( always ) ] pub fn is_sacen_1 ( & self ) -> bool { * self == SACEN_A :: SACEN_1 } }
# [ doc = "Write proxy for field `SACEN`" ] pub struct SACEN_W < 'a > { w : & 'a mut W , } impl < 'a > SACEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SACEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SAC all modules are disabled, then the SAC output high impedance" ] # [ inline ( always ) ] pub fn sacen_0 ( self ) -> & 'a mut W { self . variant ( SACEN_A :: SACEN_0 ) } # [ doc = "SAC all modules are enabled, normal mode" ] # [ inline ( always ) ] pub fn sacen_1 ( self ) -> & 'a mut W { self . variant ( SACEN_A :: SACEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - SAC OA Positive input source selection" ] # [ inline ( always ) ] pub fn psel ( & self ) -> PSEL_R { PSEL_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bit 3 - SAC Positive input MUX control." ] # [ inline ( always ) ] pub fn pmuxen ( & self ) -> PMUXEN_R { PMUXEN_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - SAC OA Negative input source selection" ] # [ inline ( always ) ] pub fn nsel ( & self ) -> NSEL_R { NSEL_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 7 - SAC Negative input MUX controL" ] # [ inline ( always ) ] pub fn nmuxen ( & self ) -> NMUXEN_R { NMUXEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - SAC OA Enable selection" ] # [ inline ( always ) ] pub fn oaen ( & self ) -> OAEN_R { OAEN_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - SAC OA power mode selection" ] # [ inline ( always ) ] pub fn oapm ( & self ) -> OAPM_R { OAPM_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - SAC Enable selection" ] # [ inline ( always ) ] pub fn sacen ( & self ) -> SACEN_R { SACEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:1 - SAC OA Positive input source selection" ] # [ inline ( always ) ] pub fn psel ( & mut self ) -> PSEL_W { PSEL_W { w : self } }
# [ doc = "Bit 3 - SAC Positive input MUX control." ] # [ inline ( always ) ] pub fn pmuxen ( & mut self ) -> PMUXEN_W { PMUXEN_W { w : self } }
# [ doc = "Bits 4:5 - SAC OA Negative input source selection" ] # [ inline ( always ) ] pub fn nsel ( & mut self ) -> NSEL_W { NSEL_W { w : self } }
# [ doc = "Bit 7 - SAC Negative input MUX controL" ] # [ inline ( always ) ] pub fn nmuxen ( & mut self ) -> NMUXEN_W { NMUXEN_W { w : self } }
# [ doc = "Bit 8 - SAC OA Enable selection" ] # [ inline ( always ) ] pub fn oaen ( & mut self ) -> OAEN_W { OAEN_W { w : self } }
# [ doc = "Bit 9 - SAC OA power mode selection" ] # [ inline ( always ) ] pub fn oapm ( & mut self ) -> OAPM_W { OAPM_W { w : self } }
# [ doc = "Bit 10 - SAC Enable selection" ] # [ inline ( always ) ] pub fn sacen ( & mut self ) -> SACEN_W { SACEN_W { w : self } }
}
}
# [ doc = "SAC PGA Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac1pga](sac1pga) module" ] pub type SAC1PGA = crate :: Reg < u16 , _SAC1PGA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC1PGA ;
# [ doc = "`read()` method returns [sac1pga::R](sac1pga::R) reader structure" ] impl crate :: Readable for SAC1PGA { }
# [ doc = "`write(|w| ..)` method takes [sac1pga::W](sac1pga::W) writer structure" ] impl crate :: Writable for SAC1PGA { }
# [ doc = "SAC PGA Control Register" ] pub mod sac1pga {
# [ doc = "Reader of register SAC1PGA" ] pub type R = crate :: R < u16 , super :: SAC1PGA > ;
# [ doc = "Writer for register SAC1PGA" ] pub type W = crate :: W < u16 , super :: SAC1PGA > ;
# [ doc = "Register SAC1PGA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC1PGA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC PGA Mode Selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum MSEL_A { # [ doc = "0: Inverting PGA mode (external pad IN- is selected)" ] MSEL_0 = 0 , # [ doc = "1: Buffer mode (floating is selected )" ] MSEL_1 = 1 , # [ doc = "2: Non-inverting mode" ] MSEL_2 = 2 , # [ doc = "3: Cascade OA Inverting mode" ] MSEL_3 = 3 } impl From < MSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : MSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `MSEL`" ] pub type MSEL_R = crate :: R < u8 , MSEL_A > ; impl MSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MSEL_A { match self . bits { 0 => MSEL_A :: MSEL_0 , 1 => MSEL_A :: MSEL_1 , 2 => MSEL_A :: MSEL_2 , 3 => MSEL_A :: MSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `MSEL_0`" ] # [ inline ( always ) ] pub fn is_msel_0 ( & self ) -> bool { * self == MSEL_A :: MSEL_0 } # [ doc = "Checks if the value of the field is `MSEL_1`" ] # [ inline ( always ) ] pub fn is_msel_1 ( & self ) -> bool { * self == MSEL_A :: MSEL_1 } # [ doc = "Checks if the value of the field is `MSEL_2`" ] # [ inline ( always ) ] pub fn is_msel_2 ( & self ) -> bool { * self == MSEL_A :: MSEL_2 } # [ doc = "Checks if the value of the field is `MSEL_3`" ] # [ inline ( always ) ] pub fn is_msel_3 ( & self ) -> bool { * self == MSEL_A :: MSEL_3 } }
# [ doc = "Write proxy for field `MSEL`" ] pub struct MSEL_W < 'a > { w : & 'a mut W , } impl < 'a > MSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Inverting PGA mode (external pad IN- is selected)" ] # [ inline ( always ) ] pub fn msel_0 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_0 ) } # [ doc = "Buffer mode (floating is selected )" ] # [ inline ( always ) ] pub fn msel_1 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_1 ) } # [ doc = "Non-inverting mode" ] # [ inline ( always ) ] pub fn msel_2 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_2 ) } # [ doc = "Cascade OA Inverting mode" ] # [ inline ( always ) ] pub fn msel_3 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `GAIN`" ] pub type GAIN_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `GAIN`" ] pub struct GAIN_W < 'a > { w : & 'a mut W , } impl < 'a > GAIN_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 4 ) ) | ( ( ( value as u16 ) & 0x07 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - SAC PGA Mode Selection" ] # [ inline ( always ) ] pub fn msel ( & self ) -> MSEL_R { MSEL_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 4:6 - SAC PGA Gain configuration" ] # [ inline ( always ) ] pub fn gain ( & self ) -> GAIN_R { GAIN_R :: new ( ( ( self . bits >> 4 ) & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - SAC PGA Mode Selection" ] # [ inline ( always ) ] pub fn msel ( & mut self ) -> MSEL_W { MSEL_W { w : self } }
# [ doc = "Bits 4:6 - SAC PGA Gain configuration" ] # [ inline ( always ) ] pub fn gain ( & mut self ) -> GAIN_W { GAIN_W { w : self } }
}
}
# [ doc = "SAC DAC Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac1dac](sac1dac) module" ] pub type SAC1DAC = crate :: Reg < u16 , _SAC1DAC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC1DAC ;
# [ doc = "`read()` method returns [sac1dac::R](sac1dac::R) reader structure" ] impl crate :: Readable for SAC1DAC { }
# [ doc = "`write(|w| ..)` method takes [sac1dac::W](sac1dac::W) writer structure" ] impl crate :: Writable for SAC1DAC { }
# [ doc = "SAC DAC Control Register" ] pub mod sac1dac {
# [ doc = "Reader of register SAC1DAC" ] pub type R = crate :: R < u16 , super :: SAC1DAC > ;
# [ doc = "Writer for register SAC1DAC" ] pub type W = crate :: W < u16 , super :: SAC1DAC > ;
# [ doc = "Register SAC1DAC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC1DAC { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC DAC enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACEN_A { # [ doc = "0: Disabled" ] DACEN_0 = 0 , # [ doc = "1: Enabled" ] DACEN_1 = 1 } impl From < DACEN_A > for bool { # [ inline ( always ) ] fn from ( variant : DACEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACEN`" ] pub type DACEN_R = crate :: R < bool , DACEN_A > ; impl DACEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACEN_A { match self . bits { false => DACEN_A :: DACEN_0 , true => DACEN_A :: DACEN_1 } } # [ doc = "Checks if the value of the field is `DACEN_0`" ] # [ inline ( always ) ] pub fn is_dacen_0 ( & self ) -> bool { * self == DACEN_A :: DACEN_0 } # [ doc = "Checks if the value of the field is `DACEN_1`" ] # [ inline ( always ) ] pub fn is_dacen_1 ( & self ) -> bool { * self == DACEN_A :: DACEN_1 } }
# [ doc = "Write proxy for field `DACEN`" ] pub struct DACEN_W < 'a > { w : & 'a mut W , } impl < 'a > DACEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn dacen_0 ( self ) -> & 'a mut W { self . variant ( DACEN_A :: DACEN_0 ) } # [ doc = "Enabled" ] # [ inline ( always ) ] pub fn dacen_1 ( self ) -> & 'a mut W { self . variant ( DACEN_A :: DACEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "SAC DAC interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACIE_A { # [ doc = "0: Disabled" ] DACIE_0 = 0 , # [ doc = "1: Enabled" ] DACIE_1 = 1 } impl From < DACIE_A > for bool { # [ inline ( always ) ] fn from ( variant : DACIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACIE`" ] pub type DACIE_R = crate :: R < bool , DACIE_A > ; impl DACIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACIE_A { match self . bits { false => DACIE_A :: DACIE_0 , true => DACIE_A :: DACIE_1 } } # [ doc = "Checks if the value of the field is `DACIE_0`" ] # [ inline ( always ) ] pub fn is_dacie_0 ( & self ) -> bool { * self == DACIE_A :: DACIE_0 } # [ doc = "Checks if the value of the field is `DACIE_1`" ] # [ inline ( always ) ] pub fn is_dacie_1 ( & self ) -> bool { * self == DACIE_A :: DACIE_1 } }
# [ doc = "Write proxy for field `DACIE`" ] pub struct DACIE_W < 'a > { w : & 'a mut W , } impl < 'a > DACIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn dacie_0 ( self ) -> & 'a mut W { self . variant ( DACIE_A :: DACIE_0 ) } # [ doc = "Enabled" ] # [ inline ( always ) ] pub fn dacie_1 ( self ) -> & 'a mut W { self . variant ( DACIE_A :: DACIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "SAC DAC DMA request enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACDMAE_A { # [ doc = "0: DMA request disabled" ] DACDMAE_0 = 0 , # [ doc = "1: DMA request enabled" ] DACDMAE_1 = 1 } impl From < DACDMAE_A > for bool { # [ inline ( always ) ] fn from ( variant : DACDMAE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACDMAE`" ] pub type DACDMAE_R = crate :: R < bool , DACDMAE_A > ; impl DACDMAE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACDMAE_A { match self . bits { false => DACDMAE_A :: DACDMAE_0 , true => DACDMAE_A :: DACDMAE_1 } } # [ doc = "Checks if the value of the field is `DACDMAE_0`" ] # [ inline ( always ) ] pub fn is_dacdmae_0 ( & self ) -> bool { * self == DACDMAE_A :: DACDMAE_0 } # [ doc = "Checks if the value of the field is `DACDMAE_1`" ] # [ inline ( always ) ] pub fn is_dacdmae_1 ( & self ) -> bool { * self == DACDMAE_A :: DACDMAE_1 } }
# [ doc = "Write proxy for field `DACDMAE`" ] pub struct DACDMAE_W < 'a > { w : & 'a mut W , } impl < 'a > DACDMAE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACDMAE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "DMA request disabled" ] # [ inline ( always ) ] pub fn dacdmae_0 ( self ) -> & 'a mut W { self . variant ( DACDMAE_A :: DACDMAE_0 ) } # [ doc = "DMA request enabled" ] # [ inline ( always ) ] pub fn dacdmae_1 ( self ) -> & 'a mut W { self . variant ( DACDMAE_A :: DACDMAE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "SAC DAC load select. Selects the load trigger for the DAC latch.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum DACLSEL_A { # [ doc = "0: DAC latch loads when DACDAT written" ] DACLSEL_0 = 0 , # [ doc = "2: Device specific 0. DAC always loads data from DACDAT at the positive edge of this signal" ] DACLSEL_2 = 2 , # [ doc = "3: Device specific 1. DAC always loads data from DACDAT at the positive edge of this signal" ] DACLSEL_3 = 3 } impl From < DACLSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : DACLSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `DACLSEL`" ] pub type DACLSEL_R = crate :: R < u8 , DACLSEL_A > ; impl DACLSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , DACLSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( DACLSEL_A :: DACLSEL_0 ) , 2 => Val ( DACLSEL_A :: DACLSEL_2 ) , 3 => Val ( DACLSEL_A :: DACLSEL_3 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DACLSEL_0`" ] # [ inline ( always ) ] pub fn is_daclsel_0 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_0 } # [ doc = "Checks if the value of the field is `DACLSEL_2`" ] # [ inline ( always ) ] pub fn is_daclsel_2 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_2 } # [ doc = "Checks if the value of the field is `DACLSEL_3`" ] # [ inline ( always ) ] pub fn is_daclsel_3 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_3 } }
# [ doc = "Write proxy for field `DACLSEL`" ] pub struct DACLSEL_W < 'a > { w : & 'a mut W , } impl < 'a > DACLSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACLSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "DAC latch loads when DACDAT written" ] # [ inline ( always ) ] pub fn daclsel_0 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_0 ) } # [ doc = "Device specific 0. DAC always loads data from DACDAT at the positive edge of this signal" ] # [ inline ( always ) ] pub fn daclsel_2 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_2 ) } # [ doc = "Device specific 1. DAC always loads data from DACDAT at the positive edge of this signal" ] # [ inline ( always ) ] pub fn daclsel_3 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "SAC DAC select reference voltage\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACSREF_A { # [ doc = "0: AVCC" ] DACSREF_0 = 0 , # [ doc = "1: Alternative reference" ] DACSREF_1 = 1 } impl From < DACSREF_A > for bool { # [ inline ( always ) ] fn from ( variant : DACSREF_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACSREF`" ] pub type DACSREF_R = crate :: R < bool , DACSREF_A > ; impl DACSREF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACSREF_A { match self . bits { false => DACSREF_A :: DACSREF_0 , true => DACSREF_A :: DACSREF_1 } } # [ doc = "Checks if the value of the field is `DACSREF_0`" ] # [ inline ( always ) ] pub fn is_dacsref_0 ( & self ) -> bool { * self == DACSREF_A :: DACSREF_0 } # [ doc = "Checks if the value of the field is `DACSREF_1`" ] # [ inline ( always ) ] pub fn is_dacsref_1 ( & self ) -> bool { * self == DACSREF_A :: DACSREF_1 } }
# [ doc = "Write proxy for field `DACSREF`" ] pub struct DACSREF_W < 'a > { w : & 'a mut W , } impl < 'a > DACSREF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACSREF_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "AVCC" ] # [ inline ( always ) ] pub fn dacsref_0 ( self ) -> & 'a mut W { self . variant ( DACSREF_A :: DACSREF_0 ) } # [ doc = "Alternative reference" ] # [ inline ( always ) ] pub fn dacsref_1 ( self ) -> & 'a mut W { self . variant ( DACSREF_A :: DACSREF_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - SAC DAC enable" ] # [ inline ( always ) ] pub fn dacen ( & self ) -> DACEN_R { DACEN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - SAC DAC interrupt enable" ] # [ inline ( always ) ] pub fn dacie ( & self ) -> DACIE_R { DACIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - SAC DAC DMA request enable" ] # [ inline ( always ) ] pub fn dacdmae ( & self ) -> DACDMAE_R { DACDMAE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:9 - SAC DAC load select. Selects the load trigger for the DAC latch." ] # [ inline ( always ) ] pub fn daclsel ( & self ) -> DACLSEL_R { DACLSEL_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 12 - SAC DAC select reference voltage" ] # [ inline ( always ) ] pub fn dacsref ( & self ) -> DACSREF_R { DACSREF_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - SAC DAC enable" ] # [ inline ( always ) ] pub fn dacen ( & mut self ) -> DACEN_W { DACEN_W { w : self } }
# [ doc = "Bit 1 - SAC DAC interrupt enable" ] # [ inline ( always ) ] pub fn dacie ( & mut self ) -> DACIE_W { DACIE_W { w : self } }
# [ doc = "Bit 2 - SAC DAC DMA request enable" ] # [ inline ( always ) ] pub fn dacdmae ( & mut self ) -> DACDMAE_W { DACDMAE_W { w : self } }
# [ doc = "Bits 8:9 - SAC DAC load select. Selects the load trigger for the DAC latch." ] # [ inline ( always ) ] pub fn daclsel ( & mut self ) -> DACLSEL_W { DACLSEL_W { w : self } }
# [ doc = "Bit 12 - SAC DAC select reference voltage" ] # [ inline ( always ) ] pub fn dacsref ( & mut self ) -> DACSREF_W { DACSREF_W { w : self } }
}
}
# [ doc = "SAC DAC Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac1dat](sac1dat) module" ] pub type SAC1DAT = crate :: Reg < u16 , _SAC1DAT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC1DAT ;
# [ doc = "`read()` method returns [sac1dat::R](sac1dat::R) reader structure" ] impl crate :: Readable for SAC1DAT { }
# [ doc = "`write(|w| ..)` method takes [sac1dat::W](sac1dat::W) writer structure" ] impl crate :: Writable for SAC1DAT { }
# [ doc = "SAC DAC Data Register" ] pub mod sac1dat {
# [ doc = "Reader of register SAC1DAT" ] pub type R = crate :: R < u16 , super :: SAC1DAT > ;
# [ doc = "Writer for register SAC1DAT" ] pub type W = crate :: W < u16 , super :: SAC1DAT > ;
# [ doc = "Register SAC1DAT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC1DAT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DACData`" ] pub type DACDATA_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `DACData`" ] pub struct DACDATA_W < 'a > { w : & 'a mut W , } impl < 'a > DACDATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0fff ) | ( ( value as u16 ) & 0x0fff ) ; self . w } }
impl R {
# [ doc = "Bits 0:11 - SAC DAC data in unsigned format." ] # [ inline ( always ) ] pub fn dacdata ( & self ) -> DACDATA_R { DACDATA_R :: new ( ( self . bits & 0x0fff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:11 - SAC DAC data in unsigned format." ] # [ inline ( always ) ] pub fn dacdata ( & mut self ) -> DACDATA_W { DACDATA_W { w : self } }
}
}
# [ doc = "SAC DAC Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac1dacsts](sac1dacsts) module" ] pub type SAC1DACSTS = crate :: Reg < u16 , _SAC1DACSTS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC1DACSTS ;
# [ doc = "`read()` method returns [sac1dacsts::R](sac1dacsts::R) reader structure" ] impl crate :: Readable for SAC1DACSTS { }
# [ doc = "`write(|w| ..)` method takes [sac1dacsts::W](sac1dacsts::W) writer structure" ] impl crate :: Writable for SAC1DACSTS { }
# [ doc = "SAC DAC Status Register" ] pub mod sac1dacsts {
# [ doc = "Reader of register SAC1DACSTS" ] pub type R = crate :: R < u16 , super :: SAC1DACSTS > ;
# [ doc = "Writer for register SAC1DACSTS" ] pub type W = crate :: W < u16 , super :: SAC1DACSTS > ;
# [ doc = "Register SAC1DACSTS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC1DACSTS { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DACIFG`" ] pub type DACIFG_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DACIFG`" ] pub struct DACIFG_W < 'a > { w : & 'a mut W , } impl < 'a > DACIFG_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - SAC DAC data update flag" ] # [ inline ( always ) ] pub fn dacifg ( & self ) -> DACIFG_R { DACIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - SAC DAC data update flag" ] # [ inline ( always ) ] pub fn dacifg ( & mut self ) -> DACIFG_W { DACIFG_W { w : self } }
}
}
# [ doc = "SAC Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac1iv](sac1iv) module" ] pub type SAC1IV = crate :: Reg < u16 , _SAC1IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC1IV ;
# [ doc = "`read()` method returns [sac1iv::R](sac1iv::R) reader structure" ] impl crate :: Readable for SAC1IV { }
# [ doc = "SAC Interrupt Vector Register" ] pub mod sac1iv {
# [ doc = "Reader of register SAC1IV" ] pub type R = crate :: R < u16 , super :: SAC1IV > ;
# [ doc = "SAC Interrupt Vector Register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum SACIV1_A { # [ doc = "0: No interrupt pending" ] SACIV_0 = 0 , # [ doc = "2: S&H completed interrupt flag (Highest priority)" ] SACIV_2 = 2 , # [ doc = "4: DAC channel update interrupt flag" ] SACIV_4 = 4 } impl From < SACIV1_A > for u16 { # [ inline ( always ) ] fn from ( variant : SACIV1_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `SACIV1`" ] pub type SACIV1_R = crate :: R < u16 , SACIV1_A > ; impl SACIV1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , SACIV1_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SACIV1_A :: SACIV_0 ) , 2 => Val ( SACIV1_A :: SACIV_2 ) , 4 => Val ( SACIV1_A :: SACIV_4 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `SACIV_0`" ] # [ inline ( always ) ] pub fn is_saciv_0 ( & self ) -> bool { * self == SACIV1_A :: SACIV_0 } # [ doc = "Checks if the value of the field is `SACIV_2`" ] # [ inline ( always ) ] pub fn is_saciv_2 ( & self ) -> bool { * self == SACIV1_A :: SACIV_2 } # [ doc = "Checks if the value of the field is `SACIV_4`" ] # [ inline ( always ) ] pub fn is_saciv_4 ( & self ) -> bool { * self == SACIV1_A :: SACIV_4 } }
impl R {
# [ doc = "Bits 0:15 - SAC Interrupt Vector Register" ] # [ inline ( always ) ] pub fn saciv1 ( & self ) -> SACIV1_R { SACIV1_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "SAC2" ] pub struct SAC2 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SAC2 { } impl SAC2 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const sac2 :: RegisterBlock { 0x0ca0 as * const _ } } impl Deref for SAC2 { type Target = sac2 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * SAC2 :: ptr ( ) } } }
# [ doc = "SAC2" ] pub mod sac2 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - SAC OA Control Register" ] pub sac2oa : SAC2OA , # [ doc = "0x02 - SAC PGA Control Register" ] pub sac2pga : SAC2PGA , # [ doc = "0x04 - SAC DAC Control Register" ] pub sac2dac : SAC2DAC , # [ doc = "0x06 - SAC DAC Data Register" ] pub sac2dat : SAC2DAT , # [ doc = "0x08 - SAC DAC Status Register" ] pub sac2dacsts : SAC2DACSTS , # [ doc = "0x0a - SAC Interrupt Vector Register" ] pub sac2iv : SAC2IV , }
# [ doc = "SAC OA Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac2oa](sac2oa) module" ] pub type SAC2OA = crate :: Reg < u16 , _SAC2OA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC2OA ;
# [ doc = "`read()` method returns [sac2oa::R](sac2oa::R) reader structure" ] impl crate :: Readable for SAC2OA { }
# [ doc = "`write(|w| ..)` method takes [sac2oa::W](sac2oa::W) writer structure" ] impl crate :: Writable for SAC2OA { }
# [ doc = "SAC OA Control Register" ] pub mod sac2oa {
# [ doc = "Reader of register SAC2OA" ] pub type R = crate :: R < u16 , super :: SAC2OA > ;
# [ doc = "Writer for register SAC2OA" ] pub type W = crate :: W < u16 , super :: SAC2OA > ;
# [ doc = "Register SAC2OA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC2OA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC OA Positive input source selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum PSEL_A { # [ doc = "0: External source selected" ] PSEL_0 = 0 , # [ doc = "1: 12-bit reference DAC source selected" ] PSEL_1 = 1 , # [ doc = "2: Pair OA source selected" ] PSEL_2 = 2 } impl From < PSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : PSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `PSEL`" ] pub type PSEL_R = crate :: R < u8 , PSEL_A > ; impl PSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , PSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( PSEL_A :: PSEL_0 ) , 1 => Val ( PSEL_A :: PSEL_1 ) , 2 => Val ( PSEL_A :: PSEL_2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `PSEL_0`" ] # [ inline ( always ) ] pub fn is_psel_0 ( & self ) -> bool { * self == PSEL_A :: PSEL_0 } # [ doc = "Checks if the value of the field is `PSEL_1`" ] # [ inline ( always ) ] pub fn is_psel_1 ( & self ) -> bool { * self == PSEL_A :: PSEL_1 } # [ doc = "Checks if the value of the field is `PSEL_2`" ] # [ inline ( always ) ] pub fn is_psel_2 ( & self ) -> bool { * self == PSEL_A :: PSEL_2 } }
# [ doc = "Write proxy for field `PSEL`" ] pub struct PSEL_W < 'a > { w : & 'a mut W , } impl < 'a > PSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "External source selected" ] # [ inline ( always ) ] pub fn psel_0 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_0 ) } # [ doc = "12-bit reference DAC source selected" ] # [ inline ( always ) ] pub fn psel_1 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_1 ) } # [ doc = "Pair OA source selected" ] # [ inline ( always ) ] pub fn psel_2 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_2 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "SAC Positive input MUX control.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PMUXEN_A { # [ doc = "0: All positive input sources are disconnected to OA positive port" ] PMUXEN_0 = 0 , # [ doc = "1: All positive input sources are connected to OA positive port" ] PMUXEN_1 = 1 } impl From < PMUXEN_A > for bool { # [ inline ( always ) ] fn from ( variant : PMUXEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `PMUXEN`" ] pub type PMUXEN_R = crate :: R < bool , PMUXEN_A > ; impl PMUXEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PMUXEN_A { match self . bits { false => PMUXEN_A :: PMUXEN_0 , true => PMUXEN_A :: PMUXEN_1 } } # [ doc = "Checks if the value of the field is `PMUXEN_0`" ] # [ inline ( always ) ] pub fn is_pmuxen_0 ( & self ) -> bool { * self == PMUXEN_A :: PMUXEN_0 } # [ doc = "Checks if the value of the field is `PMUXEN_1`" ] # [ inline ( always ) ] pub fn is_pmuxen_1 ( & self ) -> bool { * self == PMUXEN_A :: PMUXEN_1 } }
# [ doc = "Write proxy for field `PMUXEN`" ] pub struct PMUXEN_W < 'a > { w : & 'a mut W , } impl < 'a > PMUXEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PMUXEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "All positive input sources are disconnected to OA positive port" ] # [ inline ( always ) ] pub fn pmuxen_0 ( self ) -> & 'a mut W { self . variant ( PMUXEN_A :: PMUXEN_0 ) } # [ doc = "All positive input sources are connected to OA positive port" ] # [ inline ( always ) ] pub fn pmuxen_1 ( self ) -> & 'a mut W { self . variant ( PMUXEN_A :: PMUXEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "SAC OA Negative input source selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum NSEL_A { # [ doc = "0: External source selected" ] NSEL_0 = 0 , # [ doc = "1: PGA source selected" ] NSEL_1 = 1 , # [ doc = "2: Device Specific" ] NSEL_2 = 2 } impl From < NSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : NSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `NSEL`" ] pub type NSEL_R = crate :: R < u8 , NSEL_A > ; impl NSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , NSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( NSEL_A :: NSEL_0 ) , 1 => Val ( NSEL_A :: NSEL_1 ) , 2 => Val ( NSEL_A :: NSEL_2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NSEL_0`" ] # [ inline ( always ) ] pub fn is_nsel_0 ( & self ) -> bool { * self == NSEL_A :: NSEL_0 } # [ doc = "Checks if the value of the field is `NSEL_1`" ] # [ inline ( always ) ] pub fn is_nsel_1 ( & self ) -> bool { * self == NSEL_A :: NSEL_1 } # [ doc = "Checks if the value of the field is `NSEL_2`" ] # [ inline ( always ) ] pub fn is_nsel_2 ( & self ) -> bool { * self == NSEL_A :: NSEL_2 } }
# [ doc = "Write proxy for field `NSEL`" ] pub struct NSEL_W < 'a > { w : & 'a mut W , } impl < 'a > NSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "External source selected" ] # [ inline ( always ) ] pub fn nsel_0 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_0 ) } # [ doc = "PGA source selected" ] # [ inline ( always ) ] pub fn nsel_1 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_1 ) } # [ doc = "Device Specific" ] # [ inline ( always ) ] pub fn nsel_2 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_2 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "SAC Negative input MUX controL\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum NMUXEN_A { # [ doc = "0: All negative input sources are disconnected to OA negative port" ] NMUXEN_0 = 0 , # [ doc = "1: All negative input sources are connected to OA negative port" ] NMUXEN_1 = 1 } impl From < NMUXEN_A > for bool { # [ inline ( always ) ] fn from ( variant : NMUXEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `NMUXEN`" ] pub type NMUXEN_R = crate :: R < bool , NMUXEN_A > ; impl NMUXEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> NMUXEN_A { match self . bits { false => NMUXEN_A :: NMUXEN_0 , true => NMUXEN_A :: NMUXEN_1 } } # [ doc = "Checks if the value of the field is `NMUXEN_0`" ] # [ inline ( always ) ] pub fn is_nmuxen_0 ( & self ) -> bool { * self == NMUXEN_A :: NMUXEN_0 } # [ doc = "Checks if the value of the field is `NMUXEN_1`" ] # [ inline ( always ) ] pub fn is_nmuxen_1 ( & self ) -> bool { * self == NMUXEN_A :: NMUXEN_1 } }
# [ doc = "Write proxy for field `NMUXEN`" ] pub struct NMUXEN_W < 'a > { w : & 'a mut W , } impl < 'a > NMUXEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NMUXEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "All negative input sources are disconnected to OA negative port" ] # [ inline ( always ) ] pub fn nmuxen_0 ( self ) -> & 'a mut W { self . variant ( NMUXEN_A :: NMUXEN_0 ) } # [ doc = "All negative input sources are connected to OA negative port" ] # [ inline ( always ) ] pub fn nmuxen_1 ( self ) -> & 'a mut W { self . variant ( NMUXEN_A :: NMUXEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "SAC OA Enable selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OAEN_A { # [ doc = "0: SAC OA is disabled, then the SAC OA output high impedance" ] OAEN_0 = 0 , # [ doc = "1: SAC OA is enabled, normal mode" ] OAEN_1 = 1 } impl From < OAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : OAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OAEN`" ] pub type OAEN_R = crate :: R < bool , OAEN_A > ; impl OAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OAEN_A { match self . bits { false => OAEN_A :: OAEN_0 , true => OAEN_A :: OAEN_1 } } # [ doc = "Checks if the value of the field is `OAEN_0`" ] # [ inline ( always ) ] pub fn is_oaen_0 ( & self ) -> bool { * self == OAEN_A :: OAEN_0 } # [ doc = "Checks if the value of the field is `OAEN_1`" ] # [ inline ( always ) ] pub fn is_oaen_1 ( & self ) -> bool { * self == OAEN_A :: OAEN_1 } }
# [ doc = "Write proxy for field `OAEN`" ] pub struct OAEN_W < 'a > { w : & 'a mut W , } impl < 'a > OAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SAC OA is disabled, then the SAC OA output high impedance" ] # [ inline ( always ) ] pub fn oaen_0 ( self ) -> & 'a mut W { self . variant ( OAEN_A :: OAEN_0 ) } # [ doc = "SAC OA is enabled, normal mode" ] # [ inline ( always ) ] pub fn oaen_1 ( self ) -> & 'a mut W { self . variant ( OAEN_A :: OAEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "SAC OA power mode selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OAPM_A { # [ doc = "0: High speed and high power" ] OAPM_0 = 0 , # [ doc = "1: Llow speed and low power" ] OAPM_1 = 1 } impl From < OAPM_A > for bool { # [ inline ( always ) ] fn from ( variant : OAPM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OAPM`" ] pub type OAPM_R = crate :: R < bool , OAPM_A > ; impl OAPM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OAPM_A { match self . bits { false => OAPM_A :: OAPM_0 , true => OAPM_A :: OAPM_1 } } # [ doc = "Checks if the value of the field is `OAPM_0`" ] # [ inline ( always ) ] pub fn is_oapm_0 ( & self ) -> bool { * self == OAPM_A :: OAPM_0 } # [ doc = "Checks if the value of the field is `OAPM_1`" ] # [ inline ( always ) ] pub fn is_oapm_1 ( & self ) -> bool { * self == OAPM_A :: OAPM_1 } }
# [ doc = "Write proxy for field `OAPM`" ] pub struct OAPM_W < 'a > { w : & 'a mut W , } impl < 'a > OAPM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OAPM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "High speed and high power" ] # [ inline ( always ) ] pub fn oapm_0 ( self ) -> & 'a mut W { self . variant ( OAPM_A :: OAPM_0 ) } # [ doc = "Llow speed and low power" ] # [ inline ( always ) ] pub fn oapm_1 ( self ) -> & 'a mut W { self . variant ( OAPM_A :: OAPM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "SAC Enable selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SACEN_A { # [ doc = "0: SAC all modules are disabled, then the SAC output high impedance" ] SACEN_0 = 0 , # [ doc = "1: SAC all modules are enabled, normal mode" ] SACEN_1 = 1 } impl From < SACEN_A > for bool { # [ inline ( always ) ] fn from ( variant : SACEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SACEN`" ] pub type SACEN_R = crate :: R < bool , SACEN_A > ; impl SACEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SACEN_A { match self . bits { false => SACEN_A :: SACEN_0 , true => SACEN_A :: SACEN_1 } } # [ doc = "Checks if the value of the field is `SACEN_0`" ] # [ inline ( always ) ] pub fn is_sacen_0 ( & self ) -> bool { * self == SACEN_A :: SACEN_0 } # [ doc = "Checks if the value of the field is `SACEN_1`" ] # [ inline ( always ) ] pub fn is_sacen_1 ( & self ) -> bool { * self == SACEN_A :: SACEN_1 } }
# [ doc = "Write proxy for field `SACEN`" ] pub struct SACEN_W < 'a > { w : & 'a mut W , } impl < 'a > SACEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SACEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SAC all modules are disabled, then the SAC output high impedance" ] # [ inline ( always ) ] pub fn sacen_0 ( self ) -> & 'a mut W { self . variant ( SACEN_A :: SACEN_0 ) } # [ doc = "SAC all modules are enabled, normal mode" ] # [ inline ( always ) ] pub fn sacen_1 ( self ) -> & 'a mut W { self . variant ( SACEN_A :: SACEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - SAC OA Positive input source selection" ] # [ inline ( always ) ] pub fn psel ( & self ) -> PSEL_R { PSEL_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bit 3 - SAC Positive input MUX control." ] # [ inline ( always ) ] pub fn pmuxen ( & self ) -> PMUXEN_R { PMUXEN_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - SAC OA Negative input source selection" ] # [ inline ( always ) ] pub fn nsel ( & self ) -> NSEL_R { NSEL_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 7 - SAC Negative input MUX controL" ] # [ inline ( always ) ] pub fn nmuxen ( & self ) -> NMUXEN_R { NMUXEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - SAC OA Enable selection" ] # [ inline ( always ) ] pub fn oaen ( & self ) -> OAEN_R { OAEN_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - SAC OA power mode selection" ] # [ inline ( always ) ] pub fn oapm ( & self ) -> OAPM_R { OAPM_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - SAC Enable selection" ] # [ inline ( always ) ] pub fn sacen ( & self ) -> SACEN_R { SACEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:1 - SAC OA Positive input source selection" ] # [ inline ( always ) ] pub fn psel ( & mut self ) -> PSEL_W { PSEL_W { w : self } }
# [ doc = "Bit 3 - SAC Positive input MUX control." ] # [ inline ( always ) ] pub fn pmuxen ( & mut self ) -> PMUXEN_W { PMUXEN_W { w : self } }
# [ doc = "Bits 4:5 - SAC OA Negative input source selection" ] # [ inline ( always ) ] pub fn nsel ( & mut self ) -> NSEL_W { NSEL_W { w : self } }
# [ doc = "Bit 7 - SAC Negative input MUX controL" ] # [ inline ( always ) ] pub fn nmuxen ( & mut self ) -> NMUXEN_W { NMUXEN_W { w : self } }
# [ doc = "Bit 8 - SAC OA Enable selection" ] # [ inline ( always ) ] pub fn oaen ( & mut self ) -> OAEN_W { OAEN_W { w : self } }
# [ doc = "Bit 9 - SAC OA power mode selection" ] # [ inline ( always ) ] pub fn oapm ( & mut self ) -> OAPM_W { OAPM_W { w : self } }
# [ doc = "Bit 10 - SAC Enable selection" ] # [ inline ( always ) ] pub fn sacen ( & mut self ) -> SACEN_W { SACEN_W { w : self } }
}
}
# [ doc = "SAC PGA Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac2pga](sac2pga) module" ] pub type SAC2PGA = crate :: Reg < u16 , _SAC2PGA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC2PGA ;
# [ doc = "`read()` method returns [sac2pga::R](sac2pga::R) reader structure" ] impl crate :: Readable for SAC2PGA { }
# [ doc = "`write(|w| ..)` method takes [sac2pga::W](sac2pga::W) writer structure" ] impl crate :: Writable for SAC2PGA { }
# [ doc = "SAC PGA Control Register" ] pub mod sac2pga {
# [ doc = "Reader of register SAC2PGA" ] pub type R = crate :: R < u16 , super :: SAC2PGA > ;
# [ doc = "Writer for register SAC2PGA" ] pub type W = crate :: W < u16 , super :: SAC2PGA > ;
# [ doc = "Register SAC2PGA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC2PGA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC PGA Mode Selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum MSEL_A { # [ doc = "0: Inverting PGA mode (external pad IN- is selected)" ] MSEL_0 = 0 , # [ doc = "1: Buffer mode (floating is selected )" ] MSEL_1 = 1 , # [ doc = "2: Non-inverting mode" ] MSEL_2 = 2 , # [ doc = "3: Cascade OA Inverting mode" ] MSEL_3 = 3 } impl From < MSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : MSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `MSEL`" ] pub type MSEL_R = crate :: R < u8 , MSEL_A > ; impl MSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MSEL_A { match self . bits { 0 => MSEL_A :: MSEL_0 , 1 => MSEL_A :: MSEL_1 , 2 => MSEL_A :: MSEL_2 , 3 => MSEL_A :: MSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `MSEL_0`" ] # [ inline ( always ) ] pub fn is_msel_0 ( & self ) -> bool { * self == MSEL_A :: MSEL_0 } # [ doc = "Checks if the value of the field is `MSEL_1`" ] # [ inline ( always ) ] pub fn is_msel_1 ( & self ) -> bool { * self == MSEL_A :: MSEL_1 } # [ doc = "Checks if the value of the field is `MSEL_2`" ] # [ inline ( always ) ] pub fn is_msel_2 ( & self ) -> bool { * self == MSEL_A :: MSEL_2 } # [ doc = "Checks if the value of the field is `MSEL_3`" ] # [ inline ( always ) ] pub fn is_msel_3 ( & self ) -> bool { * self == MSEL_A :: MSEL_3 } }
# [ doc = "Write proxy for field `MSEL`" ] pub struct MSEL_W < 'a > { w : & 'a mut W , } impl < 'a > MSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Inverting PGA mode (external pad IN- is selected)" ] # [ inline ( always ) ] pub fn msel_0 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_0 ) } # [ doc = "Buffer mode (floating is selected )" ] # [ inline ( always ) ] pub fn msel_1 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_1 ) } # [ doc = "Non-inverting mode" ] # [ inline ( always ) ] pub fn msel_2 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_2 ) } # [ doc = "Cascade OA Inverting mode" ] # [ inline ( always ) ] pub fn msel_3 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `GAIN`" ] pub type GAIN_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `GAIN`" ] pub struct GAIN_W < 'a > { w : & 'a mut W , } impl < 'a > GAIN_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 4 ) ) | ( ( ( value as u16 ) & 0x07 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - SAC PGA Mode Selection" ] # [ inline ( always ) ] pub fn msel ( & self ) -> MSEL_R { MSEL_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 4:6 - SAC PGA Gain configuration" ] # [ inline ( always ) ] pub fn gain ( & self ) -> GAIN_R { GAIN_R :: new ( ( ( self . bits >> 4 ) & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - SAC PGA Mode Selection" ] # [ inline ( always ) ] pub fn msel ( & mut self ) -> MSEL_W { MSEL_W { w : self } }
# [ doc = "Bits 4:6 - SAC PGA Gain configuration" ] # [ inline ( always ) ] pub fn gain ( & mut self ) -> GAIN_W { GAIN_W { w : self } }
}
}
# [ doc = "SAC DAC Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac2dac](sac2dac) module" ] pub type SAC2DAC = crate :: Reg < u16 , _SAC2DAC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC2DAC ;
# [ doc = "`read()` method returns [sac2dac::R](sac2dac::R) reader structure" ] impl crate :: Readable for SAC2DAC { }
# [ doc = "`write(|w| ..)` method takes [sac2dac::W](sac2dac::W) writer structure" ] impl crate :: Writable for SAC2DAC { }
# [ doc = "SAC DAC Control Register" ] pub mod sac2dac {
# [ doc = "Reader of register SAC2DAC" ] pub type R = crate :: R < u16 , super :: SAC2DAC > ;
# [ doc = "Writer for register SAC2DAC" ] pub type W = crate :: W < u16 , super :: SAC2DAC > ;
# [ doc = "Register SAC2DAC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC2DAC { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC DAC enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACEN_A { # [ doc = "0: Disabled" ] DACEN_0 = 0 , # [ doc = "1: Enabled" ] DACEN_1 = 1 } impl From < DACEN_A > for bool { # [ inline ( always ) ] fn from ( variant : DACEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACEN`" ] pub type DACEN_R = crate :: R < bool , DACEN_A > ; impl DACEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACEN_A { match self . bits { false => DACEN_A :: DACEN_0 , true => DACEN_A :: DACEN_1 } } # [ doc = "Checks if the value of the field is `DACEN_0`" ] # [ inline ( always ) ] pub fn is_dacen_0 ( & self ) -> bool { * self == DACEN_A :: DACEN_0 } # [ doc = "Checks if the value of the field is `DACEN_1`" ] # [ inline ( always ) ] pub fn is_dacen_1 ( & self ) -> bool { * self == DACEN_A :: DACEN_1 } }
# [ doc = "Write proxy for field `DACEN`" ] pub struct DACEN_W < 'a > { w : & 'a mut W , } impl < 'a > DACEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn dacen_0 ( self ) -> & 'a mut W { self . variant ( DACEN_A :: DACEN_0 ) } # [ doc = "Enabled" ] # [ inline ( always ) ] pub fn dacen_1 ( self ) -> & 'a mut W { self . variant ( DACEN_A :: DACEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "SAC DAC interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACIE_A { # [ doc = "0: Disabled" ] DACIE_0 = 0 , # [ doc = "1: Enabled" ] DACIE_1 = 1 } impl From < DACIE_A > for bool { # [ inline ( always ) ] fn from ( variant : DACIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACIE`" ] pub type DACIE_R = crate :: R < bool , DACIE_A > ; impl DACIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACIE_A { match self . bits { false => DACIE_A :: DACIE_0 , true => DACIE_A :: DACIE_1 } } # [ doc = "Checks if the value of the field is `DACIE_0`" ] # [ inline ( always ) ] pub fn is_dacie_0 ( & self ) -> bool { * self == DACIE_A :: DACIE_0 } # [ doc = "Checks if the value of the field is `DACIE_1`" ] # [ inline ( always ) ] pub fn is_dacie_1 ( & self ) -> bool { * self == DACIE_A :: DACIE_1 } }
# [ doc = "Write proxy for field `DACIE`" ] pub struct DACIE_W < 'a > { w : & 'a mut W , } impl < 'a > DACIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn dacie_0 ( self ) -> & 'a mut W { self . variant ( DACIE_A :: DACIE_0 ) } # [ doc = "Enabled" ] # [ inline ( always ) ] pub fn dacie_1 ( self ) -> & 'a mut W { self . variant ( DACIE_A :: DACIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "SAC DAC DMA request enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACDMAE_A { # [ doc = "0: DMA request disabled" ] DACDMAE_0 = 0 , # [ doc = "1: DMA request enabled" ] DACDMAE_1 = 1 } impl From < DACDMAE_A > for bool { # [ inline ( always ) ] fn from ( variant : DACDMAE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACDMAE`" ] pub type DACDMAE_R = crate :: R < bool , DACDMAE_A > ; impl DACDMAE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACDMAE_A { match self . bits { false => DACDMAE_A :: DACDMAE_0 , true => DACDMAE_A :: DACDMAE_1 } } # [ doc = "Checks if the value of the field is `DACDMAE_0`" ] # [ inline ( always ) ] pub fn is_dacdmae_0 ( & self ) -> bool { * self == DACDMAE_A :: DACDMAE_0 } # [ doc = "Checks if the value of the field is `DACDMAE_1`" ] # [ inline ( always ) ] pub fn is_dacdmae_1 ( & self ) -> bool { * self == DACDMAE_A :: DACDMAE_1 } }
# [ doc = "Write proxy for field `DACDMAE`" ] pub struct DACDMAE_W < 'a > { w : & 'a mut W , } impl < 'a > DACDMAE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACDMAE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "DMA request disabled" ] # [ inline ( always ) ] pub fn dacdmae_0 ( self ) -> & 'a mut W { self . variant ( DACDMAE_A :: DACDMAE_0 ) } # [ doc = "DMA request enabled" ] # [ inline ( always ) ] pub fn dacdmae_1 ( self ) -> & 'a mut W { self . variant ( DACDMAE_A :: DACDMAE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "SAC DAC load select. Selects the load trigger for the DAC latch.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum DACLSEL_A { # [ doc = "0: DAC latch loads when DACDAT written" ] DACLSEL_0 = 0 , # [ doc = "2: Device specific 0. DAC always loads data from DACDAT at the positive edge of this signal" ] DACLSEL_2 = 2 , # [ doc = "3: Device specific 1. DAC always loads data from DACDAT at the positive edge of this signal" ] DACLSEL_3 = 3 } impl From < DACLSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : DACLSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `DACLSEL`" ] pub type DACLSEL_R = crate :: R < u8 , DACLSEL_A > ; impl DACLSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , DACLSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( DACLSEL_A :: DACLSEL_0 ) , 2 => Val ( DACLSEL_A :: DACLSEL_2 ) , 3 => Val ( DACLSEL_A :: DACLSEL_3 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DACLSEL_0`" ] # [ inline ( always ) ] pub fn is_daclsel_0 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_0 } # [ doc = "Checks if the value of the field is `DACLSEL_2`" ] # [ inline ( always ) ] pub fn is_daclsel_2 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_2 } # [ doc = "Checks if the value of the field is `DACLSEL_3`" ] # [ inline ( always ) ] pub fn is_daclsel_3 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_3 } }
# [ doc = "Write proxy for field `DACLSEL`" ] pub struct DACLSEL_W < 'a > { w : & 'a mut W , } impl < 'a > DACLSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACLSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "DAC latch loads when DACDAT written" ] # [ inline ( always ) ] pub fn daclsel_0 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_0 ) } # [ doc = "Device specific 0. DAC always loads data from DACDAT at the positive edge of this signal" ] # [ inline ( always ) ] pub fn daclsel_2 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_2 ) } # [ doc = "Device specific 1. DAC always loads data from DACDAT at the positive edge of this signal" ] # [ inline ( always ) ] pub fn daclsel_3 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "SAC DAC select reference voltage\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACSREF_A { # [ doc = "0: AVCC" ] DACSREF_0 = 0 , # [ doc = "1: Alternative reference" ] DACSREF_1 = 1 } impl From < DACSREF_A > for bool { # [ inline ( always ) ] fn from ( variant : DACSREF_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACSREF`" ] pub type DACSREF_R = crate :: R < bool , DACSREF_A > ; impl DACSREF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACSREF_A { match self . bits { false => DACSREF_A :: DACSREF_0 , true => DACSREF_A :: DACSREF_1 } } # [ doc = "Checks if the value of the field is `DACSREF_0`" ] # [ inline ( always ) ] pub fn is_dacsref_0 ( & self ) -> bool { * self == DACSREF_A :: DACSREF_0 } # [ doc = "Checks if the value of the field is `DACSREF_1`" ] # [ inline ( always ) ] pub fn is_dacsref_1 ( & self ) -> bool { * self == DACSREF_A :: DACSREF_1 } }
# [ doc = "Write proxy for field `DACSREF`" ] pub struct DACSREF_W < 'a > { w : & 'a mut W , } impl < 'a > DACSREF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACSREF_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "AVCC" ] # [ inline ( always ) ] pub fn dacsref_0 ( self ) -> & 'a mut W { self . variant ( DACSREF_A :: DACSREF_0 ) } # [ doc = "Alternative reference" ] # [ inline ( always ) ] pub fn dacsref_1 ( self ) -> & 'a mut W { self . variant ( DACSREF_A :: DACSREF_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - SAC DAC enable" ] # [ inline ( always ) ] pub fn dacen ( & self ) -> DACEN_R { DACEN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - SAC DAC interrupt enable" ] # [ inline ( always ) ] pub fn dacie ( & self ) -> DACIE_R { DACIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - SAC DAC DMA request enable" ] # [ inline ( always ) ] pub fn dacdmae ( & self ) -> DACDMAE_R { DACDMAE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:9 - SAC DAC load select. Selects the load trigger for the DAC latch." ] # [ inline ( always ) ] pub fn daclsel ( & self ) -> DACLSEL_R { DACLSEL_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 12 - SAC DAC select reference voltage" ] # [ inline ( always ) ] pub fn dacsref ( & self ) -> DACSREF_R { DACSREF_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - SAC DAC enable" ] # [ inline ( always ) ] pub fn dacen ( & mut self ) -> DACEN_W { DACEN_W { w : self } }
# [ doc = "Bit 1 - SAC DAC interrupt enable" ] # [ inline ( always ) ] pub fn dacie ( & mut self ) -> DACIE_W { DACIE_W { w : self } }
# [ doc = "Bit 2 - SAC DAC DMA request enable" ] # [ inline ( always ) ] pub fn dacdmae ( & mut self ) -> DACDMAE_W { DACDMAE_W { w : self } }
# [ doc = "Bits 8:9 - SAC DAC load select. Selects the load trigger for the DAC latch." ] # [ inline ( always ) ] pub fn daclsel ( & mut self ) -> DACLSEL_W { DACLSEL_W { w : self } }
# [ doc = "Bit 12 - SAC DAC select reference voltage" ] # [ inline ( always ) ] pub fn dacsref ( & mut self ) -> DACSREF_W { DACSREF_W { w : self } }
}
}
# [ doc = "SAC DAC Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac2dat](sac2dat) module" ] pub type SAC2DAT = crate :: Reg < u16 , _SAC2DAT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC2DAT ;
# [ doc = "`read()` method returns [sac2dat::R](sac2dat::R) reader structure" ] impl crate :: Readable for SAC2DAT { }
# [ doc = "`write(|w| ..)` method takes [sac2dat::W](sac2dat::W) writer structure" ] impl crate :: Writable for SAC2DAT { }
# [ doc = "SAC DAC Data Register" ] pub mod sac2dat {
# [ doc = "Reader of register SAC2DAT" ] pub type R = crate :: R < u16 , super :: SAC2DAT > ;
# [ doc = "Writer for register SAC2DAT" ] pub type W = crate :: W < u16 , super :: SAC2DAT > ;
# [ doc = "Register SAC2DAT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC2DAT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DACData`" ] pub type DACDATA_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `DACData`" ] pub struct DACDATA_W < 'a > { w : & 'a mut W , } impl < 'a > DACDATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0fff ) | ( ( value as u16 ) & 0x0fff ) ; self . w } }
impl R {
# [ doc = "Bits 0:11 - SAC DAC data in unsigned format." ] # [ inline ( always ) ] pub fn dacdata ( & self ) -> DACDATA_R { DACDATA_R :: new ( ( self . bits & 0x0fff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:11 - SAC DAC data in unsigned format." ] # [ inline ( always ) ] pub fn dacdata ( & mut self ) -> DACDATA_W { DACDATA_W { w : self } }
}
}
# [ doc = "SAC DAC Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac2dacsts](sac2dacsts) module" ] pub type SAC2DACSTS = crate :: Reg < u16 , _SAC2DACSTS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC2DACSTS ;
# [ doc = "`read()` method returns [sac2dacsts::R](sac2dacsts::R) reader structure" ] impl crate :: Readable for SAC2DACSTS { }
# [ doc = "`write(|w| ..)` method takes [sac2dacsts::W](sac2dacsts::W) writer structure" ] impl crate :: Writable for SAC2DACSTS { }
# [ doc = "SAC DAC Status Register" ] pub mod sac2dacsts {
# [ doc = "Reader of register SAC2DACSTS" ] pub type R = crate :: R < u16 , super :: SAC2DACSTS > ;
# [ doc = "Writer for register SAC2DACSTS" ] pub type W = crate :: W < u16 , super :: SAC2DACSTS > ;
# [ doc = "Register SAC2DACSTS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC2DACSTS { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DACIFG`" ] pub type DACIFG_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DACIFG`" ] pub struct DACIFG_W < 'a > { w : & 'a mut W , } impl < 'a > DACIFG_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - SAC DAC data update flag" ] # [ inline ( always ) ] pub fn dacifg ( & self ) -> DACIFG_R { DACIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - SAC DAC data update flag" ] # [ inline ( always ) ] pub fn dacifg ( & mut self ) -> DACIFG_W { DACIFG_W { w : self } }
}
}
# [ doc = "SAC Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac2iv](sac2iv) module" ] pub type SAC2IV = crate :: Reg < u16 , _SAC2IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC2IV ;
# [ doc = "`read()` method returns [sac2iv::R](sac2iv::R) reader structure" ] impl crate :: Readable for SAC2IV { }
# [ doc = "SAC Interrupt Vector Register" ] pub mod sac2iv {
# [ doc = "Reader of register SAC2IV" ] pub type R = crate :: R < u16 , super :: SAC2IV > ;
# [ doc = "SAC Interrupt Vector Register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum SACIV2_A { # [ doc = "0: No interrupt pending" ] SACIV_0 = 0 , # [ doc = "2: S&H completed interrupt flag (Highest priority)" ] SACIV_2 = 2 , # [ doc = "4: DAC channel update interrupt flag" ] SACIV_4 = 4 } impl From < SACIV2_A > for u16 { # [ inline ( always ) ] fn from ( variant : SACIV2_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `SACIV2`" ] pub type SACIV2_R = crate :: R < u16 , SACIV2_A > ; impl SACIV2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , SACIV2_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SACIV2_A :: SACIV_0 ) , 2 => Val ( SACIV2_A :: SACIV_2 ) , 4 => Val ( SACIV2_A :: SACIV_4 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `SACIV_0`" ] # [ inline ( always ) ] pub fn is_saciv_0 ( & self ) -> bool { * self == SACIV2_A :: SACIV_0 } # [ doc = "Checks if the value of the field is `SACIV_2`" ] # [ inline ( always ) ] pub fn is_saciv_2 ( & self ) -> bool { * self == SACIV2_A :: SACIV_2 } # [ doc = "Checks if the value of the field is `SACIV_4`" ] # [ inline ( always ) ] pub fn is_saciv_4 ( & self ) -> bool { * self == SACIV2_A :: SACIV_4 } }
impl R {
# [ doc = "Bits 0:15 - SAC Interrupt Vector Register" ] # [ inline ( always ) ] pub fn saciv2 ( & self ) -> SACIV2_R { SACIV2_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "SAC3" ] pub struct SAC3 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SAC3 { } impl SAC3 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const sac3 :: RegisterBlock { 0x0cb0 as * const _ } } impl Deref for SAC3 { type Target = sac3 :: RegisterBlock ; # [ inline ( always ) ] fn deref ( & self ) -> & Self :: Target { unsafe { & * SAC3 :: ptr ( ) } } }
# [ doc = "SAC3" ] pub mod sac3 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - SAC OA Control Register" ] pub sac3oa : SAC3OA , # [ doc = "0x02 - SAC PGA Control Register" ] pub sac3pga : SAC3PGA , # [ doc = "0x04 - SAC DAC Control Register" ] pub sac3dac : SAC3DAC , # [ doc = "0x06 - SAC DAC Data Register" ] pub sac3dat : SAC3DAT , # [ doc = "0x08 - SAC DAC Status Register" ] pub sac3dacsts : SAC3DACSTS , # [ doc = "0x0a - SAC Interrupt Vector Register" ] pub sac3iv : SAC3IV , }
# [ doc = "SAC OA Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac3oa](sac3oa) module" ] pub type SAC3OA = crate :: Reg < u16 , _SAC3OA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC3OA ;
# [ doc = "`read()` method returns [sac3oa::R](sac3oa::R) reader structure" ] impl crate :: Readable for SAC3OA { }
# [ doc = "`write(|w| ..)` method takes [sac3oa::W](sac3oa::W) writer structure" ] impl crate :: Writable for SAC3OA { }
# [ doc = "SAC OA Control Register" ] pub mod sac3oa {
# [ doc = "Reader of register SAC3OA" ] pub type R = crate :: R < u16 , super :: SAC3OA > ;
# [ doc = "Writer for register SAC3OA" ] pub type W = crate :: W < u16 , super :: SAC3OA > ;
# [ doc = "Register SAC3OA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC3OA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC OA Positive input source selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum PSEL_A { # [ doc = "0: External source selected" ] PSEL_0 = 0 , # [ doc = "1: 12-bit reference DAC source selected" ] PSEL_1 = 1 , # [ doc = "2: Pair OA source selected" ] PSEL_2 = 2 } impl From < PSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : PSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `PSEL`" ] pub type PSEL_R = crate :: R < u8 , PSEL_A > ; impl PSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , PSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( PSEL_A :: PSEL_0 ) , 1 => Val ( PSEL_A :: PSEL_1 ) , 2 => Val ( PSEL_A :: PSEL_2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `PSEL_0`" ] # [ inline ( always ) ] pub fn is_psel_0 ( & self ) -> bool { * self == PSEL_A :: PSEL_0 } # [ doc = "Checks if the value of the field is `PSEL_1`" ] # [ inline ( always ) ] pub fn is_psel_1 ( & self ) -> bool { * self == PSEL_A :: PSEL_1 } # [ doc = "Checks if the value of the field is `PSEL_2`" ] # [ inline ( always ) ] pub fn is_psel_2 ( & self ) -> bool { * self == PSEL_A :: PSEL_2 } }
# [ doc = "Write proxy for field `PSEL`" ] pub struct PSEL_W < 'a > { w : & 'a mut W , } impl < 'a > PSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "External source selected" ] # [ inline ( always ) ] pub fn psel_0 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_0 ) } # [ doc = "12-bit reference DAC source selected" ] # [ inline ( always ) ] pub fn psel_1 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_1 ) } # [ doc = "Pair OA source selected" ] # [ inline ( always ) ] pub fn psel_2 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: PSEL_2 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "SAC Positive input MUX control.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PMUXEN_A { # [ doc = "0: All positive input sources are disconnected to OA positive port" ] PMUXEN_0 = 0 , # [ doc = "1: All positive input sources are connected to OA positive port" ] PMUXEN_1 = 1 } impl From < PMUXEN_A > for bool { # [ inline ( always ) ] fn from ( variant : PMUXEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `PMUXEN`" ] pub type PMUXEN_R = crate :: R < bool , PMUXEN_A > ; impl PMUXEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PMUXEN_A { match self . bits { false => PMUXEN_A :: PMUXEN_0 , true => PMUXEN_A :: PMUXEN_1 } } # [ doc = "Checks if the value of the field is `PMUXEN_0`" ] # [ inline ( always ) ] pub fn is_pmuxen_0 ( & self ) -> bool { * self == PMUXEN_A :: PMUXEN_0 } # [ doc = "Checks if the value of the field is `PMUXEN_1`" ] # [ inline ( always ) ] pub fn is_pmuxen_1 ( & self ) -> bool { * self == PMUXEN_A :: PMUXEN_1 } }
# [ doc = "Write proxy for field `PMUXEN`" ] pub struct PMUXEN_W < 'a > { w : & 'a mut W , } impl < 'a > PMUXEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PMUXEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "All positive input sources are disconnected to OA positive port" ] # [ inline ( always ) ] pub fn pmuxen_0 ( self ) -> & 'a mut W { self . variant ( PMUXEN_A :: PMUXEN_0 ) } # [ doc = "All positive input sources are connected to OA positive port" ] # [ inline ( always ) ] pub fn pmuxen_1 ( self ) -> & 'a mut W { self . variant ( PMUXEN_A :: PMUXEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "SAC OA Negative input source selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum NSEL_A { # [ doc = "0: External source selected" ] NSEL_0 = 0 , # [ doc = "1: PGA source selected" ] NSEL_1 = 1 , # [ doc = "2: Device Specific" ] NSEL_2 = 2 } impl From < NSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : NSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `NSEL`" ] pub type NSEL_R = crate :: R < u8 , NSEL_A > ; impl NSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , NSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( NSEL_A :: NSEL_0 ) , 1 => Val ( NSEL_A :: NSEL_1 ) , 2 => Val ( NSEL_A :: NSEL_2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NSEL_0`" ] # [ inline ( always ) ] pub fn is_nsel_0 ( & self ) -> bool { * self == NSEL_A :: NSEL_0 } # [ doc = "Checks if the value of the field is `NSEL_1`" ] # [ inline ( always ) ] pub fn is_nsel_1 ( & self ) -> bool { * self == NSEL_A :: NSEL_1 } # [ doc = "Checks if the value of the field is `NSEL_2`" ] # [ inline ( always ) ] pub fn is_nsel_2 ( & self ) -> bool { * self == NSEL_A :: NSEL_2 } }
# [ doc = "Write proxy for field `NSEL`" ] pub struct NSEL_W < 'a > { w : & 'a mut W , } impl < 'a > NSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "External source selected" ] # [ inline ( always ) ] pub fn nsel_0 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_0 ) } # [ doc = "PGA source selected" ] # [ inline ( always ) ] pub fn nsel_1 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_1 ) } # [ doc = "Device Specific" ] # [ inline ( always ) ] pub fn nsel_2 ( self ) -> & 'a mut W { self . variant ( NSEL_A :: NSEL_2 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "SAC Negative input MUX controL\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum NMUXEN_A { # [ doc = "0: All negative input sources are disconnected to OA negative port" ] NMUXEN_0 = 0 , # [ doc = "1: All negative input sources are connected to OA negative port" ] NMUXEN_1 = 1 } impl From < NMUXEN_A > for bool { # [ inline ( always ) ] fn from ( variant : NMUXEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `NMUXEN`" ] pub type NMUXEN_R = crate :: R < bool , NMUXEN_A > ; impl NMUXEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> NMUXEN_A { match self . bits { false => NMUXEN_A :: NMUXEN_0 , true => NMUXEN_A :: NMUXEN_1 } } # [ doc = "Checks if the value of the field is `NMUXEN_0`" ] # [ inline ( always ) ] pub fn is_nmuxen_0 ( & self ) -> bool { * self == NMUXEN_A :: NMUXEN_0 } # [ doc = "Checks if the value of the field is `NMUXEN_1`" ] # [ inline ( always ) ] pub fn is_nmuxen_1 ( & self ) -> bool { * self == NMUXEN_A :: NMUXEN_1 } }
# [ doc = "Write proxy for field `NMUXEN`" ] pub struct NMUXEN_W < 'a > { w : & 'a mut W , } impl < 'a > NMUXEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NMUXEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "All negative input sources are disconnected to OA negative port" ] # [ inline ( always ) ] pub fn nmuxen_0 ( self ) -> & 'a mut W { self . variant ( NMUXEN_A :: NMUXEN_0 ) } # [ doc = "All negative input sources are connected to OA negative port" ] # [ inline ( always ) ] pub fn nmuxen_1 ( self ) -> & 'a mut W { self . variant ( NMUXEN_A :: NMUXEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "SAC OA Enable selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OAEN_A { # [ doc = "0: SAC OA is disabled, then the SAC OA output high impedance" ] OAEN_0 = 0 , # [ doc = "1: SAC OA is enabled, normal mode" ] OAEN_1 = 1 } impl From < OAEN_A > for bool { # [ inline ( always ) ] fn from ( variant : OAEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OAEN`" ] pub type OAEN_R = crate :: R < bool , OAEN_A > ; impl OAEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OAEN_A { match self . bits { false => OAEN_A :: OAEN_0 , true => OAEN_A :: OAEN_1 } } # [ doc = "Checks if the value of the field is `OAEN_0`" ] # [ inline ( always ) ] pub fn is_oaen_0 ( & self ) -> bool { * self == OAEN_A :: OAEN_0 } # [ doc = "Checks if the value of the field is `OAEN_1`" ] # [ inline ( always ) ] pub fn is_oaen_1 ( & self ) -> bool { * self == OAEN_A :: OAEN_1 } }
# [ doc = "Write proxy for field `OAEN`" ] pub struct OAEN_W < 'a > { w : & 'a mut W , } impl < 'a > OAEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OAEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SAC OA is disabled, then the SAC OA output high impedance" ] # [ inline ( always ) ] pub fn oaen_0 ( self ) -> & 'a mut W { self . variant ( OAEN_A :: OAEN_0 ) } # [ doc = "SAC OA is enabled, normal mode" ] # [ inline ( always ) ] pub fn oaen_1 ( self ) -> & 'a mut W { self . variant ( OAEN_A :: OAEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "SAC OA power mode selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OAPM_A { # [ doc = "0: High speed and high power" ] OAPM_0 = 0 , # [ doc = "1: Llow speed and low power" ] OAPM_1 = 1 } impl From < OAPM_A > for bool { # [ inline ( always ) ] fn from ( variant : OAPM_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `OAPM`" ] pub type OAPM_R = crate :: R < bool , OAPM_A > ; impl OAPM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> OAPM_A { match self . bits { false => OAPM_A :: OAPM_0 , true => OAPM_A :: OAPM_1 } } # [ doc = "Checks if the value of the field is `OAPM_0`" ] # [ inline ( always ) ] pub fn is_oapm_0 ( & self ) -> bool { * self == OAPM_A :: OAPM_0 } # [ doc = "Checks if the value of the field is `OAPM_1`" ] # [ inline ( always ) ] pub fn is_oapm_1 ( & self ) -> bool { * self == OAPM_A :: OAPM_1 } }
# [ doc = "Write proxy for field `OAPM`" ] pub struct OAPM_W < 'a > { w : & 'a mut W , } impl < 'a > OAPM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OAPM_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "High speed and high power" ] # [ inline ( always ) ] pub fn oapm_0 ( self ) -> & 'a mut W { self . variant ( OAPM_A :: OAPM_0 ) } # [ doc = "Llow speed and low power" ] # [ inline ( always ) ] pub fn oapm_1 ( self ) -> & 'a mut W { self . variant ( OAPM_A :: OAPM_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "SAC Enable selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SACEN_A { # [ doc = "0: SAC all modules are disabled, then the SAC output high impedance" ] SACEN_0 = 0 , # [ doc = "1: SAC all modules are enabled, normal mode" ] SACEN_1 = 1 } impl From < SACEN_A > for bool { # [ inline ( always ) ] fn from ( variant : SACEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `SACEN`" ] pub type SACEN_R = crate :: R < bool , SACEN_A > ; impl SACEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SACEN_A { match self . bits { false => SACEN_A :: SACEN_0 , true => SACEN_A :: SACEN_1 } } # [ doc = "Checks if the value of the field is `SACEN_0`" ] # [ inline ( always ) ] pub fn is_sacen_0 ( & self ) -> bool { * self == SACEN_A :: SACEN_0 } # [ doc = "Checks if the value of the field is `SACEN_1`" ] # [ inline ( always ) ] pub fn is_sacen_1 ( & self ) -> bool { * self == SACEN_A :: SACEN_1 } }
# [ doc = "Write proxy for field `SACEN`" ] pub struct SACEN_W < 'a > { w : & 'a mut W , } impl < 'a > SACEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SACEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "SAC all modules are disabled, then the SAC output high impedance" ] # [ inline ( always ) ] pub fn sacen_0 ( self ) -> & 'a mut W { self . variant ( SACEN_A :: SACEN_0 ) } # [ doc = "SAC all modules are enabled, normal mode" ] # [ inline ( always ) ] pub fn sacen_1 ( self ) -> & 'a mut W { self . variant ( SACEN_A :: SACEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - SAC OA Positive input source selection" ] # [ inline ( always ) ] pub fn psel ( & self ) -> PSEL_R { PSEL_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bit 3 - SAC Positive input MUX control." ] # [ inline ( always ) ] pub fn pmuxen ( & self ) -> PMUXEN_R { PMUXEN_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - SAC OA Negative input source selection" ] # [ inline ( always ) ] pub fn nsel ( & self ) -> NSEL_R { NSEL_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 7 - SAC Negative input MUX controL" ] # [ inline ( always ) ] pub fn nmuxen ( & self ) -> NMUXEN_R { NMUXEN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - SAC OA Enable selection" ] # [ inline ( always ) ] pub fn oaen ( & self ) -> OAEN_R { OAEN_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - SAC OA power mode selection" ] # [ inline ( always ) ] pub fn oapm ( & self ) -> OAPM_R { OAPM_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - SAC Enable selection" ] # [ inline ( always ) ] pub fn sacen ( & self ) -> SACEN_R { SACEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:1 - SAC OA Positive input source selection" ] # [ inline ( always ) ] pub fn psel ( & mut self ) -> PSEL_W { PSEL_W { w : self } }
# [ doc = "Bit 3 - SAC Positive input MUX control." ] # [ inline ( always ) ] pub fn pmuxen ( & mut self ) -> PMUXEN_W { PMUXEN_W { w : self } }
# [ doc = "Bits 4:5 - SAC OA Negative input source selection" ] # [ inline ( always ) ] pub fn nsel ( & mut self ) -> NSEL_W { NSEL_W { w : self } }
# [ doc = "Bit 7 - SAC Negative input MUX controL" ] # [ inline ( always ) ] pub fn nmuxen ( & mut self ) -> NMUXEN_W { NMUXEN_W { w : self } }
# [ doc = "Bit 8 - SAC OA Enable selection" ] # [ inline ( always ) ] pub fn oaen ( & mut self ) -> OAEN_W { OAEN_W { w : self } }
# [ doc = "Bit 9 - SAC OA power mode selection" ] # [ inline ( always ) ] pub fn oapm ( & mut self ) -> OAPM_W { OAPM_W { w : self } }
# [ doc = "Bit 10 - SAC Enable selection" ] # [ inline ( always ) ] pub fn sacen ( & mut self ) -> SACEN_W { SACEN_W { w : self } }
}
}
# [ doc = "SAC PGA Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac3pga](sac3pga) module" ] pub type SAC3PGA = crate :: Reg < u16 , _SAC3PGA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC3PGA ;
# [ doc = "`read()` method returns [sac3pga::R](sac3pga::R) reader structure" ] impl crate :: Readable for SAC3PGA { }
# [ doc = "`write(|w| ..)` method takes [sac3pga::W](sac3pga::W) writer structure" ] impl crate :: Writable for SAC3PGA { }
# [ doc = "SAC PGA Control Register" ] pub mod sac3pga {
# [ doc = "Reader of register SAC3PGA" ] pub type R = crate :: R < u16 , super :: SAC3PGA > ;
# [ doc = "Writer for register SAC3PGA" ] pub type W = crate :: W < u16 , super :: SAC3PGA > ;
# [ doc = "Register SAC3PGA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC3PGA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC PGA Mode Selection\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum MSEL_A { # [ doc = "0: Inverting PGA mode (external pad IN- is selected)" ] MSEL_0 = 0 , # [ doc = "1: Buffer mode (floating is selected )" ] MSEL_1 = 1 , # [ doc = "2: Non-inverting mode" ] MSEL_2 = 2 , # [ doc = "3: Cascade OA Inverting mode" ] MSEL_3 = 3 } impl From < MSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : MSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `MSEL`" ] pub type MSEL_R = crate :: R < u8 , MSEL_A > ; impl MSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MSEL_A { match self . bits { 0 => MSEL_A :: MSEL_0 , 1 => MSEL_A :: MSEL_1 , 2 => MSEL_A :: MSEL_2 , 3 => MSEL_A :: MSEL_3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `MSEL_0`" ] # [ inline ( always ) ] pub fn is_msel_0 ( & self ) -> bool { * self == MSEL_A :: MSEL_0 } # [ doc = "Checks if the value of the field is `MSEL_1`" ] # [ inline ( always ) ] pub fn is_msel_1 ( & self ) -> bool { * self == MSEL_A :: MSEL_1 } # [ doc = "Checks if the value of the field is `MSEL_2`" ] # [ inline ( always ) ] pub fn is_msel_2 ( & self ) -> bool { * self == MSEL_A :: MSEL_2 } # [ doc = "Checks if the value of the field is `MSEL_3`" ] # [ inline ( always ) ] pub fn is_msel_3 ( & self ) -> bool { * self == MSEL_A :: MSEL_3 } }
# [ doc = "Write proxy for field `MSEL`" ] pub struct MSEL_W < 'a > { w : & 'a mut W , } impl < 'a > MSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MSEL_A ) -> & 'a mut W { { self . bits ( variant . into ( ) ) } } # [ doc = "Inverting PGA mode (external pad IN- is selected)" ] # [ inline ( always ) ] pub fn msel_0 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_0 ) } # [ doc = "Buffer mode (floating is selected )" ] # [ inline ( always ) ] pub fn msel_1 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_1 ) } # [ doc = "Non-inverting mode" ] # [ inline ( always ) ] pub fn msel_2 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_2 ) } # [ doc = "Cascade OA Inverting mode" ] # [ inline ( always ) ] pub fn msel_3 ( self ) -> & 'a mut W { self . variant ( MSEL_A :: MSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `GAIN`" ] pub type GAIN_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `GAIN`" ] pub struct GAIN_W < 'a > { w : & 'a mut W , } impl < 'a > GAIN_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 4 ) ) | ( ( ( value as u16 ) & 0x07 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - SAC PGA Mode Selection" ] # [ inline ( always ) ] pub fn msel ( & self ) -> MSEL_R { MSEL_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 4:6 - SAC PGA Gain configuration" ] # [ inline ( always ) ] pub fn gain ( & self ) -> GAIN_R { GAIN_R :: new ( ( ( self . bits >> 4 ) & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - SAC PGA Mode Selection" ] # [ inline ( always ) ] pub fn msel ( & mut self ) -> MSEL_W { MSEL_W { w : self } }
# [ doc = "Bits 4:6 - SAC PGA Gain configuration" ] # [ inline ( always ) ] pub fn gain ( & mut self ) -> GAIN_W { GAIN_W { w : self } }
}
}
# [ doc = "SAC DAC Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac3dac](sac3dac) module" ] pub type SAC3DAC = crate :: Reg < u16 , _SAC3DAC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC3DAC ;
# [ doc = "`read()` method returns [sac3dac::R](sac3dac::R) reader structure" ] impl crate :: Readable for SAC3DAC { }
# [ doc = "`write(|w| ..)` method takes [sac3dac::W](sac3dac::W) writer structure" ] impl crate :: Writable for SAC3DAC { }
# [ doc = "SAC DAC Control Register" ] pub mod sac3dac {
# [ doc = "Reader of register SAC3DAC" ] pub type R = crate :: R < u16 , super :: SAC3DAC > ;
# [ doc = "Writer for register SAC3DAC" ] pub type W = crate :: W < u16 , super :: SAC3DAC > ;
# [ doc = "Register SAC3DAC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC3DAC { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "SAC DAC enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACEN_A { # [ doc = "0: Disabled" ] DACEN_0 = 0 , # [ doc = "1: Enabled" ] DACEN_1 = 1 } impl From < DACEN_A > for bool { # [ inline ( always ) ] fn from ( variant : DACEN_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACEN`" ] pub type DACEN_R = crate :: R < bool , DACEN_A > ; impl DACEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACEN_A { match self . bits { false => DACEN_A :: DACEN_0 , true => DACEN_A :: DACEN_1 } } # [ doc = "Checks if the value of the field is `DACEN_0`" ] # [ inline ( always ) ] pub fn is_dacen_0 ( & self ) -> bool { * self == DACEN_A :: DACEN_0 } # [ doc = "Checks if the value of the field is `DACEN_1`" ] # [ inline ( always ) ] pub fn is_dacen_1 ( & self ) -> bool { * self == DACEN_A :: DACEN_1 } }
# [ doc = "Write proxy for field `DACEN`" ] pub struct DACEN_W < 'a > { w : & 'a mut W , } impl < 'a > DACEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACEN_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn dacen_0 ( self ) -> & 'a mut W { self . variant ( DACEN_A :: DACEN_0 ) } # [ doc = "Enabled" ] # [ inline ( always ) ] pub fn dacen_1 ( self ) -> & 'a mut W { self . variant ( DACEN_A :: DACEN_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "SAC DAC interrupt enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACIE_A { # [ doc = "0: Disabled" ] DACIE_0 = 0 , # [ doc = "1: Enabled" ] DACIE_1 = 1 } impl From < DACIE_A > for bool { # [ inline ( always ) ] fn from ( variant : DACIE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACIE`" ] pub type DACIE_R = crate :: R < bool , DACIE_A > ; impl DACIE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACIE_A { match self . bits { false => DACIE_A :: DACIE_0 , true => DACIE_A :: DACIE_1 } } # [ doc = "Checks if the value of the field is `DACIE_0`" ] # [ inline ( always ) ] pub fn is_dacie_0 ( & self ) -> bool { * self == DACIE_A :: DACIE_0 } # [ doc = "Checks if the value of the field is `DACIE_1`" ] # [ inline ( always ) ] pub fn is_dacie_1 ( & self ) -> bool { * self == DACIE_A :: DACIE_1 } }
# [ doc = "Write proxy for field `DACIE`" ] pub struct DACIE_W < 'a > { w : & 'a mut W , } impl < 'a > DACIE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACIE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn dacie_0 ( self ) -> & 'a mut W { self . variant ( DACIE_A :: DACIE_0 ) } # [ doc = "Enabled" ] # [ inline ( always ) ] pub fn dacie_1 ( self ) -> & 'a mut W { self . variant ( DACIE_A :: DACIE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "SAC DAC DMA request enable\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACDMAE_A { # [ doc = "0: DMA request disabled" ] DACDMAE_0 = 0 , # [ doc = "1: DMA request enabled" ] DACDMAE_1 = 1 } impl From < DACDMAE_A > for bool { # [ inline ( always ) ] fn from ( variant : DACDMAE_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACDMAE`" ] pub type DACDMAE_R = crate :: R < bool , DACDMAE_A > ; impl DACDMAE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACDMAE_A { match self . bits { false => DACDMAE_A :: DACDMAE_0 , true => DACDMAE_A :: DACDMAE_1 } } # [ doc = "Checks if the value of the field is `DACDMAE_0`" ] # [ inline ( always ) ] pub fn is_dacdmae_0 ( & self ) -> bool { * self == DACDMAE_A :: DACDMAE_0 } # [ doc = "Checks if the value of the field is `DACDMAE_1`" ] # [ inline ( always ) ] pub fn is_dacdmae_1 ( & self ) -> bool { * self == DACDMAE_A :: DACDMAE_1 } }
# [ doc = "Write proxy for field `DACDMAE`" ] pub struct DACDMAE_W < 'a > { w : & 'a mut W , } impl < 'a > DACDMAE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACDMAE_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "DMA request disabled" ] # [ inline ( always ) ] pub fn dacdmae_0 ( self ) -> & 'a mut W { self . variant ( DACDMAE_A :: DACDMAE_0 ) } # [ doc = "DMA request enabled" ] # [ inline ( always ) ] pub fn dacdmae_1 ( self ) -> & 'a mut W { self . variant ( DACDMAE_A :: DACDMAE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "SAC DAC load select. Selects the load trigger for the DAC latch.\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u8 ) ] pub enum DACLSEL_A { # [ doc = "0: DAC latch loads when DACDAT written" ] DACLSEL_0 = 0 , # [ doc = "2: Device specific 0. DAC always loads data from DACDAT at the positive edge of this signal" ] DACLSEL_2 = 2 , # [ doc = "3: Device specific 1. DAC always loads data from DACDAT at the positive edge of this signal" ] DACLSEL_3 = 3 } impl From < DACLSEL_A > for u8 { # [ inline ( always ) ] fn from ( variant : DACLSEL_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `DACLSEL`" ] pub type DACLSEL_R = crate :: R < u8 , DACLSEL_A > ; impl DACLSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , DACLSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( DACLSEL_A :: DACLSEL_0 ) , 2 => Val ( DACLSEL_A :: DACLSEL_2 ) , 3 => Val ( DACLSEL_A :: DACLSEL_3 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DACLSEL_0`" ] # [ inline ( always ) ] pub fn is_daclsel_0 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_0 } # [ doc = "Checks if the value of the field is `DACLSEL_2`" ] # [ inline ( always ) ] pub fn is_daclsel_2 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_2 } # [ doc = "Checks if the value of the field is `DACLSEL_3`" ] # [ inline ( always ) ] pub fn is_daclsel_3 ( & self ) -> bool { * self == DACLSEL_A :: DACLSEL_3 } }
# [ doc = "Write proxy for field `DACLSEL`" ] pub struct DACLSEL_W < 'a > { w : & 'a mut W , } impl < 'a > DACLSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACLSEL_A ) -> & 'a mut W { unsafe { self . bits ( variant . into ( ) ) } } # [ doc = "DAC latch loads when DACDAT written" ] # [ inline ( always ) ] pub fn daclsel_0 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_0 ) } # [ doc = "Device specific 0. DAC always loads data from DACDAT at the positive edge of this signal" ] # [ inline ( always ) ] pub fn daclsel_2 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_2 ) } # [ doc = "Device specific 1. DAC always loads data from DACDAT at the positive edge of this signal" ] # [ inline ( always ) ] pub fn daclsel_3 ( self ) -> & 'a mut W { self . variant ( DACLSEL_A :: DACLSEL_3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u16 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "SAC DAC select reference voltage\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DACSREF_A { # [ doc = "0: AVCC" ] DACSREF_0 = 0 , # [ doc = "1: Alternative reference" ] DACSREF_1 = 1 } impl From < DACSREF_A > for bool { # [ inline ( always ) ] fn from ( variant : DACSREF_A ) -> Self { variant as u8 != 0 } }
# [ doc = "Reader of field `DACSREF`" ] pub type DACSREF_R = crate :: R < bool , DACSREF_A > ; impl DACSREF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DACSREF_A { match self . bits { false => DACSREF_A :: DACSREF_0 , true => DACSREF_A :: DACSREF_1 } } # [ doc = "Checks if the value of the field is `DACSREF_0`" ] # [ inline ( always ) ] pub fn is_dacsref_0 ( & self ) -> bool { * self == DACSREF_A :: DACSREF_0 } # [ doc = "Checks if the value of the field is `DACSREF_1`" ] # [ inline ( always ) ] pub fn is_dacsref_1 ( & self ) -> bool { * self == DACSREF_A :: DACSREF_1 } }
# [ doc = "Write proxy for field `DACSREF`" ] pub struct DACSREF_W < 'a > { w : & 'a mut W , } impl < 'a > DACSREF_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DACSREF_A ) -> & 'a mut W { { self . bit ( variant . into ( ) ) } } # [ doc = "AVCC" ] # [ inline ( always ) ] pub fn dacsref_0 ( self ) -> & 'a mut W { self . variant ( DACSREF_A :: DACSREF_0 ) } # [ doc = "Alternative reference" ] # [ inline ( always ) ] pub fn dacsref_1 ( self ) -> & 'a mut W { self . variant ( DACSREF_A :: DACSREF_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - SAC DAC enable" ] # [ inline ( always ) ] pub fn dacen ( & self ) -> DACEN_R { DACEN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - SAC DAC interrupt enable" ] # [ inline ( always ) ] pub fn dacie ( & self ) -> DACIE_R { DACIE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - SAC DAC DMA request enable" ] # [ inline ( always ) ] pub fn dacdmae ( & self ) -> DACDMAE_R { DACDMAE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:9 - SAC DAC load select. Selects the load trigger for the DAC latch." ] # [ inline ( always ) ] pub fn daclsel ( & self ) -> DACLSEL_R { DACLSEL_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 12 - SAC DAC select reference voltage" ] # [ inline ( always ) ] pub fn dacsref ( & self ) -> DACSREF_R { DACSREF_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - SAC DAC enable" ] # [ inline ( always ) ] pub fn dacen ( & mut self ) -> DACEN_W { DACEN_W { w : self } }
# [ doc = "Bit 1 - SAC DAC interrupt enable" ] # [ inline ( always ) ] pub fn dacie ( & mut self ) -> DACIE_W { DACIE_W { w : self } }
# [ doc = "Bit 2 - SAC DAC DMA request enable" ] # [ inline ( always ) ] pub fn dacdmae ( & mut self ) -> DACDMAE_W { DACDMAE_W { w : self } }
# [ doc = "Bits 8:9 - SAC DAC load select. Selects the load trigger for the DAC latch." ] # [ inline ( always ) ] pub fn daclsel ( & mut self ) -> DACLSEL_W { DACLSEL_W { w : self } }
# [ doc = "Bit 12 - SAC DAC select reference voltage" ] # [ inline ( always ) ] pub fn dacsref ( & mut self ) -> DACSREF_W { DACSREF_W { w : self } }
}
}
# [ doc = "SAC DAC Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac3dat](sac3dat) module" ] pub type SAC3DAT = crate :: Reg < u16 , _SAC3DAT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC3DAT ;
# [ doc = "`read()` method returns [sac3dat::R](sac3dat::R) reader structure" ] impl crate :: Readable for SAC3DAT { }
# [ doc = "`write(|w| ..)` method takes [sac3dat::W](sac3dat::W) writer structure" ] impl crate :: Writable for SAC3DAT { }
# [ doc = "SAC DAC Data Register" ] pub mod sac3dat {
# [ doc = "Reader of register SAC3DAT" ] pub type R = crate :: R < u16 , super :: SAC3DAT > ;
# [ doc = "Writer for register SAC3DAT" ] pub type W = crate :: W < u16 , super :: SAC3DAT > ;
# [ doc = "Register SAC3DAT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC3DAT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DACData`" ] pub type DACDATA_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `DACData`" ] pub struct DACDATA_W < 'a > { w : & 'a mut W , } impl < 'a > DACDATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0fff ) | ( ( value as u16 ) & 0x0fff ) ; self . w } }
impl R {
# [ doc = "Bits 0:11 - SAC DAC data in unsigned format." ] # [ inline ( always ) ] pub fn dacdata ( & self ) -> DACDATA_R { DACDATA_R :: new ( ( self . bits & 0x0fff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:11 - SAC DAC data in unsigned format." ] # [ inline ( always ) ] pub fn dacdata ( & mut self ) -> DACDATA_W { DACDATA_W { w : self } }
}
}
# [ doc = "SAC DAC Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac3dacsts](sac3dacsts) module" ] pub type SAC3DACSTS = crate :: Reg < u16 , _SAC3DACSTS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC3DACSTS ;
# [ doc = "`read()` method returns [sac3dacsts::R](sac3dacsts::R) reader structure" ] impl crate :: Readable for SAC3DACSTS { }
# [ doc = "`write(|w| ..)` method takes [sac3dacsts::W](sac3dacsts::W) writer structure" ] impl crate :: Writable for SAC3DACSTS { }
# [ doc = "SAC DAC Status Register" ] pub mod sac3dacsts {
# [ doc = "Reader of register SAC3DACSTS" ] pub type R = crate :: R < u16 , super :: SAC3DACSTS > ;
# [ doc = "Writer for register SAC3DACSTS" ] pub type W = crate :: W < u16 , super :: SAC3DACSTS > ;
# [ doc = "Register SAC3DACSTS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAC3DACSTS { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DACIFG`" ] pub type DACIFG_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DACIFG`" ] pub struct DACIFG_W < 'a > { w : & 'a mut W , } impl < 'a > DACIFG_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - SAC DAC data update flag" ] # [ inline ( always ) ] pub fn dacifg ( & self ) -> DACIFG_R { DACIFG_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - SAC DAC data update flag" ] # [ inline ( always ) ] pub fn dacifg ( & mut self ) -> DACIFG_W { DACIFG_W { w : self } }
}
}
# [ doc = "SAC Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sac3iv](sac3iv) module" ] pub type SAC3IV = crate :: Reg < u16 , _SAC3IV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAC3IV ;
# [ doc = "`read()` method returns [sac3iv::R](sac3iv::R) reader structure" ] impl crate :: Readable for SAC3IV { }
# [ doc = "SAC Interrupt Vector Register" ] pub mod sac3iv {
# [ doc = "Reader of register SAC3IV" ] pub type R = crate :: R < u16 , super :: SAC3IV > ;
# [ doc = "SAC Interrupt Vector Register\n\nValue on reset: 0" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] # [ repr ( u16 ) ] pub enum SACIV3_A { # [ doc = "0: No interrupt pending" ] SACIV_0 = 0 , # [ doc = "2: S&H completed interrupt flag (Highest priority)" ] SACIV_2 = 2 , # [ doc = "4: DAC channel update interrupt flag" ] SACIV_4 = 4 } impl From < SACIV3_A > for u16 { # [ inline ( always ) ] fn from ( variant : SACIV3_A ) -> Self { variant as _ } }
# [ doc = "Reader of field `SACIV3`" ] pub type SACIV3_R = crate :: R < u16 , SACIV3_A > ; impl SACIV3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , SACIV3_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SACIV3_A :: SACIV_0 ) , 2 => Val ( SACIV3_A :: SACIV_2 ) , 4 => Val ( SACIV3_A :: SACIV_4 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `SACIV_0`" ] # [ inline ( always ) ] pub fn is_saciv_0 ( & self ) -> bool { * self == SACIV3_A :: SACIV_0 } # [ doc = "Checks if the value of the field is `SACIV_2`" ] # [ inline ( always ) ] pub fn is_saciv_2 ( & self ) -> bool { * self == SACIV3_A :: SACIV_2 } # [ doc = "Checks if the value of the field is `SACIV_4`" ] # [ inline ( always ) ] pub fn is_saciv_4 ( & self ) -> bool { * self == SACIV3_A :: SACIV_4 } }
impl R {
# [ doc = "Bits 0:15 - SAC Interrupt Vector Register" ] # [ inline ( always ) ] pub fn saciv3 ( & self ) -> SACIV3_R { SACIV3_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ no_mangle ] static mut DEVICE_PERIPHERALS : bool = false ; # [ doc = r"All the peripherals" ] # [ allow ( non_snake_case ) ] pub struct Peripherals { # [ doc = "P1" ] pub P1 : P1 , # [ doc = "P2" ] pub P2 : P2 , # [ doc = "P3" ] pub P3 : P3 , # [ doc = "P4" ] pub P4 : P4 , # [ doc = "P5" ] pub P5 : P5 , # [ doc = "P6" ] pub P6 : P6 , # [ doc = "SFR" ] pub SFR : SFR , # [ doc = "PMM" ] pub PMM : PMM , # [ doc = "SYS" ] pub SYS : SYS , # [ doc = "CS" ] pub CS : CS , # [ doc = "FRCTL" ] pub FRCTL : FRCTL , # [ doc = "CRC" ] pub CRC : CRC , # [ doc = "WDT_A" ] pub WDT_A : WDT_A , # [ doc = "RTC" ] pub RTC : RTC , # [ doc = "TB0" ] pub TB0 : TB0 , # [ doc = "TB1" ] pub TB1 : TB1 , # [ doc = "TB2" ] pub TB2 : TB2 , # [ doc = "TB3" ] pub TB3 : TB3 , # [ doc = "MPY32" ] pub MPY32 : MPY32 , # [ doc = "E_USCI_A0" ] pub E_USCI_A0 : E_USCI_A0 , # [ doc = "E_USCI_B0" ] pub E_USCI_B0 : E_USCI_B0 , # [ doc = "E_USCI_A1" ] pub E_USCI_A1 : E_USCI_A1 , # [ doc = "E_USCI_B1" ] pub E_USCI_B1 : E_USCI_B1 , # [ doc = "BKMEM" ] pub BKMEM : BKMEM , # [ doc = "ICC" ] pub ICC : ICC , # [ doc = "ADC" ] pub ADC : ADC , # [ doc = "E_COMP0" ] pub E_COMP0 : E_COMP0 , # [ doc = "E_COMP1" ] pub E_COMP1 : E_COMP1 , # [ doc = "SAC0" ] pub SAC0 : SAC0 , # [ doc = "SAC1" ] pub SAC1 : SAC1 , # [ doc = "SAC2" ] pub SAC2 : SAC2 , # [ doc = "SAC3" ] pub SAC3 : SAC3 , } impl Peripherals { # [ doc = r"Returns all the peripherals *once*" ] # [ inline ] pub fn take ( ) -> Option < Self > { msp430 :: interrupt :: free ( | _ | { if unsafe { DEVICE_PERIPHERALS } { None } else { Some ( unsafe { Peripherals :: steal ( ) } ) } } ) } # [ doc = r"Unchecked version of `Peripherals::take`" ] # [ inline ] pub unsafe fn steal ( ) -> Self { DEVICE_PERIPHERALS = true ; Peripherals { P1 : P1 { _marker : PhantomData } , P2 : P2 { _marker : PhantomData } , P3 : P3 { _marker : PhantomData } , P4 : P4 { _marker : PhantomData } , P5 : P5 { _marker : PhantomData } , P6 : P6 { _marker : PhantomData } , SFR : SFR { _marker : PhantomData } , PMM : PMM { _marker : PhantomData } , SYS : SYS { _marker : PhantomData } , CS : CS { _marker : PhantomData } , FRCTL : FRCTL { _marker : PhantomData } , CRC : CRC { _marker : PhantomData } , WDT_A : WDT_A { _marker : PhantomData } , RTC : RTC { _marker : PhantomData } , TB0 : TB0 { _marker : PhantomData } , TB1 : TB1 { _marker : PhantomData } , TB2 : TB2 { _marker : PhantomData } , TB3 : TB3 { _marker : PhantomData } , MPY32 : MPY32 { _marker : PhantomData } , E_USCI_A0 : E_USCI_A0 { _marker : PhantomData } , E_USCI_B0 : E_USCI_B0 { _marker : PhantomData } , E_USCI_A1 : E_USCI_A1 { _marker : PhantomData } , E_USCI_B1 : E_USCI_B1 { _marker : PhantomData } , BKMEM : BKMEM { _marker : PhantomData } , ICC : ICC { _marker : PhantomData } , ADC : ADC { _marker : PhantomData } , E_COMP0 : E_COMP0 { _marker : PhantomData } , E_COMP1 : E_COMP1 { _marker : PhantomData } , SAC0 : SAC0 { _marker : PhantomData } , SAC1 : SAC1 { _marker : PhantomData } , SAC2 : SAC2 { _marker : PhantomData } , SAC3 : SAC3 { _marker : PhantomData } , } } }
